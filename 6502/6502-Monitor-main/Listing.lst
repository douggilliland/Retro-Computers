00001  ; two pass assembler with dissembler - inspiration with permision from A1 by San Bergmans
00002  ; REGB bits 0-3 are connected to LED's on 6522 
00003  ; tested in Michael Kowalski 6502 Simulator - using 65C02 Code 
00004  
00005  	
00006  		
00007  ;------------------------------------------------------------------------
00008  ; Compiler Options/Directives
00009  
00010    0000          BRKAS2		= 0					;Add a second BRK byte
00011    0000          MYWYM		= 0					;has MYWYM Board settings/Chips
00012    0000          LCD_ROUTINES	= 0					;Compile with LCD 16x2 lines 	
00013  
00014  	
00015  		.INCLUDE	"constants.65s"
00016  ; version 1.00
00017  ; two pass assembler with dissembler - inspiration with permision from A1 by San Bergmans
00018  ; REGB bits 0-3 are connected to LED's
00019  ; tested in Michael Kowalski 6502 Simulator - using 65C02 Code 
00020  
00021  ;------------------------------------------------------------------------
00022  ; Symbols used in source code
00023  ;------------------------------------------------------------------------
00024  
00025    0023          IMV		='#'				;Indicates immediate mode value
00026    0024          HEX		='$'				;Indicates a hex value
00027    0028          OPEN		='('				;Open bracket for indirect addressing
00028    0029          CLOSE		=')'				;Close bracket for indirect addressing
00029    002A          PCREL		='*'				;Indicates PC relative addressing
00030    003C          LOBYTE		='<'				;Indicates lo-byte of following word
00031    003E          HIBYTE		='>'				;Indicates hi-byte of following word
00032    002B          PLUS		='+'				;Plus in simple expressions
00033    002D          MINUS		='-'				;Minus in simple expressions
00034    002E          DOT		='.'				;Indicates a local label
00035    0027          QUOTE		='''				;delimits a string
00036    002C          COMMA		=','
00037    003B          CMNT		=';'				;indicates a full line comment
00038    002E          PROMPT		='.'            		;The assembler prompt character
00039    002D          DASH		='-'				;Dash for crued graphics
00040    0000          EOL		=$00				;End of line marker
00041    0000          EOS		=$00				;End of string marker
00042    0001          EOFLD		=$01				;End of field in tokenised source line
00043    0002          BLANK		=$02				;used to mark a blank line
00044    00FE          PRGEND		=$FE				;used to flag end of program parsing
00045    00FF          FAIL		=$FF				;used to flag failure in various searches
00046    000D          CR		=$0D            		;CR character
00047    001B          ESC		=$1B            		;ESC character
00048    0020          BELL		=$20				;BELL should be $07 but $20 for testing 
00049    0008          BS		=$08            		;Back space key
00050    0009          TAB		=$09            		;TAB character
00051    000A          LF		=$0a				;Line feed
00052    0020          SP		=$20				;Space
00053  
00054    0008          TAB1            =8              		;1st tab stop
00055    000C          TAB2            =12             		;2nd tab stop
00056    0015          TAB3            =21             		;3rd tab stop
00057  
00058  
00059  
00060  ;------------------------------------------------------------------------
00061  ; Constants
00062  ;------------------------------------------------------------------------
00063  
00064    0006          DEF_LOMEM       =     	$06             	;Default lomem page
00065    03E8          DEF_AUTO        =     	1000            	;Default Auto line number start
00066    000A          DEF_INC         =     	10              	;Default Auto increment step
00067    0280          DEF_ORG         =     	$0280           	;Default .OR
00068    0200          DEF_OBJLOW      =     	$0200           	;Default lowest object address
00069  
00070  
00071  
00072  ;------------------------------------------------------------------------
00073  ; Zero page memory
00074  ; Input buffer placed in ZP because of the many references to it. Must be
00075  ;  completely in ZP because address + index remains only one byte address
00076  ; PASS must remain the first label here! See INIT routine
00077  ;------------------------------------------------------------------------
00078  
00079  0018                            *=     $0018          		;Leave 1st part of ZP free
00080  0098            IN              .RS     128            		;Input and parse buffer 128 Characters input
00081  	
00082  	.IF LCD_ROUTINES
00083  ;------------------------------------------------------------------------
00084  ; Tracing/debuging varials
00085  ;------------------------------------------------------------------------
00086  00A7            XQT		.RS	15			;Used for tacing
00087  00A8            SAVP		.RS	1			;registers save - 5 locations must be contiguous1
00088  00A9            SAVS		.RS	1		
00089  00AA            SAVY		.RS	1
00090  00AB            SAVX		.RS	1
00091  00AC            SAVA		.RS	1
00092  	
00093  ;------------------------------------------------------------------------
00094  ; Assembler registers
00095  
00096  00AD            PASS            .RS     1               	;Assembler pass 0=1, 1=2
00097  00AF            GLOBAL          .RS     2               	;Last defined Global label
00098  00B1            GLOBAL_VAL      .RS     2              	 	;Last defined Global's value
00099  00B2            LABEL_FLAG      .RS     1              		;Found label's assigned flag (b7)
00100  00B4            PNTR            .RS     2             		;Pointer in source
00101  00B5            INDEX           .RS     1               	;Index mode 0, X or Y
00102  00B7            PC              .RS     2              		;Current program counter
00103  00B9            TA              .RS     2              		;Current target address
00104  00BB            TA_BEGIN        .RS     2               	;Begin of target address block
00105  00BD            PC_BEG          .RS     2               	;Program counter at start of line
00106  00BE            ASM_ERR         .RS     1               	;Assemble errors (max 255)
00107  00BF            UNDEF           .RS     1               	;Undefined label if <> 0
00108  00C0            FORWARD         .RS     1               	;Forward referenced label if <> 0
00109  00C1            LL_NUM          .RS     1               	;Local label's number
00110  00C2            FIRST_CHAR      .RS     1               	;First character of a label
00111  
00112  00C3            CURMNE		.RS	1			;Holds the current mne index
00113  00C4            CURADM		.RS	1			;Holds the current addressing mode
00114  
00115  ;------------------------------------------------------------------------
00116  ; Editor's registers
00117  
00118  00C5            CMD_CHR         .RS     1               	;First character of command
00119  00C6            ERROR           .RS     1               	;Latest error
00120  00C7            DUMP            .RS     1               	;Dump mode in list command
00121  00C9            PARM1           .RS     2               	;Parameter 1
00122  00CB            PARM2           .RS     2               	;Parameter 2
00123  
00124  ;------------------------------------------------------------------------
00125  ; General purpose registers
00126  
00127  00CC            NEG_FLAG        .RS     1               	;Negative flag (if <> 0)
00128  00CD            COUNT           .RS     1               	;GP counter
00129  00CE            DELIM           .RS     1               	;String/ASCII delimiter
00130  00D0            HEXVAL          .RS     2               	;16-bit value of expression
00131  00D1            LEAD0           .RS     1               	;Leading 0 flag
00132  00D2            CHAR            .RS     1               	;Character compilation register
00133  00D4            MULDIV          .RS     2               	;Multiply/divide temp
00134  00D6            EXP_SAVE        .RS     2               	;Expression save value
00135  00D8            DEC_SAVE        .RS     2               	;Decimal convert save value
00136  00D9            SAVE_Y          .RS     1               	;Save Y pointer
00137  00DB            LENG            .RS     2               	;Length of block move
00138  00DD            SRCE            .RS     2               	;Source for block move
00139  00DF            DEST            .RS     2               	;Destination for block move
00140  
00141  ;------------------------------------------------------------------------
00142  ; for disassembler
00143  
00144  00E1            PRFLAG		.RS	2
00145  00E2            TEMP1		.RS	1			; general purpose storage
00146  00E3            TEMP2		.RS	1
00147  
00148  ;------------------------------------------------------------------------
00149  ; Registers which are best NOT to be disturbed by user's program!
00150  
00151  00E4            OLD_SAVE        .RS     1               	;OLD possible if <> 0
00152  00E6            AUTO            .RS     2               	;Next Auto line number
00153  00E7            AUTO_INC        .RS     1               	;Auto increment
00154  00E8            AUTO_FLAG       .RS     1               	;Auto mode flag (if <> -)
00155  00EA            SYM_TABLE       .RS     2               	;Symbol table (if MSB <> 0)
00156  00EC            USR_OBJLO       .RS     2               	;User's safe object begin
00157  00EE            USR_OBJHI       .RS     2               	;User's safe object end	
00158  00F0            LOMEM           .RS     2               	;Lomem address   | Don't
00159  00F2            HIMEM        	.RS     2               	;Himem address |  change order
00160  00F4            XEC_LAST        .RS     2               	;Last Xec address
00161  00F6            USERKEYDEF	.RS	2			;User defined @keys 
00162  00F8            USIRQ		.RS     2			;User IRQ vector
00163  00FA            USBRK		.RS     2			;User BRK vector
00164  00FC            USMNI		.RS     2			;User NMI vector
00165  00FE            USRRS		.RS     2			;User RESET vector
00166  
00167  
00168  ;------------------------------------------------------------------------
00169  ; Simulator or HARDWARE Mapping
00170  ;------------------------------------------------------------------------
00171  
00172  io_area		= $8800				
00173    8800          io_cls	 	= io_area + 0 			;writing to this clears the output window
00174    8801          io_putc 	= io_area + 1 			;a "glass teletype" output window. BS, CR and LF are actioned
00175    8802          io_putr 	= io_area + 2 			;raw output, bytes are output as their
00176  						;characters and not actioned.
00177    8803          io_puth 	= io_area + 3 			;hex output, bytes are output as their hex code
00178    8804          io_getc 	= io_area + 4 			;SCAN_ESCing character get, will wait for input
00179    8805          io_posx 	= io_area + 5 			;set cursor x position by writing here
00180    8806          io_posy 	= io_area + 6 			;set cursor y position by writing here        
00181  	
00182    8804          KBD             = io_getc       		;Keyboard input register
00183    8804          KBDCR           = io_getc 	        	;Keyboard control register
00184  
00185  ;------------------------------------------------------------------------
00186  ; Hardware mapping
00187  ;------------------------------------------------------------------------
00188  	.IF LCD_ROUTINES
00189  
00190  	.IF MYWYM
00191  	
00192  
00193    8000          VIA     =       $8000
00194    8800          ACIA    =       io_area	
00195  		
00196  	.ENDIF
00197  	.ENDIF
00198  	
00199  	
00200  C000             			*=  $c000 			;ROM location
00201   		
00202  ;------------------------------------------------------------------------
00203  ; Lets get going
00204  ; Cold and Warm program entry points
00205  ;------------------------------------------------------------------------
00206  
00207  C000  20 E1 C5  COLD            	JSR     INIT            	;Initialise assembler
00208  C003  D8        WARM            	CLD                     	;You'll probably know why
00209  C004  20 70 D5                  	JSR     WRCRLF          	;Print CR & LF before we do anything                
00210  C007  64 E7                     	STZ     AUTO_FLAG       	;Clear auto flag
00211                  
00212  
00213  ;------------------------------------------------------------------------
00214  ; Get input line (main program loop)
00215  ;------------------------------------------------------------------------
00216  
00217  C009  A2 00     GETLINE         	LDX	#$00			;reset buffer index
00218  C00B  A9 2E     			LDA     #PROMPT         	;Print the assembler prompt
00219  C00D  20 77 D5                  	JSR     WRCHAR		
00220  C010  20 85 C8                  	JSR     AUTONUM         	;Generate line number if auto=on
00221  .IN             	
00222  		.IF MYWYM
00223  C013  AD 04 88  			LDA     KBDCR           	;Was a key pressed?
00224  C016  F0 FB                     	BEQ     .IN             	;Nope! else have have the key     
00225  		.ENDIF	
00226  C018  C9 1B     .found	               	CMP     #ESC            	;Is it the ESC key?
00227  C01A  F0 23                     	BEQ     .ESC         		;Nope!
00228  C01C  C9 08     			CMP     #BS             	;Back space key then?
00229  C01E  F0 2B     			BEQ	.BS
00230  C020  C9 09     			CMP     #TAB            	;Is it the TAB character?
00231  C022  F0 30     			BEQ	.TABS 
00232  C024  C9 0D     			CMP     #CR             	;Is it a CR then?
00233  C026  F0 4A                     	BEQ     .CR             	;Yes!                
00234  C028  C9 3A                     	CMP	#':'			;INTEL Hex loader
00235  C02A  D0 05     	                BNE	.LF			;nope then skip
00236  C02C  20 1D C1  	   		JSR     CMD_INTELHEX
00237  C02F  80 D8     	   		BRA	GETLINE          
00238                  
00239  C031  C9 0A     .LF             	CMP     #LF             	;Is it a CR then?
00240  C033  F0 DE                     	BEQ	.IN			;Strip LF useful for pasting code                                
00241  C035  95 18                     	STA     IN,X            	;Save new character in input buffer
00242  C037  20 77 D5                  	JSR     WRCHAR          	; and display it
00243  C03A  E8                        	INX
00244  C03B  10 D6                     	BPL     .IN             	;Get next character unless its 128 characters
00245  C03D  80 02                     	BRA     .CANCEL         	;Always taken! Too many chars.
00246  
00247  C03F  64 E7     .ESC            	STZ     AUTO_FLAG       	;Clear auto flag and therefore OFF
00248  		.IF MYWYM
00249  C041  A9 20     .CANCEL         	LDA	#BELL			;play bell
00250  C043  20 77 D5  			JSR	WRCHAR
00251  C046  20 70 D5  			JSR     WRCRLF     		;Print CRLF
00252  C049  80 BE                     	BRA     GETLINE         	;Always taken! Restart line
00253  	
00254  C04B  20 77 D5  .BS             	JSR     WRCHAR			;Process Back SPACE   
00255  C04E  CA                        	DEX                     	;Decrement input pointer
00256  C04F  10 C2                     	BPL     .IN             	;Still positive!
00257  C051  E8                        	INX                     	;Don't allow it to go negative
00258  C052  80 BF                     	BRA     .IN             	;Always taken!
00259  
00260  C054  A0 00     .TABS           	LDY     #0              	;Point to 1st tab stop
00261  C056  B9 9A C0  .TABS_NEXT      	LDA     TABS,Y          	;It X smaller than this one?
00262  C059  85 CC                     	STA     COUNT
00263  C05B  A9 20                     	LDA     #SP			;replace with SPACE probably dont need this
00264  C05D  E4 CC                     	CPX     COUNT
00265  C05F  90 05                     	BCC     .DOTAB         	 	;Yes! Tab to this position
00266  C061  C8                        	INY	
00267  C062  C0 03                     	CPY     #NUMTABS        	;Maximum number of tab stops
00268  C064  90 F0                     	BCC     .TABS_NEXT      	;Try next!
00269  C066  95 18     .DOTAB          	STA     IN,X            	;Save this character
00270  C068  E8                        	INX
00271  C069  20 77 D5                  	JSR     WRCHAR            	; and WRCHAR it
00272  C06C  E4 CC                     	CPX     COUNT           	;At tab stop?
00273  C06E  90 F6                     	BCC     .DOTAB          	;Not yet!
00274  C070  80 A1                     	BRA     .IN             	;Always taken!
00275  	
00276  C072  95 18     .CR             	STA     IN,X            	;Mark end of line now with CR
00277  C074  20 F8 D5  			JSR	UPPERCASE		;convert to upper case
00278  C077  20 70 D5                  	JSR     WRCRLF          	;CR new line    
00279  C07A  20 C1 C5                  	JSR     FIRSTNONSPC     	;Find first non space
00280  C07D  F0 8A     	                BEQ     GETLINE         	;End of line reached!
00281  
00282  C07F  C9 30             	        CMP     #'0'            	;Is it a line number?
00283  C081  90 04                     	BCC     .NOLINE         	;No!
00284  C083  C9 3A                     	CMP     #'9'+1
00285  C085  90 0D                     	BCC     .LINENUM        	;It is! Add it to the program
00286  C087  20 A4 C0  .NOLINE         	JSR     KEYDEF         		;Parse command, or line number
00287  C08A  A5 C5     .CHK_ERROR      	LDA     ERROR           	;Was there an error?
00288  C08C  F0 03                     	BEQ     .GETLINE        	;Nope!
00289  C08E  20 5F C4                  	JSR     PRINT_MSGS     		;Print error
00290  C091  4C 09 C0  .GETLINE        	JMP     GETLINE         	;Stay in main program loop
00291  
00292  C094  20 8A CB  .LINENUM        	JSR     ADDLINE         	;Add line to program
00293  C097  4C 8A C0                  	JMP     .CHK_ERROR      	;Check if an error occurred
00294  
00295  TABS            .BYTE     TAB1           		;1st tab stop
00296                  .BYTE     TAB2          	 	;2nd tab stop
00297                  .BYTE     TAB3         	  		;3rd tab stop
00298    0003          NUMTABS         =     3               		 	;Number of tab stops
00299  
00300  
00301  KEYS		.BYTE		ESC
00302  		.BYTE		':'			;
00303  		.BYTE     	0              		;End of table
00304  
00305  .KEYdef		.WORD		CMD_INTELHEX-1		
00306  		.WORD		CMD_ESC-1	
00307  
00308  ;------------------------------------------------------------------------
00309  ; Parse command or line number
00310  ; A holds the command character
00311  ;------------------------------------------------------------------------
00312  
00313  C0A4  A0 00     KEYDEF         		LDY     #0              	;Find command in table
00314  C0A6  84 C5                     	STY     ERROR           	;Clear error		
00315  C0A8  85 C4                     	STA     CMD_CHR
00316  
00317  C0AA  B9 D0 C0  .LOOP          	 	LDA     .TABLE,Y	
00318  C0AD  F0 1C                     	BEQ     .SYNERR         	;End of table! Syntax errorv 
00319  C0AF  C5 C4                     	CMP     CMD_CHR         	;Is it this command
00320  C0B1  F0 03                     	BEQ     .FOUND          	;Found our command!
00321  C0B3  C8                        	INY                     	;Next command from table
00322  C0B4  80 F4                     	BRA     .LOOP           	;Always taken!
00323  
00324  C0B6  20 80 CB  .FOUND          	JSR     IN_BLANK        	;Get next and see if it's blank
00325  C0B9  D0 FB                     	BNE     .FOUND          	;A CR would have been too!
00326  C0BB  98                        	TYA                     	;Point to command handler's
00327  C0BC  0A                        	ASL                     	; address in table                
00328  C0BD  A8                        	TAY     	          
00329  C0BE  B9 E6 C0                  	LDA     FUNCTIONS+1,Y   	; Get the address and use it MSB first
00330  C0C1  48                        	PHA                     	; as return address                
00331  C0C2  B9 E5 C0                  	LDA     FUNCTIONS,Y
00332  C0C5  48                        	PHA
00333  C0C6  A0 00                     	LDY     #0              	;Some commands may benefit from this
00334  C0C8  4C C3 C5                  	JMP     NNONSPC         	;Find next non space and exec cmd XR points to IN.X
00335                  	
00336  C0CB  A9 08     .SYNERR         	LDA     #ERR_SYN        	;Exit with syntax error
00337  C0CD  85 C5                     	STA     ERROR
00338  C0CF  60                        	RTS
00339  
00340  ;
00341  
00342  ;------------------------------------------------------------------------
00343  ; Table of commands
00344  ; 
00345  ;------------------------------------------------------------------------
00346  
00347  .TABLE       		.BYTE     	'A'            	;Auto line numbering
00348  			.BYTE		'B'		;Break command
00349                  	.BYTE     	'C'            	;Copy command
00350                  	.BYTE		'D'		;Dissassembler
00351                  	.BYTE     	'E'            	;Erase command
00352                  	.BYTE     	'?'            	;Help command
00353                  	.BYTE	  	'I'		;ASCII Dump	
00354                  	.BYTE     	'L'            	;List command
00355                  	.BYTE     	'M'            	;Memory command
00356                  	.BYTE     	'N'            	;New command
00357                  	.BYTE     	'O'            	;Old command
00358                  	.BYTE     	'R'            	;Renumber command
00359                  	.BYTE     	'S'            	;Start assembling
00360                  	.BYTE		'T'		;Trace code
00361                  	.BYTE     	'V'            	;Value command
00362                  	.BYTE		"W"		;Display registers
00363                  	.BYTE     	'X'            	;eXecute command
00364                  	.BYTE		'Y'		;memory configuraion
00365  			.BYTE		'Z'		;Clear Screen
00366                  	.BYTE		'@'		;User commands	
00367  CMD_BRK			.BYTE     	0             	;End of table & BRK
00368  
00369  ;------------------------------------------------------------------------
00370  ; Table of commands
00371  ;   RTS will a +1 to the address
00372  ;------------------------------------------------------------------------
00373  					 		
00374  FUNCTIONS       	.WORD   CMD_AUT-1  		;Auto line numbering
00375  			.WORD	CMD_BRK-1		;Break command
00376                  	.WORD   CMD_COP-1      		;Copy command
00377                  	.WORD	CMD_DISSASSEMBLER-1	;Dissassembler
00378                  	.WORD   CMD_ERASE-1      		;Erase command                	
00379                  	.WORD   CMD_HLP-1      		;Help command
00380                  	.WORD	CMD_ASCIIDUMP-1		;ASCII DUMP
00381                  	.WORD   CMD_LST-1      		;List command                
00382                  	.WORD	CMD_MEMORY_DUMP-1	;Memory command
00383                  	.WORD   CMD_NEW-1      		;New command
00384                  	.WORD   CMD_OLD-1      		;Old command
00385                  	.WORD   CMD_REN-1      		;Renumber command
00386                  	.WORD   CMD_ASM-1      		;Start assembling
00387                  	.WORD	CMD_TRACE-1		;Trace Code
00388                  	.WORD   CMD_VAL-1      		;Value command 
00389                  	.WORD	CMD_SHOWREG-1		;Display registers
00390                  	.WORD   CMD_XEC-1      		;eXecute command
00391  			.WORD   CMD_MEM-1      		;Memory command	
00392  			.WORD   CMD_CLS-1      		;Memory command	
00393  			.WORD	CMD_USERKEYS-1		;Allows users to add more keys after @
00394  
00395  ;----------------------------------------------------------------------------------------
00396  ; Allows users to add more keys after @
00397  ;----------------------------------------------------------------------------------------
00398  C10D  6C F4 00  CMD_USERKEYS 		JMP    (USERKEYDEF) 
00399  
00400  
00401  ;----------------------------------------------------------------------------------------
00402  ;Clear the screen
00403  ;----------------------------------------------------------------------------------------
00404  
00405  C110  4C 4E D5  CMD_CLS			JMP	CLS
00406  ;----------------------------------------------------------------------------------------
00407  C113  64 E7     CMD_ESC            	STZ     AUTO_FLAG       	;Clear auto flag and therefore OFF
00408  C115  A9 20     .CANCEL         	LDA	#BELL			;play bell
00409  C117  20 77 D5  			JSR	WRCHAR
00410  C11A  4C 70 D5  			JMP     WRCRLF     		;Print CRLF
00411  			
00412  ;----------------------------------------------------------------------------------------
00413  ;Intel HEX loader
00414  		
00415  		.INCLUDE	"INTELHEX.65s"
00416  
00417  ;----------------------------------------------------------------------------------------
00418  ;Intel HEX loader
00419  ;----------------------------------------------------------------------------------------
00420  
00421    00D9          CHECKSUM	=	LENG		
00422  
00423  C11D  78        CMD_INTELHEX		SEI				;stop Interrupts			
00424  C11E  D8        			CLD				;binary mode additons			
00425  C11F  64 D4     			STZ	EXP_SAVE		;temp			
00426  C121  64 D6     			STZ	DEC_SAVE		;Bytes count
00427  C123  64 D7     			STZ	DEC_SAVE+1						
00428  C125  64 D9     			STZ	CHECKSUM		;checksum	
00429  C127  A9 0D     			LDA	#CR			
00430  C129  8D 00 88  			STA     ACIA			;dont wait on port status			
00431  C12C  A9 0A     			LDA	#LF			
00432  C12E  8D 00 88  			STA     ACIA			;dont wait on port status			  						
00433  C131  80 33             		BRA     CONTINUE        		        		
00434          		
00435  C133  20 B3 D5  NEXTRECORD 		JSR 	RDCHAR
00436  C136  C9 0D             		CMP     #CR        		
00437  C138  D0 0E             		BNE     PROTOCOLERROR        		
00438  C13A  20 B3 D5          		JSR     RDCHAR			;CRLF and end of line (BUG there's a CHECKSUM)        		
00439  C13D  C9 0A             		CMP     #LF        		
00440  C13F  D0 07             		BNE     PROTOCOLERROR        		
00441  C141  20 B3 D5          		JSR     RDCHAR        		
00442  C144  C9 3A             		CMP     #':'        		
00443  C146  F0 1E             		BEQ     CONTINUE        		
00444          		
00445  C148  20 77 D5  PROTOCOLERROR 		JSR 	WRCHAR
00446  C14B  20 05 D5          		JSR     STRING        		
00447          		.ASCIS    BELL,CR,LF," :PROTOCOL ERROR",CR,LF
00448  C163  4C 53 C2          		JMP     TERMINATE        		
00449  
00450  C166  20 56 C2  CONTINUE 		JSR    	READ_DATA		;read rcord length with checksum add
00451  C169  85 CC             		STA     COUNT			;load the amount of bytes to load into memory        		
00452  C16B  20 56 C2          		JSR     READ_DATA		;read hgh byte of memory location         		       		
00453  C16E  85 DC             		STA     SRCE+1			;store hgh byte of memory location        		
00454  C170  20 56 C2          		JSR     READ_DATA		;read low byte with checksum add			        		
00455  C173  85 DB             		STA     SRCE			;store			        		
00456  C175  20 56 C2          		JSR     READ_DATA		;get record type 01 = end        		
00457          		;CMP     #$00			;check if 00 if yes then type #00        		
00458  C178  F0 27             		BEQ     .DATARECORD		;get the data frame        		        		
00459  C17A  C9 01             		CMP     #$01			;is it type #01 ie: end of record        		
00460  C17C  D0 03             		BNE     .INVREC			;else invalid        		
00461  C17E  4C 08 C2          		JMP     .END_RECORD        		
00462  
00463  C181  20 05 D5  .INVREC  		JSR     STRING
00464          		.ASCIS    BELL,CR,LF," :INVALID RECORD TYPE",CR,LF
00465  C19E  4C 53 C2          		JMP     TERMINATE
00466          		
00467  
00468  		.IF	MYWYM
00469  
00470  C1A1  A6 CC     .DATARECORD 		LDX  	COUNT			;DATASIZE
00471  C1A3  A0 00             		LDY     #$00        		
00472  C1A5  20 56 C2  .NEXT_BYTE 		JSR   	READ_DATA		;read two hex characters
00473  C1A8  91 DB             		STA     (SRCE),y		;store in RAM        		
00474  C1AA  D1 DB             		CMP     (SRCE),y		;did it actually store			
00475  C1AC  D0 0F             		BNE     .WRITEERROR		;no then error - probably no ram there        		
00476  C1AE  A9 23     			LDA	#'#'			;write fast			
00477  C1B0  8D 00 88  			STA     ACIA			;dont wait on port status							
00478  C1B3  C8                		INY				;next address        		
00479  C1B4  CA                		DEX				;next byte to recieve        		
00480          		;CPX     #$00			;all bytes recieved?         		
00481  C1B5  D0 EE             		BNE     .NEXT_BYTE		;no then get next record        		
00482  C1B7  20 56 C2          		JSR     READ_DATA		;get checksum	        
00483  
00484  		.IF	MYWYM        					
00485  C1BA  4C 33 C1  .LEDCNT  		JMP    NEXTRECORD
00486  
00487  C1BD  20 05 D5  .WRITEERROR 		JSR  	STRING
00488          		.ASCIS   BELL,CR,LF," :CANNOT WRITE AT ADDRESS $"
00489  C1DE  A5 DC             		LDA	SRCE+1        		
00490  C1E0  20 8A D5          		JSR	WR2HEX        		
00491  C1E3  A5 DB             		LDA	SRCE        		
00492  C1E5  20 8A D5          		JSR	WR2HEX        		
00493  C1E8  20 70 D5          		JSR	WRCRLF        		        			
00494  C1EB  80 66             		BRA     TERMINATE	
00495  
00496  C1ED  20 05 D5  .CHECKSUMERR        	JSR     STRING
00497          		.ASCIS    BELL,LF,CR," :CHECK SUM ERROR",LF,CR        		
00498  C206  80 4B             		BRA     TERMINATE        		
00499          		
00500  C208  20 BE D5  .END_RECORD  		JSR    	RD2HEX			;last two byes the CheckSUM
00501  C20B  18        			CLC			
00502  C20C  65 D9     			ADC	CHECKSUM			
00503  C20E  D0 DD     			BNE	.CHECKSUMERR				
00504  C210  20 05 D5          		JSR     STRING        		
00505          		.ASCIS    CR,LF," :INTEL-HEX SUCCESSFUL"        		
00506  C22B  20 05 D5          		JSR     STRING    		        		
00507          		.ASCIS    CR,LF," :TOTAL BYTES WRITTEN "			
00508  C246  A4 D6     			LDY	DEC_SAVE
00509  C248  A5 D7     			LDA	DEC_SAVE+1
00510  C24A  20 EA C7  			JSR	WRDECI        	        		
00511  C24D  20 70 D5          		JSR	WRCRLF        	
00512          		
00513          	.IF	MYWYM        						
00514  C250  58                		CLI        		
00515  C251  18                		CLC        		
00516  C252  60                		RTS				;return to caller
00517          			
00518  TERMINATE  
00519  		.IF	MYWYM   
00520  C253  38                		SEC        		
00521  C254  58                		CLI        		
00522  C255  60                		RTS 	       		        ;return to caller
00523          		
00524  ;---------------------------------------------------------------------------------
00525  C256  20 BE D5  READ_DATA 		JSR   	RD2HEX			;read two hex characters & checksum
00526          		;bcs     ERRS
00527  C259  48                		PHA        		
00528  C25A  18                		CLC        		
00529  C25B  65 D9             		ADC     CHECKSUM		;add to checksum        		
00530  C25D  85 D9             		STA     CHECKSUM        		        		
00531  C25F  18                		CLC
00532  C260  A5 D6             		LDA	DEC_SAVE
00533  C262  69 01             		ADC	#01
00534  C264  85 D6             		STA	DEC_SAVE
00535  C266  A5 D7             		LDA	DEC_SAVE+1		;add the carry	
00536  C268  69 00             		ADC	#00
00537  C26A  85 D7             		STA	DEC_SAVE+1
00538  C26C  68                		PLA        		
00539  C26D  60                		RTS
00540          		
00541  ;ERRS    		tsx				;remove the last RTS from stack
00542  ;        		inx
00543  ;        		inx
00544  ;        		txs
00545  ;        		jsr     STRING     ;read error from RS232
00546  ;        		.ASCIS   BELL,CR,LF," :READ ERROR FROM ACIA",CR,LF
00547  ;        		BRA     TERMINATE
00548          		        			
00549          		        			
00550  		
00551  ;------------------------------------------------------------------------
00552  ;DISSASSEMBLER
00553  ;------------------------------------------------------------------------
00554  
00555  C26E  20 22 C7  CMD_DISSASSEMBLER	JSR     GET_EXPRES         	;Get Source aka get expression 
00556  C271  D0 04                     	BNE	.CONT
00557  C273  84 DB                     	STY     SRCE			;else continue 
00558  C275  85 DC                     	STA     SRCE+1      	
00559  C277  A0 10     .CONT	        	LDY     #16
00560  
00561  C279  5A        DECODE_ONE 		PHY				;identical to ASCIIDUMP and MEM DUM s        		
00562  C27A  20 B5 C3                 		JSR	DISPLAY_ADDR        	;display SOURCE address (could remove A&Y)              		               		               		
00563  C27D  B2 DB     			LDA	(SRCE)			;Get OpCode
00564  C27F  20 A9 C2  			JSR 	INSTDSP			  		
00565  
00566  C282  A9 2D     DISPLYASIC        	LDA	#45
00567  C284  8D 05 88  			STA 	io_posx
00568  C287  E6 D9     			INC	LENG
00569  C289  A5 D9     			LDA 	LENG
00570  C28B  85 CC     			STA	COUNT			;add 1 to total length to include opcode				
00571  C28D  20 97 C3          		JSR	ASCII_DUMP		;display 
00572  C290  A5 D9             		LDA 	LENG  		
00573  C292  20 9F C2  			JSR	BUMPSRCE		;Added Length to Source
00574  C295  7A        .BUMPEX        		PLY
00575  C296  20 70 D5  			JSR     WRCRLF
00576  C299  88                        	DEY
00577  C29A  D0 DD                     	BNE	DECODE_ONE 		;decode one line
00578  C29C  64 C5                     	STZ	ERROR
00579  C29E  60                		RTS
00580          		
00581  ;------------------------------------------------------------------------	
00582  ;Bump Address by AC
00583  ;------------------------------------------------------------------------	
00584  
00585  C29F  18        BUMPSRCE        	CLC
00586  C2A0  65 DB     			ADC     SRCE 
00587  C2A2  85 DB             		STA	SRCE  
00588  C2A4  90 02             		BCC	.BUMPSRCE     		        	        		        		
00589  C2A6  E6 DC             		INC     SRCE+1                 		
00590  C2A8  60        .BUMPSRCE     		RTS     		
00591          		
00592          		
00593  ;------------------------------------------------------------------------	
00594  ;Instruction display - orginal code seems to come from MOS
00595  ;------------------------------------------------------------------------	
00596  
00597  C2A9  A8        INSTDSP			TAY   				;Save op code
00598  C2AA  4A        			LSR   				;* Even/odd test
00599  C2AB  90 05     			BCC 	.IEVEN
00600  C2AD  6A        			ROR  				;* Test B1
00601  C2AE  B0 11     			BCS 	.ERR			;XXXXXX11 instr invalid
00602  			;CMP 	#$A2	
00603  			;BEQ 	ERR			;10001001 instr invalid
00604  C2B0  29 87     			AND 	#$87			;Mask 3 bits for address mode
00605  			;ORA 	#$80			;* add indexing offset
00606  C2B2  4A        .IEVEN			LSR   				;* LSB into carry for
00607  C2B3  AA        			TAX   				;Left/right test below
00608  C2B4  BD F6 D2  			LDA 	MODE,X			;Index into address mode table
00609  C2B7  90 04     			BCC 	.RTMODE			;If carry set use LSD for
00610  C2B9  4A        			LSR   				;* print format index
00611  C2BA  4A        			LSR   		
00612  C2BB  4A        			LSR   				;If carry clear use MSD
00613  C2BC  4A        			LSR   
00614  C2BD  29 0F     .RTMODE			AND 	#$0F			;Mask for 4-bit index
00615  C2BF  D0 04     			BNE 	.GETFMT			;$0 for invalid opcodes
00616  C2C1  A0 FC     .ERR			LDY 	#$FC			;Substitute $FC for invalid op,
00617  C2C3  A9 00     			LDA 	#$00			;set print format index to 0
00618  C2C5  AA        .GETFMT			TAX   
00619  C2C6  BD 3A D3  			LDA 	MODE2,X			;Index into print format table
00620  C2C9  85 D8     			STA 	SAVE_Y			;Save for address field format
00621  C2CB  29 03     			AND 	#$03			;Mask 2-bit length.  0=1-byte
00622  C2CD  85 D9     			STA 	LENG			;*  1=2-byte, 2=3 byte
00623  C2CF  98        			TYA   				;* op code
00624  C2D0  20 A2 D4  			JSR 	GETMNE			;Lookup the mnemonic
00625  C2D3  A0 00     			LDY 	#$00
00626  C2D5  48        			PHA   				;Save mnemonic table index
00627  C2D6  B1 DB     .PROP			LDA 	(SRCE),Y
00628  C2D8  20 8A D5  			JSR 	WR2HEX
00629  C2DB  A2 01     			LDX 	#$01
00630  C2DD  20 6B C3  .PROPBL			JSR 	PRBL2
00631  C2E0  C4 D9     			CPY 	LENG			;Print instr (1 to 3 bytes)
00632  C2E2  C8        			INY   				;*  in a 12-character field
00633  C2E3  90 F1     			BCC 	.PROP
00634  C2E5  A2 03     			LDX 	#$03			;char count for mnemonic print
00635  C2E7  86 DF     			STX 	PRFLAG			;So EXPMNE prints the mnemonic
00636  C2E9  C0 04     			CPY 	#$04
00637  C2EB  90 F0     			BCC 	.PROPBL
00638  C2ED  68        			PLA   				;Recover mnemonic index
00639  C2EE  AA        			TAX
00640  C2EF  20 42 C3  			JSR 	EXPMNE			;Expand the Memonic
00641  C2F2  20 69 C3  			JSR 	PRBLNK			;Output 3 blanks
00642  C2F5  A4 D9     			LDY 	LENG			
00643  C2F7  A2 06     			LDX 	#$06			;Count for 6 print format bits
00644  C2F9  E0 03     .PPADR1			CPX 	#$03
00645  C2FB  F0 1E     			BEQ 	.PPADR5			;If X=3 then print address val
00646  C2FD  06 D8     .PPADR2			ASL 	SAVE_Y			;Test next print format bit
00647  C2FF  90 0E     			BCC 	.PPADR3			;If 0 don't print
00648  C301  BD 4D D3  			LDA 	CHAR1-1,X			; *  corresponding chars
00649  C304  20 77 D5  			JSR 	WRCHAR			;Output 1 or 2 chars
00650  C307  BD 47 D3  			LDA 	CHAR2-1,X		;*  (If char from char2 is 0,
00651  C30A  F0 03     			BEQ 	.PPADR3			;*   don't output it)
00652  C30C  20 77 D5  			JSR 	WRCHAR
00653  C30F  CA        .PPADR3			DEX   
00654  C310  D0 E7     			BNE 	.PPADR1
00655  C312  86 DF     			STX 	PRFLAG			;reset flag to 0
00656  C314  60        			RTS  				;Return if done 6 format bits
00657  C315  88        .PPADR4			DEY
00658  C316  30 E5     			BMI 	.PPADR2
00659  C318  20 8A D5  			JSR 	WR2HEX			;Output 1- or 2-byte address
00660  C31B  A5 D8     .PPADR5			LDA 	SAVE_Y
00661  C31D  C9 E8     			CMP 	#$E8			;Handle rel addressing mode
00662  C31F  B1 DB     			LDA 	(SRCE),Y		;Special print target adr
00663  C321  90 F2     			BCC 	.PPADR4			;*  (not displacement)
00664  C323  20 35 C3  .RELADR			JSR 	PCADJ3			;PCL,H + DISPL + 1 to A,Y
00665  C326  AA        			TAX   
00666  			;INX   
00667  C327  D0 01     			BNE 	PRNTYX			;*     +1 to X,Y
00668  C329  C8        			INY   		
00669  C32A  98        PRNTYX			TYA   				;falls through
00670  
00671  ;------------------------------------------------------------------------	
00672  ;print AX as a HEX word
00673  ;------------------------------------------------------------------------	
00674  C32B  20 8A D5  PRNTAX			JSR	WR2HEX			;Print target adr of branch (DUPLICATE FUNCTION to WRWORDAY)
00675  C32E  8A        PRNTX			TXA   				; *  and return
00676  C32F  4C 8A D5  			JMP 	WR2HEX        		
00677  
00678  
00679  ;------------------------------------------------------------------------------------------	
00680  ;PC Adjust
00681  ;------------------------------------------------------------------------------------------		
00682  C332  38        PCADJ			SEC
00683  C333  A5 D9     PCADJ2			LDA 	LENG			;0=1-byte, 1=2-byte, 2=3-byte
00684  C335  A4 DC     PCADJ3			LDY 	SRCE+1
00685  C337  AA        			TAX   				;* test displ sign (for rel
00686  C338  10 02     			BPL 	.PCADJ4			;*  branch).  Extend neg
00687  C33A  88        			DEY   				;*  by decrementing PCH
00688  C33B  38        			SEC				;*  by incrementin PCL
00689  			;CLC			
00690  C33C  65 DB     .PCADJ4			ADC 	SRCE
00691  C33E  90 01     			BCC 	.RTS			;PCL+LENGTH (or displ) + 1 to A
00692  C340  C8        			INY   				;*  carry into Y (PCH)
00693  C341  60        .RTS			RTS 
00694  ;------------------------------------------------------------------------	
00695  ; Expand Mnemic
00696  ; copy the 2 chars at R/LMNETB,X
00697  ; into LMNE and RMNE, and expand 
00698  ; into 3 chars at MNE to MNE+2
00699  ;------------------------------------------------------------------------
00700  	
00701  C342  BD 03 D2  EXPMNE			LDA 	LMNETB,X		;Expand Mnemic
00702  C345  85 C7     			STA 	PARM1
00703  C347  BD 45 D2  			LDA 	RMNETB,X
00704  C34A  85 C8     			STA 	PARM1+1
00705  C34C  A2 00     			LDX 	#$00
00706  C34E  A9 00     .NEXT			LDA 	#$00
00707  C350  A0 05     			LDY 	#$05
00708  C352  06 C8     .LOOP			ASL 	PARM1+1
00709  C354  26 C7     			ROL 	PARM1
00710  C356  2A        			ROL
00711  C357  88        			DEY
00712  C358  D0 F8     			BNE 	.LOOP
00713  C35A  69 40     			ADC 	#'A'-1
00714  			;STA 	MNE,X
00715  C35C  A4 DF     			LDY 	PRFLAG
00716  C35E  F0 03     			BEQ 	.SKIP
00717  C360  20 77 D5  			JSR	 WRCHAR			;print the mnemonic as well
00718  C363  E8        .SKIP			INX
00719  C364  E0 03     			CPX 	#$03
00720  C366  D0 E6     			BNE 	.NEXT
00721  C368  60        			RTS	
00722  ;------------------------------------------------------------------------       		
00723  ;Print Blank Lines 
00724  ;------------------------------------------------------------------------   	
00725  C369  A2 03     PRBLNK			LDX 	#$03			;Blank count
00726  C36B  20 6C D5  PRBL2			JSR 	WRSPACE			;Output a blank
00727  C36E  CA        			DEX   
00728  C36F  D0 FA     			BNE 	PRBL2			;Loop until count = 0
00729  C371  60        			RTS           		
00730                  	
00731  ;------------------------------------------------------------------------
00732  ;ASCII DUMP 
00733  ;------------------------------------------------------------------------
00734  
00735  C372  20 22 C7  CMD_ASCIIDUMP 		JSR     GET_EXPRES         	;Get Source aka get expression 
00736  C375  D0 04                     	BNE	.CONT
00737  C377  84 DB                     	STY     SRCE
00738  C379  85 DC                     	STA     SRCE+1                   	
00739  C37B  A9 42     .CONT	        	LDA     #$42        	
00740  C37D  85 CC             		STA     COUNT        		
00741  C37F  A0 14     			LDY     #$14        		
00742  C381  5A        .NEXTLINE 		PHY        		
00743  C382  20 B5 C3                 		JSR	DISPLAY_ADDR        	; display address format	  	
00744  C385  20 97 C3          		JSR     ASCII_DUMP        	
00745  C388  20 70 D5          		JSR     WRCRLF        	
00746  C38B  A9 2A             		LDA	#42
00747  C38D  20 9F C2          		JSR	BUMPSRCE		; Add to SRCE
00748  C390  7A                		PLY        	
00749  C391  88                		DEY        	
00750  C392  D0 ED             		BNE     .NEXTLINE        	
00751  C394  64 C5             		STZ	ERROR			; No Error
00752  C396  60                		RTS
00753          		
00754  ;------------------------------------------------------------------------
00755  ;ASCII DUMP one line
00756  ;------------------------------------------------------------------------ 
00757  
00758  C397  A9 2F     ASCII_DUMP 		LDA  	#'/'       		;ASCII DUMP - Dumps ASCII onto the screen
00759  C399  20 77 D5          		JSR     WRCHAR        	
00760  C39C  A0 00             		LDY     #$00            	    	
00761  C39E  B1 DB     .NEXTCHAR1 		LDA   	(SRCE),y
00762  C3A0  C9 1F             		CMP     #$1f        		
00763  C3A2  90 06             		BCC     .NOTASCII        		
00764  C3A4  C9 7F             		CMP     #$7f        	
00765  C3A6  B0 02             		BCS     .NOTASCII        	
00766  C3A8  80 02             		BRA     .WRITE       	      	
00767  C3AA  A9 2E     .NOTASCII 		LDA    	#'.'
00768  C3AC  20 77 D5  .WRITE   		JSR     WRCHAR
00769  C3AF  C8                		INY        	
00770  C3B0  C4 CC             		CPY     COUNT        	
00771  C3B2  D0 EA             		BNE     .NEXTCHAR1        	
00772  C3B4  60                		RTS 
00773        	
00774  ;------------------------------------------------------------------------       	
00775  ; display address without the $ A=MSD y=LSB
00776  ;------------------------------------------------------------------------ 
00777  
00778  C3B5  A9 2E     DISPLAY_ADDR   		LDA     #'.'        		
00779  C3B7  20 77 D5          		JSR     WRCHAR        		
00780  C3BA  A9 3A             		LDA     #':'        		
00781  C3BC  20 77 D5          		JSR     WRCHAR        		
00782  C3BF  A9 20     DISPLAY_ADDR_B 		LDA     #SP        		;basic version	
00783  C3C1  20 77 D5  	 		JSR     WRCHAR 
00784  C3C4  A5 DC             		LDA	SRCE+1
00785  C3C6  A4 DB             		LDY	SRCE       		
00786  C3C8  20 A7 D5          		JSR	WRWORDAY		;print address AY	        	
00787  C3CB  A9 20             		lda     #SP			;TABS HERE
00788  C3CD  20 77 D5          		JSR     WRCHAR        		
00789  C3D0  4C 77 D5          		JMP     WRCHAR     		;return to caller
00790  			
00791  ;------------------------------------------------------------------------
00792  ;ASCII DUMP one line
00793  ;------------------------------------------------------------------------ 
00794  
00795  C3D3  20 22 C7  CMD_MEMORY_DUMP		JSR     GET_EXPRES     		;DUMPS MEMORY TO THE SCREEN
00796  C3D6  D0 04     			BNE	.CONT
00797  C3D8  84 DB     			STY     SRCE
00798  C3DA  85 DC                     	STA     SRCE+1                 	 		        	        	
00799  C3DC  A0 14     .CONT        		LDY     #$14			;lines to draw        
00800  C3DE  A2 04             		LDX	#04			;divided by 4
00801  C3E0  5A        .NEWLINE 		PHY
00802  C3E1  20 B5 C3          		JSR	DISPLAY_ADDR		
00803  C3E4  A0 00            			LDY     #$00       		
00804  C3E6  B1 DB     .DUMP    		LDA     (SRCE),y
00805  C3E8  20 8A D5          		JSR     WR2HEX        	
00806  C3EB  A9 20             		LDA     #SP        	
00807  C3ED  20 77 D5          		JSR     WRCHAR        	
00808  C3F0  CA                		DEX
00809  C3F1  D0 05             		BNE	.SKIPSP	        	
00810  C3F3  A2 04             		LDX	#04        	
00811  C3F5  20 77 D5          		JSR     WRCHAR        	
00812  C3F8  C8        .SKIPSP  		INY
00813  C3F9  C0 10             		CPY     #$10        	
00814  C3FB  D0 E9             		BNE     .DUMP        	
00815  C3FD  20 6C D5          		JSR     WRSPACE        	
00816  C400  84 CC             		STY     COUNT        		
00817  C402  20 97 C3          		JSR     ASCII_DUMP        	
00818  C405  20 70 D5          		JSR     WRCRLF    
00819  C408  A9 10             		LDA	#$10
00820  C40A  20 9F C2          		JSR	BUMPSRCE    		;Add to SRCE	        		
00821  C40D  7A                		PLY       	        	
00822  C40E  88                		DEY        	
00823  C40F  D0 CF             		BNE     .NEWLINE  
00824  C411  64 C5             		STZ	ERROR      	        	
00825  C413  60                		RTS
00826          
00827  ;------------------------------------------------------------------------
00828  ; Move a part of memory down (to delete or shorten source lines)
00829  ;
00830  ; SRCE  2       Address of source data (destroyed)
00831  ; DEST  2       Address of destination data (destroyed)
00832  ; LENG  2       Holds the number of bytes to move
00833  ;------------------------------------------------------------------------
00834  
00835  C414  A0 00     MOV_DOWN        	LDY     #0              	;Clear index in 256 byte blocks
00836  C416  A6 DA                     	LDX     LENG+1          	;Get number of blocks to be moved
00837  C418  F0 0E                     	BEQ     .LAST           	;Move last (partial) block
00838  
00839  C41A  B1 DB     .LOOP1          	LDA     (SRCE),Y        	;Move this byte
00840  C41C  91 DD                     	STA     (DEST),Y
00841  C41E  C8                        	INY                     	;Point to next byte in block
00842  C41F  D0 F9                     	BNE     .LOOP1          	;Block not done yet!
00843  C421  E6 DC                     	INC     SRCE+1          	;Point to next block
00844  C423  E6 DE                     	INC     DEST+1
00845  C425  CA                        	DEX                     	;Count down blocks
00846  C426  D0 F2                     	BNE     .LOOP1          	;Not all blocs done yet!
00847  
00848  C428  A6 D9     .LAST           	LDX     LENG            	;Count remainder of last block
00849  C42A  F0 08                     	BEQ     .EXIT           	;Oh, there is no remainder!
00850  
00851  C42C  B1 DB     .LOOP2          	LDA     (SRCE),Y        	;Move this byte
00852  C42E  91 DD                     	STA     (DEST),Y
00853  C430  C8                        	INY                     	;Point to next byte in last block
00854  C431  CA                        	DEX                     	;Count down the bytes
00855  C432  D0 F8                     	BNE     .LOOP2          	;Last block not done yet!
00856  C434  60        .EXIT           	RTS
00857  
00858  ;------------------------------------------------------------------------
00859  ; Move a part of memory up (to make room for new or longer source line)
00860  ;
00861  ; SRCE  2       Address of source data
00862  ; DEST  2       Address of destination data
00863  ; LENG  2       Holds number of bytes to move
00864  ;
00865  ;------------------------------------------------------------------------
00866  
00867  C435  A6 DA     MOV_UP          	LDX     LENG+1          	;We have started the move at the
00868  C437  18                        	CLC                   		;end otherwise we risk
00869  C438  8A                        	TXA                     	;overwriting the source
00870  C439  65 DC                     	ADC     SRCE+1
00871  C43B  85 DC                     	STA     SRCE+1          	;So add Length-High to source and
00872  C43D  18                        	CLC                     	;destination address
00873  C43E  8A                        	TXA
00874  C43F  65 DE                     	ADC     DEST+1
00875  C441  85 DE                     	STA     DEST+1
00876  C443  E8                        	INX                     	;Allow BNE to signal the end
00877  C444  A4 D9                     	LDY     LENG
00878  C446  F0 0E                     	BEQ     .PAGE           	;Only entire pages to be moved!
00879  C448  88                        	DEY
00880  C449  F0 07                     	BEQ     .PART           	;Move last, partial, page first!
00881  C44B  B1 DB     .LOOP1          	LDA     (SRCE),Y        	;Move one entire page
00882  C44D  91 DD                     	STA     (DEST),Y
00883  C44F  88                        	DEY                     	; backwards
00884  C450  D0 F9                     	BNE     .LOOP1          	;Page not done yet
00885  C452  B1 DB     .PART           	LDA     (SRCE),Y        	;Move first byte of page too
00886  C454  91 DD                     	STA     (DEST),Y
00887  C456  88        .PAGE      	       	DEY
00888  C457  C6 DC     	                DEC     SRCE+1          	;Decrement source and destination
00889  C459  C6 DE                     	DEC     DEST+1
00890  C45B  CA                        	DEX
00891  C45C  D0 ED                     	BNE     .LOOP1          	;Move all pages!
00892  C45E  60                        	RTS
00893  
00894  ;------------------------------------------------------------------------
00895  ; Print error c=1 means its ERROR messages
00896  ;------------------------------------------------------------------------
00897  
00898  C45F  A4 C5     PRINT_MSGS     		LDY	ERROR
00899  C461  D0 0B     			BNE	.ERRORMSGS		;normal string		
00900  C463  A0 34     			LDY	#<TEXT1			;Error texts
00901  C465  84 DB     			STY	SRCE
00902  C467  A0 C5     			LDY	#>TEXT1 
00903  C469  84 DC     			STY	SRCE+1
00904  C46B  A8        			TAY				;index to message string
00905  C46C  80 10     			BRA	PRINT_SRCE
00906  		
00907  C46E  A0 8B     .ERRORMSGS		LDY	#<TEXT			;noramal texts		
00908  C470  84 DB     			STY	SRCE
00909  C472  A0 C4     			LDY	#>TEXT 
00910  C474  84 DC     			STY	SRCE+1	
00911  C476  A8        			TAY				;Print Errors
00912  C477  20 7E C4  			JSR     PRINT_SRCE      	;Print 3 characters                
00913  C47A  A0 00     			LDY     #0              	;Save A
00914  C47C  64 C5                     	STZ     ERROR           	;Clear the error now                                                    
00915  
00916  C47E  B1 DB     PRINT_SRCE     		LDA     (SRCE),Y       		;Get character (also GLobal Print)			
00917  C480  48        			PHA	
00918  C481  29 7F     			AND	#@01111111			
00919  C483  20 77 D5                  	JSR     WRCHAR          	; and print it
00920  C486  C8                        	INY				;check if it exceed 127
00921  C487  68                        	PLA                
00922  C488  10 F4                     	BPL	PRINT_SRCE      	; is bit=8 =1   
00923                  	       
00924  C48A  60                        	RTS
00925  ;------------------------------------------------------------------------
00926  ; Error Messages - TODO
00927  ;------------------------------------------------------------------------
00928  
00929  TEXT			.ASCIS    	" ERROR",CR,LF                 	                
00930  PNTR_ERR_SYN		.ASCIS    	" :SYNTAX"        			;Syntax error
00931  PNTR_ERR_LBL 		.ASCIS    	" :LABEL"         			;Label error / no global 
00932  PNTR_ERR_RNG    	.ASCIS     	" :INVALID RANGE"          		;Range error
00933  PNTR_ERR_MIS    	.ASCIS     	" :MISSING PARAMETER or OPERAND"     	;Missing parameter/operand
00934  PNTR_ERR_DIV    	.ASCIS     	" :DIVIDE by 0"          		;Divide by 0 error
00935  PNTR_ERR_MEM 		.ASCIS     	" :MEMORY FULL"        			;Memory full / illegal TA 
00936  PNTR_ERR_DEF    	.ASCIS     	" :UNDEFINED LABEL"          		;Undefined label
00937  PNTR_ERR_DIR    	.ASCIS     	" :ILLEGAL DIRECTIVE"          		;Illegal directive error
00938  PNTR_ERR_OPE    	.ASCIS     	" :OPERAND"          			;Operand error
00939  PNTR_ERR_MNE    	.ASCIS     	" :MNEMONIC "          			;Mnemonic error
00940  PNTR_ERR_EXT    	.ASCIS     	" :EXTRAT DEFINATION"          		;Extra definition error
00941  
00942  
00943  TEXT1        		.ASCIS     	"--------------------------"
00944  PNTR_WELCOME    	.ASCIS	  	"Giovanni OS V1.0"
00945  PNTR_AUTOTEXT		.ASCIS		"AUTONUM ENABLE startnig "
00946  PNTR_TOTALRAM		.ASCIS		"TOTAL RAM used: "
00947  PNTR_LOWERRAM		.ASCIS		"LOWER limit:    "	
00948  PNTR_UPPERRAM		.ASCIS		"UPPPER limit:   "
00949  PNTR_ERRORS     	.ASCIS     	" COMPILE ERROR(s)",CR,LF
00950  PNTR_CANCEL     	.ASCIS     	"/"		
00951  PNTR_CODE_ORG  		.ASCIS     	".ORG ->"
00952  
00953  
00954  
00955    0008          ERR_SYN		=	PNTR_ERR_SYN - TEXT	
00956    0010          ERR_LBL		=	PNTR_ERR_LBL - TEXT		
00957    0017          ERR_RNG		=	PNTR_ERR_RNG - TEXT	   
00958    0026          ERR_MIS		=	PNTR_ERR_MIS - TEXT	   
00959    0044          ERR_DIV		=	PNTR_ERR_DIV - TEXT	   
00960    0051          ERR_MEM		=	PNTR_ERR_MEM - TEXT		
00961    005E          ERR_DEF		=	PNTR_ERR_DEF - TEXT	    
00962    006F          ERR_DIR		=	PNTR_ERR_DIR - TEXT	    
00963    0082          ERR_OPE		=	PNTR_ERR_OPE - TEXT	   
00964    008B          ERR_MNE		=	PNTR_ERR_MNE - TEXT	    
00965    0096          ERR_EXT		=	PNTR_ERR_EXT - TEXT	   
00966  
00967  ;standard messages
00968    0000          STR_WWW         =     	TEXT1 - TEXT1 
00969    001A          STR_WELCOME     =     	PNTR_WELCOME - TEXT1
00970    002A          AUTOTEXT	=	PNTR_AUTOTEXT  - TEXT1
00971    0042          TOTALRAM	=	PNTR_TOTALRAM  - TEXT1
00972    0052          LOWERRAM	=	PNTR_LOWERRAM  - TEXT1
00973    0062          UPPERRAM	=	PNTR_UPPERRAM  - TEXT1
00974    0072          STR_ERRORS      =     	PNTR_ERRORS  - TEXT1	
00975    0085          STR_CANCEL      =     	PNTR_CANCEL  - TEXT1
00976    0086          CODE_ORG	=	PNTR_CODE_ORG  - TEXT1
00977  
00978          
00979  
00980  ;------------------------------------------------------------------------
00981  ; Find next non space
00982  ; Z=1 if EOL found
00983  ;------------------------------------------------------------------------
00984  
00985  C5C1  A2 00     FIRSTNONSPC     	LDX     #0              	;Start at the begin of the line
00986  C5C3  B5 18     NNONSPC         	LDA     IN,X            	;Is this a space?
00987  C5C5  C9 20                     	CMP     #SP
00988  C5C7  D0 03                     	BNE     .NOSPACE        	;It is not!
00989  C5C9  E8                        	INX
00990  C5CA  80 F7                     	BRA     NNONSPC         	;Always taken!
00991  C5CC  C9 0D     .NOSPACE        	CMP     #CR             	;Set Z if we're at EOL
00992  C5CE  60                        	RTS
00993  
00994  ;------------------------------------------------------------------------
00995  ; Initialise the assembler before we can start
00996  ;------------------------------------------------------------------------
00997  
00998  INITDATA		.WORD	$9000			;USR_OBJHI User's safe object end		
00999  			.BYTE	$00 			;Lomem address   | Don't
01000  			.BYTE	DEF_LOMEM		;LOMEM defined page
01001  			.BYTE	$00			;Himem address |  change order			
01002  			.BYTE	DEF_LOMEM		;HIMEM defined page
01003  			.WORD	XEC_RTS			;XEC_LAST Last Xec address				
01004  			.WORD	USERKEYDEF		;USERKEYDEF User defined @keys 
01005  			.WORD	IRQ_RETURN		;User IRQ vector
01006  			.WORD	BRK_RETURN		;User BRK vector	
01007  			.WORD	NMI_RETURN		;User NMI vector	
01008  			.WORD	RESET_RETURN		;User RESET vector
01009  		
01010  C5E1  D8        INIT            	CLD                     	;You'll never know
01011  		.IF LCD_ROUTINES		
01012  C5E2  A9 1A                     	LDA     #STR_WELCOME    	;Print welcome string
01013  C5E4  20 5F C4                  	JSR     PRINT_MSGS		
01014  C5E7  20 7B D5  			JSR	DRAWLINE		;Draw line
01015  	              
01016  C5EA  A2 12                     	LDX	#INIT-INITDATA		;FAST Initialise ZP (Check if portB pressed)	
01017  C5EC  BD CF C5  .INITZP         	LDA	INITDATA,X
01018  C5EF  95 EC     			STA	USR_OBJHI,X	
01019  C5F1  CA        			DEX
01020  C5F2  10 F8                     	BPL	.INITZP	               
01021  							;Memory scan
01022  C5F4  A5 F1     .LOOP           	LDA     HIMEM+1         	;Stop if we run into our own code (himem +1)
01023  C5F6  C9 C0                     	CMP     #>COLD			;/COLD
01024  C5F8  F0 18                     	BEQ     .THATSIT
01025  C5FA  B1 F0                     	LDA     (HIMEM),Y       	;See if this memory page exists
01026  C5FC  AA                        	TAX                     	;Save original value
01027  C5FD  A9 55                     	LDA     #@01010101     		;Try this value first
01028  C5FF  20 18 C6                  	JSR     PROBE
01029  C602  D0 0E                     	BNE     .THATSIT        	;End of RAM!
01030  C604  A9 AA                     	LDA     #@10101010   		;Then try this value
01031  C606  20 18 C6                  	JSR     PROBE
01032  C609  D0 07                     	BNE     .THATSIT        	;End of RAM!
01033  C60B  8A                        	TXA                     	;Restore original value
01034  C60C  91 F0                     	STA     (HIMEM),Y
01035  C60E  E6 F1                     	INC     HIMEM+1        		;Try next memory page
01036  C610  10 E2                     	BPL     .LOOP           	;No need to proceed beyond $8000!
01037  C612  20 2A CA  .THATSIT        	JSR	SHOWMEM
01038  C615  4C 5A CA  			JMP     DONEW           	;Do new command
01039           
01040  ;------------------------------------------------------------------------
01041  ; Probe memory location
01042  ;------------------------------------------------------------------------
01043  C618  91 F0     PROBE         		STA     (HIMEM),Y       	;Store this value
01044  C61A  D1 F0                     	CMP     (HIMEM),Y       	;See if it was accepted
01045  C61C  60        XEC_RTS        		RTS             
01046          
01047  ;------------------------------------------------------------------------
01048  ; Get a single 16-bit value from input line
01049  ;------------------------------------------------------------------------
01050  
01051  C61D  64 CB     GET_VAL         	STZ     NEG_FLAG        	;Clear negative flag
01052  C61F  64 CE                     	STZ     HEXVAL          	;Clear end result
01053  C621  64 CF                     	STZ     HEXVAL+1
01054  C623  64 CD                     	STZ     DELIM           	;Clear digit entered flag                                                              
01055  C625  B5 18                     	LDA     IN,X            	;Read character from IN
01056  C627  C9 2B                     	CMP     #'+'            	;Is it explicit positive?
01057  C629  F0 06                     	BEQ     .POS            	;Yes!
01058  C62B  C9 2D                     	CMP     #'-'            	;Is it a negative number?
01059  C62D  D0 05                     	BNE     .NOSIGN         	;No! No prefix sign given
01060  C62F  85 CB                     	STA     NEG_FLAG        	;Set negative flag
01061  C631  E8        .POS    	        INX                     	;Point to next byte in IN
01062  C632  B5 18     	                LDA     IN,X            	; and get it
01063  
01064  C634  C9 30     .NOSIGN 	        CMP     #'0'            	;Could it be a decimal number?
01065  C636  90 40                     	BCC     .HEX            	;Nope!
01066  C638  C9 3A                     	CMP     #'9'+1
01067  C63A  B0 3C                     	BCS     .HEX            	;Nope!
01068  
01069  ;------------------------------------------------------------------------
01070  ; Convert a decimal number to binary
01071  ;------------------------------------------------------------------------
01072  C63C  49 30     .DECLOOP  	      	EOR     #'0'            	;Strip ASCII part
01073  C63E  C9 0A                     	CMP     #9+1            	;Is it still a decimal digit?
01074  C640  B0 64                     	BCS     .DONEG1         	;Nope!
01075  C642  A8                        	TAY                     	;Save new digit
01076  C643  06 CE                     	ASL     HEXVAL          	;Multiply previous value by 10
01077  C645  26 CF                     	ROL     HEXVAL+1
01078  C647  B0 60                     	BCS     .RANGE          	;Exit with range error!
01079  C649  A5 CE                     	LDA     HEXVAL
01080  C64B  0A                        	ASL
01081  C64C  85 D6                     	STA     DEC_SAVE
01082  C64E  A5 CF                    	 	LDA     HEXVAL+1
01083  C650  2A                        	ROL
01084  C651  B0 56                     	BCS     .RANGE          	;Exit with range error!
01085  C653  06 D6                     	ASL     DEC_SAVE
01086  C655  2A                        	ROL
01087  C656  85 D7                     	STA     DEC_SAVE+1
01088  C658  B0 4F                     	BCS     .RANGE          	;Exit with range error!
01089  C65A  A5 D6                     	LDA     DEC_SAVE
01090  C65C  65 CE                     	ADC     HEXVAL
01091  C65E  85 CE                     	STA     HEXVAL
01092  C660  A5 D7                     	LDA     DEC_SAVE+1
01093  C662  65 CF                     	ADC     HEXVAL+1
01094  C664  85 CF                     	STA     HEXVAL+1
01095  C666  B0 41                     	BCS     .RANGE          	;Exit with range error!
01096  C668  98                        	TYA                     	;Add new digit to result
01097  C669  65 CE                     	ADC     HEXVAL
01098  C66B  85 CE                     	STA     HEXVAL
01099  C66D  90 04                     	BCC     .NOCY           	;No carry to high byte
01100  C66F  E6 CF                     	INC     HEXVAL+1
01101  C671  F0 36                     	BEQ     .RANGE  	        ;Exit with range error!
01102  C673  E8        .NOCY           	INX                     	;Point to next digit
01103  C674  B5 18                     	LDA     IN,X            	; and get it
01104  C676  80 C4                     	BRA     .DECLOOP        	;Always taken!
01105  
01106  ;------------------------------------------------------------------------
01107  ; Convert a hex number 16bit
01108  ;------------------------------------------------------------------------
01109  
01110  C678  C9 24     .HEX            	CMP     #'$'            	;Is it a hex number?
01111  C67A  D0 30                     	BNE     .BIN            	;Nope!
01112  
01113  C67C  E8        .HEXLOOP        	INX                     	;Get next character from IN
01114  C67D  B5 18                     	LDA     IN,X
01115  C67F  20 CD D5                  	JSR	HEX2BIN                
01116  C682  C9 FF     	        	CMP	#FAIL
01117  C684  F0 14                     	BEQ     .NOTHEX         	;No hex digit anymore!
01118  C686  0A        .DIG            	ASL                     	;Left justify new nibble
01119  C687  0A                        	ASL
01120  C688  0A                        	ASL
01121  C689  0A                        	ASL
01122  C68A  A0 04                     	LDY     #4              	;Set shift counter
01123  C68C  84 CD                     	STY     DELIM           	;Indicate that input is correct
01124  C68E  0A        .HEXSHIFT       	ASL                     	;Shift new bit into result
01125  C68F  26 CE                     	ROL     HEXVAL
01126  C691  26 CF                     	ROL     HEXVAL+1
01127  C693  B0 14                     	BCS     .RANGE          	;Exit with range error!
01128  C695  88                        	DEY                     	;Decrement counter
01129  C696  D0 F6                     	BNE     .HEXSHIFT       	;Do all 4 bits
01130  C698  F0 E2                     	BEQ     .HEXLOOP        	;Do next nibble (if any)!
01131  
01132  C69A  A5 CD     .NOTHEX         	LDA     DELIM           	;Was a digit entered?
01133  C69C  D0 08                     	BNE     .DONEG1         	;Yes!
01134  C69E  A5 BB                     	LDA     PC_BEG         	 	;If not it was the PC value!
01135  C6A0  85 CE                     	STA     HEXVAL
01136  C6A2  A5 BC                     	LDA     PC_BEG+1
01137  C6A4  85 CF                     	STA     HEXVAL+1
01138  C6A6  4C FC C6  .DONEG1         	JMP     .DONEG          	;Check negative flag & we're done
01139  C6A9  4C 31 D1  .RANGE          	JMP     RANGE_ERROR     	;Exit with range error
01140  
01141  ;------------------------------------------------------------------------
01142  ; Convert ASCII a binary number eg %..1.01.. 
01143  ;------------------------------------------------------------------------
01144  
01145  C6AC  C9 25     .BIN            	CMP     #'%'            	;Is it a binary number?
01146  C6AE  D0 38                     	BNE     .PASC           	;Nope!
01147  C6B0  E8        .BINLOOP        	INX                     	;Point to next char
01148  C6B1  B5 18                     	LDA     IN,X            	; and get it
01149  C6B3  C9 2E                     	CMP     #'.'            	;Ignore dots (for human eyes only)
01150  C6B5  F0 F9                     	BEQ     .BINLOOP
01151  C6B7  49 30                     	EOR     #'0'            	;Ignore ASCII part
01152  C6B9  4A                        	LSR                     	;Shift bit to Carry
01153  C6BA  D0 0A                     	BNE     .EXIT           	;End of binary number
01154  C6BC  26 CE                     	ROL     HEXVAL          	;Roll new bit into end result
01155  C6BE  26 CF                     	ROL     HEXVAL+1
01156  C6C0  B0 E7                     	BCS     .RANGE          	;Range error!
01157  C6C2  E6 CD                     	INC     DELIM           	;Signal that bits were entered
01158  C6C4  80 EA                     	BRA     .BINLOOP        	;Always taken! (reasonably)
01159  
01160  C6C6  A5 CD     .EXIT           	LDA     DELIM           	;Was a number entered?
01161  C6C8  D0 32                     	BNE     .DONEG          	;Yes! Check negative flag now
01162  C6CA  4C C8 CE                  	JMP     DIR_OPE         	;Exit with operand error
01163  
01164  ;------------------------------------------------------------------------
01165  ; Now it must be a label!
01166  ;------------------------------------------------------------------------
01167  
01168  C6CD  20 B4 CF  .LABEL          	JSR     FIND_LABEL      	;Find this label
01169  C6D0  B0 13                     	BCS     .OPE_ERROR      	;Exit with operand error!
01170  C6D2  F0 09                     	BEQ     .NOT_FOUND      	;Label not found!
01171  C6D4  A5 B1                     	LDA     LABEL_FLAG      	;Copy assigned flag to
01172  C6D6  05 BF                     	ORA     FORWARD         	; forward referenced flag
01173  C6D8  85 BF                     	STA     FORWARD
01174  C6DA  4C FC C6  .LBL_EXIT       	JMP     .DONEG          	;Check negative flag & we're done
01175  
01176  C6DD  85 CE     .NOT_FOUND      	STA     HEXVAL          	;A=0, clear hex val
01177  C6DF  85 CF                     	STA     HEXVAL+1
01178  C6E1  C6 BE                     	DEC     UNDEF           	;Set undefined label flag
01179  C6E3  D0 F5                     	BNE     .LBL_EXIT       	;Always taken!
01180  
01181  ;------------------------------------------------------------------------
01182  ; It's none of the above! Operand error
01183  ;------------------------------------------------------------------------
01184  
01185  C6E5  4C C8 CE  .OPE_ERROR      	JMP     DIR_OPE         	;Exit with operand error
01186  
01187  ;------------------------------------------------------------------------
01188  ; Convert a positive ASCII
01189  ;------------------------------------------------------------------------
01190  
01191  C6E8  C9 27     .PASC           	CMP     #'''            	;Is it a positive ASCII?
01192  C6EA  D0 07     	                BNE     .NASC           	;Nope!
01193  
01194  C6EC  20 0C C7          	        JSR     .GETASC         	;Get ASCII character
01195  C6EF  29 7F     	                AND     #@01111111     		;Make it positive
01196  C6F1  10 07                     	BPL     .ASC_END        	;Always taken!
01197  
01198  ;------------------------------------------------------------------------
01199  ; Convert a negative ASCII
01200  ;------------------------------------------------------------------------
01201  
01202  C6F3  C9 27     .NASC           	CMP     #'''            	;Is it negative ASCII?
01203  C6F5  D0 D6                     	BNE     .LABEL          	;Nope!
01204  C6F7  20 0C C7                  	JSR     .GETASC         	;Get ASCII character
01205  C6FA  85 CE     .ASC_END        	STA     HEXVAL          	;And save it
01206  							;Falls through to .DONEG
01207  
01208  ;------------------------------------------------------------------------
01209  ; Check negative flag and we're done
01210  ;------------------------------------------------------------------------
01211  C6FC  A5 CB     .DONEG         		LDA     NEG_FLAG        	;Is the negative flag set?
01212  C6FE  F0 03                     	BEQ     .RTS            	;Nope!
01213  C700  20 74 C8                  	JSR     NEGATE          	;Make hexval negative;
01214  
01215  C703  A5 C5     .RTS   	         	LDA     ERROR           	;Set error flag upon exit
01216  C705  08                        	PHP                     	;Save status
01217  C706  A5 CF                     	LDA     HEXVAL+1        	;Preload new value
01218  C708  A4 CE                     	LDY     HEXVAL
01219  C70A  28                        	PLP                     	;Restore status
01220  C70B  60                        	RTS
01221  
01222  ;------------------------------------------------------------------------
01223  ;Get input until delimiter
01224  ;------------------------------------------------------------------------
01225  
01226  C70C  85 CD     .GETASC         	STA     DELIM           	;Save delimiter char ( ' or ' )
01227  C70E  E8                        	INX                     	;Point to actual ASCII character
01228  C70F  B5 18                     	LDA     IN,X            	; and get it
01229  C711  C9 0D                     	CMP     #CR             	;Replace CR by a space
01230  C713  D0 02                     	BNE     .NOTCR         	 	;Don't bother!
01231  C715  A9 20                     	LDA     #SP
01232  C717  A8        .NOTCR          	TAY                     	;Temporarily save character
01233  C718  E8                        	INX                     	;See if ASCII is terminated by
01234  C719  B5 18                     	LDA     IN,X            	; delimiter
01235  C71B  C5 CD                     	CMP     DELIM
01236  C71D  D0 01                     	BNE     .DELIM          	;No, don't bother to increment
01237  C71F  E8                        	INX                     	; pointer once more
01238  C720  98        .DELIM          	TYA                     	;Get character back
01239  C721  60                        	RTS
01240  
01241  ;------------------------------------------------------------------------
01242  ; Get expression
01243  ;------------------------------------------------------------------------
01244  
01245  C722  20 1D C6  GET_EXPRES      	JSR     GET_VAL         	;Get value A=hi Y=lo address
01246  C725  D0 1E                     	BNE     .RTS            	;An error occurred!
01247  
01248  C727  85 D5     .NEXT           	STA     EXP_SAVE+1      	;Save this value for later
01249  C729  84 D4                     	STY     EXP_SAVE
01250  C72B  B5 18                     	LDA     IN,X            	;Did an operator follow the value?
01251  C72D  E8                        	INX
01252  C72E  C9 2B                     	CMP     #'+'
01253  C730  F0 14                     	BEQ     .ADD            	;Addition!
01254  C732  C9 2D                     	CMP     #'-'
01255  C734  F0 26                     	BEQ     .SUB            	;Subtraction!
01256  C736  C9 2A                     	CMP     #'*'
01257  C738  F0 38                     	BEQ     .MUL            	;Multiplication!
01258  C73A  C9 2F                     	CMP     #'/'
01259  C73C  F0 63                     	BEQ     .DIV            	;Division!
01260  C73E  CA                        	DEX                     	;End of expression. One too far
01261  C73F  A5 CF                     	LDA     HEXVAL+1        	;Load value now
01262  C741  A4 CE                     	LDY     HEXVAL
01263  C743  C4 CE                     	CPY     HEXVAL          	;Make Z=0 (No errors)
01264  C745  60        .RTS            	RTS                     	;None of the above! We're done!
01265  
01266  C746  20 1D C6  .ADD           	 	JSR     GET_VAL         	;Get next value
01267  C749  D0 FA                     	BNE     .RTS            	;An error occurred!
01268  C74B  18                        	CLC                     	;Perform add function
01269  C74C  A5 CE                     	LDA     HEXVAL
01270  C74E  65 D4                     	ADC     EXP_SAVE
01271  C750  85 CE                     	STA     HEXVAL
01272  C752  A8                        	TAY
01273  C753  A5 CF                     	LDA     HEXVAL+1
01274  C755  65 D5                     	ADC     EXP_SAVE+1
01275  C757  85 CF                     	STA     HEXVAL+1
01276  C759  4C 27 C7                  	JMP     .NEXT           	;More operands can follow
01277  
01278  C75C  20 1D C6  .SUB            	JSR     GET_VAL         	;Get next value
01279  C75F  D0 E4                     	BNE     .RTS            	;An error occurred!
01280  C761  38                        	SEC                     	;Perform subtract function
01281  C762  A5 D4                     	LDA     EXP_SAVE
01282  C764  E5 CE                     	SBC     HEXVAL
01283  C766  85 CE                     	STA     HEXVAL
01284  C768  A8                        	TAY
01285  C769  A5 D5                     	LDA     EXP_SAVE+1
01286  C76B  E5 CF                     	SBC     HEXVAL+1
01287  C76D  85 CF                     	STA     HEXVAL+1
01288  C76F  4C 27 C7                  	JMP     .NEXT           	;More operands can follow!
01289  
01290  C772  20 1D C6  .MUL            	JSR     GET_VAL         	;Get next value
01291  C775  D0 CE                     	BNE     .RTS            	;An error occurred!
01292  
01293  C777  64 D2                     	STZ     MULDIV          	;Clear temp result
01294  C779  64 D3                     	STZ     MULDIV+1
01295  C77B  A0 10                     	LDY     #16             	;Do 16-bit multiply
01296  
01297  C77D  A5 CE     .MULLOOP        	LDA     HEXVAL          	;Get LSB of operand 2 in carry
01298  C77F  4A                        	LSR
01299  C780  90 0D                     	BCC     .MULZERO        	;Multiply by 0! Forget about it
01300  C782  18                        	CLC                     	;Add shifted operand 1 to temp
01301  C783  A5 D2                     	LDA     MULDIV
01302  C785  65 D4                     	ADC     EXP_SAVE
01303  C787  85 D2                     	STA     MULDIV
01304  C789  A5 D3                     	LDA     MULDIV+1
01305  C78B  65 D5                     	ADC     EXP_SAVE+1
01306  C78D  85 D3                     	STA     MULDIV+1
01307  C78F  66 D3     .MULZERO        	ROR     MULDIV+1        	;Roll temp result bit into
01308  C791  66 D2                     	ROR     MULDIV          	; end result
01309  C793  66 CF                     	ROR     HEXVAL+1
01310  C795  66 CE                     	ROR     HEXVAL
01311  C797  88                        	DEY
01312  C798  D0 E3                     	BNE     .MULLOOP        	;Do all 16 bits!
01313  	
01314  C79A  A4 CE             	        LDY     HEXVAL          	;Preload the value
01315  C79C  A5 CF     	                LDA     HEXVAL+1
01316  C79E  4C 27 C7                  	JMP     .NEXT           	;More operands can follow!
01317  
01318  C7A1  20 1D C6  .DIV            	JSR     GET_VAL         	;Get next value
01319  C7A4  D0 9F                     	BNE     .RTS            	;An error occurred
01320  C7A6  A5 CE                     	LDA     HEXVAL          	;Avoid divide by 0
01321  C7A8  05 CF                     	ORA     HEXVAL+1
01322  C7AA  F0 31                     	BEQ     .DIVERR         	;It is divide by 0!
01323  
01324  C7AC  64 D2                  		STZ     MULDIV          	;Clear temp result
01325  C7AE  64 D3                     	STZ     MULDIV+1           
01326  C7B0  A0 10                     	LDY     #16             	;Do 16-bit multiply
01327  
01328  C7B2  06 D4     .DIVLOOP        	ASL     EXP_SAVE        	;Roll 1 bit out of operand 1
01329  C7B4  26 D5                     	ROL     EXP_SAVE+1
01330  C7B6  26 D2                     	ROL     MULDIV
01331  C7B8  26 D3                     	ROL     MULDIV+1
01332  C7BA  38                        	SEC                     	;Does operand 2 go into temp?
01333  C7BB  A5 D2                     	LDA     MULDIV
01334  C7BD  E5 CE                     	SBC     HEXVAL
01335  C7BF  48                        	PHA                     	;Don't save temp yet
01336  C7C0  A5 D3                     	LDA     MULDIV+1
01337  C7C2  E5 CF                     	SBC     HEXVAL+1
01338  C7C4  90 08                     	BCC     .DIVSKIP        	;It didn't go!
01339  C7C6  E6 D4                     	INC     EXP_SAVE        	;Set low bit of result
01340  C7C8  85 D3                     	STA     MULDIV+1        	;Save new temp result
01341  C7CA  68                        	PLA                     	;Save low byte too without
01342  C7CB  48                        	PHA                     	; affecting the stack
01343  C7CC  85 D2                     	STA     MULDIV
01344  C7CE  68        .DIVSKIP        	PLA                     	;Clear stack
01345  C7CF  88                        	DEY
01346  C7D0  D0 E0                     	BNE     .DIVLOOP       	 	;Do all 16 bits!
01347  
01348  C7D2  A4 D4     	                LDY     EXP_SAVE        	;Preload the value
01349  C7D4  84 CE                     	STY     HEXVAL
01350  C7D6  A5 D5                     	LDA     EXP_SAVE+1
01351  C7D8  85 CF                     	STA     HEXVAL+1
01352  C7DA  4C 27 C7  .NEXT_STEP      	JMP     .NEXT           	;More operands can follow!
01353  
01354  C7DD  A5 AC     .DIVERR         	LDA     PASS            	;Ignore div 0 during pass 1
01355  C7DF  F0 F9                     	BEQ     .NEXT_STEP      	;It is pass 0!
01356  C7E1  A9 44                     	LDA     #ERR_DIV        	;Exit with divide by 0 error
01357  C7E3  85 C5                     	STA     ERROR
01358  C7E5  60                        	RTS
01359  
01360  ;------------------------------------------------------------------------
01361  ; Print decimal number and/or write value to IN,X 
01362  ; HEXVAL  holds the value to be printed 16bit wide
01363  ;------------------------------------------------------------------------
01364  
01365  C7E6  A4 CE     PRDECI_HEXVAL   	LDY     HEXVAL          	;Copy value to work registers
01366  C7E8  A5 CF     			LDA	HEXVAL+1
01367  
01368  ;------------------------------------------------------------------------
01369  ; Print decimal number and/or write value to IN,X 
01370  ; A & Y  holds the value to be printed 16bit wide
01371  ;------------------------------------------------------------------------
01372  		
01373  C7EA  84 D4     WRDECI         		STY     EXP_SAVE        	;       	
01374  C7EC  85 D5                     	STA     EXP_SAVE+1
01375  C7EE  A0 04                     	LDY     #4              	;A maximum of 5 decades and 4
01376  C7F0  64 D0                     	STZ     LEAD0           	; leading zeroes
01377  
01378  C7F2  A9 30     .DECLOOP        	LDA     #'0'            	;Start with 0
01379  C7F4  85 D1                     	STA     CHAR
01380  C7F6  A5 D4     .LOOP           	LDA     EXP_SAVE        	;Try to subtract decade from
01381  C7F8  D9 2D C8                  	CMP     .DECIL,Y        	; value
01382  C7FB  A5 D5                     	LDA     EXP_SAVE+1
01383  C7FD  F9 32 C8                  	SBC     .DECIH,Y
01384  C800  90 0D                     	BCC     .DONE           	;Didn't go! Done this decade
01385  C802  85 D5                     	STA     EXP_SAVE+1      	;Save new intermediate result
01386  C804  A5 D4                     	LDA     EXP_SAVE
01387  C806  F9 2D C8                  	SBC     .DECIL,Y
01388  C809  85 D4                     	STA     EXP_SAVE
01389  C80B  E6 D1                     	INC     CHAR            	;Increment counter
01390  C80D  D0 E7                     	BNE     .LOOP
01391  
01392  C80F  A5 D1     .DONE           	LDA     CHAR            	;Get decade character
01393  C811  C8                        	INY                     	;Last digit?
01394  C812  88                        	DEY
01395  C813  F0 0A                     	BEQ     .PRINT          	;Yes! Simply print it
01396  C815  C9 30                     	CMP     #'0'            	;Is it a 0?
01397  C817  F0 02                     	BEQ     .LEAD0          	;Yep!
01398  C819  C6 D0                     	DEC    	LEAD0          		;B7=1, no more leading zeroes
01399  C81B  24 D0     .LEAD0          	BIT     LEAD0           	;Still leading zeroes?
01400  C81D  10 0A                     	BPL     .NEXT           	;Yes! Skip them
01401  
01402  C81F  20 77 D5  .PRINT          	JSR     WRCHAR          	;Print character
01403  C822  24 E7                     	BIT     AUTO_FLAG       	;Auto line number?
01404  C824  10 03                     	BPL     .NEXT           	;Nope!
01405  C826  95 18                     	STA     IN,X            	;Save character in input line
01406  C828  E8                        	INX
01407  C829  88        .NEXT           	DEY                     	;Do all 5 digits (except the LSD)
01408  C82A  10 C6                     	BPL     .DECLOOP        	;Not done them all yet!
01409  C82C  60                        	RTS
01410  
01411  
01412  .DECIL          .BYTE     $01,$0a,$64,$e8,$10
01413  .DECIH          .BYTE     $00,$00,$00,$03,$27
01414  
01415  
01416  ;------------------------------------------------------------------------
01417  ; Check object if code was generated
01418  ;------------------------------------------------------------------------
01419  
01420  C837  18        CHECK_OBJ       	CLC
01421  C838  A5 B7     			LDA     TA              	;See if code was generated
01422  C83A  45 B9                     	EOR     TA_BEGIN
01423  C83C  F0 02                     	BEQ	.NOK			;no code 		
01424  C83E  80 06                     	BRA	.CODE
01425                   		
01426  C840  A5 B8     .NOK 			LDA     TA+1			;what about high byte	
01427  C842  45 BA                     	EOR     TA_BEGIN+1
01428  C844  F0 01                     	BEQ     .CHECK_OBJ_RTS  	; No code!                           
01429  C846  38        .CODE	        	SEC	        
01430  C847  60        .CHECK_OBJ_RTS		RTS
01431  
01432  ;------------------------------------------------------------------------
01433  ; Print object range
01434  ;------------------------------------------------------------------------
01435  
01436  C848  A5 B7     PRINT_OBJ      		LDA     TA            	  	;See if code was generated
01437  C84A  45 B9                     	EOR     TA_BEGIN
01438  C84C  D0 06                     	BNE	.OK			;no code 
01439  C84E  A5 B8                     	LDA     TA+1
01440  C850  45 BA                     	EOR     TA_BEGIN+1
01441  C852  F0 1F                     	BEQ     .PRINT_OBJ_RTS  	;No code!
01442                  
01443  C854  A9 86     .OK             	LDA 	#CODE_ORG
01444  C856  20 5F C4  			JSR	PRINT_MSGS
01445  		
01446  C859  A4 B9     			LDY     TA_BEGIN        	;First print begin address
01447  C85B  A5 BA                     	LDA     TA_BEGIN+1
01448  C85D  20 A0 D5                  	JSR     WRWORD 
01449  C860  20 5D D5                  	JSR     WRDOT
01450  C863  38                        	SEC                     	;Then print end address
01451  C864  A5 B8                     	LDA     TA+1            	; (but this time one less)
01452  C866  A4 B7                     	LDY     TA
01453  C868  D0 02                     	BNE     .NOBOR          	;No borrow from high byte
01454  C86A  E9 01                     	SBC     #1
01455  C86C  88        .NOBOR          	DEY                     	;Decrement low byte
01456  C86D  20 A0 D5                  	JSR     WRWORD 
01457  C870  4C 70 D5                  	JMP     WRCRLF           	;Followed by CR
01458  C873  60        .PRINT_OBJ_RTS		RTS
01459  ;------------------------------------------------------------------------
01460  ; Make HEXVAL negative
01461  ;------------------------------------------------------------------------
01462  
01463  C874  A5 CE     NEGATE          	LDA     HEXVAL          	;Negate value
01464  C876  49 FF                     	EOR     #$FF
01465  C878  85 CE                     	STA     HEXVAL
01466  C87A  A5 CF                     	LDA     HEXVAL+1
01467  C87C  49 FF                     	EOR     #$FF
01468  C87E  E6 CE                     	INC     HEXVAL
01469  C880  D0 00                     	BNE     .RTS            	;No carry to high byte!
01470   	        	;INC             		;??????????????
01471  C882  85 CF     .RTS            	STA     HEXVAL+1
01472  C884  60                        	RTS
01473  
01474  ;------------------------------------------------------------------------
01475  ; Commands file
01476  ;------------------------------------------------------------------------
01477  
01478  ;------------------------------------------------------------------------
01479  ; Auto line numbering
01480  ; Increment is done once line is accepted
01481  ;------------------------------------------------------------------------
01482  
01483  C885  24 E7     AUTONUM         	BIT     AUTO_FLAG       	;Is auto line number enabled?
01484  C887  10 11                     	BPL     .RTS            	;Nope!
01485  C889  A5 E4                     	LDA     AUTO            	;Setup next line number
01486  C88B  85 CE                     	STA     HEXVAL
01487  C88D  A5 E5                     	LDA     AUTO+1
01488  C88F  85 CF                     	STA     HEXVAL+1
01489  C891  20 E6 C7                  	JSR     PRDECI_HEXVAL 		;Print decimal value
01490  C894  20 6C D5                  	JSR     WRSPACE         	;Followed by a space
01491  C897  95 18                     	STA     IN,X
01492  C899  E8                        	INX
01493  C89A  60        .RTS            	RTS
01494  
01495  ;------------------------------------------------------------------------
01496  ; Auto command
01497  ;------------------------------------------------------------------------
01498  
01499  C89B  F0 2F     CMD_AUT         	BEQ     SET            		;Nope!
01500  C89D  C9 2C     	                CMP     #','           	 	;Is line number given?
01501  C89F  F0 1E     	                BEQ     .INC            	;Nope!
01502  C8A1  20 1D C6  	                JSR     GET_VAL         	;Get the line number value
01503  C8A4  D0 28     	                BNE     _RTS            	;An error occurred!
01504  C8A6  84 E4     	                STY     AUTO            	;Save new value
01505  C8A8  85 E5     	                STA     AUTO+1
01506  C8AA  A9 2A     	                LDA	#AUTOTEXT
01507  C8AC  20 5F C4  	                JSR	PRINT_MSGS
01508  C8AF  A4 E4     	                LDY	AUTO
01509  C8B1  A5 E5     	                LDA	AUTO+1
01510  C8B3  20 EA C7  	                JSR	WRDECI 	
01511  C8B6  20 7B D5  			JSR	DRAWLINE		;draw line                                
01512  	                
01513  C8B9  B5 18     	                LDA     IN,X            	;Does the increment follow?
01514  C8BB  C9 2C     	                CMP     #','
01515  C8BD  D0 0D     	                BNE     SET             	;Nope!
01516  	
01517  C8BF  E8        .INC            	INX
01518  C8C0  20 1D C6  	                JSR     GET_VAL         	;Get the increment value
01519  C8C3  D0 09     	                BNE     _RTS            	;An error occurred!
01520  C8C5  C0 00     	                CPY     #0              	;Inc of 0 not allowed
01521  C8C7  D0 01     	                BNE     .NOT0           	;It is not 0!
01522  C8C9  C8                        	INY                     	;Zero was not allowed
01523  C8CA  84 E6     .NOT0           	STY     AUTO_INC        	;Save increment
01524  C8CC  C6 E7     SET            		DEC     AUTO_FLAG       	;Make b7=1 (It was 0 before!)
01525  		
01526  C8CE  60        _RTS            	RTS
01527  
01528  ;------------------------------------------------------------------------
01529  ; Copy command
01530  ;------------------------------------------------------------------------
01531  
01532  C8CF  84 BE     CMD_COP         	STY     UNDEF           	;Clear undefined label flag
01533  C8D1  20 04 C9  	                JSR     .GETVAL         	;Get Source
01534  C8D4  F0 58     	                BEQ     ERROR_MISSING   	;Missing parameter!
01535  C8D6  84 DB     	                STY     SRCE
01536  C8D8  A5 CF     	                LDA     HEXVAL+1
01537  C8DA  85 DC     	                STA     SRCE+1
01538  C8DC  20 04 C9  	                JSR     .GETVAL         	;Get Destination
01539  C8DF  F0 4D     	                BEQ     ERROR_MISSING   	;Missing parameter!
01540  C8E1  84 DD     	                STY     DEST
01541  C8E3  A5 CF     	                LDA     HEXVAL+1
01542  C8E5  85 DE     	                STA     DEST+1
01543  C8E7  20 04 C9  	                JSR     .GETVAL         	;Get length
01544  C8EA  84 D9     	                STY     LENG
01545  C8EC  A5 CF     	                LDA     HEXVAL+1
01546  C8EE  85 DA     	                STA     LENG+1
01547  C8F0  05 D9     	                ORA     LENG
01548  C8F2  F0 29     	                BEQ     .RTS            	;Length is 0! We're done
01549  	
01550  C8F4  A5 DB     	                LDA     SRCE            	;Copy up or down?
01551  C8F6  C5 DD     	                CMP     DEST
01552  C8F8  A5 DC     	                LDA     SRCE+1
01553  C8FA  E5 DE     	                SBC     DEST+1
01554  C8FC  90 03     	                BCC     .MOVEUP         	;Move up!
01555  C8FE  4C 14 C4  	                JMP     MOV_DOWN        	;Move memory block down
01556  
01557  C901  4C 35 C4  .MOVEUP         	JMP     MOV_UP          	;Move memory block up
01558  
01559  C904  20 C3 C5  .GETVAL         	JSR     NNONSPC         	;See if end of line
01560  C907  F0 15     	                BEQ     .MIS            	;Yes!
01561  C909  20 22 C7  	                JSR     GET_EXPRES      	;Get value
01562  C90C  D0 18     	                BNE     _ERROR          	;An error occurred
01563  C90E  A5 BE     	                LDA     UNDEF           	;Undefined label used?
01564  C910  D0 10     	                BNE     .UNDEF          	;Yes!
01565  C912  B5 18     	                LDA     IN,X
01566  C914  C9 0D     	                CMP     #CR             	;End of line?
01567  C916  F0 05     	                BEQ     .RTS            	;Yes! Z=1 now!
01568  C918  C9 2C     	                CMP     #','            	;Must be a comma now
01569  C91A  D0 02     	                BNE     .MIS            	;It's not!
01570  C91C  E8        	                INX                     	;Z=0 now!
01571  C91D  60        .RTS            	RTS
01572  
01573  C91E  A9 26     .MIS            	LDA     #ERR_MIS        	;Exit with missing error
01574  C920  D0 02                     	BNE     .SKIP           	;Always taken
01575  
01576  C922  A9 5E     .UNDEF          	LDA     #ERR_DEF        	;Exit with undefined label
01577  C924  85 C5     .SKIP          		STA     ERROR
01578  C926  68        _ERROR          	PLA                     	;Pull return address from stack
01579  C927  68                        	PLA
01580  C928  60                        	RTS
01581  
01582  ;------------------------------------------------------------------------
01583  ; Erase command - erase  line from editer
01584  ;------------------------------------------------------------------------
01585  
01586  C929  20 76 C9  CMD_ERASE         	JSR     BEG_END         	;Get begin and end line parameters
01587  C92C  B0 05                     	BCS     DELETE          	;Parameters given! Do delete
01588  
01589  C92E  A9 26     ERROR_MISSING   	LDA     #ERR_MIS        	;Exit with missing parameter
01590  C930  85 C5                     	STA     ERROR
01591  C932  60        ERASE_RTS         	RTS
01592  
01593  ;------------------------------------------------------------------------
01594  ; Delete block of lines
01595  ;------------------------------------------------------------------------
01596  
01597  C933  A5 C9     DELETE         		LDA     PARM2           	;Don't delete anything if
01598  C935  C5 C7     	                CMP     PARM1           	; begin > end
01599  C937  A5 CA     	                LDA     PARM2+1
01600  C939  E5 C8     	                SBC     PARM1+1
01601  C93B  90 F5     	                BCC     ERASE_RTS         	;Begin is indeed > end!
01602  	
01603  C93D  A0 C7     	                LDY     #PARM1          	;Find this line number
01604  C93F  20 D0 CC  	                JSR     FIND_LINE
01605  C942  90 EE     	                BCC     ERASE_RTS         	;EOF reached! Line not found
01606  	
01607  C944  A5 B2     	                LDA     PNTR            	;Current pointer is going to be
01608  C946  85 DD     	                STA     DEST            	; the move's destination anyway
01609  C948  A5 B3     	                LDA     PNTR+1
01610  C94A  85 DE     	                STA     DEST+1
01611  
01612  C94C  A0 01     .LOOP           	LDY     #1              	;See if we're already past end
01613  C94E  A5 C9     	                LDA     PARM2
01614  C950  D1 B2     	                CMP     (PNTR),Y
01615  C952  C8        	                INY
01616  C953  A5 CA     	                LDA     PARM2+1
01617  C955  F1 B2     	                SBC     (PNTR),Y
01618  C957  90 05     	                BCC     .FOUNDEND       	;Yes!
01619  C959  20 FB CC  	                JSR     NEXT_LINE       	;Find next line
01620  C95C  D0 EE     	                BNE     .LOOP           	;Do until end line found!
01621  
01622  C95E  A5 B2     .FOUNDEND       	LDA     PNTR            	;This pointer is going to be
01623  C960  85 DB     	                STA     SRCE            	; the source
01624  C962  45 DD     	                EOR     DEST            	;And see if source and dest are
01625  C964  85 CC     	                STA     COUNT           	; the same
01626  C966  A5 B3     	                LDA     PNTR+1
01627  C968  85 DC     	                STA     SRCE+1
01628  C96A  45 DE     	                EOR     DEST+1
01629  C96C  05 CC     	                ORA     COUNT
01630  C96E  F0 C2     	                BEQ     ERASE_RTS         	;They are the same! Why bother
01631  C970  20 9B CC  	                JSR     CALC_LENG       	;Calculate number of bytes to move
01632  C973  4C 14 C4  	                JMP     MOV_DOWN        	;Move from next line to end down
01633  
01634  ;------------------------------------------------------------------------
01635  ; Get begin and end line number from user
01636  ;------------------------------------------------------------------------
01637  
01638  C976  84 C6     BEG_END         	STY     DUMP            	;Disable dump mode
01639  C978  84 C7     	                STY     PARM1           	;Set default begin and end lines
01640  C97A  84 C8     	                STY     PARM1+1         	; Y=0
01641  C97C  88        	                DEY
01642  C97D  84 C9     	                STY     PARM2
01643  C97F  84 CA     	                STY     PARM2+1
01644  C981  20 C3 C5  	                JSR     NNONSPC         	;Are there any parameters?
01645  C984  F0 2E     	                BEQ     .NOPARM         	;No parameters given!
01646  C986  C9 44     	                CMP     #'D'            	;Dump mode?
01647  C988  F0 28     	                BEQ     .DUMP           	;Yes!
01648  		
01649  C98A  C9 2C     	                CMP     #','            	;Is begin line given?
01650  C98C  F0 17     	                BEQ     .ENDLIN        		;Nope!
01651  C98E  20 1D C6  	                JSR     GET_VAL         	;Get begin line number
01652  C991  D0 1C     	                BNE     .ERRORLB        	;An error occurred
01653  C993  84 C7     	                STY     PARM1           	;Save begin line number
01654  C995  85 C8     	                STA     PARM1+1
01655  	
01656  C997  B5 18     	                LDA     IN,X           	 	;Does the end line number follow?
01657  C999  C9 2C     	                CMP     #','
01658  C99B  F0 08     	                BEQ     .ENDLIN         	;Yes! Get it
01659  C99D  A5 CF     	                LDA     HEXVAL+1        	;If not make begin = end
01660  C99F  85 CA     .SAVE_DONE      	STA     PARM2+1
01661  C9A1  84 C9                     	STY     PARM2
01662  C9A3  38        .DONE           	SEC                     	;Indicate parameter given
01663  C9A4  60                        	RTS
01664  
01665  C9A5  20 80 CB  .ENDLIN         	JSR     IN_BLANK        	;Get next and see if it's blank
01666  C9A8  F0 F9     	                BEQ     .DONE           	;EOL! No line number
01667  C9AA  20 1D C6  	                JSR     GET_VAL
01668  C9AD  F0 F0     	                BEQ     .SAVE_DONE      	;No error occurred
01669  
01670  C9AF  68        .ERRORLB        	PLA                     	;An error occurred, pop return
01671  C9B0  68                        	PLA                     	; address from stack
01672  C9B1  60                        	RTS
01673  
01674  C9B2  85 C6     .DUMP           	STA     DUMP            	;Activate dump mode and CY=0
01675  C9B4  18        .NOPARM         	CLC                     	;Indicate no parameters are given
01676  C9B5  60                        	RTS                     	; (DEL requires them!)
01677  
01678  ;------------------------------------------------------------------------
01679  ; LIST command
01680  ;------------------------------------------------------------------------
01681  
01682  C9B6  20 76 C9  CMD_LST         	JSR     BEG_END         	;Get begin and end line parameters
01683  C9B9  A0 C7                     	LDY     #PARM1          	;Find first line
01684  C9BB  20 D0 CC                  	JSR     FIND_LINE
01685  
01686  C9BE  20 AD D5  .LOOP           	JSR     SCAN_ESC            	;SCAN_ESC if key pressed
01687  C9C1  F0 3E     	                BEQ     .RTS            	;ESC pressed!
01688  C9C3  A0 00     	                LDY     #0              	;Check EOF
01689  C9C5  B1 B2     	                LDA     (PNTR),Y
01690  C9C7  F0 38     	                BEQ     .RTS            	;Yes!
01691  C9C9  C8        	                INY                     	;See if we're past end line
01692  C9CA  38        	                SEC
01693  C9CB  B1 B2     	                LDA     (PNTR),Y
01694  C9CD  85 CE     	                STA     HEXVAL
01695  C9CF  E5 C9     	                SBC     PARM2
01696  C9D1  85 CD     	                STA     DELIM           	;Used to see if equal
01697  C9D3  C8        	                INY
01698  C9D4  B1 B2     	                LDA     (PNTR),Y
01699  C9D6  85 CF     	                STA     HEXVAL+1
01700  C9D8  E5 CA     	                SBC     PARM2+1
01701  C9DA  05 CD     	                ORA     DELIM
01702  C9DC  F0 02     	                BEQ     .EQUAL          	;Hey, last line to list!
01703  C9DE  B0 21     	                BCS     .RTS            	;We're done!
01704  
01705  C9E0  A5 C6     .EQUAL          	LDA     DUMP            	;Dump mode?
01706  C9E2  D0 06                     	BNE     .SKIP           	;Yes! Skip line number printing
01707  C9E4  20 E6 C7                  	JSR     PRDECI_HEXVAL
01708  C9E7  20 6C D5                  	JSR     WRSPACE
01709  
01710  C9EA  20 0B CD  .SKIP           	JSR     UNPACK          	;Unpack current line
01711  C9ED  A2 00                     	LDX     #0              	;Print the entire unpacked line
01712  C9EF  B5 18     .PRINT          	LDA     IN,X
01713  C9F1  E8        	                INX
01714  C9F2  20 77 D5  	                JSR     WRCHAR
01715  C9F5  C9 0D     	                CMP     #CR             	;End of line?
01716  C9F7  D0 F6     	                BNE     .PRINT          	;Not yet!
01717  C9F9  20 75 D5  	                JSR	PRLF			;New line on screen	
01718  C9FC  20 FB CC  	                JSR     NEXT_LINE       	;Set pointer to next line
01719  C9FF  D0 BD     	                BNE     .LOOP           	;Repeat if not EOF!
01720  CA01  60        .RTS            	RTS
01721  
01722  ;------------------------------------------------------------------------
01723  ; MEMORY command
01724  ; Warning! Range is not checked! It's your own responsibility to set the
01725  ; range. Illegal ranges are belowe $0200, above RAM, inside own source,
01726  ; lomem => himem.
01727  ;------------------------------------------------------------------------
01728  
01729  CA02  F0 26     CMD_MEM         	BEQ     SHOWMEM         	;Yes! Set Lomem,Himem
01730  CA04  B5 18     	                LDA     IN,X            	;Is lomem given?
01731  CA06  C9 2C     	                CMP     #','
01732  CA08  F0 0F     	                BEQ     .HIMEM          	;Nope!
01733  	
01734  CA0A  20 1D C6  	                JSR     GET_VAL         	;Get lomem value
01735  CA0D  D0 5C     	                BNE     RTS_MEM         	;An error occurred!
01736  CA0F  84 EE     	                STY     LOMEM           	;Copy new lomem value
01737  CA11  85 EF     	                STA     LOMEM+1
01738  	
01739  CA13  B5 18     	                LDA     IN,X            	;Is highmem given? (soft)
01740  CA15  C9 2C     	                CMP     #','
01741  CA17  D0 0A     	                BNE     .DONE           	;Nope! Leave it
01742  
01743  CA19  E8        .HIMEM          	INX
01744  CA1A  20 1D C6  	                JSR     GET_VAL         	;Get himem value
01745  CA1D  D0 4C     	                BNE     RTS_MEM         	;An error occurred!
01746  CA1F  84 F0     	                STY     HIMEM           	;Copy new himem value
01747  CA21  85 F1     	                STA     HIMEM+1
01748  
01749  CA23  A0 00     .DONE          		LDY     #0              	;Perform a new command
01750  CA25  84 E3                     	STY     OLD_SAVE        	;However OLD will not work now
01751  CA27  20 5A CA                  	JSR     DONEW           	;Clear source program
01752                  
01753  CA2A  A9 52     SHOWMEM         	LDA	#LOWERRAM		;SHOW Memory Values.
01754  CA2C  20 5F C4  			JSR	PRINT_MSGS		
01755  CA2F  A5 EF     			LDA     LOMEM+1         	;Print lomem
01756  CA31  A4 EE     	                LDY     LOMEM
01757  CA33  20 4E CA  	                JSR     .PRWORDCR
01758  	               
01759  CA36  A9 62     	               	LDA	#UPPERRAM
01760  CA38  20 5F C4  			JSR	PRINT_MSGS                
01761  CA3B  A5 F1     	                LDA     HIMEM+1         	;And himem
01762  CA3D  A4 F0     	                LDY     HIMEM
01763  CA3F  20 4E CA  	                JSR     .PRWORDCR
01764  	
01765  CA42  A9 42     	                LDA	#TOTALRAM		
01766  CA44  20 5F C4  			JSR	PRINT_MSGS 		
01767  CA47  20 BB CC  	                JSR     FIND_EOFZ       	;Find end of source file
01768  CA4A  A4 B2     	                LDY     PNTR
01769  CA4C  A5 B3     	                LDA     PNTR+1                
01770                  
01771  CA4E  20 A0 D5  .PRWORDCR       	JSR     WRWORD 
01772  CA51  4C 70 D5                  	JMP     WRCRLF
01773  
01774  
01775  ;------------------------------------------------------------------------
01776  ; NEW command
01777  ;------------------------------------------------------------------------
01778  
01779  CA54  B1 EE     CMD_NEW        		LDA     (LOMEM),Y       	;Save first byte of program (OLD)
01780  CA56  F0 13                     	BEQ     RTS_MEM         	;But don't do it if already 0!
01781  CA58  85 E3                     	STA     OLD_SAVE
01782  
01783  CA5A  98        DONEW           	TYA                     	;Make A=0
01784  CA5B  91 EE                     	STA     (LOMEM),Y       	;Clear first byte of program
01785  CA5D  85 E9                     	STA     SYM_TABLE+1     	;Invalidate symbol table
01786  CA5F  A9 E8                     	LDA     #<DEF_AUTO       	;Set default AUTO line number
01787  CA61  85 E4     	                STA     AUTO
01788  CA63  A9 03     	                LDA     #>DEF_AUTO
01789  CA65  85 E5     	                STA     AUTO+1
01790  CA67  A9 0A     	                LDA     #DEF_INC        	;Set default AUTO increment
01791  CA69  85 E6     	                STA     AUTO_INC
01792  CA6B  60        RTS_MEM         	RTS
01793  
01794  ;------------------------------------------------------------------------
01795  ; OLD command 
01796  ;------------------------------------------------------------------------
01797                     					;Save some space by omitting error
01798  CA6C  A5 E3     CMD_OLD         	LDA     OLD_SAVE        	;Is it possible to do OLD?
01799  CA6E  F0 04     	                BEQ     ._ERROR         	;OLD not possible!
01800  CA70  91 EE     	                STA     (LOMEM),Y       	;Save old value into program
01801  CA72  84 E3     	                STY     OLD_SAVE        	;Clear old flag
01802  CA74  60        ._ERROR         	RTS
01803  
01804  ;------------------------------------------------------------------------
01805  ; Renumber command
01806  ;------------------------------------------------------------------------
01807  
01808  CA75  84 C7     CMD_REN         	STY     PARM1           	;Set default values
01809  CA77  84 C8     	                STY     PARM1+1         	;Start renumbering from line 0
01810  CA79  A9 E8     	                LDA     #<DEF_AUTO       	;Set default renumber start addr.
01811  CA7B  85 C9     	                STA     PARM2
01812  CA7D  A9 03     	                LDA     #>DEF_AUTO
01813  CA7F  85 CA     	                STA     PARM2+1
01814  CA81  A9 0A     	                LDA     #DEF_INC        	;Set default increment
01815  CA83  85 D9     	                STA     LENG
01816  	
01817  CA85  20 C3 C5  	                JSR     NNONSPC         	;Are there any parameters?
01818  CA88  F0 2F     	                BEQ     .RENUMBER       	;No parameters given!
01819  CA8A  C9 2C     	                CMP     #','            	;Is begin line given?
01820  CA8C  F0 0F     	                BEQ     .STRTLIN        	;Nope!
01821  	
01822  CA8E  20 1D C6  	                JSR     GET_VAL         	;Get begin line number
01823  CA91  D0 5D     	                BNE     .DONE           	;An error occurred
01824  CA93  84 C7     	                STY     PARM1           	;Save begin line number
01825  CA95  85 C8     	                STA     PARM1+1
01826  	
01827  CA97  B5 18     	                LDA     IN,X            	;Does the start line number follow?
01828  CA99  C9 2C     	                CMP     #','
01829  CA9B  D0 1C     	                BNE     .RENUMBER       	;Nope! Get going
01830  
01831  CA9D  E8        .STRTLIN        	INX                     	;Get start line
01832  CA9E  20 1D C6  	                JSR     GET_VAL
01833  CAA1  D0 4D     	                BNE     .DONE
01834  CAA3  84 C9     	                STY     PARM2
01835  CAA5  85 CA     	                STA     PARM2+1
01836  	
01837  CAA7  B5 18     	                LDA     IN,X            	;Is increment given?
01838  CAA9  C9 2C     	                CMP     #','
01839  CAAB  D0 0C     	                BNE     .RENUMBER       	;Nope! Get going
01840  	
01841  CAAD  E8        	                INX
01842  CAAE  20 1D C6  	                JSR     GET_VAL         	;Get increment value
01843  CAB1  D0 3D     	                BNE     .DONE
01844  CAB3  C0 00     	                CPY     #0              	;May not be zero!
01845  CAB5  F0 3A     	                BEQ     .RANGE          	;Exit with range error
01846  CAB7  84 D9     	                STY     LENG            	;Save increment
01847  
01848  CAB9  A5 C9     .RENUMBER       	LDA     PARM2           	;See if begin line <= start line
01849  CABB  C5 C7     	                CMP     PARM1           	; to avoid double line numbers
01850  CABD  A5 CA     	                LDA     PARM2+1
01851  CABF  E5 C8     	                SBC     PARM1+1
01852  CAC1  90 2E     	                BCC     .RANGE          	;Nope! Exit with range error
01853  	
01854  CAC3  A5 C9     	                LDA     PARM2           	;Copy parm2 to auto number
01855  CAC5  85 E4     	                STA     AUTO
01856  CAC7  A5 CA     	                LDA     PARM2+1
01857  CAC9  85 E5     	                STA     AUTO+1
01858  CACB  A5 D9     	                LDA     LENG            	;Copy increment to auto_inc
01859  CACD  85 E6     	                STA     AUTO_INC
01860  	
01861  CACF  A0 C7     	                LDY     #PARM1          	;Find first line number
01862  CAD1  20 D0 CC  	                JSR     FIND_LINE
01863  CAD4  90 1A     	                BCC     .DONE           	;End of file!
01864  CAD6  A0 00     	                LDY     #0
01865  
01866  CAD8  C8        .LOOP           	INY                     	;Set new line number
01867  CAD9  18        	                CLC                     	; and calculate next number
01868  CADA  A5 E4     	                LDA     AUTO
01869  CADC  91 B2     	                STA     (PNTR),Y
01870  CADE  65 E6     	                ADC     AUTO_INC
01871  CAE0  85 E4     	                STA     AUTO
01872  CAE2  C8        	                INY
01873  CAE3  A5 E5     	                LDA     AUTO+1
01874  CAE5  91 B2     	                STA     (PNTR),Y
01875  CAE7  69 00     	                ADC     #0
01876  CAE9  85 E5     	                STA     AUTO+1
01877  CAEB  20 FB CC  	                JSR     NEXT_LINE       	;Set pointer to next line
01878  CAEE  D0 E8     	                BNE     .LOOP           	;Nope!
01879  CAF0  60        .DONE           	RTS
01880  CAF1  4C 31 D1  .RANGE          	JMP     RANGE_ERROR     	;Exit with range error
01881  
01882  ;------------------------------------------------------------------------
01883  ; Value command
01884  ;------------------------------------------------------------------------
01885  
01886  CAF4  F0 58     CMD_VAL         	BEQ     .RTS            	;EOL! Missing operand error!
01887  CAF6  A9 00     .LOOP           	LDA     #0
01888  CAF8  85 BE     	                STA     UNDEF           	;Clear undefined label flag
01889  CAFA  20 22 C7  	                JSR     GET_EXPRES      	;Get value
01890  CAFD  D0 4F     	                BNE     .RTS            	;An error occurred!
01891  CAFF  A5 BE     	                LDA     UNDEF           	;Undefined label used?
01892  CB01  D0 62     	                BNE     VAL_UNDEF       	;Yes!
01893  	
01894  CB03  20 E6 C7  			JSR     PRDECI_HEXVAL		;Print value in decimal (ABS)
01895  CB06  20 6C D5  	                JSR     WRSPACE
01896  	
01897  CB09  A5 CF     	                LDA     HEXVAL+1        	;Save original value
01898  CB0B  48        	                PHA
01899  CB0C  A5 CE     	                LDA     HEXVAL
01900  CB0E  48        	                PHA
01901  CB0F  A9 2B     	                LDA     #'+'            	;Print same value, but this time
01902  CB11  24 CF     	                BIT     HEXVAL+1        	; it may be negative
01903  CB13  10 05     	                BPL     .POS            	;It is positive!
01904  CB15  20 74 C8  	                JSR     NEGATE          	;Make value positive again
01905  CB18  A9 2D     	                LDA     #'-'
01906  CB1A  20 77 D5  .POS            	JSR     WRCHAR            	;Print sign
01907  CB1D  20 E6 C7  	                JSR     PRDECI_HEXVAL          	;Print value
01908  CB20  20 6C D5  	                JSR     WRSPACE
01909  	
01910  CB23  68        	                PLA                     	;Restore hexval
01911  CB24  A8        	                TAY
01912  CB25  85 CE     	                STA     HEXVAL
01913  CB27  68        	                PLA
01914  CB28  85 CF     	                STA     HEXVAL+1
01915  CB2A  20 A0 D5  	                JSR     WRWORD           	;Write value as hex
01916  CB2D  20 6C D5  	                JSR     WRSPACE
01917  	
01918  CB30  A9 25     	                LDA     #'%'            	;Print percent aka binary
01919  CB32  20 77 D5  	                JSR     WRCHAR
01920  CB35  A5 CF     	                LDA     HEXVAL+1        	;Is high byte 0?
01921  CB37  F0 06     	                BEQ     .LOW            	;Yes! Do only the low byte
01922  CB39  20 4F CB  	                JSR     WRBIN         	 	;Print this byte binary
01923  CB3C  20 5D D5  	                JSR     WRDOT
01924  CB3F  A5 CE     .LOW            	LDA     HEXVAL          	;Print low byte in binary too
01925  CB41  20 4F CB  	                JSR     WRBIN
01926  	
01927  CB44  20 70 D5  	                JSR     WRCRLF
01928  CB47  B5 18     	                LDA     IN,X            	;Is next char a comma?
01929  CB49  E8        	                INX
01930  CB4A  C9 2C     	                CMP     #','
01931  CB4C  F0 A8     	                BEQ     .LOOP           	;Yes! Then more will follow!
01932  CB4E  60        .RTS            	RTS                     	;Ignore rest (soft error check)
01933  
01934  ;------------------------------------------------------------------------
01935  ; Print binary  IN = AC
01936  ;------------------------------------------------------------------------
01937  				
01938  CB4F  85 D1     WRBIN          		STA     CHAR			;
01939  CB51  20 57 CB                  	JSR     .PRNIB          	;Print nibble
01940  CB54  20 5D D5                  	JSR     WRDOT
01941  CB57  A0 04     .PRNIB          	LDY     #4              	;Setup bit counter
01942  CB59  A9 18     .BITLOOP       		LDA     #'0'/2          	;Start with ASCII 0
01943  CB5B  06 D1                     	ASL     CHAR            	;Move next bit to CY
01944  CB5D  2A                        	ROL                     	;Add bit to ASCII
01945  CB5E  20 77 D5                  	JSR     WRCHAR            	; and print it
01946  CB61  88                        	DEY
01947  CB62  D0 F5                     	BNE     .BITLOOP        	;Do all 4 bits
01948  CB64  60        VAL_RTS         	RTS
01949  CB65  4C 2C CF  VAL_UNDEF       	JMP     UNDEF_ERROR     	;Exit with undefined label used
01950  
01951  ;------------------------------------------------------------------------
01952  ; XEC command
01953  ;------------------------------------------------------------------------
01954  
01955  CB68  F0 0D     CMD_XEC         	BEQ     .RUN            	;Nope! Run from last known addr.
01956  CB6A  20 22 C7                  	JSR     GET_EXPRES      	;Get address to run from
01957  CB6D  D0 F5                     	BNE     VAL_RTS         	;An error occurred!
01958  CB6F  A6 BE                     	LDX     UNDEF           	;Undefined label used?
01959  CB71  D0 F2                     	BNE     VAL_UNDEF       	;Yep!
01960  CB73  84 F2                     	STY     XEC_LAST        	;Save XEC address
01961  CB75  85 F3                     	STA     XEC_LAST+1
01962  
01963  CB77  20 7D CB  .RUN            	JSR     .JSRIND         	;Imitate JSR (IND)
01964  CB7A  4C 70 D5                  	JMP     WRCRLF			;print CR LF
01965  CB7D  6C F2 00  .JSRIND         	JMP     (XEC_LAST)      ;GO!
01966  
01967  ;------------------------------------------------------------------------
01968  ; IN_BLANK  - Get next and see if it's blank
01969  ;------------------------------------------------------------------------
01970  
01971  CB80  E8        IN_BLANK        	INX                     	;Find end of command in IN
01972  CB81  B5 18                     	LDA     IN,X            	;Get character
01973  CB83  C9 20                     	CMP     #SP
01974  CB85  F0 02                     	BEQ     .RTS            	;A space is the end!
01975  CB87  C9 0D                     	CMP     #CR			;CR is EOL
01976  CB89  60        .RTS            	RTS
01977  
01978  ;------------------------------------------------------------------------
01979  ; ADDLINE - Add line to the program 
01980  ; - todo remove PACK into subroutine and add more optoins aka any repitable chars
01981  ;------------------------------------------------------------------------
01982  
01983  CB8A  20 1D C6  ADDLINE         	JSR     GET_VAL         	;Get line number
01984  CB8D  F0 01                     	BEQ     .NOERR          	;No error occurred!
01985  CB8F  60                        	RTS
01986  
01987  CB90  18        .NOERR          	CLC
01988  CB91  A5 CE     	                LDA     HEXVAL          	;Calculate next auto line number
01989  CB93  65 E6     	                ADC     AUTO_INC
01990  CB95  85 E4     	                STA     AUTO
01991  CB97  A9 00     	                LDA     #0              	;Invalidate symbol table
01992  CB99  85 E9     	                STA     SYM_TABLE+1
01993  CB9B  85 E3     	                STA     OLD_SAVE        	;Invalidate OLD command
01994  CB9D  65 CF     	                ADC     HEXVAL+1       	 	;Oh yes, we were busy adding
01995  CB9F  85 E5     	                STA     AUTO+1          	; something!	
01996  CBA1  8A        	                TXA                     	;Save read index
01997  CBA2  A8        	                TAY
01998  CBA3  20 C3 C5  	                JSR     NNONSPC         	;See if line contains text
01999  CBA6  D0 0F     	                BNE     .OK             	;It does!
02000  CBA8  A5 CE     	                LDA     HEXVAL          	;Set begin and end line to linenum
02001  CBAA  85 C7     	                STA     PARM1           	; to delete this line from source
02002  CBAC  85 C9     	                STA     PARM2
02003  CBAE  A5 CF     	                LDA     HEXVAL+1
02004  CBB0  85 C8     	                STA     PARM1+1
02005  CBB2  85 CA     	                STA     PARM2+1
02006  CBB4  4C 33 C9  	                JMP     DELETE          	;Delete this line!
02007  
02008  CBB7  98        .OK             	TYA                     	;Restore read index
02009  CBB8  AA        	                TAX
02010  CBB9  A0 00     	                LDY     #0              	;Clear write index
02011  CBBB  B5 18     	                LDA     IN,X            	;Ignore first space after linenum
02012  CBBD  C9 20     	                CMP     #SP             	; (not part of source)
02013  CBBF  D0 01     	                BNE     .LOOP1          	;Forget about 1st space!
02014  CBC1  E8        .LOOP           	INX                    		;Get next character
02015  CBC2  B5 18     .LOOP1          	LDA     IN,X
02016  CBC4  C9 20     	                CMP     #SP             	;Is it a space?
02017  CBC6  F0 0E     	                BEQ     .PACK           	;Yes! Pack it!
02018  CBC8  C9 2D     	                CMP     #DASH           	;Is it a dash?
02019  CBCA  F0 0A     	                BEQ     .PACK           	;Yes! Pack it!
02020  CBCC  C9 0D     	                CMP     #CR             	;Is it end of line?
02021  CBCE  F0 2B     	                BEQ     .EOL            	;Yes! Packed entire line now!
02022  CBD0  99 18 00  .WRITE          	STA     IN,Y            	;Save normal character
02023  CBD3  C8        	                INY                     	;Increment write pointer
02024  CBD4  80 EB     	                BRA     .LOOP           	;Always taken!
02025  
02026  CBD6  85 CD     .PACK           	STA     DELIM           	;Save character to pack
02027  CBD8  A9 01                    		LDA     #1              	;Init repetition counter
02028  CBDA  85 CC                     	STA     COUNT
02029  CBDC  E8        .PCKLOOP        	INX                     	;Count number of same characters
02030  CBDD  B5 18                     	LDA     IN,X
02031  CBDF  C5 CD     	                CMP     DELIM
02032  CBE1  D0 09     	                BNE     .PCKEXIT        	;It's not the same anymore!
02033  CBE3  E6 CC     	                INC     COUNT           	;Increment counter
02034  CBE5  A5 CC     	                LDA     COUNT           	;Don't allow it to exceed 63
02035  CBE7  C9 3F     	                CMP     #63
02036  CBE9  90 F1     	                BCC     .PCKLOOP        	;Still OK!
02037  CBEB  E8        	                INX                     	;Compensate for normal exit
02038  CBEC  CA        .PCKEXIT        	DEX                     	;We're too far now
02039  CBED  A5 CD                     	LDA     DELIM           	;Was it space or dash?
02040  CBEF  49 20     	                EOR     #' '            	;  (Makes A=0 if it is space                
02041  CBF1  F0 02     	                BEQ     .SPACE          	;It was space!
02042  CBF3  A9 40     	                LDA     #@01000000      	;Set dash flag
02043  CBF5  05 CC     .SPACE          	ORA     COUNT           	;Combine with counter
02044  CBF7  09 80     			ORA	#@10000000		;Set PACK flag
02045  CBF9  80 D5     	                BRA     .WRITE          	;Always taken!
02046  
02047  CBFB  98        .EOL            	TYA                     	;Add 3 byte overhead to length
02048  CBFC  18        	                CLC
02049  CBFD  69 03     	                ADC     #3
02050  CBFF  85 D9     	                STA     LENG            	;Save length
02051  CC01  85 CC     	                STA     COUNT
02052  CC03  A0 CE     	                LDY     #HEXVAL         	;Find line in program memory
02053  CC05  20 D0 CC  	                JSR     FIND_LINE
02054  CC08  90 31     	                BCC     .NEWLINE        	;EOF! Line does not exist yet
02055  CC0A  D0 2F     	                BNE     .NEWLINE        	;Line does not exist yet
02056  
02057  ; The line number already exists. Compare both line lengths
02058  
02059  CC0C  A0 00                    	 	LDY     #0              	;Is new line longer or shorter?
02060  CC0E  38                        	SEC
02061  CC0F  A5 D9                     	LDA     LENG
02062  CC11  F1 B2                     	SBC     (PNTR),Y
02063  CC13  F0 5C                     	BEQ     .INSERT         	;Line length did not change!
02064  CC15  85 D9                     	STA     LENG            	;Save number of bytes difference
02065  CC17  B0 22                     	BCS     .NEWLINE        	;Make room for longer line
02066  
02067  CC19  38        .SHORTER        	SEC                     	;Setup source and destination to
02068  CC1A  A5 B2     	                LDA     PNTR            	; move the source down
02069  CC1C  48        	                PHA
02070  CC1D  85 DD     	                STA     DEST
02071  CC1F  E5 D9     	                SBC     LENG            	;(length is negative!)
02072  CC21  85 DB     	                STA     SRCE
02073  CC23  A5 B3     	                LDA     PNTR+1
02074  CC25  48        	                PHA
02075  CC26  85 DE     	                STA     DEST+1
02076  CC28  E9 FF     	                SBC     #-1             	;(keep high byte negative too!)
02077  CC2A  85 DC     	                STA     SRCE+1
02078  CC2C  20 9B CC  	                JSR     CALC_LENG       	;Get the number of bytes to move
02079  CC2F  68        	                PLA                     	;Restore PNTR (was destroyed by
02080  CC30  85 B3     	                STA     PNTR+1          	; CALC_LENG)
02081  CC32  68        	                PLA
02082  CC33  85 B2     	                STA     PNTR
02083  CC35  20 14 C4  	                JSR     MOV_DOWN        	;Move rest of program down
02084  CC38  4C 71 CC  	                JMP     .INSERT         	;Insert new, shorter, line
02085  
02086  CC3B  A5 B2     .NEWLINE        	LDA     PNTR            	;Use current pointer as
02087  CC3D  48        	                PHA                     	; source
02088  CC3E  85 DB     	                STA     SRCE
02089  CC40  18        	                CLC                     	;Add new line's length to it
02090  CC41  65 D9     	                ADC     LENG            	; to find the destination
02091  CC43  85 DD     	                STA     DEST
02092  CC45  A5 B3     	                LDA     PNTR+1
02093  CC47  48        	                PHA
02094  CC48  85 DC     	                STA     SRCE+1
02095  CC4A  69 00     	                ADC     #0
02096  CC4C  85 DE     	                STA     DEST+1
02097  CC4E  20 9B CC  	                JSR     CALC_LENG       	;Calculate number of bytes to move
02098  	
02099  CC51  18        	                CLC                     	;See if there's enough room in
02100  CC52  A5 DD     	                LDA     DEST            	; memory until HIMEM
02101  CC54  65 D9     	                ADC     LENG
02102  CC56  85 B2     	                STA     PNTR
02103  CC58  A5 DE     	                LDA     DEST+1
02104  CC5A  65 DA     	                ADC     LENG+1
02105  CC5C  85 B3     	                STA     PNTR+1
02106  CC5E  A5 F0     	                LDA     HIMEM
02107  CC60  C5 B2     	                CMP     PNTR
02108  CC62  A5 F1     	                LDA     HIMEM+1
02109  CC64  E5 B3     	                SBC     PNTR+1
02110  CC66  90 2C     	                BCC     .MEMFUL         	;Memory full!
02111  CC68  20 35 C4  	                JSR     MOV_UP          	;Move them!
02112  CC6B  68        	                PLA                     	;Restore pointer
02113  CC6C  85 B3     	                STA     PNTR+1
02114  CC6E  68        	                PLA
02115  CC6F  85 B2     	                STA     PNTR
02116  
02117  CC71  A0 00     .INSERT         	LDY     #0              	;Insert new line to freed space
02118  CC73  A2 00     	                LDX     #0
02119  CC75  A5 CC     	                LDA     COUNT           	;Start with length byte
02120  CC77  91 B2     	                STA     (PNTR),Y
02121  CC79  38        	                SEC                     	;Subtract header length
02122  CC7A  E9 03     	                SBC     #3
02123  CC7C  85 CC     	                STA     COUNT
02124  CC7E  C8        	                INY
02125  CC7F  A5 CE     	                LDA     HEXVAL          	;Then comes the line number
02126  CC81  91 B2     	                STA     (PNTR),Y
02127  CC83  C8        	                INY
02128  CC84  A5 CF     	                LDA     HEXVAL+1
02129  CC86  91 B2     	                STA     (PNTR),Y
02130  CC88  C8        	                INY
02131  CC89  B5 18     .INSLOOP        	LDA     IN,X            	;Get byte from new line
02132  CC8B  91 B2     	                STA     (PNTR),Y        	; and store it
02133  CC8D  E8        	                INX
02134  CC8E  C8        	                INY
02135  CC8F  C6 CC     	                DEC     COUNT
02136  CC91  D0 F6     	                BNE     .INSLOOP        	;Not all bytes done yet!
02137  CC93  60        	                RTS
02138  
02139  CC94  A9 51     .MEMFUL        	 	LDA     #ERR_MEM        	;Exit with memory full error
02140  CC96  85 C5                     	STA     ERROR
02141  CC98  68                        	PLA                     	;Clear stack
02142  CC99  68                        	PLA
02143  CC9A  60                        	RTS
02144  
02145  ;------------------------------------------------------------------------
02146  ; Calculate the length of the memory block to be moved
02147  ;------------------------------------------------------------------------
02148  
02149  CC9B  20 BE CC  CALC_LENG       	JSR     FIND_EOF        	;Find end of source
02150  CC9E  38        	                SEC                     	;Calculate number of bytes to
02151  CC9F  A5 B2     	                LDA     PNTR            	; be moved
02152  CCA1  E5 DB     	                SBC     SRCE
02153  CCA3  85 D9     	                STA     LENG
02154  CCA5  A5 B3     	                LDA     PNTR+1
02155  CCA7  E5 DC     	                SBC     SRCE+1
02156  CCA9  85 DA     	                STA     LENG+1
02157  CCAB  E6 D9     	                INC     LENG            	;Move end byte too!
02158  CCAD  D0 02     	                BNE     .NOCY
02159  CCAF  E6 DA     	                INC     LENG+1
02160  CCB1  60        .NOCY           	RTS
02161  
02162  ;------------------------------------------------------------------------
02163  ; Set pointer to begin of file
02164  ;------------------------------------------------------------------------
02165  
02166  CCB2  A5 EE     SET_BOF         	LDA     LOMEM           	;Set pointer to begin of program
02167  CCB4  85 B2     	                STA     PNTR            	; memory
02168  CCB6  A5 EF     	                LDA     LOMEM+1
02169  CCB8  85 B3     	                STA     PNTR+1
02170  CCBA  60        	                RTS
02171  
02172  ;------------------------------------------------------------------------
02173  ; Find end of program memory
02174  ;------------------------------------------------------------------------
02175  
02176  CCBB  20 B2 CC  FIND_EOFZ       	JSR     SET_BOF         	;Set pointer to begin of file
02177  CCBE  A0 00     FIND_EOF        	LDY     #0              	;Point to line length
02178  CCC0  B1 B2     .LOOP           	LDA     (PNTR),Y        	;Get current line's length
02179  CCC2  F0 0B     	                BEQ     .EOF            	;EOF found!
02180  CCC4  18        	                CLC                     	;Add line length to current pntr
02181  CCC5  65 B2     	                ADC     PNTR
02182  CCC7  85 B2     	                STA     PNTR
02183  CCC9  90 F5     	                BCC     .LOOP           	;Carry is not set!
02184  CCCB  E6 B3     	                INC     PNTR+1
02185  CCCD  B0 F1     	                BCS     .LOOP           	;Always taken
02186  CCCF  60        .EOF            	RTS
02187  
02188  ;------------------------------------------------------------------------
02189  ; Find line in program memory
02190  ; Line number to search for is located at 0,Y
02191  ; EOF -> C=0
02192  ; Line found -> C=1 & Z=1
02193  ; Line not found, pointing at next higher line -> C=1 & Z=0
02194  ;------------------------------------------------------------------------
02195  
02196  CCD0  B9 00 00  FIND_LINE       	LDA     0,Y             	;Get line number to find
02197  CCD3  85 CE     	                STA     HEXVAL
02198  CCD5  B9 01 00  	                LDA     1,Y
02199  CCD8  85 CF     	                STA     HEXVAL+1
02200  CCDA  20 B2 CC  	                JSR     SET_BOF         	;Start looking at begin of program
02201  CCDD  A0 00     	                LDY     #0              	;Empty program?
02202  CCDF  B1 B2     	                LDA     (PNTR),Y
02203  CCE1  F0 16     	                BEQ     .EOF            	;Yes!
02204  
02205  CCE3  C8        .LOOP           	INY                     	;Point to line number
02206  CCE4  38                        	SEC                     	;Subtract wanted line from this
02207  CCE5  B1 B2     	                LDA     (PNTR),Y        	; line number
02208  CCE7  E5 CE     	                SBC     HEXVAL
02209  CCE9  85 CD     	                STA     DELIM
02210  CCEB  C8        	                INY
02211  CCEC  B1 B2     	                LDA     (PNTR),Y
02212  CCEE  E5 CF     	                SBC     HEXVAL+1
02213  CCF0  05 CD     	                ORA     DELIM           	;Z=1 if line is found
02214  CCF2  B0 06     	                BCS     .QUIT           	;Found it or past it!
02215  CCF4  20 FB CC  	                JSR     NEXT_LINE       	;Find next line
02216  CCF7  D0 EA     	                BNE     .LOOP           	;Not end of file yet!
02217  CCF9  18        .EOF            	CLC                     	;Indicate EOF
02218  CCFA  60        .QUIT           	RTS
02219  
02220  ;------------------------------------------------------------------------
02221  ; Set pointer to the next line
02222  ;------------------------------------------------------------------------
02223  
02224  CCFB  A0 00     NEXT_LINE       	LDY     #0              	;Point to line length
02225  CCFD  B1 B2     	                LDA     (PNTR),Y        	;Add length to pointer
02226  CCFF  18        	                CLC
02227  CD00  65 B2     	                ADC     PNTR
02228  CD02  85 B2     	                STA     PNTR
02229  CD04  90 02     	                BCC     .SKIP           	;No carry!
02230  CD06  E6 B3     	                INC     PNTR+1
02231  CD08  B1 B2     .SKIP           	LDA     (PNTR),Y        	;Set Z if this is EOF
02232  CD0A  60                        	RTS
02233  
02234  ;------------------------------------------------------------------------
02235  ; Unpack source line to IN (Without line number)
02236  ;------------------------------------------------------------------------
02237  
02238  CD0B  A0 00     UNPACK          	LDY     #0              	;Get line length
02239  CD0D  B1 B2     	                LDA     (PNTR),Y
02240  CD0F  38        	                SEC
02241  CD10  E9 03     	                SBC     #3              	;Subtract length and line-num
02242  CD12  85 CC     	                STA     COUNT
02243  CD14  A2 00     	                LDX     #0              	;Start at IN
02244  CD16  A0 03     	                LDY     #3              	;This is where the fun is
02245  CD18  B1 B2     .LOOP           	LDA     (PNTR),Y        	;Get byte from source
02246  CD1A  30 0D     	                BMI     .UNPACK         	;It's a packed byte! was bpl
02247  CD1C  95 18     	                STA     IN,X            	;It's a normal character
02248  CD1E  E8        	                INX
02249  CD1F  C8        .NEXT           	INY                     	;Point to next source byte
02250  CD20  C6 CC     	                DEC     COUNT           	;Decrement length counter
02251  CD22  D0 F4     	                BNE     .LOOP           	;Not done yet!
02252  	
02253  CD24  A9 0D     	                LDA     #CR             	;Terminate unpacked line with CR
02254  CD26  95 18     	                STA     IN,X
02255  CD28  60        	                RTS
02256  
02257  CD29  48        .UNPACK         	PHA                     	;Save packed type (space or -)
02258  CD2A  84 CD     	                STY     DELIM           	;Save source code pointer
02259  CD2C  29 3F     	                AND     #@00111111     		;Strip away type flag
02260  CD2E  A8        	                TAY                     	;	 to keep repeat counter
02261  CD2F  68        	                PLA                     	;Find out what type it was
02262  CD30  0A        	                ASL
02263  CD31  30 04     	                BMI     .DASH           	;It was a DASH!
02264  CD33  A9 20     	                LDA     #' '            	;Expand a space
02265  CD35  D0 02     	                BNE     .EXPAND         	;Always taken!
02266  
02267  CD37  A9 2D     .DASH           	LDA     #DASH           	; Expand a dash
02268  CD39  95 18     .EXPAND         	STA     IN,X            	; Save character to IN
02269  CD3B  E8        	                INX
02270  CD3C  88        	                DEY                     	;Decrement counter
02271  CD3D  D0 FA     	                BNE     .EXPAND         	;Not done yet!
02272  CD3F  A4 CD     	                LDY     DELIM           	;Restore index in source
02273  CD41  D0 DC     	                BNE     .NEXT           	;Always taken!
02274  
02275  ;------------------------------------------------------------------------
02276  ; Assemble command
02277  ;------------------------------------------------------------------------
02278  
02279  CD43  20 7B D5  CMD_ASM         	JSR 	DRAWLINE             
02280  CD46  20 BB CC  			JSR     FIND_EOFZ       	;Find end of file
02281  CD49  A4 B2     	                LDY     PNTR            	;Set begin of symbol table
02282  CD4B  A6 B3     	                LDX     PNTR+1
02283  CD4D  C8        	                INY                     	;Symtab starts 1 byte after EOF
02284  CD4E  D0 01     	                BNE     .NOCY           	;No carry!
02285  CD50  E8        	                INX
02286  CD51  84 E8     .NOCY           	STY     SYM_TABLE
02287  CD53  86 E9                     	STX     SYM_TABLE+1
02288  
02289  CD55  A0 00     	                LDY     #0              	;I presume that we're not beyond
02290  CD57  98        	                TYA                     	; himem already for memory's sake
02291  CD58  91 E8     	                STA     (SYM_TABLE),Y   	;Clear symbol table
02292  CD5A  85 AC     	                STA     PASS            	;Set pass 0
02293  CD5C  85 BD     	                STA     ASM_ERR         	;Clear error counter
02294  	
02295  CD5E  20 7E CD  	                JSR     ASSEMBLE        	;Start pass 1
02296  CD61  A5 BD     	                LDA     ASM_ERR         	;Were there any errors?
02297  CD63  D0 08     	                BNE     .ERRORS         	;Yep!
02298  CD65  C6 AC     	                DEC     PASS            	;Start pass 2 (Must be $FF !)
02299  CD67  20 7E CD  	                JSR     ASSEMBLE                   
02300  CD6A  20 48 C8  	                JSR     PRINT_OBJ       	;Print last object range
02301                  
02302  CD6D  20 7B D5  .ERRORS         	JSR	DRAWLINE
02303  CD70  A5 BD     			LDA     ASM_ERR         	;Print number of errors
02304  CD72  85 CE     	                STA     HEXVAL
02305  CD74  64 CF     	                STZ     HEXVAL+1
02306  CD76  20 E6 C7  	                JSR     PRDECI_HEXVAL
02307  CD79  A9 72     	                LDA     #STR_ERRORS     	;Print errors string behind it
02308  CD7B  4C 5F C4  	                JMP     PRINT_MSGS
02309  
02310  ;------------------------------------------------------------------------
02311  ; This is what we came for, assembling!!!!
02312  ;------------------------------------------------------------------------
02313  
02314  CD7E  20 B2 CC  ASSEMBLE        	JSR     SET_BOF         	;Start at begin of program
02315  CD81  64 AE     		        STZ     GLOBAL+1        	;Make last global label invalid        
02316  CD83  AD 80 02  	                LDA     DEF_ORG        		;Setup default PC
02317  CD86  85 B5     	                STA     PC
02318  CD88  85 B7     	                STA     TA
02319  CD8A  85 B9     	                STA     TA_BEGIN
02320  CD8C  AD 81 02  	                LDA     DEF_ORG+1
02321  CD8F  85 B6     	                STA     PC+1
02322  CD91  85 B8     	                STA     TA+1
02323  CD93  85 BA     	                STA     TA_BEGIN+1
02324  
02325  CD95  20 AD D5  .LINE           	JSR     SCAN_ESC        	;SCAN_ESC output if necessary
02326  CD98  F0 48     	                BEQ     .DONE           	;ESC was pressed!
02327  CD9A  A5 B5     	                LDA     PC              	;Copy PC at begin of line
02328  CD9C  85 BB     	                STA     PC_BEG
02329  CD9E  A5 B6     	                LDA     PC+1
02330  CDA0  85 BC     	                STA     PC_BEG+1
02331  CDA2  A0 00     	                LDY     #0              	;End of program?
02332  CDA4  B1 B2     	                LDA     (PNTR),Y
02333  CDA6  F0 3A     	                BEQ     .DONE           	;Yes! We're done (with this pass)
02334  CDA8  84 BE     	                STY     UNDEF           	;Clear undefined label flag
02335  CDAA  84 BF     	                STY     FORWARD         	;and forward ref. label flag
02336  CDAC  84 C5     	                STY     ERROR           	;Clear error number
02337  CDAE  20 0B CD  	                JSR     UNPACK          	;Unpack this line to IN
02338  	
02339  CDB1  A2 00     	                LDX     #0
02340  CDB3  A5 18     	                LDA     IN              	;Can it be a label?
02341  CDB5  C9 20     	                CMP     #' '
02342  CDB7  F0 0B     	                BEQ     .NO_LABEL       	;Nope!
02343  CDB9  C9 0D     	                CMP     #CR             	;Can't be CR, but just in case
02344  CDBB  F0 1D     	                BEQ     .NEXT           	;Do next line!
02345  CDBD  C9 3B     	                CMP     #';'
02346  CDBF  F0 19     	                BEQ     .NEXT           	;It's a comment, ignore line
02347  CDC1  20 B6 D0  	                JSR     ADD_LABEL       	;Add this label to symbol table
02348  
02349  CDC4  20 C3 C5  .NO_LABEL       	JSR     NNONSPC         	;Find next non space now
02350  CDC7  F0 11     	                BEQ     .NEXT           	;That was all, next line please!
02351  CDC9  C9 3B     	                CMP     #';'
02352  CDCB  F0 0D     	                BEQ     .NEXT           	;The rest is comment!
02353  CDCD  C9 2E     	                CMP     #'.'            	;Can it be a directive?
02354  CDCF  F0 06     	                BEQ     .DIRECT         	;Yes! Handle it
02355  CDD1  20 4D D1  	                JSR     MNEMON          	;Decode mnemonic and operand  
02356  CDD4  4C DA CD  	                JMP     .NEXT           	;That's it!
02357  
02358  CDD7  20 0B CE  .DIRECT         	JSR     DIRECT          	;Decode directive
02359  
02360  CDDA  20 E3 CD  .NEXT           	JSR     CHCK_ERROR      	;Handle errors
02361  CDDD  20 FB CC                  	JSR     NEXT_LINE       	;Point to next line
02362  CDE0  D0 B3                     	BNE     .LINE           	;Not EOF!
02363  CDE2  60        .DONE           	RTS
02364  
02365  ;------------------------------------------------------------------------
02366  ; Check error
02367  ; If ERROR<>0 print line number and error behind it
02368  ; Also increment error counter
02369  ;------------------------------------------------------------------------
02370  
02371  CDE3  A5 C5     CHCK_ERROR      	LDA     ERROR           	;Did an error occur?
02372  CDE5  D0 09                     	BNE     .ERRORS         	;Yes!
02373  CDE7  A5 BE                     	LDA     UNDEF           	;Undefined label used in pass 2?
02374  CDE9  25 AC                     	AND     PASS            	; (0 if pass 1)
02375  CDEB  F0 1D                     	BEQ     .RTS            	;Nope!
02376  CDED  20 2C CF                  	JSR     UNDEF_ERROR     	;Exit with undefined label error
02377  
02378  CDF0  A0 01     .ERRORS         	LDY     #1              	;Print line number
02379  CDF2  B1 B2                     	LDA     (PNTR),Y
02380  CDF4  85 CE                     	STA     HEXVAL
02381  CDF6  C8                        	INY
02382  CDF7  B1 B2                     	LDA     (PNTR),Y
02383  CDF9  85 CF                     	STA     HEXVAL+1
02384  CDFB  20 E6 C7                  	JSR     PRDECI_HEXVAL
02385  CDFE  20 6C D5                  	JSR     WRSPACE
02386  CE01  20 5F C4                  	JSR     PRINT_MSGS     		;Print the error
02387  CE04  E6 BD                     	INC     ASM_ERR         	;Increment error counter
02388  CE06  D0 02                     	BNE     .RTS            	;No error overflow!
02389  CE08  C6 BD                     	DEC     ASM_ERR         	;Max indicator is 255 errors.
02390  CE0A  60        .RTS           		RTS
02391  
02392  ;------------------------------------------------------------------------
02393  ; Decode directive
02394  ;------------------------------------------------------------------------
02395  
02396  CE0B  20 3A D1  DIRECT          	JSR     NEXT_IN         	;Get directive's name
02397  CE0E  F0 31                     	BEQ     .EERROR        		;It may not be CR already!
02398  CE10  85 C7                     	STA     PARM1
02399  CE12  20 38 D1                  	JSR     NEXT_IN_Y0
02400  CE15  F0 2A                     	BEQ     .EERROR         	;It may not be CR already!
02401                  	
02402  CE17  85 C8                     	STA     PARM1+1
02403  CE19  B9 46 CE  .SEARCH         	LDA     .TABLE,Y        	;Could it be this one?
02404  CE1C  F0 23                     	BEQ     .EERROR         	;Nope! Directive not found!
02405  CE1E  C5 C7                     	CMP     PARM1
02406  CE20  D0 07                     	BNE     .NEXT           	;Nope!
02407  CE22  B9 47 CE                  	LDA     .TABLE+1,Y
02408  CE25  C5 C8                     	CMP     PARM1+1
02409  CE27  F0 04                     	BEQ     .GOTIT         	 	;Found directive!
02410  CE29  C8        .NEXT           	INY                     	;Point to next directive in table
02411  CE2A  C8                        	INY
02412  CE2B  80 EC                     	BRA     .SEARCH         	;Always taken!
02413  
02414  CE2D  B9 58 CE  .GOTIT          	LDA     .JUMPS+1,Y      	;Get directive handler's address
02415  CE30  48                        	PHA
02416  CE31  B9 57 CE                  	LDA     .JUMPS,Y
02417  CE34  48                        	PHA
02418  CE35  20 38 D1  .EOF_DIR        	JSR     NEXT_IN_Y0      	;Find end of directive first
02419  CE38  F0 0B                     	BEQ     .JUMP           	;Execute directive!
02420  CE3A  C9 20                     	CMP     #SP            		; Is it a space already?
02421  CE3C  D0 F7                     	BNE     .EOF_DIR        	; Nope, not end of directive yet!
02422  CE3E  4C C3 C5                  	JMP     NNONSPC         	; Find next non space
02423  
02424  CE41  A9 6F     .EERROR         	LDA     #ERR_DIR        	; Exit with directive ERROR
02425  CE43  85 C5                     	STA     ERROR
02426  CE45  60        .JUMP           	RTS
02427  
02428  .TABLE          	.BYTE     "AS"          	;ASCII string
02429                  	.BYTE     "AT"          	;ASCII string terminated
02430                  	.BYTE     "BS"          	;Block skip
02431                  	.BYTE     "DA"          	;Data directive
02432                  	.BYTE     "EQ"          	;Word directive
02433                  	.BYTE     "OR"          	;ORG directive
02434                  	.BYTE     "TA"          	;Target address directive
02435                  	.BYTE	  "DB"			;Byte	directive	
02436                  	.BYTE     00            	;End of table
02437  
02438  .JUMPS          	.DW     DIR_AS-1        	;ASCII string
02439                  	.DW     DIR_AT-1        	;ASCII string terminated
02440                  	.DW     DIR_BS-1        	;Block skip
02441                  	.DW     DIR_DA-1        	;Data directive
02442                  	.DW     DIR_EQ-1        	;Word directive
02443                  	.DW     DIR_OR-1        	;ORG directive
02444                  	.DW     DIR_TA-1        	;Target address directive
02445                  	.DW	DIR_DB-1		;Byte directive
02446  
02447  ;------------------------------------------------------------------------
02448  ; .BYTE and .AT directives
02449  ;------------------------------------------------------------------------
02450  
02451  CE67  A0 80     DIR_AT          	LDY     #@10000000     		;Set end flag
02452  CE69  84 D0     DIR_AS          	STY     LEAD0          		;Save end flag
02453  CE6B  A0 7F                     	LDY     #@01111111     		;In case of positive ASCII
02454  CE6D  C9 2D                     	CMP     #'-'           		;Is it the sign flag?
02455  CE6F  D0 07                     	BNE     .POS           		;No! Positive ASCII
02456  CE71  A0 FF                     	LDY     #@11111111     		;Set negative ASCII flag
02457  CE73  20 3A D1                  	JSR     NEXT_IN         	;Point to next character
02458  CE76  F0 50                     	BEQ     DIR_OPE         	;Premature EOL!
02459  CE78  84 D1     .POS            	STY     CHAR            	;Save ASCII polarity
02460  CE7A  85 CD                     	STA     DELIM           	;Save delimiter character
02461  CE7C  20 3A D1  .LOOP           	JSR     NEXT_IN         	;Get next char
02462  CE7F  F0 47                     	BEQ     DIR_OPE         	;Sudden EOL!
02463  CE81  C5 CD                     	CMP     DELIM           	;End of string?
02464  CE83  F0 10                     	BEQ     .EXIT           	;Yes!
02465  CE85  25 D1                     	AND     CHAR            	;Set/clear b7
02466  CE87  B4 19                     	LDY     IN+1,X          	;Is next char the delimiter?
02467  CE89  C4 CD                     	CPY     DELIM
02468  CE8B  D0 02                     	BNE     .NOT_END        	;Nope!
02469  CE8D  45 D0                     	EOR     LEAD0           	;Invert b7 if end flag set
02470  CE8F  20 60 CF  .NOT_END        	JSR     SAVE_OBJ        	;Save byte to object
02471  CE92  4C 7C CE                  	JMP     .LOOP           	;Do all characters
02472  
02473  CE95  20 3A D1  .EXIT           	JSR     NEXT_IN         	;Next char must be blank or EOL
02474  CE98  F0 04                     	BEQ     .RTS            	;It is!
02475  CE9A  C9 20                     	CMP     #SP
02476  CE9C  D0 2A                     	BNE     DIR_OPE         	;It is not!
02477  CE9E  60        .RTS            	RTS
02478  
02479  ;------------------------------------------------------------------------
02480  ; .BS directive
02481  ;------------------------------------------------------------------------
02482  
02483  CE9F  20 22 C7  DIR_BS          	JSR     GET_EXPRES      	;Evaluate expression
02484  CEA2  D0 28                     	BNE     DIR_EXIT        	;An ERROR occurred
02485  CEA4  A5 BE                     	LDA     UNDEF
02486  CEA6  D0 1D                     	BNE     .UNDEF          	;Undefined labels not allowed
02487  CEA8  A5 AC                     	LDA     PASS            	;Don't increment TA during pass 1
02488  CEAA  F0 05                     	BEQ     .PC
02489  CEAC  A0 B7                     	LDY     #TA             	;Add expression to TA
02490  CEAE  20 B3 CE                  	JSR     .ADD
02491  CEB1  A0 B5     .PC             	LDY     #PC             	;Add expression to PC
02492  CEB3  18        .ADD 		      	CLC
02493  CEB4  B9 00 00  	                LDA     0,Y
02494  CEB7  65 CE             	        ADC     HEXVAL
02495  CEB9  99 00 00                  	STA     0,Y
02496  CEBC  B9 01 00                  	LDA     1,Y
02497  CEBF  65 CF                     	ADC     HEXVAL+1
02498  CEC1  99 01 00                  	STA     1,Y
02499  CEC4  60                        	RTS
02500  CEC5  4C 53 CF  .UNDEF          	JMP     DIR_UNDEF       	;Undefined label used!
02501  
02502  CEC8  A9 82     DIR_OPE         	LDA     #ERR_OPE        	;Exit with operand EERROR
02503  CECA  85 C5                     	STA     ERROR
02504  CECC  60        DIR_EXIT        	RTS
02505  
02506  ;------------------------------------------------------------------------
02507  ; .BYTE directive Data directive
02508  ;------------------------------------------------------------------------
02509  
02510  CECD  A9 3C     DIR_DB          	LDA 	#'<'
02511  CECF  85 D1     			STA     CHAR            	;Save prefix
02512  CED1  80 0A     			BRA	PREFIXDA		;get single bytes
02513  
02514  ;------------------------------------------------------------------------
02515  ; .BYTE directive Data directive
02516  ;------------------------------------------------------------------------
02517  
02518  CED3  85 D1     DIR_DA          	STA     CHAR            	;Save prefix
02519  CED5  C9 3C                     	CMP     #'<'            	;Low byte only?
02520  CED7  F0 04                     	BEQ     PREFIXDA        	;Yes!
02521  CED9  C9 3E                     	CMP     #'>'            	;High byte only?
02522  CEDB  D0 03                     	BNE     NOPREFIX       		;Nope!
02523  CEDD  E8        PREFIXDA        	INX                     	;Get next character
02524  CEDE  B5 18                     	LDA     IN,X
02525  CEE0  20 22 C7  NOPREFIX        	JSR     GET_EXPRES      	;Evaluate expression
02526  CEE3  D0 E7                     	BNE     DIR_EXIT        	;An ERROR occurred!
02527  CEE5  A4 D1                     	LDY     CHAR            	;What prefix was used?
02528  CEE7  A5 CE                     	LDA     HEXVAL
02529  CEE9  C0 3C                     	CPY     #'<'
02530  CEEB  F0 09                     	BEQ     .LOW            	;Low byte only!
02531  CEED  C0 3E                     	CPY     #'>'
02532  CEEF  F0 03                     	BEQ     .HIGH           	;High byte only!
02533  CEF1  20 60 CF                  	JSR     SAVE_OBJ        	;Save low byte first
02534  CEF4  A5 CF     .HIGH           	LDA     HEXVAL+1        	;Then save high byte
02535  CEF6  20 60 CF  .LOW            	JSR     SAVE_OBJ
02536  CEF9  B5 18                     	LDA     IN,X            	;More parameters
02537  CEFB  C9 2C                     	CMP     #','
02538  CEFD  D0 CD                     	BNE     DIR_EXIT        	;Nope!
02539  CEFF  E8                        	INX
02540  CF00  B5 18                     	LDA     IN,X
02541  CF02  80 CF                     	BRA     DIR_DA          	;Always taken!
02542  	
02543  ;------------------------------------------------------------------------
02544  ; .EQ directive
02545  ;------------------------------------------------------------------------
02546  
02547  CF04  A5 AC     DIR_EQ          	LDA     PASS            	;What pass are we in?
02548  CF06  D0 1E                     	BNE     .RTS            	;Don't bother about .EQ during 2!
02549  CF08  20 22 C7                  	JSR     GET_EXPRES      	;Evaluate expression
02550  CF0B  D0 BB                     	BNE     DIR_OPE         	;An ERROR occurred!
02551  CF0D  A5 BE                     	LDA     UNDEF           	;Undefined labels are not allowed
02552  CF0F  D0 1B                     	BNE     UNDEF_ERROR     	;Yes!
02553  CF11  A5 18                     	LDA     IN              	;Was a label declared here?
02554  CF13  C9 41                     	CMP     #'A'
02555  CF15  90 10                     	BCC     NOLABEL         	;Nope!
02556  CF17  C9 5B                     	CMP     #'Z'+1
02557  CF19  B0 0C                     	BCS     NOLABEL         	;Nope!
02558  CF1B  A0 01                     	LDY     #1              	;Point to label's value
02559  CF1D  A5 CE                     	LDA     HEXVAL          	;and change it
02560  CF1F  91 AD                     	STA     (GLOBAL),Y
02561  CF21  C8                        	INY
02562  CF22  A5 CF                     	LDA     HEXVAL+1
02563  CF24  91 AD                     	STA     (GLOBAL),Y
02564  CF26  60        .RTS            	RTS
02565  
02566  CF27  A9 10     NOLABEL         	LDA     #ERR_LBL        	;Exit with label EERROR		
02567  CF29  85 C5                    	 	STA     ERROR
02568  CF2B  60        DIR_EXIT2       	RTS
02569  
02570  CF2C  A9 5E     UNDEF_ERROR     	LDA     #ERR_DEF        	;Exit with undefined label ERROR
02571  CF2E  85 C5                     	STA     ERROR
02572  CF30  60                        	RTS
02573  
02574  ;------------------------------------------------------------------------
02575  ; .OR directive
02576  ;------------------------------------------------------------------------
02577  
02578  CF31  20 48 C8  DIR_OR       		JSR     PRINT_OBJ       	;Print length of previous block
02579  CF34  20 22 C7                  	JSR     GET_EXPRES      	;Evaluate expression
02580  CF37  D0 1E                     	BNE     FATAL_ERROR2    	;Can't accept errors here!
02581  CF39  84 B5                     	STY     PC              	;Save PC and TA
02582  CF3B  85 B6                     	STA     PC+1
02583  CF3D  80 08                     	BRA     DIR_TA2         	;Always taken!
02584  
02585  ;------------------------------------------------------------------------
02586  ; .TA directive
02587  ;------------------------------------------------------------------------
02588  
02589  CF3F  20 48 C8  DIR_TA          	JSR     PRINT_OBJ       	;Print length of previous block
02590  CF42  20 22 C7                  	JSR     GET_EXPRES      	;Evaluate expression
02591  CF45  D0 16                     	BNE     DIR_OPE2        	;An EERROR occurred!
02592  CF47  84 B7     DIR_TA2         	STY     TA              	;Save target address
02593  CF49  84 B9                     	STY     TA_BEGIN
02594  CF4B  85 B8                     	STA     TA+1
02595  CF4D  85 BA                     	STA     TA_BEGIN+1
02596  CF4F  A5 BE                     	LDA     UNDEF           	;Undefined label used?
02597  CF51  F0 D8                     	BEQ     DIR_EXIT2       	;Nope! We're done now
02598  
02599  CF53  A9 5E     DIR_UNDEF       	LDA     #ERR_DEF        	;Can't allow undefined labels!
02600  CF55  85 C5     FATAL_ERROR     	STA     ERROR
02601  CF57  20 E3 CD  FATAL_ERROR2    	JSR     CHCK_ERROR      	;Print the error
02602  CF5A  4C 09 C0                  	JMP     GETLINE         	;And abort assembly! Fatal EERROR
02603  CF5D  4C C8 CE  DIR_OPE2        	JMP     DIR_OPE         	;Operand EERROR
02604  
02605  ;------------------------------------------------------------------------
02606  ; Save byte to target
02607  ;------------------------------------------------------------------------
02608  
02609  CF60  A4 AC     SAVE_OBJ   		LDY     PASS            	;What pass?
02610  CF62  F0 2E     	                BEQ     .INCPC          	;Pass 1! Don't save anything
02611  CF64  48                	        PHA
02612  CF65  A4 B7                     	LDY     TA              	;See if below standard safe limit
02613  CF67  C4 00                     	CPY     <DEF_OBJLOW
02614  CF69  A5 B8                     	LDA     TA+1
02615  CF6B  E5 02                     	SBC     >DEF_OBJLOW
02616  CF6D  90 08                     	BCC     .USR            	;Below default safe range!
02617  CF6F  C4 EE                     	CPY     LOMEM           	;See if it's above LOMEM now
02618  CF71  A5 B8                     	LDA     TA+1
02619  CF73  E5 EF                     	SBC     LOMEM+1
02620  CF75  90 10                     	BCC     .SAFE           	;We're in safe range!
02621  
02622  CF77  C4 EA     .USR            	CPY     USR_OBJLO       	;See if below user safe limit
02623  CF79  A5 B8                     	LDA     TA+1
02624  CF7B  E5 EB                     	SBC     USR_OBJLO+1
02625  CF7D  90 1A                     	BCC     MEM_FULL        	;Yes! Exit with ERROR
02626  CF7F  C4 EC                     	CPY     USR_OBJHI       	;See if it's above user safe limit
02627  CF81  A5 B8                     	LDA     TA+1
02628  CF83  E5 ED                     	SBC     USR_OBJHI+1
02629  CF85  B0 12                     	BCS     MEM_FULL        	;Yes! Exit with ERROR
02630  
02631  CF87  68        .SAFE           	PLA
02632  CF88  A0 00                     	LDY     #0
02633  CF8A  91 B7                     	STA     (TA),Y          	;Save byte
02634  CF8C  E6 B7                     	INC     TA              	;Increment target address
02635  CF8E  D0 02                     	BNE     .INCPC          	;No carry!
02636  CF90  E6 B8                     	INC     TA+1
02637  
02638  CF92  E6 B5     .INCPC          	INC     PC              	;Increment PC
02639  CF94  D0 02                     	BNE     .RTS            	;No carry!
02640  CF96  E6 B6                     	INC     PC+1
02641  CF98  60        .RTS            	RTS
02642  
02643  CF99  A9 51     MEM_FULL        	LDA     #ERR_MEM        	;Exit with fatal memory ERROR
02644  CF9B  80 B8                     	BRA     FATAL_ERROR     	;(ignoring the stack)
02645  
02646  ;------------------------------------------------------------------------
02647  ;  Expand the size of the symbol table by A
02648  ;  Presuming DEST points to current end flag ($00)
02649  ;  Warning END flag is not moved! Must be done by calling routine!
02650  ;------------------------------------------------------------------------
02651  
02652  CF9D  18        EXP_SYM        	 	CLC                     	;See if there's enough room to
02653  CF9E  65 DD                     	ADC     DEST            	;expand
02654  CFA0  85 D9                     	STA     LENG
02655  CFA2  A9 00                     	LDA     #0
02656  CFA4  A8                        	TAY                     	;Point to first byte in new space
02657  CFA5  65 DE                     	ADC     DEST+1
02658  CFA7  85 DA                     	STA     LENG+1
02659  CFA9  A5 F0             	        LDA     HIMEM           	;See if there's enough room
02660  CFAB  C5 D9     	                CMP     LENG            	;for it
02661  CFAD  A5 F1                     	LDA     HIMEM+1
02662  CFAF  E5 DA                     	SBC     LENG+1
02663  CFB1  90 E6                     	BCC     MEM_FULL        	;Memory full!
02664  CFB3  60                        	RTS
02665  
02666  ;------------------------------------------------------------------------
02667  ; Find label in symbol table
02668  ; Upon exit:
02669  ; C=1 if not a legal label name was given
02670  ; Z=1 if label not found
02671  ; X will always point to end of label name + 1 in parse buffer
02672  ; Y will always be 0
02673  ; DEST will point at global label (or end of symbol table $00)
02674  ; DEST will point at local label (or end of local labels $FF)
02675  ;------------------------------------------------------------------------
02676  
02677  CFB4  A5 E9     FIND_LABEL      	LDA     SYM_TABLE+1     	;Is symbol table valid?
02678  CFB6  F0 13                     	BEQ     .NOSYM          	;Nope!
02679  CFB8  B5 18                     	LDA     IN,X            	;Save first character of label
02680  CFBA  85 C1                     	STA     FIRST_CHAR
02681  CFBC  C9 2E                     	CMP     #'.'            	;Is it a local label?
02682  CFBE  F0 14                     	BEQ     FIND_LOCAL      	;Yes!
02683  	
02684  CFC0  C9 41     	                CMP     #'A'            	;First character must be A-Z
02685  CFC2  90 0E             	        BCC     NO_LABEL        	;It's not!
02686  CFC4  C9 5B                     	CMP     #'Z'+1
02687  CFC6  B0 0A                     	BCS     NO_LABEL        	;It's not!
02688  	
02689  CFC8  4C 29 D0          	        JMP     FIND_GLOBAL     	;Find global label
02690  	
02691  CFCB  18        .NOSYM          	CLC                     	;Indicate label given
02692  CFCC  20 2C CF                  	JSR     UNDEF_ERROR     	;Exit with undefined labelEERRORr
02693  CFCF  A9 00                     	LDA     #0              	;Make Z=0 meaning label not found
02694  CFD1  60                        	RTS
02695  
02696  CFD2  38        NO_LABEL        	SEC                    	 	;Indicate no label given
02697  CFD3  60                        	RTS
02698  
02699  ;------------------------------------------------------------------------
02700  ; Find a local label in the symbol table
02701  ;------------------------------------------------------------------------
02702  
02703  CFD4  A5 AD     FIND_LOCAL      	LDA     GLOBAL          	;Start looking from the begin of
02704  CFD6  85 DD     	                STA     DEST            	;the last assigned global label
02705  CFD8  A5 AE     	                LDA     GLOBAL+1
02706  CFDA  85 DE     	                STA     DEST+1
02707  CFDC  F0 F4     	                BEQ     NO_LABEL        	;No global label ERROR!
02708  CFDE  E8        	                INX                     	;Next char must be a digit!
02709  CFDF  B5 18     	                LDA     IN,X
02710  CFE1  C9 30     	                CMP     #'0'
02711  CFE3  90 ED     	                BCC     NO_LABEL        	;It's not!
02712  CFE5  C9 3A     	                CMP     #'9'+1
02713  CFE7  B0 E9     	                BCS     NO_LABEL        	;It's not!
02714  	
02715  CFE9  20 1D C6  	                JSR     GET_VAL         	;Get local label number
02716  CFEC  A5 CE     	                LDA     HEXVAL
02717  CFEE  85 C0     	                STA     LL_NUM
02718  CFF0  C9 64     	                CMP     #100            	;Value must be below 100!
02719  CFF2  B0 DE     	                BCS     NO_LABEL        	;It is not!
02720  CFF4  A5 CF     	                LDA     HEXVAL+1
02721  CFF6  D0 DA     	                BNE     NO_LABEL        	;It is not!
02722  	
02723  CFF8  A0 03     	                LDY     #5-2            	;Point to start of local labels
02724  CFFA  C8        .LOOP           	INY                     	;Each record contains 2 bytes
02725  CFFB  C8        	                INY
02726  CFFC  B1 DD     	                LDA     (DEST),Y        	;Could it be this one?
02727  CFFE  C9 FF     	                CMP     #$FF
02728  D000  F0 15     	                BEQ     .DONE           	;Nope! End of record
02729  D002  29 7F     	                AND     #@01111111      	;Ignore label declared flag !!!
02730  D004  C5 C0     	                CMP     LL_NUM
02731  D006  D0 F2     	                BNE     .LOOP           	;It's not this one!
02732  	
02733  D008  C8        	                INY
02734  D009  18        	                CLC                     	;Add label's offset to global
02735  D00A  A5 AF     	                LDA     GLOBAL_VAL      	; label's value
02736  D00C  71 DD     	                ADC     (DEST),Y
02737  D00E  85 CE     	                STA     HEXVAL
02738  D010  A5 B0     	                LDA     GLOBAL_VAL+1
02739  D012  69 00     	                ADC     #0
02740  D014  85 CF     	                STA     HEXVAL+1
02741  D016  88        	                DEY
02742  
02743  D017  18        .DONE           	CLC                     	;Add offset to pointer
02744  D018  98        	                TYA
02745  D019  65 DD     	                ADC     DEST
02746  D01B  85 DD     	                STA     DEST
02747  D01D  90 02     	                BCC     .NOCY           	;No carry
02748  D01F  E6 DE     	                INC     DEST+1
02749  D021  A0 00     .NOCY           	LDY     #0              	;Now clear Y (points to same addr)
02750  D023  B1 DD     	                LDA     (DEST),Y        	;Set/clear label found flag
02751  D025  C9 FF     	                CMP     #$FF            	;Z=1 if label not found
02752  D027  18        	                CLC                     	;There was no EERROR in label name
02753  D028  60        	                RTS
02754  
02755  ;------------------------------------------------------------------------
02756  ; Find a global label in the symbol table
02757  ;------------------------------------------------------------------------
02758  
02759  D029  A5 E8     FIND_GLOBAL     	LDA     SYM_TABLE       	;Start looking from the begin of
02760  D02B  85 DD     	                STA     DEST            	; the symbol table
02761  D02D  A5 E9     	                LDA     SYM_TABLE+1
02762  D02F  85 DE     	                STA     DEST+1
02763  
02764  D031  86 D8                     	STX     SAVE_Y          	;Save start of label name
02765  D033  E8        .MARK_END       	INX                     	;Find end of label we're looking
02766  D034  B5 18     	                LDA     IN,X            	; for
02767  D036  C9 2E     	                CMP     #'.'
02768  D038  F0 F9     	                BEQ     .MARK_END       	;Not end yet!
02769  D03A  C9 30     	                CMP     #'0'
02770  D03C  90 0C     	                BCC     .FOUND_END      	;End!
02771  D03E  C9 3A     	                CMP     #'9'+1
02772  D040  90 F1     	                BCC     .MARK_END
02773  D042  C9 41     	                CMP     #'A'
02774  D044  90 04     	                BCC     .FOUND_END      	;End!
02775  D046  C9 5B     	                CMP     #'Z'+1
02776  D048  90 E9     	                BCC     .MARK_END
02777  D04A  86 CD     .FOUND_END      	STX     DELIM           	;Character must be restored later!
02778                  	;AND     #@01111111      	;Temporarily mark end of label = z=1
02779  D04C  09 80                     	ORA     #@10000000     		;Ignore declared flag
02780  D04E  95 18                     	STA     IN,X
02781  
02782  D050  A0 00     .FND_GLOBAL     	LDY     #0              	;Outer search loop
02783  D052  B1 DD     	                LDA     (DEST),Y
02784  D054  F0 27     	                BEQ     .EXIT           	;End of symbol table reached!
02785  	                ;ORA     #@10000000     	;Ignore declared flag
02786  D056  29 7F     	                AND     #@01111111      	;Ignore declared flag
02787  D058  C5 C1     	                CMP     FIRST_CHAR      	;Should we bother looking further?
02788  D05A  D0 45     	                BNE     .FAIL           	;Nope! Find next global label
02789  	
02790  D05C  A6 D8     	                LDX     SAVE_Y          	;Point to begin of label again
02791  D05E  A0 04     	                LDY     #4              	;Get pointer to label's name
02792  D060  B1 DD     	                LDA     (DEST),Y        	; in source file
02793  D062  85 DC     	                STA     SRCE+1          	;(Going backwards leaves Y=3)
02794  D064  88        	                DEY
02795  D065  B1 DD     	                LDA     (DEST),Y
02796  D067  85 DB     	                STA     SRCE
02797  
02798  D069  B5 18     .CMP_GLOBAL     	LDA     IN,X            	;Compare strings
02799  D06B  30 08     	                BMI     .EOL            	;End of label reached! 
02800  D06D  D1 DB     	                CMP     (SRCE),Y        	;Do they still match?
02801  D06F  D0 30     	                BNE     .FAIL           	;Nope!
02802  D071  E8        	                INX
02803  D072  C8        	                INY
02804  D073  D0 F4     	                BNE     .CMP_GLOBAL     	;Keep trying! Always taken
02805  
02806  D075  B1 DB     .EOL            	LDA     (SRCE),Y        	;Is label in source also at end?
02807  D077  30 04                     	BMI     .EXIT          	 	;Yes! (packed space or LineLeng)
02808  D079  C9 3A                     	CMP     #':'
02809  D07B  D0 24                     	BNE     .FAIL           	;Nope!
02810  
02811  D07D  A6 CD     .EXIT           	LDX     DELIM           	;Label found or at end of symtab
02812  D07F  B5 18                    	 	LDA     IN,X            	;Restore end of label marker
02813  	                ;ORA     #@10000000		;only used for apple
02814  D081  29 7F     	                AND     #@01111111
02815  D083  95 18     	                STA     IN,X
02816  D085  A0 00     	                LDY     #0
02817  D087  B1 DD     	                LDA     (DEST),Y        	;A will be 0 if label not found
02818  D089  F0 14     	                BEQ     .RTS            	;Label not found!
02819  D08B  49 80     	                EOR     #@10000000      	;Save label's assigned flag
02820  	                ;AND     #@10000000      	;  (inverted!)
02821  D08D  25 AC     	                AND     PASS            	;Remains 0 if pass 1
02822  D08F  85 B1     	                STA     LABEL_FLAG
02823  D091  C8        	                INY
02824  D092  B1 DD     	                LDA     (DEST),Y        	;Save label's value
02825  D094  85 CE     	                STA     HEXVAL
02826  D096  C8        	                INY
02827  D097  B1 DD     	                LDA     (DEST),Y
02828  D099  85 CF     	                STA     HEXVAL+1
02829  D09B  A0 00     	                LDY     #0              	;Restore pointer
02830  D09D  A5 C1     	                LDA     FIRST_CHAR      	; and first char (Z=0)
02831  D09F  18        .RTS            	CLC                     	;There was no EERROR in label name
02832  D0A0  60        	                RTS
02833  	
02834  D0A1  A0 05     .FAIL          	 	LDY     #5              	;Find next label
02835  D0A3  B1 DD     .NXT_GLOBAL    		LDA     (DEST),Y        	;Try to find $FF which signals
02836  D0A5  C8        	                INY                     	; the end of this label
02837  D0A6  C9 FF     	                CMP     #$FF
02838  D0A8  D0 F9     	                BNE     .NXT_GLOBAL     	;Not yet!
02839  D0AA  98        	                TYA                     	;Add current offset to DEST
02840  D0AB  18        	                CLC
02841  D0AC  65 DD     	                ADC     DEST
02842  D0AE  85 DD     	                STA     DEST
02843  D0B0  90 9E     	                BCC     .FND_GLOBAL     	;No carry needed!
02844  D0B2  E6 DE     	                INC     DEST+1
02845  D0B4  80 9A     	                BRA     .FND_GLOBAL     	;Always taken!
02846  
02847  ;------------------------------------------------------------------------
02848  ; Add label
02849  ;------------------------------------------------------------------------
02850  
02851  D0B6  20 B4 CF  ADD_LABEL       	JSR     FIND_LABEL      	;Find label in symbol table
02852  D0B9  B0 44     	                BCS     .LBL_ERR        	;It was not a valid label!
02853  D0BB  D0 47     	                BNE     .FOUND_IT       	;Found the label!
02854  D0BD  A5 C1     	                LDA     FIRST_CHAR      	;What type of label is it?
02855  D0BF  C9 2E     	                CMP     #'.'
02856  D0C1  F0 56     	                BEQ     .ADD_LOCAL      	;It is a local label!
02857  	
02858  D0C3  A9 06     	                LDA     #6              	;Make room for 6 bytes in the
02859  D0C5  20 9D CF  	                JSR     EXP_SYM         	; symbol table
02860  D0C8  A5 C1     	                LDA     FIRST_CHAR      	;Save first character of label
02861  ; 		         AND     #@01111111     	; in symbol table (clear declared
02862  D0CA  91 DD     	                STA     (DEST),Y        	;  flag first)
02863  D0CC  C8        	                INY
02864  D0CD  A5 B5     	                LDA     PC              	;Place current PC into symbol
02865  D0CF  91 DD     	                STA     (DEST),Y        	; table
02866  D0D1  C8        	                INY
02867  D0D2  A5 B6     	                LDA     PC+1
02868  D0D4  91 DD     	                STA     (DEST),Y
02869  D0D6  C8        	                INY                     	;Place source pointer in symbol
02870  D0D7  A5 B2     	                LDA     PNTR            	; table (where the label name
02871  D0D9  91 DD     	                STA     (DEST),Y        	;  can be found)
02872  D0DB  C8        	                INY
02873  D0DC  A5 B3     	                LDA     PNTR+1
02874  D0DE  20 40 D1  	                JSR     SAVE_ENDSYM     	;Save last 3 bytes of symbol table
02875  
02876  D0E1  A5 DD     .COPY_GLOBAL    	LDA     DEST            	;Copy symbol table pointer
02877  D0E3  85 AD     	                STA     GLOBAL          	; to last global label
02878  D0E5  A5 DE     	                LDA     DEST+1
02879  D0E7  85 AE     	                STA     GLOBAL+1
02880  D0E9  A0 01     	                LDY     #1              	;Copy last global label's value
02881  D0EB  B1 DD     	                LDA     (DEST),Y
02882  D0ED  85 AF     	                STA     GLOBAL_VAL
02883  D0EF  C8        	                INY
02884  D0F0  B1 DD     	                LDA     (DEST),Y
02885  D0F2  85 B0     	                STA     GLOBAL_VAL+1
02886  D0F4  CA        	                DEX
02887  
02888  D0F5  20 3A D1  .BLANK          	JSR     NEXT_IN         	;Find first blank or EOL
02889  D0F8  F0 04                     	BEQ     .RTS            	;EOL!
02890  D0FA  C9 20                     	CMP     #SP
02891  D0FC  D0 F7                     	BNE     .BLANK          	;Try again!
02892  D0FE  60        .RTS            	RTS
02893  
02894  D0FF  20 27 CF  .LBL_ERR        	JSR     NOLABEL         	;Exit with label EERROR
02895  D102  D0 F1                     	BNE     .BLANK          	;Always taken!
02896  
02897  D104  A5 AC     .FOUND_IT       	LDA     PASS            	;What pass are we in?
02898  D106  F0 0D     	                BEQ     .EXT_DEF        	;Pass 1! Extra definition
02899  	
02900  D108  B1 DD     	                LDA     (DEST),Y        	;Set declared flag in pass 2
02901  D10A  09 80     	                ORA     #@10000000
02902  D10C  91 DD     	                STA     (DEST),Y
02903  	
02904  D10E  A5 C1     	                LDA     FIRST_CHAR      	;What type was the label?
02905  D110  C9 2E     	                CMP     #'.'
02906  D112  D0 CD     	                BNE     .COPY_GLOBAL    	;Copy last global label pointer
02907  D114  60        	                RTS
02908  
02909  D115  A9 96     .EXT_DEF        	LDA     #ERR_EXT        	;Exit with extra definition EERROR
02910  D117  80 1A                     	BRA	SET_ERROR
02911  
02912  D119  A9 02     .ADD_LOCAL      	LDA     #2              	;Make room for 2 bytes in the
02913  D11B  20 9D CF                  	JSR     EXP_SYM         	; symbol table
02914  D11E  A5 C0                     	LDA     LL_NUM          	;Save label number in symbol
02915  D120  91 DD                     	STA     (DEST),Y        	;  table
02916  D122  C8                        	INY
02917  D123  38                        	SEC                     	;Calculate offset from last global
02918  D124  A5 B5                     	LDA     PC
02919  D126  E5 AF                     	SBC     GLOBAL_VAL
02920  D128  20 40 D1                  	JSR     SAVE_ENDSYM     	;Save last 3 bytes of symbol table
02921  
02922  D12B  A5 B6                     	LDA     PC+1            	;Check offset range now
02923  D12D  E5 B0                     	SBC     GLOBAL_VAL+1
02924  D12F  F0 CD                     	BEQ     .RTS            	;Range is OK!
02925  
02926  ;------------------------------------------------------------------------
02927  ; Set RANGE and set ERRRO
02928  ;------------------------------------------------------------------------
02929  D131  A9 17     RANGE_ERROR     	LDA     #ERR_RNG        	;Exit with range EERROR
02930  D133  85 C5     SET_ERROR       	STA     ERROR
02931  D135  4C 02 D4                  	JMP	BAD			;set Y=FAIL
02932  
02933  ;------------------------------------------------------------------------
02934  ; Get next char from input buffer and compare it with CR
02935  ;------------------------------------------------------------------------
02936  
02937  D138  A0 00     NEXT_IN_Y0      	LDY     #0              	;Clear Y for different purposes
02938  D13A  E8        NEXT_IN         	INX                     	;Well, let's do just that!
02939  D13B  B5 18     IN_CR           	LDA     IN,X
02940  D13D  C9 0D                     	CMP     #CR
02941  D13F  60                        	RTS
02942  
02943  ;------------------------------------------------------------------------
02944  ; Save last 3 bytes to symbol table to save some code
02945  ;------------------------------------------------------------------------
02946  
02947  D140  91 DD     SAVE_ENDSYM     	STA     (DEST),Y        	;Save low byte of offset only
02948  D142  C8                        	INY
02949  D143  A9 FF                     	LDA     #$FF            	;Save end of label marker
02950  D145  91 DD                     	STA     (DEST),Y
02951  D147  C8                        	INY
02952  D148  A9 00                     	LDA     #0              	;Save new end of symbol table flag
02953  D14A  91 DD                     	STA     (DEST),Y
02954  D14C  60                        	RTS
02955  
02956  
02957  	.include	"Dissassembler Lib.65s"
02958  
02959  ;------------------------------------------------------------------------
02960  ; Decode mnemonic and operand
02961  ;------------------------------------------------------------------------
02962  
02963  D14D  20 54 D1  MNEMON         		JSR	CMPMNE			;AC = has left MNE :THEN FND INDEX AND SAVE IT IN	
02964  D150  20 E1 D1  			JSR	CALCAM			;Calculate addres 		
02965  D153  60        .MNE_ERR        	RTS
02966  
02967  ;------------------------------------------------------------------------
02968  ; Compress MEN into PARM1 & PARM1+1
02969  ; X points to the index in the keyboard IN
02970  ;------------------------------------------------------------------------
02971  
02972  D154  DA        CMPMNE			PHX				;save X index to keyboard buffer
02973  D155  18        			CLC				;AC = has left MNE
02974  D156  66 C7     			ROR 	PARM1						
02975  D158  8A        			TXA
02976  D159  18        			CLC
02977  D15A  69 18     			ADC	#IN			;Calc IN address + X
02978  D15C  85 DB     			STA	SRCE
02979  D15E  64 DC     			STZ	SRCE+1			;*** Could be removed if ZP load
02980  D160  A0 02     			LDY 	#$02			;Three letters
02981  D162  38        .NEXT2			SEC
02982  D163  B1 DB     			LDA     (SRCE),Y 		;get the letters SHOULD BE ZERO Page load
02983  D165  E9 40     			SBC 	#'A'-1
02984  D167  A2 05     			LDX 	#$05			;shift
02985  D169  4A        .NEXTROT		LSR
02986  D16A  66 C7     			ROR 	PARM1
02987  D16C  66 C8     			ROR 	PARM1+1
02988  D16E  CA        			DEX
02989  D16F  D0 F8     			BNE 	.NEXTROT
02990  D171  88        			DEY
02991  D172  10 EE     			BPL 	.NEXT2			;Nemonic now compressed		
02992  D174  A2 42     			LDX 	#NUMMN			;Number of mnemonics to search through
02993  D176  BD 02 D2  .LOOP			LDA 	LMNETB-1,X		;search 
02994  D179  C5 C7     			CMP 	PARM1
02995  D17B  D0 07     			BNE 	.NXT
02996  D17D  BD 44 D2  			LDA 	RMNETB-1,X
02997  D180  C5 C8     			CMP 	PARM1+1
02998  D182  F0 03     			BEQ 	.FND
02999  D184  CA        .NXT			DEX
03000  D185  D0 EF     			BNE 	.LOOP
03001  D187  CA        .FND			DEX				;X = $FF for failure
03002  D188  86 C2     			STX	CURMNE 
03003  D18A  FA        			PLX				;restore X 
03004  D18B  E8        			INX
03005  D18C  E8        			INX
03006  D18D  E8        			INX				;Adjust the buffer index to point to next Char
03007  D18E  60        			RTS		
03008  
03009  ;.ERR		LDA	#01
03010  		;STA	ERROR		
03011  		;RTS
03012  
03013  
03014  ;------------------------------------------------------------------------
03015  ; Make Object code from NME
03016  ; MNE is in CURMNE, addr mode is in CURADM
03017  ; and the args are in HEXVAL,H
03018  ; calculate the object code, and update PC
03019  ;------------------------------------------------------------------------
03020  
03021  D18F  A4 C2     MKOBJC			LDY 	CURMNE			;Index to the table
03022  D191  B9 A5 D2  			LDA 	BASE,Y			;get base value for current mnemonic
03023  D194  A6 C3     			LDX 	CURADM			;ADdress mode
03024  D196  18        			CLC
03025  D197  7D E7 D2  			ADC 	OFFSET,X		;add in the offset	
03026  D19A  E0 0C     .NOSTZ			CPX 	#ABY			;handle exceptions
03027  D19C  F0 14     			BEQ 	.CHABY
03028  D19E  E0 02     			CPX 	#IMM
03029  D1A0  D0 17     			BNE 	.CONT
03030  D1A2  C0 22     			CPY 	#$22			;check if BIT first
03031  D1A4  D0 02     			BNE 	.NOBIT
03032  D1A6  69 68     			ADC 	#ADJBIT
03033  D1A8  C0 28     .NOBIT			CPY 	#$28			;immediate mode need to adjust a range
03034  D1AA  30 0D     			BMI 	.CONT
03035  D1AC  C0 30     			CPY 	#$2F+1
03036  D1AE  B0 09     			BCS 	.CONT
03037  D1B0  69 08     			ADC 	#ADJIMM			;carry is clear
03038  		;	BNE .CONT	
03039  D1B2  C0 35     .CHABY			CPY 	#$35			;LDX check
03040  D1B4  D0 03     			BNE 	.CONT
03041  D1B6  18        			CLC
03042  D1B7  69 04     			ADC 	#ADJABY
03043  D1B9  C0 23     .CONT			CPY 	#$23			;STZ needs special handling
03044  D1BB  D0 0A     			BNE 	.DONE
03045  D1BD  E0 0A     			CPX 	#ABS
03046  D1BF  30 06     			BMI 	.DONE
03047  D1C1  F0 02     			BEQ 	.SKIP
03048  D1C3  69 F1     			ADC 	#$1-$10			;carry is set
03049  D1C5  69 2F     .SKIP			ADC 	#$30-1			;carry is set
03050  D1C7  20 60 CF  .DONE			JSR 	SAVE_OBJ		;we have the object code
03051  
03052  		.IF 	BRKAS2				;if we want to add two BRK
03053  
03054  .MKARG							;where appropriate, the arg value is in HEXVAL,H
03055  							;copy to ARGS and null terminate
03056  D1CA  8A        			TXA				;quick check for X=0
03057  D1CB  F0 13     			BEQ 	.DORTS			;IMP - no args
03058  D1CD  CA        			DEX
03059  D1CE  F0 10     			BEQ 	.DORTS			;ACC - no args		
03060  D1D0  A5 CE     			LDA	HEXVAL
03061  D1D2  E0 09     			CPX 	#ABS-1			;word arg if X is greater than or equal to ABS
03062  D1D4  30 05     			BMI 	.DOBYTE			;X < #ABS	
03063  D1D6  20 60 CF  .DOWORD			JSR 	SAVE_OBJ		;Save byte(s)
03064  D1D9  A5 CF     			LDA 	HEXVAL+1
03065  D1DB  20 60 CF  .DOBYTE			JSR 	SAVE_OBJ
03066  D1DE  64 C5     			STZ	ERROR			;no
03067  D1E0  60        .DORTS			RTS
03068  
03069  
03070  ;------------------------------------------------------------------------
03071  ; work out the addressing mode
03072  ;------------------------------------------------------------------------	
03073  
03074  CALCAM			; work out the addressing mode
03075  D1E1  20 6C D3  			JSR 	ADDMOD	
03076  D1E4  E0 FF     			CPX 	#FAIL
03077  D1E6  D0 A7     			BNE 	MKOBJC
03078  			;LDY 	#$FF	; Illegal address mode error
03079  D1E8  60        			RTS
03080  
03081  ;------------------------------------------------------------------------------------------		
03082  ; lookup table for disassembly special cases
03083  ;------------------------------------------------------------------------------------------	
03084    001A          TBLSZ	= $1A
03085  DISTBL	.BYTE $80, $41, $4C, $38, $6C, $38, $7C, $38
03086  	.BYTE $0A, $30, $2A, $31, $4A, $32, $6A, $33
03087  	.BYTE $9C, $23, $9E, $23, $04, $20, $0C, $20
03088  	.BYTE $89, $22
03089  
03090  ; Data and related constants
03091  
03092  MODES			; Addressing mode constants
03093    0000          IMP = $00		;
03094    0001          ACC = $01
03095    0002          IMM = $02		; #$nn or #'<char>' or #LABEL
03096    0003          REL = $03		; *+nn or LABEL
03097    0004          ZPG = $04		; $nn or LABEL
03098    0005          ZPX = $05		; $nn,X or LABEL,X
03099    0006          ZPY = $06		; $nn,Y or LABEL,Y
03100    0007          IDZ = $07		; ($nn) or (LABEL)
03101    0008          IDX = $08		; ($nn,X) or (LABEL,X)
03102    0009          IDY = $09		; ($nn),Y or (LABEL),Y
03103    000A          ABS = $0A		; $nnnn or LABEL
03104    000B          ABX = $0B		; $nnnn,X or LABEL,X
03105    000C          ABY = $0C		; $nnnn,Y or LABEL,Y
03106    000D          IND = $0D		; ($nnnn) or (LABEL)
03107    000E          IAX = $0E		; ($nnnn,X) or (LABEL,X)
03108  
03109    0042          NUMMN 	=$42		; number of mnemonics
03110  
03111  
03112  ;------------------------------------------------------------------------------------------		
03113  ; lookup table Assembler and Dissambler
03114  ;------------------------------------------------------------------------------------------
03115  
03116  ; Tables
03117  
03118  LMNETB		
03119  		.BYTE $82	; PHP
03120  		.BYTE $1B	; CLC
03121  		.BYTE $83	; PLP
03122  		.BYTE $99	; SEC
03123  		.BYTE $82	; PHA
03124  		.BYTE $1B	; CLI
03125  		.BYTE $83	; PLA
03126  		.BYTE $99	; SEI
03127  		.BYTE $21	; DEY
03128  		.BYTE $A6	; TYA
03129  		.BYTE $A0	; TAY
03130  		.BYTE $1B	; CLV
03131  		.BYTE $4B	; INY
03132  		.BYTE $1B	; CLD
03133  		.BYTE $4B	; INX
03134  		.BYTE $99	; SED
03135  		.BYTE $14	; BRK	
03136  		.BYTE $4B	; INA
03137  		.BYTE $54	; JSR
03138  		.BYTE $21	; DEA	
03139  		.BYTE $95	; RTI
03140  		.BYTE $82	; PHY
03141  		.BYTE $95	; RTS
03142  		.BYTE $83	; PLY
03143  		.BYTE $A6	; TXA
03144  		.BYTE $A6	; TXS
03145  		.BYTE $A0	; TAX
03146  		.BYTE $A4	; TSX
03147  		.BYTE $21	; DEX
03148  		.BYTE $82	; PHX
03149  		.BYTE $73	; NOP
03150  		.BYTE $83	; PLX
03151  		.BYTE $A4	; TSB
03152  		.BYTE $A4	; TRB
03153  		.BYTE $12	; BIT
03154  		.BYTE $9D	; STZ
03155  		.BYTE $9D	; STY
03156  		.BYTE $61	; LDY
03157  		.BYTE $1C	; CPY
03158  		.BYTE $1C	; CPX
03159  		.BYTE $7C	; ORA
03160  		.BYTE $0B	; AND
03161  		.BYTE $2B	; EOR
03162  		.BYTE $9	; ADC
03163  		.BYTE $9D	; STA
03164  		.BYTE $61	; LDA
03165  		.BYTE $1B	; CMP
03166  		.BYTE $98	; SBC
03167  		.BYTE $0C	; ASL
03168  		.BYTE $93	; ROL
03169  		.BYTE $64	; LSR
03170  		.BYTE $93	; ROR
03171  		.BYTE $9D	; STX
03172  		.BYTE $61	; LDX
03173  		.BYTE $21	; DEC
03174  		.BYTE $4B	; INC
03175  		.BYTE $53	; JMP
03176  		.BYTE $14	; BPL
03177  		.BYTE $13	; BMI
03178  		.BYTE $15	; BVC
03179  		.BYTE $15	; BVS
03180  		.BYTE $10	; BCC
03181  		.BYTE $10	; BCS
03182  		.BYTE $13	; BNE
03183  		.BYTE $11	; BEQ
03184  		.BYTE $14	; BRA
03185  RMNETB
03186  		.BYTE $20	; PHP
03187  		.BYTE $06	; CLC
03188  		.BYTE $20	; PLP
03189  		.BYTE $46	; SEC
03190  		.BYTE $02	; PHA
03191  		.BYTE $12	; CLI
03192  		.BYTE $02	; PLA
03193  		.BYTE $52	; SEI
03194  		.BYTE $72	; DEY
03195  		.BYTE $42	; TYA
03196  		.BYTE $72	; TAY
03197  		.BYTE $2C	; CLV
03198  		.BYTE $B2	; INY
03199  		.BYTE $08	; CLD
03200  		.BYTE $B0	; INX
03201  		.BYTE $48	; SED
03202  		.BYTE $96	; BRK	
03203  		.BYTE $82	; INA
03204  		.BYTE $E4	; JSR
03205  		.BYTE $42	; DEA	
03206  		.BYTE $12	; RTI
03207  		.BYTE $32	; PHY
03208  		.BYTE $26	; RTS
03209  		.BYTE $32	; PLY
03210  		.BYTE $02	; TXA
03211  		.BYTE $26	; TXS
03212  		.BYTE $70	; TAX
03213  		.BYTE $F0	; TSX
03214  		.BYTE $70	; DEX
03215  		.BYTE $30	; PHX
03216  		.BYTE $E0	; NOP
03217  		.BYTE $30	; PLX
03218  		.BYTE $C4	; TSB
03219  		.BYTE $84	; TRB
03220  		.BYTE $68	; BIT
03221  		.BYTE $34	; STZ
03222  		.BYTE $32	; STY
03223  		.BYTE $32	; LDY
03224  		.BYTE $32	; CPY
03225  		.BYTE $30	; CPX
03226  		.BYTE $82	; ORA
03227  		.BYTE $88	; AND
03228  		.BYTE $E4	; EOR
03229  		.BYTE $06	; ADC
03230  		.BYTE $02	; STA
03231  		.BYTE $02	; LDA
03232  		.BYTE $60	; CMP
03233  		.BYTE $86	; SBC
03234  		.BYTE $D8	; ASL
03235  		.BYTE $D8	; ROL
03236  		.BYTE $E4	; LSR
03237  		.BYTE $E4	; ROR
03238  		.BYTE $30	; STX
03239  		.BYTE $30	; LDX
03240  		.BYTE $46	; DEC
03241  		.BYTE $86	; INC
03242  		.BYTE $60	; JMP
03243  		.BYTE $18	; BPL
03244  		.BYTE $52	; BMI
03245  		.BYTE $86	; BVC
03246  		.BYTE $A6	; BVS
03247  		.BYTE $C6	; BCC
03248  		.BYTE $E6	; BCS
03249  		.BYTE $8A	; BNE
03250  		.BYTE $62	; BEQ
03251  		.BYTE $82	; BRA
03252  	
03253  MIN			; Minimum legal value for MNE for each mode.
03254  	.BYTE $00, $30, $25, $39
03255  	.BYTE $20, $28, $34
03256  	.BYTE $28, $28, $28
03257  	.BYTE $20, $28, $28
03258  	.BYTE $38, $38
03259  MAX			; Maximum +1 legal value of MNE for each mode. 
03260  	.BYTE $1F+1, $33+1, $2F+1, $41+1
03261  	.BYTE $37+1, $33+1, $35+1
03262  	.BYTE $2F+1, $2F+1, $2F+1
03263  	.BYTE $38+1, $33+1, $2F+1
03264  	.BYTE $38+1, $38+1
03265  BASE			; Base value for each opcode
03266  	.BYTE $08, $18, $28, $38, $48, $58, $68, $78
03267  	.BYTE $88, $98, $A8, $B8, $C8, $D8, $E8, $F8
03268  	.BYTE $00, $1A, $14, $3A, $40, $5A, $60, $7A
03269  	.BYTE $8A, $9A, $AA, $BA, $CA, $DA, $EA, $FA	
03270  	.BYTE $00, $10, $20, $60, $80, $A0, $C0, $E0
03271  	.BYTE $01, $21, $41, $61, $81, $A1, $C1, $E1
03272  	.BYTE $02, $22, $42, $62, $82, $A2, $C2, $E2
03273  	.BYTE $40, $10, $30, $50, $70, $90, $B0, $D0
03274  	.BYTE $F0, $80
03275  	
03276  OFFSET			; Default offset values for each mode, 
03277  			; added to BASE to get the opcode
03278  	.BYTE $00, $08, $00, $00, $04, $14, $14
03279  	.BYTE $11, $00, $10, $0C, $1C, $18, $2C
03280  	.BYTE $3C
03281  	
03282  ;------------------------------------------------------------------------
03283  ; offset adjustments for the mnemonic exceptions
03284  ;------------------------------------------------------------------------
03285    0004          ADJABY  =$04
03286    0008          ADJIMM  =$08
03287    0068          ADJBIT	=$68
03288    00D0          ADJSTZ	=$D0
03289  
03290  ;------------------------------------------------------------------------	
03291  ; disassembler data
03292  ; XXXXXXZ0 instrs
03293  ; * Z=0, right half-byte
03294  ; * Z=1, left half-byte
03295  ;------------------------------------------------------------------------
03296  MODE		.BYTE $0F, $22, $FF, $33, $CB
03297  		.BYTE $62, $FF, $73, $03, $22
03298  		.BYTE $FF, $33, $CB, $66, $FF
03299  		.BYTE $77, $0F, $20, $FF, $33
03300  		.BYTE $CB, $60, $FF, $70, $0F
03301  		.BYTE $22, $FF, $39, $CB, $66
03302  		.BYTE $FF, $7D, $0B, $22, $FF
03303  		.BYTE $33, $CB, $A6, $FF, $73
03304  		.BYTE $11, $22, $FF, $33, $CB
03305  		.BYTE $A6, $FF, $87, $01, $22
03306  		.BYTE $FF, $33, $CB, $60, $FF
03307  		.BYTE $70, $01, $22, $FF, $33
03308  		.BYTE $CB, $60, $FF, $70
03309  ; YYXXXZ01 instrs
03310  		.BYTE $24, $31, $65, $78
03311  	
03312  MODE2		.BYTE $00		;ERR
03313  		.BYTE $21		;IMM		
03314  		.BYTE $81		;Z-PAG
03315  		.BYTE $82		;ABS
03316  		.BYTE $59		;(Z-PAG,X)
03317  		.BYTE $4D		;(Z-PAG),Y
03318  		.BYTE $91		;Z-PAG,X
03319  		.BYTE $92		;ABS,X
03320  		.BYTE $86		;ABS,Y
03321  		.BYTE $4A		;(ABS)
03322  		.BYTE $85		;Z-PAG,Y
03323  		.BYTE $9D		;REL
03324  		.BYTE $49		;(Z-PAG)
03325  		.BYTE $5A		;(ABS,X)
03326  	
03327  ;------------------------------------------------------------------------	
03328  CHAR2		.BYTE 'Y', $00, 'X', '$', '$', $00
03329  CHAR1		.BYTE ',', ')', ',', '#', '(', '$'
03330  	
03331  ; Special case mnemonics	
03332    0008          SPCNT	= $08		; duplicate some checks so I can use the same loop above
03333  
03334  ; Opcodes
03335  SPINC1		.BYTE $12, $22, $23, $24, $25, $35, $36, $37
03336  
03337  ; 1st address mode to check
03338  SPINC2		.BYTE $0A, $0B, $0B, $05, $0B, $0C, $0B, $0B
03339  
03340  ; 2nd address mode to check
03341  SPINC3		.BYTE $0A, $05, $05, $05, $05, $0C, $05, $05
03342  
03343  
03344  
03345  
03346  ;------------------------------------------------------------------------   
03347  ;Find addressing MODE
03348  ;SRCE = points top begining of NME in buffer
03349  ;CURMNE = location of found NME
03350  
03351  ADDMOD							;Check the arguments and work out the
03352  							;addressing mode
03353  							;return mode in X
03354  							;default error value for mode
03355  							;save it	
03356  							;Start checking the format...	
03357  		
03358  D36C  A4 C2     			LDY 	CURMNE			;Holds the current mne index
03359  D36E  20 C3 C5  			JSR	NNONSPC			;get next no space 				
03360  D371  86 D8     			STX     SAVE_Y          	;Save current location in IN							
03361  D373  D0 13     			BNE 	.NOTSP			;Not could be 
03362  		
03363  D375  C0 12     .EOL			CPY 	#$12			;check exception first - JSR
03364  D377  F0 09     			BEQ	.RET
03365  D379  A0 00     			LDY 	#IMP			;implied mode - space
03366  D37B  20 F3 D3  			JSR 	CHKMOD			;check command is ok with this mode
03367  D37E  C0 FF     			CPY 	#FAIL			;not ok		
03368  D380  F0 01     			BEQ 	.NOTIMP			;may still be accumulator mode though
03369  D382  60        .RET			RTS
03370  D383  A0 01     .NOTIMP 		LDY 	#ACC			;accumulator mode - space
03371  D385  4C F3 D3  			JMP 	CHKMOD			;check command is ok with this mode
03372  		
03373  D388  C9 23     .NOTSP			CMP 	#IMV			;immediate mode - '#'
03374  D38A  F0 0B     			BEQ 	.DOIMM				
03375  D38C  A0 03     			LDY 	#REL
03376  D38E  20 F3 D3  			JSR 	CHKMOD			;check if command is a branch
03377  D391  C0 FF     			CPY 	#FAIL
03378  D393  F0 1E     			BEQ 	.NOTREL					
03379  D395  80 70     			BRA 	DOREL			;Do relative Addressing
03380  	
03381  D397  C0 2C     .DOIMM			CPY 	#$2C			;check exception first - STA
03382  D399  F0 67     			BEQ 	BAD			
03383  D39B  C0 35     			CPY 	#$35			;check inclusion - STX
03384  D39D  F0 0D     			BEQ 	.IMMOK
03385  D39F  C0 22     			CPY 	#$22			;check inclusion - BIT
03386  D3A1  F0 09     			BEQ 	.IMMOK
03387  D3A3  A0 02     			LDY 	#IMM		
03388  D3A5  20 F3 D3  			JSR 	CHKMOD			;check command is ok with this mode
03389  D3A8  C0 FF     			CPY 	#FAIL
03390  D3AA  F0 D6     			BEQ 	.RET
03391  		
03392  D3AC  A6 D8     .IMMOK			LDX	SAVE_Y
03393  D3AE  E8        			INX				;Get next Charater 
03394  D3AF  20 22 C7  			JSR	GET_EXPRES
03395  D3B2  60        			RTS
03396  		
03397  .NOTREL 		;LDX	SAVE_Y			;save two bytes :-) 
03398  D3B3  B5 18     			LDA	IN,X			;check the more complicated modes
03399  D3B5  C9 28     			CMP 	#OPEN			;indirection?
03400  D3B7  D0 01     			BNE 	.CONT			;no
03401  D3B9  E8        			INX				;skip the '('
03402  D3BA  A6 D8     .CONT			LDX	SAVE_Y			;restore the index
03403  D3BC  20 28 D4  			JSR 	FMT2AM			;calculate the addressing mode from the format
03404  D3BF  E0 FF     			CPX 	#FAIL
03405  D3C1  F0 BF     			BEQ 	.RET
03406  D3C3  84 C3     			STY 	CURADM
03407  ;			JMP CHKEXS
03408  ; 			falls through
03409  
03410  ;------------------------------------------------------------------------
03411  
03412  CHKEXS							;Current addressing mode is in X
03413  D3C5  C0 06     			CPY 	#ZPY			;for MNE indices 28 to 2F, ZPY is illegal
03414  D3C7  D0 0E     			BNE 	.CONT			;but ABY is ok, so promote byte argument to word
03415  D3C9  A4 C2     			LDY 	CURMNE
03416  D3CB  C0 28     			CPY 	#$28
03417  D3CD  90 08     			BCC 	.CONT
03418  D3CF  C0 30     			CPY 	#$2F+1
03419  D3D1  B0 04     			BCS 	.CONT	
03420  D3D3  A0 0C     			LDY 	#ABY			;updated addressing mode
03421  D3D5  D0 28     			BNE 	OK
03422  D3D7  A2 08     .CONT			LDX 	#SPCNT			;check special includes
03423  D3D9  BD 53 D3  .LOOP			LDA 	SPINC1-1,X		;load mnemonic code
03424  D3DC  C5 C2     			CMP 	CURMNE
03425  D3DE  D0 0E     			BNE 	.NEXT
03426  D3E0  BC 5B D3  			LDY 	SPINC2-1,X		;load addressing mode
03427  D3E3  C4 C3     			CPY 	CURADM
03428  D3E5  F0 18     			BEQ 	OK			;match - so ok
03429  D3E7  BC 63 D3  			LDY 	SPINC3-1,X		;load addressing mode
03430  D3EA  C4 C3     			CPY 	CURADM
03431  D3EC  F0 11     			BEQ 	OK			;match - so ok
03432  D3EE  CA        .NEXT			DEX
03433  D3EF  D0 E8     			BNE 	.LOOP
03434  D3F1  A4 C3     			LDY 	CURADM
03435  ;	BNE CHKMOD	; wasn't in the exceptions table - check normally
03436  ; falls through
03437  
03438  
03439  ;------------------------------------------------------------------------
03440  ; CHeck Adressing Mode
03441  
03442  D3F3  A5 C2     CHKMOD			LDA 	CURMNE			;always > 0
03443  D3F5  D9 87 D2  			CMP 	MIN,y			;mode index in X
03444  D3F8  90 08     			BCC 	BAD			;mnemonic < MIN
03445  D3FA  D9 96 D2  			CMP 	MAX,y			;MAX,X holds actually MAX + 1
03446  D3FD  B0 03     			BCS 	BAD			;mnemonic > MAX
03447  D3FF  84 C3     OK			STY 	CURADM			;save mode		
03448  D401  60        			RTS
03449  				
03450  ;------------------------------------------------------------------------
03451  
03452  D402  A0 FF     BAD			LDY 	#FAIL			;Illegal addressing mode error
03453  D404  84 C5     			STY	ERROR	
03454  D406  60        			RTS
03455  
03456  ;------------------------------------------------------------------------		
03457  ; Calculate relative addressing mode
03458  ;------------------------------------------------------------------------		
03459  D407  A6 D8     DOREL			LDX	SAVE_Y 			; restore index			
03460  D409  20 C3 C5  			JSR     NNONSPC         	;Find next non space
03461  D40C  20 22 C7                  	JSR     GET_EXPRES      	;Evaluate expression                
03462  D40F  A5 BE                     	LDA     UNDEF           	;Undefined label used?
03463  D411  D0 14                     	BNE     HEXVAL2OBJ      	;Yes! Can't verify range
03464  D413  18                        	CLC                     	;Calculate displacement (+1!)
03465  D414  A5 CE                     	LDA     HEXVAL
03466  D416  E5 B5                     	SBC     PC
03467  D418  85 CE                     	STA     HEXVAL
03468  D41A  10 02                     	BPL     .NOBOR          	;No borrow needed
03469  D41C  E6 CF                     	INC     HEXVAL+1
03470  D41E  A5 CF     .NOBOR          	LDA     HEXVAL+1        	;See if high byte of displacement
03471  D420  E5 B6                     	SBC     PC+1             	;is 0
03472  D422  F0 03                     	BEQ     HEXVAL2OBJ      	;OK!
03473  D424  20 31 D1  .RANGE          	JSR     RANGE_ERROR     	;Range error!
03474  D427  60        HEXVAL2OBJ      	RTS
03475  		;LDA     HEXVAL          	;Save displacement
03476                  ;JMP     SAVE_OBJ
03477  		
03478          	
03479  ;------------------------------------------------------------------------
03480  
03481  FMT2AM			; calculate the addressing given
03482  			; the format of the arguments; 
03483  			; return format in X, and
03484  			; location to CHKEXT from in A
03485  			; $FF		invalid
03486  			; #ZPG		$nn
03487  			; #ZPX		$nn,X
03488  			; #ZPY		$nn,Y
03489  			; #ABS		$nnnn
03490  			; #ABX		$nnnn,X
03491  			; #ABY		$nnnn,Y
03492  			; #IND		($nnnn)
03493  			; #IDX		($nn,X)
03494  			; #IDY		($nn),Y
03495  			; #INZ		($nn)
03496  			; #IAX		($nnnn,X)
03497  ;		
03498  ;	Addressing modes are organised as follows:
03499  ;
03500  ;	IMP (0)	ZPG (4) INZ (7) ABS (A) IND (D)
03501  ;	ACC (1) ZPX (5) INX (8) ABX (B) IAX (E)
03502  ;	IMM (2) ZPY (6) INY (9) ABY (C) ---
03503  ;	REL (3) ---	 ---	---	---
03504  ;
03505  ;	so algorithm below starts with 4, adds 3 if indirect
03506  ;	and adds 6 if absolute (i.e. 2 byte address), then adds 1 or 2
03507  ;	if ,X or ,Y format
03508  ;
03509  			;LDX 	#$00			;save two btyes :-)
03510  D428  A9 04     			LDA 	#$04			; start with mode index of 4
03511  D42A  B4 18     			LDY 	IN,X
03512  D42C  C0 28     			CPY 	#OPEN			;Compar '('
03513  D42E  D0 04     			BNE 	.SKIP
03514  D430  18        			CLC				;add 3 for indirect modes
03515  D431  69 03     			ADC 	#$03
03516  D433  E8        			INX
03517  
03518  D434  48        .SKIP			PHA
03519  D435  20 22 C7  			JSR	GET_EXPRES		;Get all the bytes			
03520  D438  CA        			DEX
03521  D439  38        			SEC				;count bytes (1 or 2 only)
03522  D43A  8A        			TXA				;Contains last count
03523  D43B  E5 D8     			SBC	SAVE_Y			;subtract the begining of addressing
03524  D43D  4A        			LSR				;divied by 2			
03525  D43E  A8        			TAY				;byte count in Y 
03526  D43F  A5 C2     			LDA 	CURMNE
03527  D441  C9 12     			CMP 	#$12			;is it JSR?
03528  D443  F0 04     			BEQ 	.JSR
03529  D445  C9 38     			CMP 	#$38			;is it JMP?
03530  D447  D0 01     			BNE 	.NOJMP
03531  		
03532  .JSR			;LDY 	#$2			;force 2 bytes for these two situations
03533  D449  C8        			INY				;following code treats Y = 3 the same as Y = 2
03534  
03535  D44A  68        .NOJMP			PLA				;mode base back in A
03536  D44B  E8        			INX				;check for NBYTS failure
03537  D44C  F0 51     			BEQ 	FERR
03538  D44E  88        			DEY
03539  D44F  F0 03     			BEQ 	.1BYT
03540  D451  18        .2BYT			CLC				;Two bytes eg: stx $xxxx
03541  D452  69 06     			ADC 	#$06			;add 6 to base index for 2 byte modes
03542  D454  A8        .1BYT			TAY				;mode index now in Y
03543  D455  20 C3 C5  .CHECK			JSR	NNONSPC			;next Char in the buffer
03544  D458  F0 04     			BEQ 	.DONE			;Check for CR
03545  D45A  C9 20     			CMP 	#SP
03546  D45C  D0 0D     			BNE 	.CONT
03547  D45E  A5 D1     .DONE			LDA 	CHAR			;first Bracket
03548  D460  C9 28     			CMP 	#OPEN			;brackets must match
03549  D462  F0 3B     			BEQ 	FERR
03550  D464  C0 0F     .RET			CPY 	#$0F			;compare the amount of bytes
03551  D466  10 37     			BPL 	FERR			;no indirect absolute Y mode
03552  D468  98        			TYA
03553  D469  AA        			TAX
03554  D46A  60        			RTS
03555  D46B  C9 29     .CONT			CMP 	#CLOSE
03556  D46D  D0 0B     			BNE 	.MORE
03557  D46F  A9 20     			LDA 	#SP
03558  D471  85 D1     			STA 	CHAR			;erase brackets now they have found them
03559  D473  E8        			INX				;next char in the keyboardf buffer
03560  D474  B5 18     			LDA 	IN,X
03561  D476  C9 2C     			CMP 	#COMMA		
03562  D478  D0 DB     			BNE 	.CHECK
03563  D47A  20 C3 C5  .MORE			JSR	NNONSPC			;Next Character (skipping spaces)
03564  D47D  C9 2C     			CMP 	#COMMA
03565  D47F  D0 1E     			BNE 	FERR
03566  D481  E8        			INX
03567  D482  B5 18     			LDA 	IN,X			;Next Character
03568  D484  C9 58     			CMP 	#'X'
03569  D486  F0 0D     			BEQ 	.ISX
03570  D488  C9 59     .ISY			CMP 	#'Y'
03571  D48A  D0 13     			BNE 	FERR
03572  D48C  A5 D1     			LDA 	CHAR
03573  D48E  C9 28     			CMP 	#OPEN
03574  D490  F0 0D     			BEQ 	FERR
03575  D492  95 16     			STA 	IN-2,X			;to avoid ,X check below
03576  D494  C8        			INY
03577  D495  C8        .ISX			INY
03578  D496  B5 16     			LDA 	IN-2,X
03579  D498  C9 29     			CMP 	#CLOSE			;No such thing as (...),X mode
03580  D49A  F0 03     			BEQ 	FERR
03581  D49C  E8        			INX
03582  D49D  80 B6     			BRA 	.CHECK			;always
03583  D49F  A2 FF     FERR			LDX 	#FAIL			;error message generated upstream
03584  D4A1  60        FRET			RTS
03585  
03586          	          
03587  ;------------------------------------------------------------------------------------------		
03588  ; Get the MNE index using the following rules:
03589  ; 	- lookup awkward cases in a lookup table (DISTBL)
03590  ;	- consider opcodes by category:
03591  ;		1: nnnn1000 -> nnnn
03592  ;		2: nnn10000 -> nnn + BPL
03593  ;		3: nnnn1010 or 0nn00000 -> BRK + nnnn(0nn0)
03594  ;		4: change nnnX0010 to nnnX0001
03595  ;		5: nnnXXXab -> 001abnnn if >= 23
03596  ;		6: 001abnnn + 1 otherwise
03597  ;------------------------------------------------------------------------------------------		
03598  	
03599  GETMNE							;get mnemonic index for opcode in A
03600  							;on completion, A holds the index 
03601  							;into the mnemonic table
03602  D4A2  85 E1     			STA 	TEMP1			;will need it later
03603  D4A4  A2 1A     			LDX 	#TBLSZ			;check lookup table first
03604  D4A6  BD E7 D1  .LOOP			LDA 	DISTBL-2,X
03605  D4A9  C5 E1     			CMP 	TEMP1
03606  D4AB  D0 04     			BNE 	.SKIP
03607  D4AD  BD E8 D1  			LDA 	DISTBL-1,X		;got it
03608  D4B0  60        			RTS
03609  D4B1  CA        .SKIP			DEX
03610  D4B2  CA        			DEX
03611  D4B3  D0 F1     			BNE 	.LOOP
03612  D4B5  A5 E1     			LDA 	TEMP1	
03613  D4B7  4A        			LSR
03614  D4B8  4A        			LSR
03615  D4B9  4A        			LSR
03616  D4BA  4A        			LSR
03617  D4BB  85 E2     				STA 	TEMP2		;save the high nibble
03618  D4BD  A5 E1     				LDA 	TEMP1
03619  D4BF  29 0F     			AND 	#$0F
03620  D4C1  C9 08     			CMP 	#$08
03621  D4C3  D0 03     			BNE 	.NOTC1
03622  D4C5  A5 E2     			LDA 	TEMP2			;high nibble is our index
03623  D4C7  60        			RTS	
03624  D4C8  A5 E1     .NOTC1			LDA 	TEMP1
03625  D4CA  29 1F     			AND 	#$1F
03626  D4CC  C9 10     			CMP 	#$10
03627  D4CE  D0 06     			BNE 	.NOTC2
03628  D4D0  A5 E2     			LDA 	TEMP2
03629  D4D2  4A        			LSR
03630  D4D3  69 38     			ADC 	#$39-1			;since carry is set
03631  D4D5  60        			RTS
03632  D4D6  A5 E1     .NOTC2			LDA 	TEMP1
03633  D4D8  29 9F     			AND 	#$9F
03634  D4DA  F0 06     			BEQ 	.DOC3
03635  D4DC  29 0F     			AND 	#$0F
03636  D4DE  C9 0A     			CMP 	#$0A
03637  D4E0  D0 06     			BNE 	.NOTC3
03638  D4E2  A5 E2     .DOC3			LDA 	TEMP2
03639  D4E4  18        			CLC
03640  D4E5  69 10     			ADC 	#$10
03641  D4E7  60        			RTS
03642  D4E8  A6 E1     .NOTC3			LDX 	TEMP1			;does this code end in 10010?
03643  D4EA  8A        			TXA
03644  D4EB  29 1F     			AND 	#$1F
03645  D4ED  C9 12     			CMP 	#$12
03646  D4EF  D0 01     			BNE 	.1
03647  D4F1  CA        			DEX
03648  D4F2  8A        .1			TXA				;? ABCD EFGH - thanks bogax, www.6502.org/forum
03649  D4F3  0A        			ASL				;A BCDE FGH0
03650  D4F4  69 80     			ADC 	#$80			;B ?CDE FGHA
03651  D4F6  2A        			ROL				;? CDEF GHAB
03652  D4F7  0A        			ASL				;C DEFG HAB0
03653  D4F8  29 1F     			AND 	#$1F			;C 000G HAB0
03654  D4FA  69 20     			ADC 	#$20			;0 001G HABC
03655  D4FC  C9 23     			CMP 	#$23
03656  D4FE  30 01     			BMI 	.NOTC5
03657  D500  60        			RTS
03658  D501  AA        .NOTC5			TAX
03659  D502  E8        			INX
03660  D503  8A        			TXA
03661  D504  60        			RTS        	       	
03662  
03663  
03664  	
03665  ;------------------------------------------------------------------------
03666  ;------------------------------------------------------------------------
03667  ;GENRAL LIBRARY ROUTINES BELOW
03668  
03669     
03670  
03671  	.include	"General Lib.65s"				
03672  ; version 1.00
03673  ; two pass assembler with dissembler - inspiration with permision from A1 by San Bergmans
03674  ; REGB bits 0-3 are connected to LED's
03675  ; tested in Michael Kowalski 6502 Simulator - using 65C02 Code        		
03676  ;--------------------------------------------------------------------
03677  ;prints a string ending with EOS 
03678  D505  08        STRING  		PHP				;print stringz to screen
03679  D506  48        	        	PHA	        	
03680  D507  DA                		PHX        		
03681  D508  5A                		PHY        		
03682  D509  A5 DB             		LDA     SRCE        		;Save SRCE 	
03683  D50B  48                		PHA        		
03684  D50C  A5 DC             		LDA     SRCE+1        		
03685  D50E  48                		PHA        		
03686  D50F  BA                		TSX        		
03687  D510  BD 07 01          		LDA     $0107,x        		
03688  D513  85 DB             		STA     SRCE        		
03689  D515  BD 08 01          		LDA     $0108,x
03690  D518  85 DC             		STA     SRCE+1        		
03691  D51A  A0 01             		LDY     #$01        		
03692  D51C  B1 DB     .NEXTCHAR 		LDA     (SRCE),Y        		
03693  D51E  48        			PHA
03694  D51F  29 7F     			AND	#@01111111		;strip negative bit			
03695  D521  20 77 D5          		JSR     WRCHAR        		
03696  D524  68                		PLA
03697  D525  30 07             		BMI	.ADJUST_RETURN 		;if z=1 then end.
03698  D527  C8                		INY
03699  D528  D0 F2             		BNE     .NEXTCHAR		;more than $ff characters        		
03700  D52A  E6 DC             		INC     SRCE+1
03701  D52C  80 EE             		BRA     .NEXTCHAR      		
03702  D52E  98        .ADJUST_RETURN 		TYA
03703  D52F  18                		CLC	        		
03704  D530  65 DB             		ADC     SRCE			;BUMPSRCE        		
03705  D532  9D 07 01          		STA     $0107,x        		
03706  D535  A5 DC             		LDA     SRCE+1        		
03707  D537  69 00             		ADC     #$00        		
03708  D539  9D 08 01          		STA     $0108,x        		
03709  D53C  68                		PLA        			;Restore SRC
03710  D53D  85 DC             		STA     SRCE+1       	 		
03711  D53F  68                		PLA        		
03712  D540  85 DB             		STA     SRCE
03713  D542  7A                		PLY        		
03714  D543  FA                		PLX        		
03715  D544  68                		PLA        	
03716  D545  28                		PLP        		
03717  D546  60                		RTS    
03718  ;------------------------------------------------------------
03719  ; ANSI GOTO x & y 
03720  ;------------------------------------------------------------
03721  GOTOXY 			 	
03722  		.IF MYWYM
03723  D547  8E 05 88          		STX	io_posx 		;use simlulator
03724  D54A  8C 06 88  			STY	io_posy			
03725  D54D  60        			RTS		
03726  		.ENDIF			
03727          			
03728  ;------------------------------------------------------------------------
03729  ; ANSI - Clear Screen
03730  ;  low level
03731  ;------------------------------------------------------------------------
03732  CLS     		
03733  		.IF MYWYM
03734  D54E  8D 00 88  			STA	io_cls			;use simlulator	
03735  D551  60        			RTS			
03736          	.ENDIF
03737          	
03738  ;------------------------------------------------------------------------
03739  ; ANSI -  Bring Cursor Home 
03740  ;------------------------------------------------------------------------
03741  D552  20 05 D5  HOME    		JSR     STRING        	
03742          		.BYTE	ESC, "[1;1H",EOS          	        		
03743  D55C  60                		RTS       	        	
03744          	
03745  ;------------------------------------------------------------------------
03746  ; Print a dot
03747  ;------------------------------------------------------------------------
03748  D55D  A9 2E     WRDOT           	LDA     #'.'            	;Print a dot
03749  D55F  80 16                     	BRA     WRCHAR
03750  
03751  ;------------------------------------------------------------------------
03752  ; Check Tabs
03753  ;------------------------------------------------------------------------
03754  
03755  D561  48        TABS3   		PHA
03756  D562  AD 05 88  			LDA 	io_posx
03757  D565  A9 14     			LDA 	#20
03758  			;CLC
03759  			;ADC	#06
03760  D567  8D 05 88  			STA 	io_posx
03761  D56A  68        			PLA
03762  D56B  60        			RTS	
03763  		                
03764  ;------------------------------------------------------------------------
03765  ; Print a space
03766  ;------------------------------------------------------------------------
03767  D56C  A9 20     WRSPACE         	LDA     #SP            		;Print a space
03768  D56E  80 07     			BRA     WRCHAR		
03769                  
03770  ;------------------------------------------------------------------------
03771  ; Print a CR
03772  ;------------------------------------------------------------------------
03773  
03774  D570  A9 0D     WRCRLF          	LDA     #CR             	;Print a CR & LF		
03775  D572  20 77 D5  			JSR	WRCHAR
03776  D575  A9 0A     PRLF			LDA	#LF			;fall through to WRCHAR
03777  
03778  ;--------------------------------------------------------------
03779  ;WRCHAR Out charater to the screen
03780  ;  Low level
03781  ;--------------------------------------------------------------
03782  WRCHAR  	
03783  		.IF LCD_ROUTINES
03784  
03785  		.IF MYWYM
03786  D577  8D 01 88  			STA	io_putc			;Else use simulator
03787  D57A  60        			RTS
03788  		.ENDIF	
03789  						
03790  ;--------------------------------------------------------------
03791  ;REPWRCHAR Out charater to the screen
03792  ; A= Char  y= times
03793  ;--------------------------------------------------------------
03794  D57B  20 70 D5  DRAWLINE		JSR	WRCRLF
03795  D57E  A9 2D     			LDA	#DASH
03796  D580  A0 32     			LDY	#50
03797  D582  20 77 D5  REPWRCHAR 		JSR	WRCHAR					
03798  D585  88        			DEY
03799  D586  10 FA     			BPL	REPWRCHAR 						
03800  D588  80 E6     			BRA	WRCRLF
03801  
03802  ;--------------------------------------------------------------
03803  ;convert binary into a ASCII characters 
03804  ;write to screen eg xx
03805  
03806  D58A  48        WR2HEX  		PHA        	
03807  D58B  4A                		LSR				;write 2 hex digits        	
03808  D58C  4A                		LSR        	
03809  D58D  4A                		LSR        	
03810  D58E  4A                		LSR        	
03811  D58F  20 93 D5          		JSR     WR1HEX        	
03812  D592  68                		PLA        	
03813  D593  D8        WR1HEX        		CLD        			;write 1 character HEX eg x 
03814  D594  29 0F             		AND     #$0f        	
03815  D596  C9 0A             		CMP     #$0a        	
03816  D598  90 02             		BCC     .z09        	        	
03817  D59A  69 06             		ADC     #$06			;carry is set        	
03818  D59C  69 30     .z09     		ADC     #$30
03819  D59E  80 D7             		BRA     WRCHAR     
03820          	
03821  ;------------------------------------------------------------------------
03822  ; Print word in hex
03823  ; A holds MSB, Y holds LSB, eg $xxxx
03824  ;------------------------------------------------------------------------
03825  
03826  D5A0  48        WRWORD         		PHA                     	;Save MSB
03827  D5A1  A9 24                     	LDA     #'$'            	;Print dollar symbol
03828  D5A3  20 77 D5                  	JSR     WRCHAR
03829  D5A6  68                        	PLA
03830  D5A7  20 8A D5  WRWORDAY       		JSR     WR2HEX          	;Print MSB
03831  D5AA  98                        	TYA
03832  D5AB  80 DD                     	BRA     WR2HEX          	;Print LSB
03833  
03834  ;------------------------------------------------------------------------
03835  ; SCAN_ESC if key is pressed
03836  ;  Low level
03837  ;------------------------------------------------------------------------
03838  
03839  SCAN_ESC    
03840  		.IF MYWYM		
03841  D5AD  AD 04 88  			LDA     KBDCR           	;Was a key pressed?
03842  D5B0  C9 1B     			CMP     #ESC   			;Make Z=1 if ESC
03843  D5B2  60        			RTS
03844  		.ENDIF
03845  
03846  
03847  ;------------------------------------------------------------------------
03848  ; Wait for keypressed
03849  ;  Low level
03850  ;------------------------------------------------------------------------
03851  
03852  RDCHAR
03853    		.IF MYWYM 
03854  D5B3  AD 04 88  			LDA	KBDCR			;Else use simulator 		
03855  D5B6  F0 FB     			BEQ 	RDCHAR 		
03856  D5B8  60        			RTS	
03857  		.ENDIF
03858  	
03859  
03860  ;--------------------------------------------------------------------
03861  D5B9  20 B3 D5  RD1HEX  		JSR     RDCHAR
03862  D5BC  80 0F             		BRA     HEX2BIN        	
03863  
03864  ;--------------------------------------------------------------------
03865  D5BE  20 B9 D5  RD2HEX  		JSR     RD1HEX        	
03866  D5C1  0A                		ASL        	
03867  D5C2  0A                		ASL        	
03868  D5C3  0A                		ASL        	
03869  D5C4  0A                		ASL        	        	
03870  D5C5  85 E1             		STA     TEMP1            	
03871  D5C7  20 B9 D5          		JSR     RD1HEX        	        	
03872  D5CA  05 E1             		ORA     TEMP1       	        	        	
03873  D5CC  60                		RTS      	
03874  
03875  
03876  ;--------------------------------------------------------------
03877  ;AC in HEX out BIN
03878  
03879  D5CD  49 30     HEX2BIN			EOR     #'0'            	;Ignore ASCII part for decimals				
03880  D5CF  C9 0A                     	CMP     #9+1	
03881  D5D1  90 08                     	BCC     .okhex          	;It was a decimal digit!
03882  D5D3  69 88                     	ADC     #$88            	;Map letters A - F to $FA-FF
03883  D5D5  C9 FA                     	CMP     #$fa
03884  D5D7  90 03                     	BCC     .invalid        	;No hex digit anymore!
03885  D5D9  29 0F                     	AND	#$0F		  	
03886  D5DB  60        .okhex   		RTS
03887  
03888  D5DC  A9 FF     .invalid 		LDA 	#FAIL
03889  D5DE  60        			RTS
03890  			;SEC
03891  			;JSR     STRING
03892          		;.ASCIS   CR,LF,BELL," :HEX 2 BIN CONVERSION",CR,LF        	
03893          		;BRK
03894  
03895  ;--------------------------------------------------------------
03896  ;Restore saved registers
03897  ;--------------------------------------------------------------
03898  D5DF  A5 A7     RESTORE 		LDA SAVP     		 	;Restore 6502 Register Contents 
03899  D5E1  48                		PHA             	 	;Used by tracing software
03900  D5E2  A5 AB             		LDA SAVA	
03901  D5E4  A6 AA     			LDX SAVX
03902  D5E6  A4 A9             		LDY SAVY
03903  D5E8  28                		PLP
03904  D5E9  60                		RTS
03905  
03906  ;------------------------------------------------------------------------
03907  ; Save HW registers
03908  ;------------------------------------------------------------------------    	
03909          	
03910  D5EA  85 AB     SAVE    		STA SAVA        		;Save 6502 HW registers
03911  D5EC  86 AA     			STX SAVX
03912  D5EE  84 A9             		STY SAVY
03913  D5F0  08                		PHP
03914  D5F1  68                		PLA
03915  D5F2  85 A7             		STA SAVP			;svae the flags
03916  D5F4  BA                		TSX
03917  D5F5  86 A8             		STX SAVS			;stack pointer        		
03918  D5F7  60                		RTS	
03919          	
03920  ;--------------------------------------------------------------
03921  ;Convert buffer to uppercase         	
03922  D5F8  B5 18     UPPERCASE 		LDA 	IN,x
03923  D5FA  C9 7B             		CMP     #'z'+1        		
03924  D5FC  B0 08     	        	BCS     .NEXTDIGIT        	
03925  D5FE  C9 61             		CMP     #'a'	        	
03926  D600  90 04             		BCC     .NEXTDIGIT        	
03927  D602  E9 20             		SBC     #SP        	
03928  D604  95 18             		STA     IN,x        		
03929  D606  CA        .NEXTDIGIT 		DEX
03930  D607  10 EF     			BPL     UPPERCASE		;end of string        	
03931  D609  60                		RTS       	
03932   
03933   
03934    
03935   
03936   		.IF LCD_ROUTINES
03937  		.ENDIF       				;End of LCD Routines
03938  
03939   
03940  ;------------------------------------------------------------------------------------------        	
03941  ;Interrupts Handling       	
03942  ;------------------------------------------------------------------------------------------
03943  D60A  6C FA 00  NMI_VECTOR     		JMP     (USMNI)        		;NMI hardware interrupt handler        			      		
03944          		    				;loop through RAM        		
03945  
03946  ;------------------------------------------------------------------------------------------
03947  NMI_RETURN 		 				;Routines http://6502.org/tutorials/interrupts.html	
03948          			
03949  D60D  40        IRQ_RETURN     		RTI				;IRQ return address - used to store in RAM 
03950  
03951  ;------------------------------------------------------------------------------------------
03952  ;
03953  ;------------------------------------------------------------------------------------------
03954  D60E  48        IRQ_VECTOR     		PHA                		;IRQ hardware interrupt
03955  D60F  DA                		PHX
03956  D610  BA                		TSX
03957  D611  BD 03 01          		LDA     $0103,x			;check if caused by a 
03958  D614  FA                		PLX				;done with X so restore it
03959  D615  89 10             		BIT     #$10			;BRK instruction        	
03960  D617  D0 04             		BNE     GOBRK			;yes        	
03961  D619  68                		PLA				;no must have been an IRQ        	
03962  D61A  6C F6 00          		JMP     (USIRQ)        	
03963  D61D  68        GOBRK   		PLA		
03964  D61E  6C F8 00          		JMP     (USBRK)
03965  
03966  ;------------------------------------------------------------------------------------------
03967  ;        	
03968  ;------------------------------------------------------------------------------------------
03969  D621  28        BRK_RETURN     		PLP
03970  D622  20 EA D5          		JSR 	SAVE       		;Save the Registers
03971  D625  68                		PLA              		; save the Program counter
03972  D626  85 DB             		STA 	SRCE
03973  D628  68                		PLA
03974  D629  85 DC             		STA 	SRCE+1
03975  D62B  BA        			TSX			
03976  D62C  86 A8             		STX 	SAVS			;save registers
03977  D62E  20 CC D6  XBRK			JSR 	TRACE_DIS		;show registers		
03978  D631  58        			CLI
03979  D632  4C 03 C0  			JMP    	WARM 
03980  
03981  
03982  
03983  ;------------------------------------------------------------------------
03984  ; Tracing
03985  ;------------------------------------------------------------------------	
03986  
03987  D635  68        CMD_TRACE		PLA				;Pull caller address off stack
03988  D636  68        			PLA				
03989  D637  20 22 C7  			JSR 	GET_EXPRES 
03990  D63A  D0 07     			BNE	.CONT
03991  D63C  84 DB     		        STY     SRCE			; else continue 
03992  D63E  85 DC                     	STA     SRCE+1  
03993  D640  20 4E D5                  	JSR	CLS			;Clear the screen                	
03994  D643  20 CC D6  .CONT			JSR 	TRACE_DIS						
03995  D646  A2 08     			LDX 	#$08
03996  D648  BD C3 D6  XQINIT  		LDA 	INITBL-1,X 		;Init XEQ AREA with dummy code into Excute area
03997  D64B  95 98             		STA 	XQT,X			
03998  D64D  CA                		DEX
03999  D64E  D0 F8             		BNE 	XQINIT
04000          		
04001  D650  A1 DB             		LDA 	(SRCE,X)    		;Get the user code OP- Current source line address
04002  D652  F0 DA             		BEQ 	XBRK		       	;Special If BRK       	
04003  D654  A4 D9             		LDY 	LENG     		;Length from Dissassembler 
04004  D656  C9 80             		CMP	#$80			;BRA instructions	
04005  D658  D0 02             		BNE	.BRNCH 			
04006  D65A  A9 F0             		LDA	#$F0			;Fudge BRA into a BEQ
04007  D65C  C9 20     .BRNCH        		CMP 	#$20
04008  D65E  F0 38             		BEQ 	XJSR       		;Handle JSR, RTS, JMP,
04009  D660  C9 60             		CMP 	#$60    	   	;RTS
04010  D662  F0 26             		BEQ 	XRTS
04011  D664  C9 4C             		CMP 	#$4C			;JMP
04012  D666  F0 38             		BEQ 	XJMP
04013  D668  C9 6C             		CMP 	#$6C			;JMP ()
04014  D66A  F0 35             		BEQ 	XJMPAT
04015  D66C  C9 40             		CMP 	#$40			;RTI - this is special
04016  D66E  F0 16             		BEQ 	XRTI
04017  D670  29 1F             		AND 	#$1F
04018  D672  49 14             		EOR 	#$14
04019  D674  C9 04             		CMP 	#$04       		;Copy use code into the XEQ area
04020  D676  F0 02             		BEQ 	.XQ2       		;  with trialing NOP command
04021  D678  B1 DB     .XQ1    		LDA 	(SRCE),Y    		;Changce relative branch
04022  D67A  99 98 00  .XQ2    		STA 	XQT,Y      		;  Disp to 4
04023  D67D  88                		DEY            			;  JMP to branch or
04024  D67E  10 F8             		BPL 	.XQ1      	 	;  NBRANCK (not branch) from XEQ.
04025  D680  20 DF D5          		JSR 	RESTORE    		;Restore user registers 
04026  D683  4C 98 00          		JMP	 XQT        		;XEQ excute user code in RAM
04027  D686  18        XRTI    		CLC
04028  D687  68                		PLA     	        	;Simulate RTI by expect flags register
04029  D688  85 A7             		STA 	SAVP     		; status from stack, then return
04030  D68A  68        XRTS    		PLA              		;RTS simulate
04031  D68B  85 DB            	 		STA 	SRCE        		;  Extract PC from stack 
04032  D68D  68                		PLA             		;  and update PC 
04033  D68E  85 DC     PCINC2  		STA 	SRCE+1
04034  D690  20 33 C3  PCINC3  		JSR 	PCADJ2			;Update by the length of the instruction
04035  D693  84 DC             		STY 	SRCE+1
04036  D695  18                		CLC
04037  D696  80 11             		BRA 	NEWPCL			;Always taken
04038          	
04039  D698  18        XJSR    		CLC				;Handle JSR instructions
04040  D699  20 33 C3          		JSR 	PCADJ2     		;Update the PC
04041  D69C  5A                		PHY				;and push it onto the stak
04042  D69D  48                		PHA
04043  D69E  A0 02             		LDY 	#$02
04044  D6A0  18        XJMP    		CLC
04045  D6A1  B1 DB     XJMPAT  		LDA 	(SRCE),Y
04046  D6A3  AA                		TAX              		;LOAD PC FOR JMP,
04047  D6A4  88                		DEY              		;  (JMP) SIMULATE.
04048  D6A5  B1 DB             		LDA 	(SRCE),Y
04049  D6A7  86 DC             		STX 	SRCE+1
04050  D6A9  85 DB     NEWPCL  		STA 	SRCE
04051  D6AB  B0 F3             		BCS 	XJMP
04052  RTS_TRACE     		;STZ	ERROR			;no error - save a bytes
04053  D6AD  4C 09 C0  			JMP	GETLINE 		;stack may carry JSR/RTS address's
04054          		
04055  ;------------------------------------------------------------------------
04056  ; TRACE - Branch taken calculation
04057  ;------------------------------------------------------------------------
04058  D6B0  38        BRANCH  		SEC     	         	;branch Taken
04059  D6B1  A0 01             		LDY 	#$01       		;  Then add len + 2
04060  D6B3  B1 DB             		LDA	(SRCE),Y
04061  D6B5  20 35 C3          		JSR 	PCADJ3        		;calculate address
04062  D6B8  85 DB             		STA 	SRCE
04063  D6BA  84 DC             		STY	SRCE+1		
04064  D6BC  80 EF             		BRA 	RTS_TRACE		;save a byte
04065  
04066  ;------------------------------------------------------------------------
04067  ; TRACE - Normal return from Trace command
04068  ;------------------------------------------------------------------------
04069         		
04070  D6BE  20 EA D5  NBRNCH  		JSR 	SAVE       		;Normal Return after
04071  D6C1  38                		SEC              		;  XEQ used for
04072  D6C2  80 CC             		BRA 	PCINC3     		;Goto PC update
04073  
04074  ;------------------------------------------------------------------------
04075  ; TRACE - Initial Build for Tracing
04076  ;------------------------------------------------------------------------
04077  D6C4  EA        INITBL  		NOP				;Dummy fill for Tracing
04078  D6C5  EA                		NOP              		;XEQ area
04079  D6C6  4C BE D6          		JMP NBRNCH     			;Normal return
04080  D6C9  4C B0 D6          		JMP BRANCH
04081          		       	
04082  
04083  ;------------------------------------------------------------------------------------------
04084  ; TRACE - show registers and dissamble OPCODE and display
04085  ;------------------------------------------------------------------------------------------
04086  D6CC  20 D8 D6  TRACE_DIS		JSR 	CMD_SHOWREG		;show registers	
04087  D6CF  20 B5 C3  			JSR	DISPLAY_ADDR        	;display SOURCE address (could remove A&Y)              		               		               		
04088  D6D2  B2 DB     			LDA	(SRCE)			;Get OpCode
04089  D6D4  20 A9 C2  			JSR 	INSTDSP					
04090  D6D7  60                		RTS
04091  
04092  ;------------------------------------------------------------------------------------------  
04093  ; Show the registers
04094  ;------------------------------------------------------------------------------------------  
04095  D6D8  D8        CMD_SHOWREG		CLD				;debugging
04096  D6D9  AC 06 88  			LDY	io_posy			;GETY position
04097  			;INY	
04098  D6DC  C0 05     			CPY	#05
04099  D6DE  10 02     			BPL	.reset
04100  D6E0  A0 05     			LDY	#05	
04101  			
04102  D6E2  5A        .reset			PHY	
04103  D6E3  A2 00     			LDX	#00			;top left
04104  D6E5  A0 00     			LDY	#00
04105  D6E7  20 47 D5  			JSR	GOTOXY	
04106  D6EA  20 05 D5  			JSR	STRING
04107  		.ASCII " _____ _____ _____ _____ _____                    ",CR,LF
04108  		.ASCIS "|_   _| __  |  _  |     |   __|  AC="
04109  			
04110  D745  A5 AB     			LDA	SAVA 
04111  D747  20 8A D5          		JSR     WR2HEX     		;Accumulator        		
04112  D74A  20 6C D5          		JSR     WRSPACE        		
04113          		
04114  D74D  20 05 D5          		JSR	STRING
04115          	.ASCIS 	"  SP="        		
04116  D755  A5 A8             		LDA	SAVS
04117  D757  20 8A D5          		JSR     WR2HEX     		;Stack Pointer
04118  D75A  20 6C D5          		JSR     WRSPACE
04119  		
04120  			        		
04121  D75D  20 05 D5          		JSR	STRING
04122  		.ASCIS CR,LF,"  | | |    -|     |   --|   __|  XR="
04123          		
04124  D786  A5 AA             		LDA	SAVX 
04125  D788  20 8A D5          		JSR     WR2HEX     		;X Reg        		
04126  D78B  20 6C D5          		JSR     WRSPACE        		
04127          		
04128  D78E  20 05 D5          		JSR     STRING	        
04129  	        .ASCII   "  NV*B.DIZC",CR,LF
04130  	        .ASCIS "  |_| |__|__|__|__|_____|_____|  YR="
04131  	        	
04132  D7C2  A5 A9             		LDA	SAVY 
04133  D7C4  20 8A D5          		JSR     WR2HEX     		;Y Reg
04134  D7C7  20 6C D5          		JSR     WRSPACE        		
04135          	
04136  D7CA  20 6C D5          		JSR	WRSPACE
04137  D7CD  20 6C D5          		JSR	WRSPACE
04138          		
04139  D7D0  A5 A7             		LDA	SAVP
04140  D7D2  20 4F CB          		JSR	WRBIN			;Flags       	        	
04141  D7D5  20 7B D5          		JSR	DRAWLINE
04142  D7D8  7A                		PLY
04143  D7D9  8C 06 88          		STY	io_posy	        		
04144  D7DC  60                		RTS        			;Start of code	
04145          	
04146  ;------------------------------------------------------------------------------------------
04147  D7DD  78        RESET_VECTOR   		SEI				;Hardware reset routine
04148  
04149  		.IF	MYWYM
04150  		
04151   ;       	lda     #b00010000		;heck if portB button ON for custom RESET
04152  ;        	bit     VIA
04153  ;        	beq     NORMALRESET		;ignore this instructions
04154  ;        	jmp     (USRRST)
04155  
04156  D7DE  A2 FF     RESET_RETURN 		LDX	#$ff       		;normal boot up procedure
04157  
04158  D7E0  9A                		TXS
04159  ;			SED
04160  ;			SEC
04161  ;			LDA 	#$20
04162  ;			SBC 	#$0F
04163  ;			CMP	#$0B
04164  ;			BNE	DET6502
04165  ;			JSR	STRING
04166  ;		.ASCIS	"detected a 65C02 CPU"
04167  ;DET6502			NOP		
04168  
04169  D7E1  D8                		CLD
04170          		
04171          	.IF	MYWYM
04172          	
04173  D7E2  58                		CLI        		        		
04174  D7E3  4C 00 C0          		JMP	COLD       	
04175  	
04176  
04177  	
04178  
04179  ;------------------------------------------------------------------------------------------
04180  ;Display help screen
04181  ;------------------------------------------------------------------------------------------
04182  D7E6  20 05 D5  CMD_HLP 		JSR     STRING            	
04183  		.ASCII CR,"  _______  _______  _____    ______  __ ",CR,LF 		                         
04184  		.ASCII " |   |   ||    ___||     |  |   __ \|  |",CR,LF 		 	
04185  		.ASCII " |       ||    ___||     |_ |    __/|__|           @  User defined command",CR,LF                          
04186  		.ASCII " |___|___||_______||_______||___|   |__|           A  Auto line numbering",CR,LF 
04187  		.ASCII "                                                   B  Break command",CR,LF                
04188  		.ASCII "   EXPANSION PORT LOW     EXPANSION PORT TOP       C  Copy command",CR,LF                      
04189  		.ASCII "  +-------------------+  +-------------------+     D  Dissassembler",CR,LF                  
04190  		.ASCII "  |[]GND         +5V[]|  |[]PA0         IRQ[]|     I  ASCII Dump",CR,LF     
04191  		.ASCII "  |[]A12         +5V[]|  |[]PA1         NMI[]|     L  List command",CR,LF                        
04192  		.ASCII "  |[]A7           NC[]|  |[]PA2         R/W[]|     M  Memory command",CR,LF                     
04193  		.ASCII "  |[]A6           A8[]|  |[]PA3          02[]|     N  New command",CR,LF                     
04194  		.ASCII "  |[]A5           A9[]|  |[]PA4         CA1[]|     O  Old command",CR,LF                   
04195  		.ASCII "  |[]A4          A11[]|  |[]PA5         PB5[]|     R  Renumber command",CR,LF              
04196  		.ASCII "  |[]A3          GND[]|  |[]PA6         PB6[]|     S  Start assembling",CR,LF                   
04197  		.ASCII "  |[]A2          A10[]|  |[]PA7         PB7[]|     T  Trace code",CR,LF                       
04198  		.ASCII "  |[]A1           CS[]|  +-------------------+     V  Value command",CR,LF                  
04199  		.ASCII "  |[]A0           D7[]|                            X  eXecute command",CR,LF                    
04200  		.ASCII "  |[]D0           D6[]|   HARDWARE MAPPING         Y  Memory configuraion",CR,LF 
04201  		.ASCII "  |[]D1           D5[]|                            E  Erase line",CR,LF                    
04202  		.ASCII "  |[]D2           D4[]|    CS   $2000              Z  Clear Screen",CR,LF                                                                                       
04203  		.ASCII "  |[]GND          D3[]|    VIA  $4000              W  Display Register",CR,LF                                              
04204  		.ASCIS "  +-------------------+    ACIA $6000",CR,LF
04205  DD93  60        			RTS
04206  			
04207  			
04208  ;------------------------------------------------------------------------------------------
04209  ;interrupt vectors        
04210  ;------------------------------------------------------------------------------------------
04211  FFFA            			*=	 $fffa 			
04212          		.WORD   NMI_VECTOR		; NMI_VECTOR
04213          		.WORD   RESET_VECTOR		; REST VECTOR
04214          		.WORD   IRQ_VECTOR		; IRQ_VECTOR        	
04215  
