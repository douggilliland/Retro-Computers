  Tue Dec  5 2017  6:27                                                                                                    Page 1


                                               ***************************************
                                               **      WDC 65C02 Macro Assembler    **
                                               **                                   **
                                               **     Version 3.49.1- Feb  6 2006    **
                                               ***************************************

     1                        ;***************************************************************************************************
     2                        ;*     C02Monitor 2.0 - Initial Release version for Pocket SBC  (c)2013-2017 by Kevin E. Maier     *
     3                        ;*                                                                                                 *
     4                        ;*  Monitor Functions are divided into groups as follows:                                          *
     5                        ;*   1. Memory Operations:                                                                         *
     6                        ;*      - Fill Memory: Source, Length, Value (prompts for commit)                                  *
     7                        ;*      - Move Memory: Source, Target, Length (prompts for commit)                                 *
     8                        ;*      - Compare Memory: Source, Target, Length                                                   *
     9                        ;*      - Examine/Edit: Address, Data (edit) sequential memory                                     *
    10                        ;*      - Input ASCII Text into memory: Address, Data (ESC quits)                                  *
    11                        ;*      - Hex Data Search: Hex data bytes up to 16                                                 *
    12                        ;*      - Text String Seach: ASCII data up to 16 characters                                        *
    13                        ;*      - Display Memory as Hex/ASCII: Address start - 256 consecutive bytes displayed             *
    14                        ;*      - Execute from Memory: Start address                                                       *
    15                        ;*                                                                                                 *
    16                        ;*   2. Register Operations:                                                                       *
    17                        ;*      - Display All Registers                                                                    *
    18                        ;*      - Display/Edit A, X, Y, Stack Pointer, Processor Status                                    *
    19                        ;*                                                                                                 *
    20                        ;*   3. Timer Functions:                                                                           *
    21                        ;*      - Set delay time: Millisecond count and 16-bit Loop Count                                  *
    22                        ;*      - Execute Millisecond Delay 1-256 times 10ms (Jiffy Clock)                                 *
    23                        ;*      - Execute Millisecond Delay times 16-bit Loop Count                                        *
    24                        ;*      - Extended Delay: up to 256 times above count                                              *
    25                        ;*      - RTC function based on 10ms Jiffy Clock: Ticks, Seconds, Minutes, Hours, Days             *
    26                        ;*                                                                                                 *
    27                        ;*   4. Keyboard Macro Facility:                                                                   *
    28                        ;*      - Provides up to 127 byte keyboard buffer loop capability                                  *
    29                        ;*      - Optional 16-bit Loop Counter (1-65,535)                                                  *
    30                        ;*      - Send Break command (ExtraPutty Terminal) exits Macro function                            *
    31                        ;*                                                                                                 *
    32                        ;*   5. Control-Key Functions:                                                                     *
    33                        ;*      - CTRL-D: Table-Driven Disassembler - Supports Full WDC Opcodes/Addressing modes           *
    34                        ;*      - CTRL-L: Xmodem Loader w/CRC-16 Support, auto detect S19 Records from WDC Linker          *
    35                        ;*      - CTRL-P: Program EEPROM - Source, Target, Length (Source must be RAM based)               *
    36                        ;*      - CTRL-Q: Query Commands - Shows all available Monitor functions                           *
    37                        ;*      - CTRL-R: Reset System - Initiates Cold Start of BIOS and Monitor                          *
    38                        ;*      - CTRL-T: Shows Elapsed time since System Cold Start                                       *
    39                        ;*      - CTRL-V: Shows Version for BIOS and Monitor                                               *
    40                        ;*      - CTRL-Z: Zeros out ALL RAM and initates Cold Start of BIOS and Monitor                    *
    41                        ;*                                                                                                 *
    42                        ;*   6. Panic Button (NMI Support Routine)                                                         *
    43                        ;*      - Saves Page Zero, CPU Stack, Console Buffer and Vector/Config Data pages                  *
    44                        ;*      - Re-initializes Vector and Configuration Data in Page $03                                 *
    45                        ;*      - Clears Console Buffer pointers and restarts Console only                                 *
    46                        ;***************************************************************************************************
    47                        	PL	66	;Page Length
    48                        	PW	132	;Page Width (# of char/line)
    49                        	CHIP	W65C02S	;Enable WDC 65C02 instructions
    50                        ;******************************************************************************
    51                        ;	Page Zero definitions $00 to $AF reserved for user routines
    52             000000B0   PGZERO_ST	.EQU	$B0	;Start of Page Zero usage
    53                        ;NOTES:	Locations $00 and $01 are used to zero RAM (calls CPU reset)
    54                        ;	EEPROM Byte Write routine loaded into Page Zero at $00-$14
    55                        ;
    56                        ;Page Zero Buffers used by the default Monitor code, Two buffers are required;
    57                        ;	DATABUFF is used by the HEX2ASC routine (6 bytes).	INBUFF is used by RDLINE routine (4 bytes)
  Tue Dec  5 2017  6:27                                                                                                    Page 2


    58             000000B0   BUFF_PG0	.EQU	PGZERO_ST+00	;Default Page zero location for Monitor buffers
    59                        ;
    60                        ;INBUFF is used for conversion from 4 HEX characters to a 16-bit address
    61             000000B0   INBUFF		.EQU	BUFF_PG0+00	;4 bytes ($B0-$B3)
    62                        ;DATABUFF is used for conversion of 16-bit binary to ASCII decimal output
    63                        ; note string is terminated by null character
    64             000000B4   DATABUFF	.EQU	BUFF_PG0+04	;6 bytes ($B4-$B9)
    65                        ;
    66                        ;16-bit variables:
    67             000000BA   HEXDATAH	.EQU	PGZERO_ST+10	;Hexadecimal input
    68             000000BB   HEXDATAL	.EQU	PGZERO_ST+11
    69             000000BC   BINVALL		.EQU	PGZERO_ST+12	;Binary Value for HEX2ASC
    70             000000BD   BINVALH		.EQU	PGZERO_ST+13
    71             000000BE   COMLO			.EQU	PGZERO_ST+14	;User command address
    72             000000BF   COMHI			.EQU	PGZERO_ST+15
    73             000000C0   INDEXL		.EQU	PGZERO_ST+16	;Index for address - multiple routines
    74             000000C1   INDEXH		.EQU	PGZERO_ST+17
    75             000000C2   TEMP1L		.EQU	PGZERO_ST+18	;Index for word temp value used by Memdump
    76             000000C3   TEMP1H		.EQU	PGZERO_ST+19
    77             000000C4   TEMP2L		.EQU	PGZERO_ST+20	;Index for Text entry
    78             000000C5   TEMP2H		.EQU	PGZERO_ST+21
    79             000000C6   PROMPTL		.EQU	PGZERO_ST+22	;Prompt string address
    80             000000C7   PROMPTH		.EQU	PGZERO_ST+23
    81             000000C8   SRCL			.EQU	PGZERO_ST+24	;Source address for memory operations
    82             000000C9   SRCH			.EQU	PGZERO_ST+25
    83             000000CA   TGTL			.EQU	PGZERO_ST+26	;Target address for memory operations
    84             000000CB   TGTH			.EQU	PGZERO_ST+27
    85             000000CC   LENL			.EQU	PGZERO_ST+28	;Length address for memory operations
    86             000000CD   LENH			.EQU	PGZERO_ST+29
    87                        ;
    88                        ;8-bit variables and constants:
    89             000000CE   BUFIDX		.EQU	PGZERO_ST+30	;Buffer index
    90             000000CF   BUFLEN		.EQU	PGZERO_ST+31	;Buffer length
    91             000000D0   IDX				.EQU	PGZERO_ST+32	;Temp Indexing
    92             000000D1   IDY				.EQU	PGZERO_ST+33	;Temp Indexing
    93             000000D2   TEMP1			.EQU	PGZERO_ST+34	;Temp - Code Conversion routines
    94             000000D3   TEMP2			.EQU	PGZERO_ST+35	;Temp - Memory/EEPROM/SREC routines - Disassembler
    95             000000D4   TEMP3			.EQU	PGZERO_ST+36	;Temp - EEPROM/SREC routines
    96             000000D5   CMDFLAG		.EQU	PGZERO_ST+37	;Command Flag - used by RDLINE & others
    97             000000D6   OPXMDM		.EQU	PGZERO_ST+38	;Saved Opcode/Xmodem Flag variable
    98                        ;
    99                        ;Xmodem transfer variables
   100             000000D7   CRCHI			.EQU	PGZERO_ST+39	;CRC hi byte  (two byte variable)
   101             000000D8   CRCLO			.EQU	PGZERO_ST+40	;CRC lo byte - Operand in Disassembler
   102             000000D9   CRCCNT		.EQU	PGZERO_ST+41	;CRC retry count - Operand in Disassembler
   103             000000DA   PTRL			.EQU	PGZERO_ST+42	;Data pointer lo byte - Mnemonic in Disassembler
   104             000000DB   PTRH			.EQU	PGZERO_ST+43	;Data pointer hi byte - Mnemonic in Disassembler
   105             000000DC   BLKNO			.EQU	PGZERO_ST+44	;Block number
   106                        ;
   107                        ;Macro Loop Counter variables
   108             000000DD   LPCNTL		.EQU	PGZERO_ST+45	;Loop Count low byte
   109             000000DE   LPCNTH		.EQU	PGZERO_ST+46	;Loop Count high byte
   110             000000DF   LPCNTF		.EQU	PGZERO_ST+47	;Loop Count flag byte
   111                        ;
   112                        ;	BIOS variables, pointers, flags located at top of Page Zero.
   113             000000E0   BIOS_PG0	.EQU	PGZERO_ST+48	;Start of BIOS page zero use ($E0-$FF)
   114                        ;	- BRK handler routine
   115             000000E0   PCL				.EQU	BIOS_PG0+0	;Program Counter Low index
   116             000000E1   PCH				.EQU	BIOS_PG0+1	;Program Counter High index
   117             000000E2   PREG			.EQU	BIOS_PG0+2	;Temp Status reg
   118             000000E3   SREG			.EQU	BIOS_PG0+3	;Temp Stack ptr
   119             000000E4   YREG			.EQU	BIOS_PG0+4	;Temp Y reg
   120             000000E5   XREG			.EQU	BIOS_PG0+5	;Temp X reg
  Tue Dec  5 2017  6:27                                                                                                    Page 3


   121             000000E6   AREG			.EQU	BIOS_PG0+6	;Temp A reg
   122                        ;
   123                        ;	- 2691 IRQ handler pointers and status
   124             000000E7   ICNT			.EQU	BIOS_PG0+7	;Input buffer count
   125             000000E8   IHEAD			.EQU	BIOS_PG0+8	;Input buffer head pointer
   126             000000E9   ITAIL			.EQU	BIOS_PG0+9	;Input buffer tail pointer
   127             000000EA   OCNT			.EQU	BIOS_PG0+10	;Output buffer count
   128             000000EB   OHEAD			.EQU	BIOS_PG0+11	;Output buffer head pointer
   129             000000EC   OTAIL			.EQU	BIOS_PG0+12	;Output buffer tail pointer
   130             000000ED   UART_IRT	.EQU	BIOS_PG0+13	;2691 Interrupt Status byte
   131             000000EE   UART_SRT	.EQU	BIOS_PG0+14	;2691 Status Register byte
   132                        ;
   133                        ;	- Real-Time Clock variables
   134             000000EF   TICKS			.EQU	BIOS_PG0+15	;# timer countdowns for 1 second (100)
   135             000000F0   SECS			.EQU	BIOS_PG0+16	;Seconds: 0-59
   136             000000F1   MINS			.EQU	BIOS_PG0+17	;Minutes: 0-59
   137             000000F2   HOURS			.EQU	BIOS_PG0+18	;Hours: 0-23
   138             000000F3   DAYSL			.EQU	BIOS_PG0+19	;Days: Low-Order byte 0-65535
   139             000000F4   DAYSH			.EQU	BIOS_PG0+20	;Days: High order byte >179 Years ;-)
   140                        ;
   141                        ;	- Delay Timer variables
   142             000000F5   MSDELAY		.EQU	BIOS_PG0+21	;Timer delay countdown byte (255 > 0)
   143             000000F6   MATCH			.EQU	BIOS_PG0+22	;Delay Match flag, $FF is set, $00 is cleared
   144             000000F7   SETIM			.EQU	BIOS_PG0+23	;Set timeout for delay routines - BIOS use only
   145             000000F8   DELLO			.EQU	BIOS_PG0+24	;Delay value BIOS use only
   146             000000F9   DELHI			.EQU	BIOS_PG0+25	;Delay value BIOS use only
   147             000000FA   XDL				.EQU	BIOS_PG0+26	;XL Delay count
   148                        ;
   149                        ;Spare BIOS bytes for future use
   150             000000FB   SPARE_B0	.EQU	BIOS_PG0+27	;Spare BIOS page zero byte
   151             000000FC   SPARE_B1	.EQU	BIOS_PG0+28	;Spare BIOS page zero byte
   152             000000FD   SPARE_B2	.EQU	BIOS_PG0+29	;Spare BIOS page zero byte
   153             000000FE   SPARE_B3	.EQU	BIOS_PG0+30	;Spare BIOS page zero byte
   154             000000FF   SPARE_B4	.EQU	BIOS_PG0+31	;Spare BIOS page zero byte
   155                        ;
   156                        ;******************************************************************************
   157             00000300   SOFTVEC		.EQU	$0300	;Start of soft vectors
   158                        ;The Interrupt structure is vector based. During startup, Page $03 is loaded from ROM
   159                        ; The soft vectors are structured to allow inserting additional routines either before
   160                        ; or after the core routines. This allows flexibility and changing of routine priority
   161                        ;
   162                        ;The main set of vectors occupy the first 16 bytes of Page $03. The ROM handler for
   163                        ; NMI, BRK and IRQ jump to the first 3 vectors. The following 3 vectors are loaded with
   164                        ; returns to the ROM handler for each. The following 2 vectors are the cold and warm
   165                        ; entry points for the Monitor. After the basic initialization, the monitor is entered
   166                        ;
   167                        ;The following vector set allows inserts, pre or post for NMI/BRK/IRQ. There a total of 8 inserts
   168                        ; which occupy 16 bytes. They can be used as required. Currently, all of these are available.
   169                        ;
   170             00000300   NMIVEC0		.EQU	SOFTVEC+0	;NMI Interrupt Vector 0
   171             00000302   BRKVEC0		.EQU	SOFTVEC+2	;BRK Interrupt Vector 0
   172             00000304   IRQVEC0		.EQU	SOFTVEC+4	;INTERRUPT VECTOR 0
   173                        ;
   174             00000306   NMIRTVEC0	.EQU	SOFTVEC+6	;NMI Return Handler 0
   175             00000308   BRKRTVEC0	.EQU	SOFTVEC+8	;BRK Return Handler 0
   176             0000030A   IRQRTVEC0	.EQU	SOFTVEC+10	;IRQ Return Handler 0
   177                        ;
   178             0000030C   CLDMNVEC0	.EQU	SOFTVEC+12	;Cold Monitor Entry Vector 0
   179             0000030E   WRMMNVEC0	.EQU	SOFTVEC+14	;Warm Monitor Entry Vector 0
   180                        ;
   181             00000310   VECINSRT0	.EQU	SOFTVEC+16	;1st Vector Insert
   182             00000312   VECINSRT1	.EQU	SOFTVEC+18	;2nd Vector Insert
   183             00000314   VECINSRT2	.EQU	SOFTVEC+20	;3rd Vector Insert
  Tue Dec  5 2017  6:27                                                                                                    Page 4


   184             00000316   VECINSRT3	.EQU	SOFTVEC+22	;4th Vector Insert
   185             00000318   VECINSRT4	.EQU	SOFTVEC+24	;5th Vector Insert
   186             0000031A   VECINSRT5	.EQU	SOFTVEC+26	;6th Vector Insert
   187             0000031C   VECINSRT6	.EQU	SOFTVEC+28	;7th Vector Insert
   188             0000031E   VECINSRT7	.EQU	SOFTVEC+30	;8th Vector Insert
   189                        ;
   190                        ;******************************************************************************
   191                        ;Search Buffer is 16 bytes in length. Used to hold search string for text or hex data
   192             00000340   SRCHBUFF	.EQU	$340	;Located in Page $03 following HW config data
   193                        ;
   194                        ;Xmodem/CRC Loader also provides Motorola S19 Record sense and load. Designed to handle the S19
   195                        ; records from the WDC Assembler/Linker package. This requires a 44 byte buffer to parse each valid
   196                        ; S1 record, located just before the 132 Byte Xmodem frame buffer. Total Buffer space for the
   197                        ; Xmodem/CRC Loader is 176 bytes
   198                        ;
   199                        ;Valid S-record headers are "S1" and "S9"/ For S1, the maximum length is "19" hex. The last S1 record
   200                        ; can be less. S9 record is always the last record with no data. WDC Linker also appends a CR/LF to
   201                        ; the end of each record for a total 44 bytes.
   202             00000350   SRBUFF		.EQU	$0350	;Start of Motorola S-record buffer, 44 bytes in length
   203                        ;
   204                        ;Xmodem frame buffer. The entire Xmodem frame is buffered here and then checked for proper header and
   205                        ; frame number, CRC-16 on the data, then moved to user RAM.
   206             0000037C   RBUFF			.EQU	$037C	;Xmodem temp 132 byte receive buffer
   207                        ;
   208                        ;Page $03 is completely allocated for Buffers, Config Data and Vector pointers.	Much of this can be
   209                        ; used as temporary buffer space as needed provided the	Monitor functions that required are not
   210                        ; being used concurrently. Additional Xmodem variables, etc. are defined here: 
   211                        ;XMODEM Control Character Constants
   212             00000001   SOH				.EQU	$01	;Start of Block Header
   213             00000004   EOT				.EQU	$04	;End of Text marker
   214             00000006   ACK				.EQU	$06	;Good Block Acknowledge
   215             00000015   NAK				.EQU	$15	;Bad Block acknowledged
   216             00000018   CAN				.EQU	$18	;Cancel character
   217                        ;
   218             0000FFE0   BIOS_MSG	.EQU	$FFE0	;BIOS Message hard-coded here
   219                        ;******************************************************************************
   220             00000000   BURN_BYTE	.EQU	$0000	;Location in RAM for BYTE write routine
   221                        ;******************************************************************************
   222                        ;	The following 32 functions are provided by BIOS and available via the JMP
   223                        ;	$FF00	- $FF33 are Reserved for future expansion
   224                        ;
   225                        ;	$FF36 CHRIN_NW		;(character input from console, no waiting, clear carry if none)
   226                        ;	$FF39 CHRIN				;(character input from console)
   227                        ;	$FF3C CHROUT			;(character output to console)
   228                        ;	$FF3F SET_DLY			;(set delay value for milliseconds and 16-bit counter)
   229                        ;	$FF42 EXE_MSDLY		;(execute millisecond delay 1-256 * 10 milliseconds)
   230                        ;	$FF45 EXE_LGDLY		;(execute long delay; millisecond delay * 16-bit count)
   231                        ;	$FF48 EXE_XLDLY		;(execute extra long delay; 8-bit count * long delay)
   232                        ;	$FF4B INIT_VEC		;(initialize soft vectors at $0300 from ROM)
   233                        ;	$FF4E INIT_CFG		;(initialize soft config values at $0320 from ROM)
   234                        ;	$FF51 INIT_2691		;(initialize SCC2691 console 38.4K, 8-N-1 RTS/CTS)
   235                        ;	$FF54 RESET_2691	;(reset SCC2691) - called before INIT_2691
   236                        ;	$FF57 MONWARM			;(Monitor warm start - jumps to page $03)
   237                        ;	$FF5A MONCOLD			;(Monitor cold start - jumps to page $03)
   238                        ; $FF5D	COLDSTRT		;(System cold start - RESET vector for 65C02)
   239                        ;
   240                        ;******************************************************************************
   241                        ;BIOS JUMP Table starts here:
   242                        ;	- BIOS calls are listed below - total of 32
   243                        ;	- Reserved calls are for future hardware support
   244                        ;
   245             0000FF00   B_Reserve00		.EQU	$FF00	;Call 00
   246             0000FF03   B_Reserve01		.EQU	$FF03	;Call 01
  Tue Dec  5 2017  6:27                                                                                                    Page 5


   247             0000FF06   B_Reserve02		.EQU	$FF06	;Call 02
   248             0000FF09   B_Reserve03		.EQU	$FF09	;Call 03
   249             0000FF0C   B_Reserve04		.EQU	$FF0C	;Call 04
   250             0000FF0F   B_Reserve05		.EQU	$FF0F	;Call 05
   251             0000FF12   B_Reserve06		.EQU	$FF12	;Call 06
   252             0000FF15   B_Reserve07		.EQU	$FF15	;Call 07
   253             0000FF18   B_Reserve08		.EQU	$FF18	;Call 08
   254             0000FF1B   B_Reserve09		.EQU	$FF1B	;Call 09
   255             0000FF1E   B_Reserve10		.EQU	$FF1E	;Call 10
   256             0000FF21   B_Reserve11		.EQU	$FF21	;Call 11
   257             0000FF24   B_Reserve12		.EQU	$FF24	;Call 12
   258             0000FF27   B_Reserve13		.EQU	$FF27	;Call 13
   259             0000FF2A   B_Reserve14		.EQU	$FF2A	;Call 14
   260             0000FF2D   B_Reserve15		.EQU	$FF2D	;Call 15
   261             0000FF30   B_Reserve16		.EQU	$FF30	;Call 16
   262             0000FF33   B_Reserve17		.EQU	$FF33	;Call 17
   263                        ;
   264             0000FF36   B_CHRIN_NW		.EQU	$FF36	;Call 18
   265             0000FF39   B_CHRIN				.EQU	$FF39	;Call 19
   266             0000FF3C   B_CHROUT			.EQU	$FF3C	;Call 20
   267                        ;
   268             0000FF3F   B_SET_DLY			.EQU	$FF3F	;Call 21
   269             0000FF42   B_EXE_MSDLY		.EQU	$FF42	;Call 22
   270             0000FF45   B_EXE_LGDLY		.EQU	$FF45	;Call 23
   271             0000FF48   B_EXE_XLDLY		.EQU	$FF48	;Call 24
   272                        ;
   273             0000FF4B   B_INIT_VEC		.EQU	$FF4B	;Call 25
   274             0000FF4E   B_INIT_CFG		.EQU	$FF4E	;Call 26
   275             0000FF51   B_INIT_2691		.EQU	$FF51	;Call 27
   276             0000FF54   B_RESET_2691	.EQU	$FF54	;Call 28
   277                        ;
   278             0000FF57   B_WRMMNVEC0		.EQU	$FF57	;Call 29
   279             0000FF5A   B_CLDMNVEC0		.EQU	$FF5A	;Call 30
   280             0000FF5D   B_COLDSTRT		.EQU	$FF5D	;Call 31
   281                        ;
   282                        ;******************************************************************************
   283                        					.ORG $E000    ;6KB reserved for monitor $E000 through $F7FF
   284                        ;******************************************************************************
   285                        ;		Monitor JUMP table - 32 JUMP calls are available
   286                        ;
   287 00:E000: 4C 60 E0     M_MONITOR		JMP	MONITOR	;Call 0
   288 00:E003: 4C 65 E0     M_WRM_MON		JMP	WRM_MON	;Call 1
   289 00:E006: 4C 9D E0     M_RESERVE2	JMP	RESERVED	;Call 2
   290 00:E009: 4C 9D E0     M_RESERVE3	JMP	RESERVED	;Call 3
   291 00:E00C: 4C 9D E0     M_RESERVE4	JMP	RESERVED	;Call 4
   292 00:E00F: 4C 9D E0     M_RESERVE5	JMP	RESERVED	;Call 5
   293 00:E012: 4C 9D E0     M_RESERVE6	JMP	RESERVED	;Call 6
   294 00:E015: 4C 9D E0     M_RESERVE7	JMP	RESERVED	;Call 7
   295 00:E018: 4C 9D E0     M_RESERVE8	JMP	RESERVED	;Call 8
   296 00:E01B: 4C 9D E0     M_RESERVE9	JMP	RESERVED	;Call 9
   297 00:E01E: 4C 9D E0     M_RESERVE10	JMP	RESERVED	;Call 10
   298                        ;
   299 00:E021: 4C 6A E5     M_PRSTAT1		JMP	PRSTAT1	;Call 11
   300 00:E024: 4C 14 E6     M_DIS_LINE	JMP	DIS_LINE	;Call 12
   301 00:E027: 4C 57 E1     M_INCINDEX	JMP	INCINDEX	;Call 13
   302 00:E02A: 4C 4E E1     M_DECINDEX	JMP	DECINDEX	;Call 14
   303 00:E02D: 4C CC E1     M_RDLINE		JMP	RDLINE	;Call 15
   304 00:E030: 4C 10 E2     M_RDCHAR		JMP	RDCHAR	;Call 16
   305 00:E033: 4C 06 E1     M_HEXIN2		JMP	HEXIN2	;Call 17
   306 00:E036: 4C F9 E0     M_HEXIN4		JMP	HEXIN4	;Call 18
   307 00:E039: 4C BE E0     M_HEX2ASC		JMP	HEX2ASC	;Call 19
   308 00:E03C: 4C A8 E0     M_BIN2ASC		JMP	BIN2ASC	;Call 20
   309 00:E03F: 4C 8E E0     M_ASC2BIN		JMP	ASC2BIN	;Call 21
  Tue Dec  5 2017  6:27                                                                                                    Page 6


   310 00:E042: 4C 5E E1     M_BEEP			JMP	BEEP	;Call 22
   311 00:E045: 4C 81 E1     M_DOLLAR		JMP	DOLLAR	;Call 23
   312 00:E048: 4C 89 E1     M_CROUT			JMP	CROUT	;Call 24
   313 00:E04B: 4C 7C E1     M_SPC				JMP	SPC	;Call 25
   314 00:E04E: 4C AE E1     M_PRBYTE		JMP	PRBYTE	;Call 26
   315 00:E051: 4C C4 E1     M_PRWORD		JMP	PRWORD	;Call 27
   316 00:E054: 4C A1 E1     M_PRASC			JMP	PRASC	;Call 28
   317 00:E057: 4C 99 E7     M_PROMPT		JMP	PROMPT	;Call 29
   318 00:E05A: 4C 91 E7     M_PROMPTR		JMP	PROMPTR	;Call 30
   319 00:E05D: 4C 1A E2     M_CONTINUE	JMP	CONTINUE	;Call 31
   320                        ;
   321                        ;START OF MONITOR CODE
   322                        ;*******************************************
   323                        ;*  This is the Monitor Cold start vector  *
   324                        ;*******************************************
   325 00:E060: A9 14        MONITOR		LDA	#$14	;Get intro msg / BEEP
   326 00:E062: 20 99 E7     					JSR	PROMPT	;Send to Console
   327                        ;
   328                        ;*******************************************
   329                        ;*           Command input loop            *
   330                        ;*******************************************
   331                        ;*  This in the Monitor Warm start vector  *
   332                        ;*******************************************
   333 00:E065: A2 FF        WRM_MON		LDX	#$FF	;Initialize Stack pointer
   334 00:E067: 9A           					TXS	;Xfer to stack
   335 00:E068: 64 D5        					STZ	CMDFLAG	;Clear Command flag
   336 00:E06A: A9 16        					LDA	#$16	;Get prompt msg
   337 00:E06C: 20 99 E7     					JSR	PROMPT	;Send to terminal
   338                        ;
   339 00:E06F: 20 10 E2     CMON			JSR	RDCHAR	;Wait for keystroke (converts to upper-case)
   340 00:E072: A2 1C        					LDX	#MONTAB-MONCMD-1	;Get command list count
   341 00:E074: DD FC E9     CMD_LP		CMP	MONCMD,X	;Compare to command list
   342 00:E077: D0 0D        					BNE	CMD_DEC	;Check for next command and loop
   343 00:E079: 48           					PHA	;Save keystroke
   344 00:E07A: 8A           					TXA	;Xfer Command index to A reg
   345 00:E07B: 0A           					ASL	A	;Multiply keystroke value by 2
   346 00:E07C: AA           					TAX	;Get monitor command processor address from table MONTAB
   347 00:E07D: 68           					PLA	;Restore keystroke (some commands send keystroke to terminal
                    )
   348 00:E07E: 20 83 E0     					JSR	DOCMD	;Call Monitor command processor as a subroutine
   349 00:E081: 80 E2        					BRA	WRM_MON	;Command processed, branch and wait for next command
   350 00:E083: 7C 19 EA     DOCMD			JMP	(MONTAB,X)	;Execute CMD from Table
   351                        ;
   352 00:E086: CA           CMD_DEC		DEX	;Decrement index count
   353 00:E087: 10 EB        					BPL	CMD_LP	;If more to check, loop back
   354 00:E089: 20 5E E1     					JSR	BEEP	;Beep for error,
   355 00:E08C: 80 E1        					BRA	CMON	;re-enter monitor
   356                        ;
   357                        ;***********************************************
   358                        ;* Basic Subroutines used by multiple routines *
   359                        ;***********************************************
   360                        ;
   361                        ;ASC2BIN subroutine: Convert 2 ASCII HEX digits to a binary (byte) value
   362                        ; Enter: A register = high digit, Y register = low digit
   363                        ; Return: A register = binary value
   364 00:E08E: 20 9E E0     ASC2BIN		JSR	BINARY	;Convert high digit to 4-bit nibble
   365 00:E091: 0A           					ASL	A	;Shift to high nibble
   366 00:E092: 0A           					ASL	A
   367 00:E093: 0A           					ASL	A
   368 00:E094: 0A           					ASL	A
   369 00:E095: 85 D2        					STA	TEMP1	;Store it in temp area
   370 00:E097: 98           					TYA	;Get Low digit
   371 00:E098: 20 9E E0     					JSR	BINARY	;Convert low digit to 4-bit nibble
  Tue Dec  5 2017  6:27                                                                                                    Page 7


   372 00:E09B: 05 D2        					ORA	TEMP1	;OR in the high nibble
   373 00:E09D: 60           RESERVED	RTS	;Return to caller
   374                        ;
   375 00:E09E: 38           BINARY		SEC	;Set carry for subtraction
   376 00:E09F: E9 30        					SBC	#$30	;Subtract $30 from ASCII HEX digit
   377 00:E0A1: C9 0A        					CMP	#$0A	;Check for result < 10     
   378 00:E0A3: 90 02        					BCC	BNOK	;Branch if 0-9
   379 00:E0A5: E9 07        					SBC	#$07	;Else, subtract 7 for A-F
   380 00:E0A7: 60           BNOK			RTS	;Return to caller
   381                        ;
   382                        ;BIN2ASC subroutine: Convert single byte to two ASCII HEX digits
   383                        ; Enter: A register contains byte value to convert
   384                        ; Return: A register = high digit, Y register = low digit
   385 00:E0A8: 48           BIN2ASC		PHA	;Save A Reg on stack
   386 00:E0A9: 29 0F        					AND	#$0F	;Mask off high nibble
   387 00:E0AB: 20 B4 E0     					JSR	ASCII	;Convert nibble to ASCII HEX digit
   388 00:E0AE: A8           					TAY	;Move to Y Reg
   389 00:E0AF: 68           					PLA	;Get character back from stack
   390 00:E0B0: 4A           					LSR	A	;Shift high nibble to lower 4 bits
   391 00:E0B1: 4A           					LSR	A
   392 00:E0B2: 4A           					LSR	A
   393 00:E0B3: 4A           					LSR	A
   394                        ;
   395 00:E0B4: C9 0A        ASCII			CMP	#$0A	;Check for 10 or less
   396 00:E0B6: 90 03        					BCC	ASOK	;Branch if less than 10
   397 00:E0B8: 18           					CLC	;Clear carry for addition
   398 00:E0B9: 69 07        					ADC	#$07	;Add $07 for A-F
   399 00:E0BB: 69 30        ASOK			ADC	#$30	;Add $30 for ASCII
   400 00:E0BD: 60           					RTS	;Return to caller
   401                        ;
   402                        ;HEX2ASC - Accepts 16-bit Hexadecimal value and converts to an ASCII decimal string. Input is via the
   403                        ; A and Y registers and output is up to 5 ASCII digits in DATABUFF. The High Byte is in the Y register
   404                        ; and Low Byte is in the A register. Output data is placed in variable DATABUFF and terminated with a
   405                        ; null character. PROMPTR routine is used to print the ASCII decimal value.
   406                        ; Routine based on Michael Barry's code. Saved many bytes ;-)
   407 00:E0BE: 85 BC        HEX2ASC		STA	BINVALL	;Save Low byte
   408 00:E0C0: 84 BD        					STY	BINVALH	;Save High byte
   409 00:E0C2: A2 05        					LDX	#5	;Get ASCII buffer offset
   410 00:E0C4: 74 B4        					STZ	DATABUFF,X	;Zero last buffer byte for null end
   411                        ;
   412 00:E0C6: A9 00        CNVERT		LDA	#$00	;Clear remainder
   413 00:E0C8: A0 10        					LDY	#16	;Set loop count for 16-bits
   414                        ;
   415 00:E0CA: C9 05        DVLOOP		CMP	#$05	;Partial remainder >= 10/2
   416 00:E0CC: 90 02        					BCC	DVLOOP2	;Branch if less
   417 00:E0CE: E9 05        					SBC	#$05	;Update partial, set carry
   418                        ;
   419 00:E0D0: 26 BC        DVLOOP2		ROL	BINVALL	;Shift carry into dividend
   420 00:E0D2: 26 BD        					ROL	BINVALH	;Which will be quotient
   421 00:E0D4: 2A           					ROL	A	;Rotate A reg
   422 00:E0D5: 88           					DEY	;Decrement count
   423 00:E0D6: D0 F2        					BNE	DVLOOP	;Branch back until done
   424 00:E0D8: 09 30        					ORA	#$30	;Or in bits for ASCII
   425                        ;
   426 00:E0DA: CA           					DEX	;Decrement buffer index
   427 00:E0DB: 95 B4        					STA	DATABUFF,X	;Store value into buffer
   428                        ;
   429 00:E0DD: A5 BC        					LDA	BINVALL	;Get the Low byte
   430 00:E0DF: 05 BD        					ORA	BINVALH	;OR in the High byte (check for zero)
   431 00:E0E1: D0 E3        					BNE	CNVERT	;Branch back until done
   432 00:E0E3: 86 D2        					STX	TEMP1	;Save buffer offset
   433                        ;
   434                        ;Conversion is complete, get the string address, add offset, then call prompt routine and return
  Tue Dec  5 2017  6:27                                                                                                    Page 8


   435                        ; note DATABUFF is fixed location in Page 0, carry flag need not be cleared as result can never
   436                        ; set flag after ADC instruction, Y Reg always zero
   437 00:E0E5: A9 B4        					LDA	#<DATABUFF	;Get Low byte Address
   438 00:E0E7: 65 D2        					ADC	TEMP1	;Add in buffer offset (no leading zeros)
   439 00:E0E9: A0 00        					LDY	#>DATABUFF	;Get High byte address
   440 00:E0EB: 4C 91 E7     					JMP	PROMPTR	;Send to terminal and return
   441                        ;
   442                        ;SETUP subroutine: Request HEX address input from terminal
   443 00:E0EE: 20 3C FF     SETUP			JSR	B_CHROUT	;Send command keystroke to terminal
   444 00:E0F1: 20 7C E1     					JSR	SPC	;Send [SPACE] to terminal
   445 00:E0F4: 80 03        					BRA	HEXIN4	;Request a 0-4 digit HEX address input from terminal
   446                        ;
   447                        ;HEX input subroutines: Request 1 to 4 ASCII HEX digits from terminal, then convert digits into a
   448                        ; binary value. For 1 to 4 digits entered, HEXDATAH and HEXDATAL contain the output.
   449                        ; Variable BUFIDX will contain the number of digits entered
   450                        ; HEXIN2 - returns value in A reg and Y reg only (Y reg always $00)
   451                        ; HEXIN4 - returns values in A reg, Y reg and INDEXL/INDEXH
   452                        ; HEX2 - Prints MSG# in A reg then calls HEXIN2, HEX4 - Prints MSG# in A reg then calls HEXIN4
   453 00:E0F6: 20 99 E7     HEX4			JSR	PROMPT	;Print MSG # from A reg
   454 00:E0F9: A2 04        HEXIN4		LDX	#$04	;Set for number of characters allowed
   455 00:E0FB: 20 08 E1     					JSR	HEXINPUT	;Convert digits
   456 00:E0FE: 84 C1        					STY	INDEXH	;Store to INDEXH
   457 00:E100: 85 C0        					STA	INDEXL	;Store to INDEXL
   458 00:E102: 60           					RTS	;Return to caller
   459                        ;
   460 00:E103: 20 99 E7     HEX2			JSR	PROMPT	;Print MSG # from A reg
   461 00:E106: A2 02        HEXIN2		LDX	#$02	;Set for number of characters allowed
   462                        ;
   463                        ;HEXINPUT subroutine: request 1 to 4 HEX digits from terminal, then convert ASCII HEX to HEX
   464                        ;Setup RDLINE subroutine parameters:
   465 00:E108: 20 81 E1     HEXINPUT	JSR	DOLLAR	;Send "$" to console
   466 00:E10B: 20 CC E1     					JSR	RDLINE	;Request ASCII HEX input from terminal
   467 00:E10E: F0 28        					BEQ	HINEXIT	;Exit if none (Z flag already set)
   468 00:E110: 64 BA        					STZ	HEXDATAH	;Clear Upper HEX byte
   469 00:E112: 64 BB        					STZ	HEXDATAL	;Clear Lower HEX byte
   470 00:E114: A0 02        					LDY	#$02	;Set index for 2 bytes
   471 00:E116: 5A           ASCLOOP		PHY	;Save it to stack
   472 00:E117: B5 AF        					LDA	INBUFF-1,X	;Read ASCII digit from buffer
   473 00:E119: A8           					TAY	;Xfer to Y Reg (LSD)
   474 00:E11A: CA           					DEX	;Decrement input count
   475 00:E11B: F0 04        					BEQ	NO_UPNB	;Branch if no upper nibble
   476 00:E11D: B5 AF        					LDA	INBUFF-1,X	;Read ASCII digit from buffer
   477 00:E11F: 80 02        					BRA	DO_UPNB	;Branch to include upper nibble
   478 00:E121: A9 30        NO_UPNB		LDA	#$30	;Load ASCII "0" (MSD)
   479 00:E123: 20 8E E0     DO_UPNB		JSR	ASC2BIN	;Convert ASCII digits to binary value
   480 00:E126: 7A           					PLY	;Get index from stack
   481 00:E127: 99 B9 00     					STA	HEXDATAH-1,Y	;Write byte to indexed HEX input buffer loca
                    tion
   482 00:E12A: E0 00        					CPX	#$00	;Any more digits?
   483 00:E12C: F0 04        					BEQ	HINDONE	;If not, exit
   484 00:E12E: 88           					DEY	;Else, decrement to next byte set
   485 00:E12F: CA           					DEX	;Decrement index count
   486 00:E130: D0 E4        					BNE	ASCLOOP	;Loop back for next byte
   487 00:E132: A4 BA        HINDONE		LDY	HEXDATAH	;Get High Byte
   488 00:E134: A5 BB        					LDA	HEXDATAL	;Get Low Byte
   489 00:E136: A6 CE        					LDX	BUFIDX	;Get input count (Z flag)
   490 00:E138: 60           HINEXIT		RTS	;And return to caller
   491                        ;
   492                        ;Routines to update pointers for memory operations. UPD_STL subroutine: Increments Source and Target
   493                        ; pointers. UPD_TL subroutine: Increments Target pointers only, then drops into decrement length
   494                        ; pointer. Used by multiple Memory operation commands.
   495 00:E139: E6 C8        UPD_STL		INC	SRCL	;Increment source low byte
   496 00:E13B: D0 02        					BNE	UPD_TL	;Check for rollover
  Tue Dec  5 2017  6:27                                                                                                    Page 9


   497 00:E13D: E6 C9        					INC	SRCH	;Increment source high byte
   498 00:E13F: E6 CA        UPD_TL		INC	TGTL	;Increment target low byte
   499 00:E141: D0 02        					BNE	DECLEN	;Check for rollover
   500 00:E143: E6 CB        					INC	TGTH	;Increment target high byte
   501                        ;
   502                        ;DECLEN subroutine: decrement 16-bit variable LENL/LENH
   503 00:E145: A5 CC        DECLEN		LDA	LENL	;Get length low byte
   504 00:E147: D0 02        					BNE	SKP_LENH	;Test for LENL = zero
   505 00:E149: C6 CD        					DEC	LENH	;Else decrement length high byte
   506 00:E14B: C6 CC        SKP_LENH	DEC	LENL	;Decrement length low byte
   507 00:E14D: 60           					RTS	;Return to caller
   508                        ;
   509                        ;DECINDEX subroutine: decrement 16 bit variable INDEXL/INDEXH
   510 00:E14E: A5 C0        DECINDEX	LDA	INDEXL	;Get index low byte
   511 00:E150: D0 02        					BNE	SKP_IDXH	;Test for INDEXL = zero
   512 00:E152: C6 C1        					DEC	INDEXH	;Decrement index high byte
   513 00:E154: C6 C0        SKP_IDXH	DEC	INDEXL	;Decrement index low byte
   514 00:E156: 60           					RTS	;Return to caller
   515                        ;
   516                        ;INCINDEX subroutine: increment 16 bit variable INDEXL/INDEXH
   517 00:E157: E6 C0        INCINDEX	INC	INDEXL	;Increment index low byte
   518 00:E159: D0 02        					BNE	SKP_IDX	;If not zero, skip high byte
   519 00:E15B: E6 C1        					INC	INDEXH	;Increment index high byte
   520 00:E15D: 60           SKP_IDX		RTS	;Return to caller
   521                        ;
   522                        ;Output routines for formatting, backspace, CR/LF, BEEP, etc. all routines preserve the A reg on exit.
   523                        ;BEEP subroutine: Send ASCII [BELL] to terminal
   524 00:E15E: 48           BEEP			PHA	;Save A reg on Stack
   525 00:E15F: A9 07        					LDA	#$07	;Get ASCII [BELL] to terminal
   526 00:E161: 80 2E        					BRA	SENDIT	;Branch to send
   527                        ;
   528                        ;BSOUT subroutine: send a Backspace to terminal
   529 00:E163: 20 69 E1     BSOUT			JSR	BSOUT2	;Send an ASCII backspace
   530 00:E166: 20 7C E1     					JSR	SPC	;Send space to clear out character
   531 00:E169: 48           BSOUT2		PHA	;Save character in A reg
   532 00:E16A: A9 08        					LDA	#$08	;Send another Backspace to return
   533 00:E16C: 80 23        BRCHOUT		BRA	SENDIT	;Branch to send
   534                        ;
   535 00:E16E: 20 69 E1     BSOUT3T		JSR	BSOUT2	;Send a Backspace 3 times
   536 00:E171: 20 69 E1     BSOUT2T		JSR	BSOUT2	;Send a Backspace 2 times
   537 00:E174: 80 F3        					BRA	BSOUT2	;Send a Backspace and return
   538                        ;
   539                        ;SPC subroutines: Send a Space to terminal 1,2 or 4 times
   540 00:E176: 20 79 E1     SPC4			JSR	SPC2	;Send 4 Spaces to terminal
   541 00:E179: 20 7C E1     SPC2			JSR	SPC	;Send 2 Spaces to terminal
   542 00:E17C: 48           SPC				PHA	;Save character in A reg
   543 00:E17D: A9 20        					LDA	#$20	;Get ASCII Space
   544 00:E17F: 80 10        					BRA	SENDIT	;Branch to send
   545                        ;
   546                        ;DOLLAR subroutine: Send "$" to terminal
   547 00:E181: 48           DOLLAR		PHA	;Save A reg on STACK
   548 00:E182: A9 24        					LDA	#$24	;Get ASCII "$"
   549 00:E184: 80 0B        					BRA	SENDIT	;Branch to send
   550                        ;
   551                        ;Send CR,LF to terminal
   552 00:E186: 20 89 E1     CR2				JSR	CROUT	;Send CR,LF to terminal
   553 00:E189: 48           CROUT			PHA	;Save A reg
   554 00:E18A: A9 0D        					LDA	#$0D	;Get ASCII Return
   555 00:E18C: 20 3C FF     					JSR	B_CHROUT	;Send to terminal
   556 00:E18F: A9 0A        					LDA	#$0A	;Get ASCII Linefeed
   557 00:E191: 20 3C FF     SENDIT		JSR	B_CHROUT	;Send to terminal
   558 00:E194: 68           					PLA	;Restore A reg
   559 00:E195: 60           					RTS	;Return to caller
  Tue Dec  5 2017  6:27                                                                                                    Page 10


   560                        ;
   561                        ;GLINE subroutine: Send a horizontal line to console used by memory display only.
   562 00:E196: A2 4F        GLINE			LDX	#$4F	;Load index for 79 decimal
   563 00:E198: A9 7E        					LDA	#$7E	;Get "~" character
   564 00:E19A: 20 3C FF     GLINEL		JSR	B_CHROUT	;Send to terminal (draw a line)
   565 00:E19D: CA           					DEX	;Decrement count
   566 00:E19E: D0 FA        					BNE	GLINEL	;Branch back until done
   567 00:E1A0: 60           					RTS	;Return to caller
   568                        ;
   569                        ;Routines to output 8/16-bit Binary Data and Ascii characters
   570                        ; PRASC subroutine: Print A-reg as ASCII (Printable ASCII values = $20 - $7E), else print "."
   571 00:E1A1: C9 7F        PRASC			CMP	#$7F	;Check for first 128
   572 00:E1A3: B0 04        					BCS	PERIOD	;If = or higher, branch
   573 00:E1A5: C9 20        					CMP	#$20	;Check for control characters
   574 00:E1A7: B0 02        					BCS	ASCOUT	;If space or higher, branch and print
   575 00:E1A9: A9 2E        PERIOD		LDA	#$2E	;Else, print a "."
   576 00:E1AB: 4C 3C FF     ASCOUT		JMP	B_CHROUT	;Send byte in A-Reg, then return
   577                        ;
   578                        ;PRBYTE subroutine: Converts a single Byte to 2 HEX ASCII characters and sends to console
   579                        ; on entry, A reg contains the Byte to convert/send. Register contents are preserved on entry/exit.
   580 00:E1AE: 48           PRBYTE		PHA	;Save A register
   581 00:E1AF: 5A           					PHY	;Save Y register
   582 00:E1B0: 20 A8 E0     PRBYT2		JSR	BIN2ASC	;Convert A reg to 2 ASCII Hex characters
   583 00:E1B3: 20 3C FF     					JSR	B_CHROUT	;Print high nibble from A reg
   584 00:E1B6: 98           					TYA	;Transfer low nibble to A reg
   585 00:E1B7: 20 3C FF     					JSR	B_CHROUT	;Print low nibble from A reg
   586 00:E1BA: 7A           					PLY	;Restore Y Register
   587 00:E1BB: 68           					PLA	;Restore A Register
   588 00:E1BC: 60           					RTS	;And return to caller
   589                        ;
   590                        ;PRINDEX	subroutine: Prints a $ sign followed by INDEXH/L
   591 00:E1BD: 20 81 E1     PRINDEX		JSR	DOLLAR	;Print a $ sign
   592 00:E1C0: A5 C1        					LDA	INDEXH	;Get Index high byte
   593 00:E1C2: A4 C0        					LDY	INDEXL	;Get Index low byte
   594                        ;
   595                        ;PRWORD	subroutine: Converts a 16-bit word to 4 HEX ASCII characters and sends to console.
   596                        ; On entry, A reg contains High Byte, Y reg contains Low Byte. Register are preserved on entry/exit.
   597 00:E1C4: 48           PRWORD		PHA	;Save A register
   598 00:E1C5: 5A           					PHY	;Save Y register
   599 00:E1C6: 20 AE E1     					JSR	PRBYTE	;Convert and print one HEX character (00-FF)
   600 00:E1C9: 98           					TYA	;Get Low byte value
   601 00:E1CA: 80 E4        					BRA	PRBYT2	;Finish up Low Byte and exit
   602                        ;
   603                        ;RDLINE subroutine: Store keystrokes in buffer until [RETURN] key it struck
   604                        ; Used only for Hex entry, so only (0-9,A-F) are accepted entries. Lower-case alpha characters are
   605                        ; converted to upper-case. On entry, X reg = buffer length. On exit, X reg = buffer count
   606                        ; [BACKSPACE] key removes keystrokes from buffer. [ESCAPE] key aborts then re-enters monitor. 
   607 00:E1CC: 86 CF        RDLINE		STX	BUFLEN	;Store buffer length   
   608 00:E1CE: 64 CE        					STZ	BUFIDX	;Zero buffer index
   609 00:E1D0: 20 10 E2     RDLOOP		JSR	RDCHAR	;Get character from terminal, convert LC2UC
   610 00:E1D3: C9 1B        					CMP	#$1B	;Check for ESC key
   611 00:E1D5: F0 36        					BEQ	RDNULL	;If yes, exit back to Monitor
   612 00:E1D7: C9 0D        NOTESC		CMP	#$0D	;Check for C/R
   613 00:E1D9: F0 2B        					BEQ	EXITRD	;Exit if yes
   614 00:E1DB: C9 08        					CMP	#$08	;Check for Backspace
   615 00:E1DD: F0 1C        					BEQ	RDBKSP	;If yes handle backspace
   616 00:E1DF: C9 30        TSTHEX		CMP	#$30	;Check for '0' or higher
   617 00:E1E1: 90 0A        					BCC	INPERR	;Branch to error if less than '0'
   618 00:E1E3: C9 47        					CMP	#$47	;Check for 'G' ('F'+1)
   619 00:E1E5: B0 06        					BCS	INPERR	;Branch to error if 'G' or higher
   620 00:E1E7: A6 CE        FULTST		LDX	BUFIDX	;Get the current buffer index
   621 00:E1E9: E4 CF        					CPX	BUFLEN	;Compare to length for space
   622 00:E1EB: 90 05        					BCC	STRCHR	;Branch to store in buffer
  Tue Dec  5 2017  6:27                                                                                                    Page 11


   623 00:E1ED: 20 5E E1     INPERR		JSR	BEEP	;Else, error, send Bell to terminal
   624 00:E1F0: 80 DE        					BRA	RDLOOP	;Branch back to RDLOOP
   625 00:E1F2: 95 B0        STRCHR		STA	INBUFF,X	;Store keystroke in buffer
   626 00:E1F4: 20 3C FF     					JSR	B_CHROUT	;Send keystroke to terminal
   627 00:E1F7: E6 CE        					INC	BUFIDX	;Increment buffer index
   628 00:E1F9: 80 D5        					BRA	RDLOOP	;Branch back to RDLOOP
   629 00:E1FB: A5 CE        RDBKSP		LDA	BUFIDX	;Check if buffer is empty
   630 00:E1FD: F0 EE        					BEQ	INPERR	;Branch if yes
   631 00:E1FF: C6 CE        					DEC	BUFIDX	;Else, decrement buffer index
   632 00:E201: 20 63 E1     					JSR	BSOUT	;Send Backspace to terminal
   633 00:E204: 80 CA        					BRA	RDLOOP	;Loop back and continue
   634 00:E206: A6 CE        EXITRD		LDX	BUFIDX	;Get keystroke count (Z flag)
   635 00:E208: D0 0F        					BNE	AOK	;If data entered, normal exit
   636 00:E20A: FF D5 0C     					BBS7	CMDFLAG,AOK	;Branch if CMD flag active
   637 00:E20D: 6C 0E 03     RDNULL		JMP	(WRMMNVEC0)	;Quit to Monitor warm start
   638                        ;
   639                        ;RDCHAR subroutine: Waits for a keystroke to be entered.
   640                        ; if keystroke is a lower-case alphabetical, convert it to upper-case
   641 00:E210: 20 39 FF     RDCHAR		JSR	B_CHRIN	;Request keystroke input from terminal
   642 00:E213: C9 61        					CMP	#$61	;Check for lower case value range
   643 00:E215: 90 02        					BCC	AOK	;Branch if < $61, control code/upper-case/numeric
   644 00:E217: E9 20        					SBC	#$20	;Subtract $20 to convert to upper case
   645 00:E219: 60           AOK				RTS	;Character received, return to caller
   646                        ;
   647                        ;Continue routine: called by commands to confirm execution, when No is confirmed, return address
   648                        ;is removed from stack and the exit goes back to the monitor input loop.
   649                        ;Short version prompts for (Y/N) only.
   650 00:E21A: A9 00        CONTINUE	LDA	#$00	;Get msg "cont? (Y/N)" to terminal
   651 00:E21C: 80 02        					BRA	SH_CONT	;Branch down
   652 00:E21E: A9 01        CONTINUE2	LDA	#$01	;Get short msg "(Y/N)" only
   653 00:E220: 20 99 E7     SH_CONT		JSR	PROMPT	;Send to terminal
   654 00:E223: 20 10 E2     TRY_AGN		JSR	RDCHAR	;Get keystroke from terminal
   655 00:E226: C9 59        					CMP	#$59	;"Y" key?
   656 00:E228: F0 0B        					BEQ	DOCONT	;if yes, continue/exit
   657 00:E22A: C9 4E        					CMP	#$4E	;if "N", quit/exit
   658 00:E22C: F0 05        					BEQ	DONTCNT	;Return if not ESC
   659 00:E22E: 20 5E E1     					JSR	BEEP	;Send Beep to console
   660 00:E231: 80 F0        					BRA	TRY_AGN	;Loop back, try again
   661 00:E233: 68           DONTCNT		PLA	;Else remove return address
   662 00:E234: 68           					PLA	;discard it,
   663 00:E235: 60           DOCONT		RTS	;Return
   664                        ;
   665                        ;******************************
   666                        ;* Monitor command processors *
   667                        ;******************************
   668                        ;
   669                        ;[,] Delay Setup Routine
   670                        ;	This routine gets hex input via the console
   671                        ;	- first is a hex byte ($00-$FF) for the millisecond count
   672                        ;	- second is a hex word ($0000-$FFFF) for the delay multiplier
   673                        ;		these are stored in variables SETIM, DELLO/DELHI
   674 00:E236: A9 17        SET_DELAY	LDA	#$17	;Get millisecond delay message
   675 00:E238: 20 03 E1     					JSR	HEX2	;Use short cut version for print and input
   676 00:E23B: 85 F7        					STA	SETIM	;Else store millisecond count in variable
   677 00:E23D: A9 18        GETMULT		LDA	#$18	;Get Multiplier message
   678 00:E23F: 20 F6 E0     					JSR	HEX4	;Use short cut version for print and input
   679 00:E242: 85 F8        					STA	DELLO	;Store Low byte
   680 00:E244: 84 F9        					STY	DELHI	;Store High byte
   681 00:E246: 60           					RTS	;Return to caller
   682                        ;
   683                        ;[\] Execute XL Delay Get an 8-bit value for extra long delay, execute is entered.
   684 00:E247: A9 19        SET_XLDLY	LDA	#$19	;Get XL Loop message
   685 00:E249: 20 03 E1     					JSR	HEX2	;Use short cut version for print and input
  Tue Dec  5 2017  6:27                                                                                                    Page 12


   686 00:E24C: 85 FA        					STA	XDL	;Save delay value
   687 00:E24E: A9 0D        					LDA	#$0D	;Get ASCII C/R
   688 00:E250: 20 3C FF     					JSR	B_CHROUT	;Send C/R (shows delay has been executed, no
                     L/F)
   689 00:E253: 4C 48 FF     					JMP	B_EXE_XLDLY	;Execute Extra Long delay loop
   690                        ;
   691                        ;[(] INIMACRO command: Initialize keystroke input buffer
   692                        ;initializes buffer head/tail pointers and resets buffer count to zero
   693                        ;input buffer appears empty so command macro starts at the head of the buffer
   694 00:E256: 64 DD        INIMACRO	STZ	LPCNTL	;Zero Loop count low byte
   695 00:E258: 64 DE        					STZ	LPCNTH	;Zero Loop count high byte
   696 00:E25A: 64 DF        					STZ	LPCNTF	;Zero Loop count flag
   697                        ;
   698 00:E25C: A9 26        LP_CNT_FL	LDA	#$26	;Get Loop Count msg
   699 00:E25E: 20 99 E7     					JSR	PROMPT	:send to console
   700 00:E261: A9 01        					LDA	#$01	;Get short msg "(Y/N)" only
   701 00:E263: 20 99 E7     					JSR	PROMPT	;Send to terminal
   702 00:E266: 20 10 E2     					JSR	RDCHAR	;Get keystroke from terminal
   703 00:E269: C9 59        					CMP	#$59	;"Y" key?
   704 00:E26B: F0 09        					BEQ	DOLOOPS	;if yes, set loop flag
   705 00:E26D: C9 4E        					CMP	#$4E	;if "N", quit/exit
   706 00:E26F: F0 07        					BEQ	NOLOOPS	;if no, don't set loop flag
   707 00:E271: 20 5E E1     					JSR	BEEP	;Neither y/n selected, sound bell
   708 00:E274: 80 E6        					BRA	LP_CNT_FL	;Branch back, try again
   709                        ;
   710 00:E276: F7 DF        DOLOOPS		SMB7	LPCNTF	;Set high order bit of Loop flag
   711 00:E278: 64 E7        NOLOOPS		STZ	ICNT	;Zero Input buffer count
   712 00:E27A: 64 E9        					STZ	ITAIL	;Zero Input buffer tail pointer
   713 00:E27C: 64 E8        MACINI		STZ	IHEAD	;Zero Input buffer head pointer
   714 00:E27E: 60           DONEFILL	RTS	;Return to caller
   715                        ;
   716                        ;[)] RUNMACRO command: Run monitor command macro. This will indicate that there are 128 keystrokes
   717                        ; in the keystroke input buffer. The monitor will process these as if they were received from the
   718                        ; terminal (typed-in by the user). Because the last keystroke stored in the keystroke buffer was ")",
   719                        ; this will loop continuously. Use [SEND BREAK] to exit Macro
   720 00:E27F: A9 7F        RUNMACRO	LDA	#$7F	;Set keystroke buffer tail pointer to $7F
   721 00:E281: 85 E9        					STA	ITAIL	;Push tail pointer to end
   722 00:E283: 1A           					INC	A	;Increment to $80 for buffer count (full)
   723 00:E284: 85 E7        					STA	ICNT	;Make count show as full
   724 00:E286: 7F DF 15     					BBR7	LPCNTF,NOLP_CNT	;If Loop flag clear, branch around it
   725 00:E289: E6 DD        					INC	LPCNTL	;Increment loops low byte
   726 00:E28B: D0 02        					BNE	SKP_LPC	;If not zero, skip high byte
   727 00:E28D: E6 DE        					INC	LPCNTH	;Increment loops high byte
   728 00:E28F: A9 27        SKP_LPC		LDA	#$27	;Get Loops msg
   729 00:E291: 20 99 E7     					JSR	PROMPT	;Send to console
   730 00:E294: A5 DD        					LDA	LPCNTL	;Get Loop count low
   731 00:E296: A4 DE        					LDY	LPCNTH	;Get Loop count high
   732 00:E298: 20 BE E0     					JSR	HEX2ASC	;Print Loop count
   733 00:E29B: 20 89 E1     					JSR	CROUT	;Send C/R to console
   734 00:E29E: 80 DC        NOLP_CNT	BRA	MACINI	;Zero Head pointer and exit
   735                        ;
   736                        ;[C] Compare one memory range to another and display any addresses which do not match
   737                        ;[M] Move routine uses this section for parameter input, then branches to MOVER below
   738                        ;[F] Fill routine uses this section for parameter input but requires a fill byte value
   739                        ;[CTRL-P] Program EEPROM uses this section for parameter input and to write the EEPROM
   740                        ;Uses source, target and length input parameters. errors in compare are shown in target space
   741 00:E2A0: A9 05        FM_INPUT	LDA	#$05	;Send "val: " to terminal
   742 00:E2A2: 20 03 E1     					JSR	HEX2	;Use short cut version for print and input
   743 00:E2A5: AA           					TAX	;Xfer fill byte to X reg
   744 00:E2A6: 20 1A E2     					JSR	CONTINUE	;Handle continue prompt
   745                        ;
   746                        ;Memory fill routine: parameter gathered below with Move/Fill, then a jump to here
   747                        ;Xreg contains fill byte value
  Tue Dec  5 2017  6:27                                                                                                    Page 13


   748 00:E2A9: A5 CC        FILL_LP		LDA	LENL	;Get length low byte
   749 00:E2AB: 05 CD        					ORA	LENH	;OR in length high byte
   750 00:E2AD: F0 CF        					BEQ	DONEFILL	;Exit if zero
   751 00:E2AF: 8A           					TXA	;Get fill byte
   752 00:E2B0: 92 CA        					STA	(TGTL)	;Store in target location
   753 00:E2B2: 20 3F E1     					JSR	UPD_TL	;Update Target/Length pointers
   754 00:E2B5: 80 F2        					BRA	FILL_LP	;Loop back until done
   755                        ;
   756                        ;Compare/Move/Fill memory operations enter here, branches as required
   757 00:E2B7: 85 D3        CPMVFL		STA	TEMP2	;Save command character
   758 00:E2B9: 20 3C FF     					JSR	B_CHROUT	;Print command character (C/M/F)
   759 00:E2BC: C9 46        					CMP	#$46	;Check for F - fill memory
   760 00:E2BE: D0 0B        					BNE	PRGE_E	;If not continue normal parameter input
   761 00:E2C0: A9 03        					LDA	#$03	;Get msg " addr:"
   762 00:E2C2: 80 12        					BRA	F_INPUT	;Branch to handle parameter input
   763                        ;
   764                        ;EEPROM wrte operation enters here
   765 00:E2C4: A9 21        PROGEE		LDA	#$21	;Get PRG_EE msg
   766 00:E2C6: 20 99 E7     					JSR	PROMPT	;send to terminal
   767 00:E2C9: 64 D3        					STZ	TEMP2	;Clear (Compare/Fill/Move) / error flag
   768                        ;
   769 00:E2CB: A9 06        PRGE_E		LDA	#$06	;Send " src:" to terminal
   770 00:E2CD: 20 F6 E0     					JSR	HEX4	;Use short cut version for print and input
   771 00:E2D0: 85 C8        					STA	SRCL	;Else, store source address in variable SRCL,SRCH
   772 00:E2D2: 84 C9        					STY	SRCH	;Store high address
   773 00:E2D4: A9 07        					LDA	#$07	;Send " tgt:" to terminal
   774 00:E2D6: 20 F6 E0     F_INPUT		JSR	HEX4	;Use short cut version for print and input
   775 00:E2D9: 85 CA        					STA	TGTL	;Else, store target address in variable TGTL,TGTH
   776 00:E2DB: 84 CB        					STY	TGTH	;Store high address
   777 00:E2DD: A9 04        					LDA	#$04	;Send " len:" to terminal
   778 00:E2DF: 20 F6 E0     					JSR	HEX4	;Use short cut version for print and input
   779 00:E2E2: 85 CC        					STA	LENL	;ELSE, store length address in variable LENL,LENH
   780 00:E2E4: 84 CD        					STY	LENH	;Store high address
   781                        ;
   782                        ; All input parameters for Source, Target and Length entered
   783 00:E2E6: A5 D3        					LDA	TEMP2	;Get Command character
   784 00:E2E8: C9 46        					CMP	#$46	;Check for fill memory
   785 00:E2EA: F0 B4        					BEQ	FM_INPUT	;Handle the remaining input
   786 00:E2EC: C9 43        					CMP	#$43	;Test for Compare
   787 00:E2EE: F0 38        					BEQ	COMPLP	;Branch if yes
   788 00:E2F0: C9 4D        					CMP	#$4D	;Check for Move
   789 00:E2F2: F0 5D        					BEQ	MOVER	;Branch if yes
   790                        ;
   791 00:E2F4: A9 22        PROG_EE		LDA	#$22	;Get warning msg
   792 00:E2F6: 20 99 E7     					JSR	PROMPT	;Send to console
   793 00:E2F9: 20 1E E2     					JSR	CONTINUE2	;Prompt for y/n
   794                        ;
   795                        ;Programming of the EEPROM is now confirmed by user. This routine will copy the core move and test
   796                        ; routine from ROM to RAM, then call COMPLP to write and compare. As I/O can generate interrupts
   797                        ; which point to ROM routines, all interrupts must be disabled during the program sequence.
   798                        ;
   799                        ;Send message to console for writing EEPROM
   800 00:E2FC: A9 23        					LDA	#$23	;Get write message
   801 00:E2FE: 20 99 E7     					JSR	PROMPT	;Send to console
   802 00:E301: A5 EA        OC_LOOP		LDA	OCNT	;Check output buffer count
   803 00:E303: D0 FC        					BNE	OC_LOOP	;Loop back until buffer sent
   804                        ;
   805                        ;Xfer byte write code to RAM for execution
   806 00:E305: A2 15        					LDX	#BYTE_WRE-BYTE_WRS+1	;Get length of byte write code
   807 00:E307: BD 9F E3     BYTE_XFER	LDA	BYTE_WRS-1,X	;Get code
   808 00:E30A: 95 FF        					STA	BURN_BYTE-1,X	;Write code to RAM
   809 00:E30C: CA           					DEX	;Decrement index
   810 00:E30D: D0 F8        					BNE	BYTE_XFER	;Loop back until done
  Tue Dec  5 2017  6:27                                                                                                    Page 14


   811                        ;
   812                        ;Wait for 1/2 second for RAM/ROM access to settle
   813 00:E30F: A9 32        					LDA	#$32	;Set milliseconds to 50(*10 ms)
   814 00:E311: 20 3F FF     					JSR	B_SET_DLY	;Set Delay parameters
   815 00:E314: 20 42 FF     					JSR	B_EXE_MSDLY	;Call delay for 1/2 second
   816                        ;
   817 00:E317: F7 D3        PROG_EEP	SMB7	TEMP2	;Set EEPROM write active mask
   818 00:E319: 20 28 E3     					JSR	COMPLP	;Call routine to write/compare
   819 00:E31C: 6F D3 04     					BBR6	TEMP2,PRG_GOOD	;Skip down if no error
   820 00:E31F: A9 25        					LDA	#$25	;Get Prog failed message
   821 00:E321: 80 02        					BRA	BRA_PRMPT	;Branch to Prompt routine
   822                        ;
   823 00:E323: A9 24        PRG_GOOD	LDA	#$24	;Get completed message
   824 00:E325: 4C 99 E7     BRA_PRMPT	JMP	PROMPT	;Send to console and exit
   825                        ;
   826 00:E328: A5 CC        COMPLP		LDA	LENL	;Get low byte of length
   827 00:E32A: 05 CD        					ORA	LENH	;OR in High byte of length
   828 00:E32C: F0 71        					BEQ	QUITMV	;If zero, nothing to compare/write
   829 00:E32E: 7F D3 03     					BBR7	TEMP2,SKP_BURN	;Skip burn if bit 7 clear
   830 00:E331: 20 00 00     					JSR	BURN_BYTE	;Else Burn a byte to EEPROM
   831 00:E334: B2 C8        SKP_BURN	LDA	(SRCL)	;Else load source
   832 00:E336: D2 CA        					CMP	(TGTL)	;Compare to source
   833 00:E338: F0 12        					BEQ	CMP_OK	;If compare is good, continue
   834                        ;
   835 00:E33A: E7 D3        					SMB6	TEMP2	;Set bit 6 of TEMP2 flag (compare error)
   836 00:E33C: 20 79 E1     					JSR	SPC2	;Send 2 spaces
   837 00:E33F: 20 81 E1     					JSR	DOLLAR	;Print $ sign
   838 00:E342: A5 CB        					LDA	TGTH	;Get high byte of address
   839 00:E344: A4 CA        					LDY	TGTL	;Get Low byte of address
   840 00:E346: 20 C4 E1     					JSR	PRWORD	;Print word
   841 00:E349: 20 7C E1     					JSR	SPC	;Add 1 space for formatting
   842                        ;
   843 00:E34C: 20 39 E1     CMP_OK		JSR	UPD_STL	;Update pointers
   844 00:E34F: 80 D7        					BRA	COMPLP	;Loop back until done
   845                        ;
   846                        ;Parameters for move memory entered and validated, now make decision on which direction to do the
   847                        ; actual move, if overlapping, move from end to start, else from start to end.
   848 00:E351: 20 1A E2     MOVER			JSR	CONTINUE	;Prompt to continue move
   849 00:E354: 38           					SEC	;Set carry flag for subtract
   850 00:E355: A5 CA        					LDA	TGTL	;Get target lo byte
   851 00:E357: E5 C8        					SBC	SRCL	;Subtract source lo byte
   852 00:E359: AA           					TAX	;Move to X reg temporarily
   853 00:E35A: A5 CB        					LDA	TGTH	;Get target hi byte
   854 00:E35C: E5 C9        					SBC	SRCH	;Subtract source hi byte
   855 00:E35E: A8           					TAY	;Move to Y reg temporarily
   856 00:E35F: 8A           					TXA	;Xfer lo byte difference to A reg
   857 00:E360: C5 CC        					CMP	LENL	;Compare to lo byte length
   858 00:E362: 98           					TYA	;Xfer hi byte difference to A reg
   859 00:E363: E5 CD        					SBC	LENH	;Subtract length lo byte
   860 00:E365: 90 0F        					BCC	RIGHT	;If carry is clear, overwrite condition exists
   861                        ;Move memory block first byte to last byte, no overlap condition
   862 00:E367: A5 CC        MVNO_LP		LDA	LENL	;Get length low byte
   863 00:E369: 05 CD        					ORA	LENH	;OR in length high byte
   864 00:E36B: F0 32        					BEQ	QUITMV	;Exit if zero bytes to move
   865 00:E36D: B2 C8        					LDA	(SRCL)	;Load source data
   866 00:E36F: 92 CA        					STA	(TGTL)	;Store as target data
   867 00:E371: 20 39 E1     					JSR	UPD_STL	;Update Source/Target/Length variables
   868 00:E374: 80 F1        					BRA	MVNO_LP	;Branch back until length is zero
   869                        ;
   870                        ;Move memory block last byte to first byte avoids overwrite in source/target overlap
   871 00:E376: A6 CD        RIGHT			LDX	LENH	;Get the length hi byte count
   872 00:E378: 18           					CLC	;Clear carry flag for add
   873 00:E379: 8A           					TXA	;Xfer High page to A reg
  Tue Dec  5 2017  6:27                                                                                                    Page 15


   874 00:E37A: 65 C9        					ADC	SRCH	;Add in source hi byte
   875 00:E37C: 85 C9        					STA	SRCH	;Store in source hi byte
   876 00:E37E: 18           					CLC	;Clear carry for add
   877 00:E37F: 8A           					TXA	;Xfer High page to A reg 
   878 00:E380: 65 CB        					ADC	TGTH	;Add to target hi byte
   879 00:E382: 85 CB        					STA	TGTH	;Store to target hi byte
   880 00:E384: E8           					INX	;Increment high page value for use below in loop
   881 00:E385: A4 CC        					LDY	LENL	;Get length lo byte
   882 00:E387: F0 0E        					BEQ	MVPG	;If zero no partial page to move
   883 00:E389: 88           					DEY	;Else, decrement page byte index
   884 00:E38A: F0 07        					BEQ	MVPAG	;If zero, no pages to move
   885 00:E38C: B1 C8        MVPRT			LDA	(SRCL),Y	;Load source data
   886 00:E38E: 91 CA        					STA	(TGTL),Y	;Store to target data
   887 00:E390: 88           					DEY	;Decrement index
   888 00:E391: D0 F9        					BNE  MVPRT	;Branch back until partial page moved
   889 00:E393: B1 C8        MVPAG			LDA	(SRCL),Y	;Load source data
   890 00:E395: 91 CA        					STA	(TGTL),Y	;Store to target data
   891 00:E397: 88           MVPG			DEY	;Decrement page count
   892 00:E398: C6 C9        					DEC	SRCH	;Decrement source hi page
   893 00:E39A: C6 CB        					DEC	TGTH	;Decrement target hi page
   894 00:E39C: CA           					DEX	;Decrement page count
   895 00:E39D: D0 ED        					BNE	MVPRT	;Loop back until all pages moved
   896 00:E39F: 60           QUITMV		RTS	;Return to caller
   897                        ;
   898 00:E3A0: 78           BYTE_WRS	SEI	;Disable interrupts
   899 00:E3A1: B2 C8        					LDA	(SRCL)	;Get source byte
   900 00:E3A3: 92 CA        					STA	(TGTL)	;Write to target byte
   901 00:E3A5: B2 CA        					LDA	(TGTL)	;Read target byte (EEPROM)
   902 00:E3A7: 29 40        					AND	#%01000000	;Mask off bit 6 - toggle bit
   903 00:E3A9: 85 D4        BYTE_WLP	STA	TEMP3	;Store in Temp location
   904 00:E3AB: B2 CA        					LDA	(TGTL)	;Read target byte again (EEPROM)
   905 00:E3AD: 29 40        					AND	#%01000000	;Mask off bit 6 - toggle bit
   906 00:E3AF: C5 D4        					CMP	TEMP3	;Compare to last read (toggles if write mode)
   907 00:E3B1: D0 F6        					BNE	BYTE_WLP	;Branch back if not done
   908 00:E3B3: 58           					CLI	;Re-enable interrupts
   909 00:E3B4: 60           BYTE_WRE	RTS	;Return to caller
   910                        ;
   911                        ;[D] HEX/TEXT DUMP command:
   912                        ; Display in HEX followed by TEXT the contents of 256 consecutive memory addresses
   913 00:E3B5: F7 D5        MDUMP			SMB7	CMDFLAG	;Set Command flag
   914 00:E3B7: 20 EE E0     					JSR	SETUP	;Request HEX address input from terminal
   915 00:E3BA: D0 08        					BNE	LINED	;Branch if new address entered (Z flag set already)
   916 00:E3BC: A5 C2        					LDA	TEMP1L	;Else, point to next consecutive memory page
   917 00:E3BE: 85 C0        					STA	INDEXL	;address saved during last memory dump
   918 00:E3C0: A5 C3        					LDA	TEMP1H	;xfer high byte of address
   919 00:E3C2: 85 C1        					STA	INDEXH	;save in pointer
   920 00:E3C4: 20 0F E4     LINED			JSR	DMPGR	;Send address offsets to terminal 
   921 00:E3C7: 20 96 E1     					JSR	GLINE	;Send horizontal line to terminal
   922 00:E3CA: 20 89 E1     					JSR	CROUT	;Send CR,LF to terminal
   923 00:E3CD: A2 10        					LDX	#$10	;Set line count for 16 rows
   924 00:E3CF: 20 76 E1     DLINE			JSR	SPC4	;Send 4 Spaces to terminal
   925 00:E3D2: 20 BD E1     					JSR	PRINDEX	;Print INDEX value
   926 00:E3D5: 20 79 E1     					JSR	SPC2	;Send 2 Spaces to terminal
   927 00:E3D8: A0 00        					LDY	#$00	;Initialize line byte counter
   928 00:E3DA: 20 21 E5     GETBYT		JSR	SENGBYT	;Use Search Engine Get Byte (excludes I/O)
   929 00:E3DD: 99 40 03     					STA	SRCHBUFF,Y	:Save in Seach buffer (16 bytes)
   930 00:E3E0: 20 AE E1     					JSR	PRBYTE	;Display byte as a HEX value
   931 00:E3E3: 20 7C E1     					JSR	SPC	;Send Space to terminal
   932 00:E3E6: 20 57 E1     					JSR	INCINDEX	;Increment Index to next byte location
   933 00:E3E9: C8           					INY	;Increment index
   934 00:E3EA: C0 10        					CPY	#$10	;Check for all 16
   935 00:E3EC: D0 EC        					BNE	GETBYT	;loop back until 16 bytes have been displayed
   936 00:E3EE: 20 7C E1     					JSR	SPC	;Send a space
  Tue Dec  5 2017  6:27                                                                                                    Page 16


   937 00:E3F1: A0 00        					LDY	#$00	;Reset index for SRCHBUFF
   938 00:E3F3: B9 40 03     GETBYT2		LDA	SRCHBUFF,Y	Get buffered line (16 bytes)
   939 00:E3F6: 20 A1 E1     					JSR	PRASC	;Print ASCII character
   940 00:E3F9: C8           					INY	:increment index to next byte
   941 00:E3FA: C0 10        					CPY	#$10	;Check for 16 bytes
   942 00:E3FC: D0 F5        					BNE	GETBYT2	;loop back until 16 bytes have been displayed		
                    			
   943 00:E3FE: 20 89 E1     					JSR	CROUT	;else, send CR,LF to terminal
   944 00:E401: A5 C0        					LDA	INDEXL	;Get current index low
   945 00:E403: 85 C2        					STA	TEMP1L	;Save to temp1 low
   946 00:E405: A5 C1        					LDA	INDEXH	;Get current index high
   947 00:E407: 85 C3        					STA	TEMP1H	;Save to temp1 high
   948 00:E409: CA           					DEX	;Decrement line count
   949 00:E40A: D0 C3        					BNE	DLINE	;Branch back until all 16 done
   950 00:E40C: 20 96 E1     					JSR	GLINE	;Send horizontal line to terminal
   951                        ;DMPGR subroutine: Send address offsets to terminal
   952 00:E40F: A9 02        DMPGR			LDA	#$02	;Get msg for "addr:" to terminal
   953 00:E411: 20 99 E7     					JSR	PROMPT	;Send to terminal
   954 00:E414: 20 79 E1     					JSR	SPC2	;Add two additional spaces
   955 00:E417: A2 00        					LDX	#$00	;Zero index count
   956 00:E419: 8A           MDLOOP		TXA	;Send "00" thru "0F", separated by 1 Space, to terminal
   957 00:E41A: 20 AE E1     					JSR	PRBYTE	;Print byte value
   958 00:E41D: 20 7C E1     					JSR	SPC	;Add a space
   959 00:E420: E8           					INX	;Increment the count
   960 00:E421: E0 10        					CPX	#$10	;Check for 16
   961 00:E423: D0 F4        					BNE	MDLOOP	;Loop back until done
   962                        ;	Print the ASCII text header "0123456789ABCDEF"
   963 00:E425: 20 7C E1     					JSR	SPC	;Send a space
   964 00:E428: A2 00        					LDX	#$00	;Zero X reg for "0"
   965 00:E42A: 8A           MTLOOP		TXA	;Xfer to A reg
   966 00:E42B: 20 A8 E0     					JSR	BIN2ASC	;Convert Byte to two ASCII digits
   967 00:E42E: 98           					TYA	;Xfer the low nibble character to A reg
   968 00:E42F: 20 3C FF     					JSR	B_CHROUT	;Send least significant HEX to terminal
   969 00:E432: E8           					INX	;Increment to next HEX character
   970 00:E433: E0 10        					CPX	#$10	;Check for 16
   971 00:E435: D0 F3        					BNE	MTLOOP	:branch back till done
   972 00:E437: 4C 89 E1     					JMP	CROUT	;Do a CR/LF and return
   973                        ;
   974                        ;[E] Examine/Edit command: Display in HEX then change the contents of a specified memory address
   975 00:E43A: 20 EE E0     CHANGE		JSR	SETUP	;Request HEX address input from terminal
   976 00:E43D: 20 79 E1     CHNG_LP		JSR	SPC2	;Send 2 spaces
   977 00:E440: B2 C0        					LDA	(INDEXL)	;Read specified address
   978 00:E442: 20 AE E1     					JSR	PRBYTE	;Display HEX value read
   979 00:E445: 20 6E E1     					JSR	BSOUT3T ;Send 3 Backspaces
   980 00:E448: 20 06 E1     					JSR	HEXIN2	;Get input, result in A reg
   981 00:E44B: 92 C0        					STA	(INDEXL)	;Save entered value at Index pointer
   982 00:E44D: D2 C0        					CMP	(INDEXL)	;Compare to ensure a match
   983 00:E44F: F0 05        					BEQ	CHOK	;Branch if compare is good
   984 00:E451: A9 3F        					LDA	#$3F	;Get "?" for bad compare
   985 00:E453: 20 3C FF     					JSR	B_CHROUT	;Send to terminal
   986 00:E456: 20 57 E1     CHOK			JSR	INCINDEX	;Increment Index
   987 00:E459: 80 E2        					BRA	CHNG_LP	;Loop to continue command
   988                        ;
   989                        ;[G] GO command: Begin executing program code at a specified address. Prompts the user for a start
   990                        ; address, places it in COMLO/COMHI. If no address entered, uses default address at COMLO/COMHI
   991                        ; Loads the A,X,Y,P registers from presets and does a JSR to the routine. Upon return, registers
   992                        ; are saved back to presets for display later. Also saves the stack pointer and status register
   993                        ; upon return. Stack pointer is not changed due to constant IRQ service routines
   994 00:E45B: F7 D5        GO				SMB7	CMDFLAG	;Set Command flag
   995 00:E45D: 20 EE E0     					JSR	SETUP	;Get HEX address (A/Y regs hold 16-bit value)
   996 00:E460: F0 04        					BEQ	EXEC_GO	;If not, setup registers and execute (Z flag set alr
                    eady)
   997 00:E462: 85 BE        					STA	COMLO	;Save entered address to pointer low byte
  Tue Dec  5 2017  6:27                                                                                                    Page 17


   998 00:E464: 84 BF        					STY	COMHI	;Save entered address to pointer hi byte
   999                        ;Preload all 65C02 MPU registers from monitor's preset/result variables
  1000 00:E466: A5 E2        EXEC_GO		LDA	PREG	;Load processor status register preset
  1001 00:E468: 48           					PHA	;Push it to the stack
  1002 00:E469: A5 E6        					LDA	AREG	;Load A-Reg preset
  1003 00:E46B: A6 E5        					LDX	XREG	;Load X-Reg preset
  1004 00:E46D: A4 E4        					LDY	YREG	;Load Y-Reg preset
  1005 00:E46F: 28           					PLP	;Pull the processor status register
  1006                        ;Call user program code as a subroutine
  1007 00:E470: 20 82 E4     					JSR	DOCOM	;Execute code at specified address
  1008                        ;Store all 65C02 MPU registers to monitor's preset/result variables: store results
  1009 00:E473: 08           					PHP	;Save the processor status register to the stack
  1010 00:E474: 85 E6        					STA	AREG	;Store A-Reg result
  1011 00:E476: 86 E5        					STX	XREG	;Store X-Reg result
  1012 00:E478: 84 E4        					STY	YREG	;Store Y-Reg result
  1013 00:E47A: 68           					PLA	;Get the processor status register
  1014 00:E47B: 85 E2        					STA	PREG	;Store the result
  1015 00:E47D: BA           					TSX	;Xfer stack pointer to X-reg
  1016 00:E47E: 86 E3        					STX	SREG	;Store the result
  1017 00:E480: D8           					CLD	;Clear BCD mode in case of sloppy user code ;-)
  1018 00:E481: 60           TXT_EXT		RTS	;Return to caller
  1019 00:E482: 6C BE 00     DOCOM			JMP	(COMLO)	;Execute the command
  1020                        ;
  1021                        ;[T] LOCATE TEXT STRING command: search memory for an entered text string
  1022                        ;Memory range scanned is $0800 through $FFFF (specified in SENGINE subroutine)
  1023                        ;SRCHTXT subroutine: request 1 - 16 character text string from terminal, followed by Return
  1024                        ;[ESCAPE] aborts, [BACKSPACE] erases last keystroke. String will be stored in SRCHBUFF
  1025 00:E485: A9 08        SRCHTXT		LDA	#$08	;Get msg " find text:"
  1026 00:E487: 20 99 E7     					JSR	PROMPT	;Send to terminal
  1027 00:E48A: A2 00        					LDX	#$00	;Initialize index/byte counter
  1028 00:E48C: 20 39 FF     STLOOP		JSR	B_CHRIN	;Get input from terminal
  1029 00:E48F: C9 0D        					CMP	#$0D	;Check for C/R
  1030 00:E491: F0 3B        					BEQ	SRCHRDY	;Branch to search engine
  1031 00:E493: C9 1B        					CMP	#$1B	;Check for ESC
  1032 00:E495: F0 EA        					BEQ	TXT_EXT	;Exit to borrowed RTS
  1033 00:E497: C9 08        					CMP	#$08	;Check for B/S
  1034 00:E499: D0 09        					BNE	STBRA	;If not, store character into buffer
  1035 00:E49B: 8A           					TXA	;Xfer count to A reg
  1036 00:E49C: F0 EE        					BEQ	STLOOP	;Branch to input if zero
  1037 00:E49E: 20 63 E1     					JSR	BSOUT	;Else, send B/S to terminal
  1038 00:E4A1: CA           					DEX	;Decrement index/byte counter
  1039 00:E4A2: 80 E8        					BRA	STLOOP	;Branch back and continue
  1040 00:E4A4: 9D 40 03     STBRA			STA	SRCHBUFF,X	;Store character in buffer location
  1041 00:E4A7: 20 3C FF     					JSR	B_CHROUT	;Send character to terminal
  1042 00:E4AA: E8           					INX	;Increment counter
  1043 00:E4AB: E0 10        					CPX	#$10	;Check count for 16
  1044 00:E4AD: D0 DD        					BNE	STLOOP	;Loop back for another character
  1045 00:E4AF: 80 1D        					BRA	SRCHRDY	;Branch to search engine
  1046                        ;
  1047                        ;[H] LOCATE BYTE STRING command: Search memory for an entered byte string. Memory range scanned
  1048                        ; is $0400 through $FFFF. SRCHBYT subroutine: request 0 - 16 byte string from terminal, each byte
  1049                        ; followed by [RETURN]. [ESCAPE] aborts. HEX data will be stored in SRCHBUFF
  1050 00:E4B1: F7 D5        SRCHBYT		SMB7	CMDFLAG	;Set Command flag
  1051 00:E4B3: A9 09        					LDA	#$09	;Get msg " find bin:"
  1052 00:E4B5: 20 99 E7     					JSR	PROMPT	;Send to terminal
  1053 00:E4B8: A2 00        					LDX	#$00	;Initialize index
  1054 00:E4BA: DA           SBLOOP		PHX	;Save index on stack
  1055 00:E4BB: 20 06 E1     					JSR	HEXIN2	;Request HEX byte
  1056 00:E4BE: 20 7C E1     					JSR	SPC	;Send space to terminal
  1057 00:E4C1: FA           					PLX	;Restore index from stack
  1058 00:E4C2: A4 CE        					LDY	BUFIDX	;Get # of characters entered 
  1059 00:E4C4: F0 08        					BEQ	SRCHRDY ;Branch if no characters
  1060 00:E4C6: 9D 40 03     					STA	SRCHBUFF,X ;Else, store in buffer
  Tue Dec  5 2017  6:27                                                                                                    Page 18


  1061 00:E4C9: E8           					INX	;Increment index
  1062 00:E4CA: E0 10        					CPX	#$10	;Check for 16 (max)
  1063 00:E4CC: D0 EC        					BNE	SBLOOP	;Loop back until done/full
  1064 00:E4CE: 86 D0        SRCHRDY		STX	IDX	;Save input character count
  1065 00:E4D0: E0 00        					CPX	#$00	;Check buffer count
  1066 00:E4D2: F0 AD        					BEQ	TXT_EXT	;Exit if no bytes in buffer
  1067 00:E4D4: A9 0C        					LDA	#$0C	;Else, get msg "Searching.."
  1068 00:E4D6: 20 99 E7     					JSR	PROMPT	;Send to terminal
  1069                        ;
  1070                        ;SENGINE subroutine: Scan memory range $0400 through $FFFF for exact match to string contained in
  1071                        ; buffer SRCHBUFF (1 to 16 bytes/characters). Display address of first byte/character of each match
  1072                        ; found until the end of memory is reached.
  1073 00:E4D9: A9 04        SENGINE		LDA	#$04	;Initialize address to $0400: skip over $0000 through $03FF
  1074 00:E4DB: 85 C1        					STA	INDEXH	;Store high byte
  1075 00:E4DD: 64 C0        					STZ	INDEXL ;Zero low byte
  1076 00:E4DF: A2 00        SENGBR2		LDX	#$00	;Initialize buffer index
  1077 00:E4E1: 20 21 E5     SENGBR3		JSR	SENGBYT	;Get the next byte from Index pointer
  1078 00:E4E4: DD 40 03     					CMP	SRCHBUFF,X	;Compare to search buffer
  1079 00:E4E7: F0 05        					BEQ	SENGBR1	;Branch for a match
  1080 00:E4E9: 20 33 E5     					JSR	SINCPTR	;Increment pointer, test for end of memory
  1081 00:E4EC: 80 F1        					BRA	SENGBR2	;Loop back to continue
  1082 00:E4EE: 20 33 E5     SENGBR1		JSR	SINCPTR	;Increment pointer, test for end of memory
  1083 00:E4F1: E8           					INX	;Increment buffer index
  1084 00:E4F2: E4 D0        					CPX	IDX	;Compare buffer index to address index
  1085 00:E4F4: D0 EB        					BNE	SENGBR3	;Loop back until done
  1086 00:E4F6: 38           					SEC	;Subtract buffer index from memory pointer; Set carry
  1087 00:E4F7: A5 C0        					LDA	INDEXL	;Get current address for match lo byte
  1088 00:E4F9: E5 D0        					SBC	IDX	;Subtract from buffer index
  1089 00:E4FB: 85 C0        					STA	INDEXL	;Save it back to lo address pointer
  1090 00:E4FD: A5 C1        					LDA	INDEXH	;Get current address for match hi byte
  1091 00:E4FF: E9 00        					SBC	#$00	;Subtract carry flag
  1092 00:E501: 85 C1        					STA	INDEXH	;Save it back to hi address pointer
  1093 00:E503: A9 0B        					LDA	#$0B	;Get msg "found"
  1094 00:E505: 20 99 E7     					JSR	PROMPT	;Send to terminal
  1095 00:E508: A9 3A        					LDA	#':'	;Get Ascii colon
  1096 00:E50A: 20 3C FF     					JSR	B_CHROUT	;Send to console
  1097 00:E50D: 20 BD E1     					JSR	PRINDEX	;Print Index address
  1098 00:E510: A9 0D        					LDA	#$0D	;Get msg "(n)ext? "
  1099 00:E512: 20 99 E7     					JSR	PROMPT	;Send to terminal
  1100 00:E515: 20 10 E2     					JSR	RDCHAR	;Get input from terminal
  1101 00:E518: C9 4E        					CMP	#$4E	;Check for "(n)ext"
  1102 00:E51A: D0 4A        					BNE	NCAREG	;Exit if not requesting next
  1103 00:E51C: 20 33 E5     					JSR	SINCPTR	;Increment address pointer, test for end of memory
  1104 00:E51F: 80 BE        					BRA	SENGBR2	;Branch back and continue till done
  1105                        ;
  1106                        ;Search Engine GetByte routine: This routine gets the byte value from the current Index pointer
  1107                        ; location. It also checks the Index location FIRST. The I/O page is excluded from the actual data
  1108                        ; search to prevent corrupting any I/O devices which are sensitive to any READ operations outside of
  1109                        ; the BIOS which supports it. An example is the NXP UART family, of which the SCC2691 is used here.
  1110                        ; Current I/O Page Range is $FE00 - $FE9F
  1111                        ; NOTE: $FEA0 - $FEFF used for vector/config data - allows searching here
  1112 00:E521: A5 C1        SENGBYT		LDA	INDEXH	;Get High byte address for current Index
  1113 00:E523: C9 FE        					CMP	#$FE	;Check for Base I/O page
  1114 00:E525: F0 03        					BEQ	CHK_UPR	;If yes, check for I/O range
  1115 00:E527: B2 C0        SENRTBYT	LDA	(INDEXL)	;Else Get byte from current pointer
  1116 00:E529: 60           					RTS	;Return to caller
  1117 00:E52A: A5 C0        CHK_UPR		LDA	INDEXL	;Get Low byte address for current Index
  1118 00:E52C: C9 A0        					CMP	#$A0	;Check for end of I/O addresses
  1119 00:E52E: B0 F7        					BCS	SENRTBYT	;Return actual data if range is $FEA0 or hig
                    her
  1120 00:E530: A9 FE        					LDA	#$FE	;Get $FE as seed byte instead of I/O device read
  1121 00:E532: 60           					RTS	;Return to caller
  1122                        ;				
  Tue Dec  5 2017  6:27                                                                                                    Page 19


  1123                        ;Increment memory address pointer. If pointer high byte = 00 (end of searchable ROM memory),
  1124                        ;send "not found" to terminal then return to monitor 
  1125 00:E533: 20 57 E1     SINCPTR		JSR	INCINDEX	;Increment Index pointer
  1126 00:E536: A5 C1        					LDA	INDEXH	;Check for wrap to $0000
  1127 00:E538: D0 2C        					BNE	NCAREG	;If not, return
  1128 00:E53A: 68           					PLA	;Else, Pull return address from stack
  1129 00:E53B: 68           					PLA	;and exit with msg
  1130 00:E53C: A9 0A        					LDA	#$0A	;Get msg "not found"
  1131 00:E53E: 4C 99 E7     					JMP	PROMPT	;Send msg to terminal and exit
  1132                        ;
  1133                        ;[P] Processor Status command: Display then change PS preset/result
  1134 00:E541: A9 0E        PRG				LDA	#$0E	;Get MSG # for Processor Status register
  1135 00:E543: 80 0E        					BRA	REG_UPT	;Finish register update
  1136                        ;
  1137                        ;[S] Stack Pointer command: Display then change SP preset/result
  1138 00:E545: A9 0F        SRG				LDA	#$0F	;Get MSG # for Stack register
  1139 00:E547: 80 0A        					BRA	REG_UPT	;Finish Register update
  1140                        ;
  1141                        ;[Y] Y-Register command: Display then change Y-reg preset/result
  1142 00:E549: A9 10        YRG				LDA	#$10	;Get MSG # for Y Reg
  1143 00:E54B: 80 06        					BRA	REG_UPT	;Finish register update
  1144                        ;
  1145                        ;[X] X-Register command: Display then change X-reg preset/result
  1146 00:E54D: A9 11        XRG				LDA	#$11	;Get MSG # for X Reg
  1147 00:E54F: 80 02        					BRA	REG_UPT	;Finish register update
  1148                        ;
  1149                        ;[A] A-Register command: Display then change A-reg preset/result
  1150 00:E551: A9 12        ARG				LDA	#$12	;Get MSG # for A reg
  1151                        ;
  1152 00:E553: 48           REG_UPT		PHA	;Save MSG # to stack
  1153 00:E554: AA           					TAX	;Xfer to X reg
  1154 00:E555: 20 99 E7     					JSR	PROMPT	;Print Register message
  1155 00:E558: B5 D4        					LDA	PREG-$0E,X	;Read Register (A,X,Y,S,P) preset/result
  1156 00:E55A: 20 AE E1     					JSR	PRBYTE	;Display HEX value of register
  1157 00:E55D: 20 7C E1     					JSR	SPC	;Send [SPACE] to terminal
  1158 00:E560: 20 06 E1     					JSR	HEXIN2	;Get up to 2 HEX characters
  1159 00:E563: FA           					PLX	;Get MSG # from stack
  1160 00:E564: 95 D4        					STA	PREG-$0E,X	;Write register (A,X,Y,S,P) preset/result
  1161 00:E566: 60           NCAREG		RTS	;Return to caller
  1162                        ;
  1163                        ;[R] REGISTERS command: Display contents of all preset/result memory locations
  1164 00:E567: 20 3C FF     PRSTAT		JSR	B_CHROUT	;Send "R" to terminal
  1165 00:E56A: A9 13        PRSTAT1		LDA	#$13	;Get Header msg
  1166 00:E56C: 20 99 E7     					JSR	PROMPT	;Send to terminal
  1167 00:E56F: A5 E1        					LDA	PCH	;Get PC high byte
  1168 00:E571: A4 E0        					LDY	PCL	;Get PC low byte
  1169 00:E573: 20 C4 E1     					JSR	PRWORD	;Print 16-bit word
  1170 00:E576: 20 7C E1     					JSR	SPC	;Send 1 space
  1171                        ;
  1172 00:E579: A2 04        					LDX	#$04	;Set for count of 4
  1173 00:E57B: B5 E2        REGPLOOP	LDA	PREG,X	;Start with A reg variable
  1174 00:E57D: 20 AE E1     					JSR	PRBYTE	;Print it
  1175 00:E580: 20 7C E1     					JSR	SPC	;Send 1 space
  1176 00:E583: CA           					DEX	;Decrement count
  1177 00:E584: D0 F5        					BNE	REGPLOOP	;Loop back till all 4 are sent
  1178                        ;
  1179 00:E586: A5 E2        					LDA	PREG	;Get Status register preset
  1180 00:E588: A2 08        					LDX	#$08	;Get the index count for 8 bits
  1181 00:E58A: 0A           SREG_LP		ASL	A	;Shift bit into Carry
  1182 00:E58B: 48           					PHA	;Save current (shifted) SR value
  1183 00:E58C: A9 30        					LDA	#$30	;Load an Ascii zero
  1184 00:E58E: 69 00        					ADC	#$00	;Add zero (with Carry)
  1185 00:E590: 20 3C FF     					JSR	B_CHROUT	;Print bit value (0 or 1)
  Tue Dec  5 2017  6:27                                                                                                    Page 20


  1186 00:E593: 68           					PLA	;Get current (shifted) SR value
  1187 00:E594: CA           					DEX	;Decrement bit count
  1188 00:E595: D0 F3        					BNE	SREG_LP	;Loop back until all 8 printed
  1189 00:E597: 4C 89 E1     					JMP	CROUT	;Send CR/LF and return
  1190                        ;
  1191                        ;[I] command: TEXT ENTRY enter ASCII text beginning at a specified address
  1192 00:E59A: 20 EE E0     TEXT			JSR	SETUP	;Send "I" command, handle setup
  1193 00:E59D: 20 89 E1     EDJMP1		JSR	CROUT	;Send CR,LF to terminal
  1194 00:E5A0: 85 C4        					STA	TEMP2L	;Save current edit address
  1195 00:E5A2: 84 C5        					STY	TEMP2H	;Save high byte
  1196 00:E5A4: 20 39 FF     EDJMP2		JSR	B_CHRIN	;Request a keystroke from terminal
  1197 00:E5A7: C9 1B        					CMP	#$1B	;Check for end text entry
  1198 00:E5A9: F0 3C        					BEQ	EDITDUN	;Branch and close out if yes
  1199 00:E5AB: C9 0D        					CMP	#$0D	;Else, check for Return key
  1200 00:E5AD: D0 12        					BNE	ENOTRET	;Branch if not
  1201 00:E5AF: 92 C0        					STA	(INDEXL)	;Save CR to current Index pointer
  1202 00:E5B1: 20 57 E1     					JSR	INCINDEX	;Increment edit memory address pointer
  1203 00:E5B4: A9 0A        					LDA	#$0A	;Get a LF character
  1204 00:E5B6: 92 C0        					STA	(INDEXL)	;Store it in memory
  1205 00:E5B8: 20 57 E1     					JSR	INCINDEX	;Increment edit memory address pointer
  1206 00:E5BB: A5 C0        					LDA	INDEXL	;Get Start of next line
  1207 00:E5BD: A4 C1        					LDY	INDEXH	;and the high byte
  1208 00:E5BF: 80 DC        					BRA	EDJMP1	;Loop back to continue 
  1209 00:E5C1: C9 08        ENOTRET		CMP	#$08	;Check for backspace character
  1210 00:E5C3: F0 0A        					BEQ	EDBKSPC	;Branch if yes
  1211 00:E5C5: 92 C0        					STA	(INDEXL)	;Else, save to current Index pointer
  1212 00:E5C7: 20 3C FF     					JSR	B_CHROUT	;Send keystroke to terminal
  1213 00:E5CA: 20 57 E1     					JSR	INCINDEX	;Increment edit memory address pointer
  1214 00:E5CD: 80 D5        					BRA	EDJMP2	;Loop back to EDJMP2
  1215                        ;Handle Backspace, don't allow past starting address
  1216 00:E5CF: A5 C0        EDBKSPC		LDA	INDEXL	;Get current index low byte
  1217 00:E5D1: C5 C4        					CMP	TEMP2L	;Compare to initial start address
  1218 00:E5D3: D0 06        					BNE	EDDOBKS	;if not equal, perform backspace
  1219 00:E5D5: A5 C1        					LDA	INDEXH	;Get current index high byte
  1220 00:E5D7: C5 C5        					CMP	TEMP2H	;Compare to initial start address
  1221 00:E5D9: F0 C9        					BEQ	EDJMP2	;If same, branch to input loop
  1222 00:E5DB: 20 63 E1     EDDOBKS		JSR	BSOUT	;Send backspace to terminal
  1223 00:E5DE: 20 4E E1     					JSR	DECINDEX	;Decrement edit memory address pointer
  1224 00:E5E1: A9 00        					LDA	#$00	;Get a null character
  1225 00:E5E3: 92 C0        					STA	(INDEXL)	;Store in place of character
  1226 00:E5E5: 80 BD        					BRA	EDJMP2	;LOOP back to EDJMP2
  1227 00:E5E7: 20 86 E1     EDITDUN		JSR	CR2	;Send 2 CR,LF to terminal
  1228 00:E5EA: 4C BD E1     					JMP	PRINDEX	;Print INDEX value
  1229                        ;
  1230                        ;[CTRL-D]	Disassembler: Table-Driven Disassembler. Supports ALL W65C02 Opcodes and Address modes.
  1231 00:E5ED: A9 2C        DSSMBLR		LDA	#$2C	;Intro Message
  1232 00:E5EF: 20 99 E7     					JSR	PROMPT	;Send to terminal
  1233 00:E5F2: A9 03        					LDA	#$03	;Msg 03 -" addr:"
  1234 00:E5F4: 20 F6 E0     					JSR	HEX4	;Print msg and get address
  1235 00:E5F7: 20 89 E1     					JSR	CROUT	;Send CR,LF to terminal
  1236 00:E5FA: A2 16        RPT_LST		LDX	#$16	;Set list count to 22
  1237 00:E5FC: DA           DIS_LOOP	PHX	;Push count to stack
  1238 00:E5FD: 20 14 E6     					JSR	DIS_LINE	;Disassemble 1 instruction
  1239 00:E600: FA           					PLX	;Pull count from stack
  1240 00:E601: CA           					DEX	;Decrement count
  1241 00:E602: D0 F8        					BNE	DIS_LOOP	;Loop back till list count is zero
  1242 00:E604: 20 39 FF     LST_LOOP	JSR	B_CHRIN	;Get input from terminal
  1243 00:E607: C9 0D        					CMP	#$0D	;Check for Return key
  1244 00:E609: F0 32        					BEQ	EXT_LIST	;Exit if Return
  1245 00:E60B: C9 20        					CMP	#$20	;Check for Space
  1246 00:E60D: D0 EB        					BNE	RPT_LST	;If not, go back and list another page
  1247 00:E60F: 20 14 E6     					JSR	DIS_LINE	;Else, Disassemble one line
  1248 00:E612: 80 F0        					BRA	LST_LOOP	;Branch back and continue
  Tue Dec  5 2017  6:27                                                                                                    Page 21


  1249                        ;
  1250                        ;DISASSEMBLE LINE: disassemble 1 instruction from working address
  1251 00:E614: 20 BD E1     DIS_LINE	JSR	PRINDEX	;Print working address
  1252 00:E617: 20 79 E1     					JSR	SPC2	;Send 2 spaces to terminal
  1253 00:E61A: B2 C0        					LDA	(INDEXL)	;Read opcode from working memory pointer
  1254 00:E61C: 85 D6        					STA	OPXMDM	;Save opcode
  1255 00:E61E: 20 85 E6     					JSR	PRB_SPC2	;Print byte, 2 spaces
  1256 00:E621: 4A           					LSR	A	;Divide by 2 / shift low order bit into carry flag
  1257 00:E622: AA           					TAX	;Xfer Opcode /2 to X reg
  1258 00:E623: BD 7A EE     					LDA	HDLR_IDX,X	;Get Pointer to handler table
  1259 00:E626: B0 04        					BCS	USE_RGHT	;If carry set use low nibble (odd)
  1260 00:E628: 4A           					LSR	A	;Else shift upper nibble to lower nibble (even)
  1261 00:E629: 4A           					LSR	A
  1262 00:E62A: 4A           					LSR	A
  1263 00:E62B: 4A           					LSR	A
  1264 00:E62C: 29 0F        USE_RGHT	AND	#$0F	;Mask off high nibble
  1265 00:E62E: 0A           					ASL	A	;Multiply by 2 for index
  1266 00:E62F: AA           					TAX	;Use handler pointer to index handler table
  1267 00:E630: 20 3E E6     					JSR	DODISL	;Call disassembler handler 
  1268 00:E633: 20 89 E1     					JSR	CROUT	;Send CR,LF to terminal
  1269 00:E636: 64 D3        					STZ	TEMP2	;Clear all flag bits
  1270                        ;
  1271                        ;INCNDX routine: increment working address pointer then read it
  1272 00:E638: 20 57 E1     INCNDX		JSR	INCINDEX	;Increment working address pointer
  1273 00:E63B: B2 C0        					LDA	(INDEXL)	;Read from working memory address
  1274 00:E63D: 60           EXT_LIST	RTS	;Done, return to caller/exit
  1275                        ;
  1276 00:E63E: 7C FA EE     DODISL		JMP	(HDLR_TAB,X)	;Execute address mode handler
  1277                        ;
  1278                        ;THREE BYTE routine: display operand bytes then mnemonic for three-byte instruction
  1279                        ; TWO BYTE routine: display operand byte then mnemonic for two-byte instruction
  1280 00:E641: F7 D3        TRI_BYTE	SMB7	TEMP2	;Set Flag bit for 3-byte instruction
  1281 00:E643: 20 82 E6     TWO_BYTE	JSR	GET_NEXT	;Read, display operand byte
  1282 00:E646: 85 D8        					STA	CRCLO	;Save operand byte in CRCLO
  1283 00:E648: 7F D3 0A     					BBR7	TEMP2,2BYTSPC	;Branch for 2-byte is clear
  1284 00:E64B: 20 82 E6     					JSR	GET_NEXT	;Read, display operand high byte
  1285 00:E64E: 85 D7        					STA	CRCHI	;Save operand high byte in CRCHI
  1286 00:E650: 80 06        					BRA	3BYTSPC	;Send 2 spaces, send Mnemonic, return
  1287                        ;
  1288                        ;IMPLIED disassembler handler: single byte instructions: implied mode
  1289                        ; (note: ACC_MODE handler calls this)   
  1290 00:E652: 20 76 E1     IMPLIED		JSR	SPC4	;Send 4 spaces
  1291 00:E655: 20 76 E1     2BYTSPC		JSR	SPC4	;Send 4 spaces
  1292 00:E658: 20 79 E1     3BYTSPC		JSR	SPC2	;Send 2 spaces
  1293                        ;
  1294                        ;PRT_MNEM subroutine: send 3 character mnemonic to terminal
  1295                        ; Mnemonic indexed by opcode byte. Sends "???" if byte is not a valid opcode
  1296 00:E65B: A4 D6        PRT_MNEM	LDY	OPXMDM	;Get current Opcode as index
  1297 00:E65D: BE 1A EF     					LDX	MNE_PTAB,Y	;Get opcode pointer from table
  1298 00:E660: BD 1A F0     					LDA	DIS_NMEM,X	;Get left byte
  1299 00:E663: 85 DA        					STA	PTRL	;Store it to pointer
  1300 00:E665: BD 1B F0     					LDA	DIS_NMEM+1,X	;Get right byte
  1301 00:E668: 85 DB        					STA	PTRH	;Store it to pointer
  1302 00:E66A: A2 03        					LDX	#$03	;Set count for 3 characters
  1303 00:E66C: A9 00        NEXT_NME	LDA	#$00	;Zero A reg
  1304 00:E66E: A0 05        					LDY	#$05	;Set count for 5 bits per character
  1305 00:E670: 06 DB        LOOP_NME	ASL	PTRH	;Shift right byte into carry
  1306 00:E672: 26 DA        					ROL	PTRL	;Rotate left byte byte into A reg
  1307 00:E674: 2A           					ROL	A	;Rotate into A reg
  1308 00:E675: 88           					DEY	;Decrement bit count
  1309 00:E676: D0 F8        					BNE	LOOP_NME	;Loop back till 5 bits in A reg
  1310 00:E678: 69 3F        					ADC	#$3F	;Add $3F to convert to Ascii
  1311 00:E67A: 20 3C FF     					JSR	B_CHROUT	;Send the character to terminal
  Tue Dec  5 2017  6:27                                                                                                    Page 22


  1312 00:E67D: CA           					DEX	;Decrement character count
  1313 00:E67E: D0 EC        					BNE	NEXT_NME	;Loop back till 3 characters sent
  1314 00:E680: 80 06        					BRA	BR_SPC2	;Send 2 spaces to terminal, return
  1315                        ;
  1316                        ;GET_NEXT subroutine: increment/read working address
  1317                        ; Display byte, send 2 spaces to terminal (displays operand byte(s))
  1318 00:E682: 20 38 E6     GET_NEXT	JSR	INCNDX	;Increment working index
  1319 00:E685: 20 AE E1     PRB_SPC2	JSR	PRBYTE	;Display Byte from working index
  1320 00:E688: 4C 79 E1     BR_SPC2		JMP	SPC2	;Send 2 spaces to terminal and return
  1321                        ;
  1322                        ;Disassembler handlers:
  1323                        ;
  1324                        ;LF_BRKT subroutine: send "(" to terminal
  1325 00:E68B: A9 28        LF_BRKT		LDA	#$28	;Get "("
  1326 00:E68D: 80 0F        					BRA	BR_COUT	;Send to terminal and return
  1327                        ;
  1328                        ;ZP_IMMEDIATE: two byte instructions: zero-page immediate mode
  1329 00:E68F: 20 43 E6     ZP_IMED		JSR	TWO_BYTE	;Display operand byte, then mnemonic
  1330 00:E692: A9 23        					LDA	#$23	;Get "#" character
  1331 00:E694: 20 3C FF     					JSR	B_CHROUT	;Send to terminal
  1332 00:E697: 80 1B        					BRA	PRT1_OP	;Display operand byte again, return
  1333                        ;
  1334                        ;ACC_MODE: single byte A reg mode instructions: implied mode 
  1335 00:E699: 20 52 E6     ACC_MODE	JSR	IMPLIED	;Send 10 spaces to terminal then display mnemonic
  1336 00:E69C: A9 41        					LDA	#$41	;Get "A" character
  1337 00:E69E: 4C 3C FF     BR_COUT		JMP	B_CHROUT	;Send it and return
  1338                        ;
  1339                        ;ABSOLUTE: three byte instructions: absolute mode 
  1340 00:E6A1: 20 41 E6     ABSOLUTE	JSR	TRI_BYTE	;Display operand bytes, then mnemonic
  1341                        ;
  1342                        ;Print 2 Operands: display operand bytes of a three-byte instruction
  1343 00:E6A4: 20 81 E1     PRT2_OP		JSR	DOLLAR	;Send "$" to terminal
  1344 00:E6A7: A5 D7        					LDA	CRCHI	;Load operand high byte
  1345 00:E6A9: 20 AE E1     					JSR	PRBYTE	;Send to terminal
  1346 00:E6AC: A5 D8        BR_PRBTE	LDA	CRCLO	;Load operand low byte
  1347 00:E6AE: 4C AE E1     					JMP	PRBYTE	;Send to terminal and return
  1348                        ;
  1349                        ;ZP_ABS: two byte instructions: zero-page absolute
  1350 00:E6B1: 20 43 E6     ZP_ABS		JSR	TWO_BYTE	;Display operand byte, then mnemonic
  1351                        ;
  1352                        ;Print 1 Operand byte: display operand byte of a two-byte instruction 
  1353 00:E6B4: 20 81 E1     PRT1_OP		JSR	DOLLAR	;Send "$" to terminal
  1354 00:E6B7: 80 F3        					BRA	BR_PRBTE	;Branch to complete
  1355                        ;
  1356                        ;INDIRECT: two or three byte instructions: indirect modes
  1357 00:E6B9: A5 D6        INDIRECT	LDA	OPXMDM	;Read saved opcode byte
  1358 00:E6BB: C9 6C        					CMP	#$6C	;Check for JMP(INDIRECT)
  1359 00:E6BD: D0 13        					BNE	ZP_IND	;Branch if not
  1360                        ;
  1361 00:E6BF: 20 41 E6     					JSR	TRI_BYTE	;Display operand bytes, then mnemonic
  1362 00:E6C2: 20 8B E6     					JSR	LF_BRKT	;Send "(" to terminal
  1363 00:E6C5: 20 A4 E6     					JSR	PRT2_OP	;Display operand bytes again
  1364 00:E6C8: 80 0B        					BRA	RT_BRKT	;Send ")" to terminal, return
  1365                        ;
  1366                        ;Following group is used multiple times, space savings
  1367 00:E6CA: 20 43 E6     DSPLY3		JSR	TWO_BYTE	;Display operand byte, then mnemonic
  1368 00:E6CD: 20 8B E6     					JSR	LF_BRKT	;Send "(" to terminal
  1369 00:E6D0: 80 E2        					BRA	PRT1_OP	;Display operand byte again, return
  1370                        ;
  1371                        ;this is for a two byte instruction: zero page indirect mode 
  1372 00:E6D2: 20 CA E6     ZP_IND		JSR	DSPLY3	;Do the 3 routines
  1373                        ;
  1374                        ;RT_BRKT subroutine: send ")" to terminal
  Tue Dec  5 2017  6:27                                                                                                    Page 23


  1375 00:E6D5: A9 29        RT_BRKT		LDA	#$29	;Get ")"
  1376 00:E6D7: 80 C5        					BRA	BR_COUT	;Send to terminal and return
  1377                        ;
  1378                        ;ZP_ABS_X: two byte instructions: zero-page absolute indexed by X mode  
  1379 00:E6D9: 20 B1 E6     ZP_ABS_X	JSR	ZP_ABS	;Display operand byte, mnemonic, operand byte
  1380                        ;
  1381                        ;Print Comma,X: send ",X" to terminal
  1382 00:E6DC: A9 2C        COM_X			LDA	#$2C	;Get ","
  1383 00:E6DE: 20 3C FF     					JSR	B_CHROUT	;Send to terminal
  1384 00:E6E1: A9 58        					LDA	#$58	;Get "X"
  1385 00:E6E3: 80 B9        					BRA	BR_COUT	;Send to terminal, return
  1386                        ;
  1387                        ;ZP_ABS_Y: two byte instructions: zero-page absolute indexed by Y mode
  1388 00:E6E5: 20 B1 E6     ZP_ABS_Y	JSR	ZP_ABS	;Display operand byte, mnemonic, operand byte
  1389                        ;
  1390                        ;Print Comma,Y: send ",Y" to terminal
  1391 00:E6E8: A9 2C        COM_Y			LDA	#$2C	;Get ","
  1392 00:E6EA: 20 3C FF     					JSR	B_CHROUT	;Send to terminal
  1393 00:E6ED: A9 59        					LDA	#$59	;Get "Y"
  1394 00:E6EF: 80 AD        					BRA	BR_COUT	;Send to terminal, return
  1395                        ;
  1396                        ;ABS_Y: three byte instructions: absolute indexed by Y mode
  1397                        ;ABS_X: three byte instructions: absolute indexed by X mode
  1398 00:E6F1: E7 D3        ABS_Y			SMB6	TEMP2
  1399 00:E6F3: 20 41 E6     ABS_X			JSR	TRI_BYTE	;Display operand bytes, then mnemonic
  1400 00:E6F6: 20 A4 E6     					JSR	PRT2_OP	;Display operand bytes again
  1401 00:E6F9: EF D3 EC     					BBS6	TEMP2,COM_Y
  1402 00:E6FC: 80 DE        					BRA	COM_X	;Send ",X" to terminal, return
  1403                        ;
  1404                        ;ZP_IND_X: two byte instructions: zero-page indirect pre-indexed by X mode  
  1405 00:E6FE: 20 CA E6     ZP_IND_X	JSR	DSPLY3	;Do the 3 routines
  1406 00:E701: 20 DC E6     					JSR	COM_X	;Send ",X" to terminal
  1407 00:E704: 80 CF        					BRA	RT_BRKT	;Send ")" to terminal, return
  1408                        ;
  1409                        ;ZP_IND_Y: two byte instructions: zero-page indirect post-indexed by Y mode 
  1410 00:E706: 20 CA E6     ZP_IND_Y	JSR	DSPLY3	Do the 3 routines
  1411 00:E709: 20 D5 E6     					JSR	RT_BRKT	;Send ")" to terminal
  1412 00:E70C: 80 DA        					BRA	COM_Y	;Send ",Y" to terminal, return
  1413                        ;
  1414                        ;IND_ABS_X: three byte instruction: JMP (INDIRECT,X) 16 bit indirect
  1415 00:E70E: 20 41 E6     IND_ABS_X	JSR	TRI_BYTE	;Display operand bytes, then mnemonic
  1416 00:E711: 20 8B E6     					JSR	LF_BRKT	;Send "(" to terminal
  1417 00:E714: 20 A4 E6     					JSR	PRT2_OP	;Display operand bytes again
  1418 00:E717: 20 DC E6     					JSR	COM_X	;Send ",X" to terminal
  1419 00:E71A: 80 B9        					BRA	RT_BRKT	;Send ")" to terminal then done INDABSX handler, RET
                    URN
  1420                        ;
  1421                        ;ZP_XMB: two byte instructions: zero page set/clear memory bit
  1422 00:E71C: 20 79 E7     ZP_XMB		JSR	SRMB	;Display operand byte, mnemonic, isolate bit selector from opcode
  1423 00:E71F: C9 08        					CMP	#$08	;Check if 0-7 or 8-F
  1424 00:E721: 90 02        					BCC	SRBIT	;Just add $30 (0-7)
  1425 00:E723: E9 08        					SBC	#$08	;Subtract $08 - convert $8-$F to $0-$7
  1426 00:E725: 18           SRBIT			CLC	;Convert bit selector value to an ASCII decimal digit
  1427 00:E726: 69 30        					ADC	#$30	;add "0" to bit selector value
  1428 00:E728: 20 3C FF     					JSR	B_CHROUT	;Send digit to terminal
  1429 00:E72B: 20 7C E1     					JSR	SPC	;Send a space to terminal
  1430 00:E72E: 80 84        					BRA	PRT1_OP	;Display operand byte again then return
  1431                        ;
  1432                        ;ZP_BBX: three byte instruction: branch on zero-page bit set/clear
  1433 00:E730: 20 71 E7     ZP_BBX		JSR	SRMB2	;Display operand bytes, mnemonic, isolate bit selector from opcode
  1434 00:E733: C9 08        					CMP	#$08	;Check if $0-$7 or $8-$F
  1435 00:E735: 90 02        					BCC	SRBIT2	;Just add $30 ($0-$7)
  1436 00:E737: E9 08        					SBC	#$08	;Subtract $08 - convert $8-$F to $0-$7
  Tue Dec  5 2017  6:27                                                                                                    Page 24


  1437 00:E739: 20 25 E7     SRBIT2		JSR	SRBIT	;Convert and display bit selector digit
  1438 00:E73C: A5 D7        					LDA	CRCHI	;Move second operand to first operand position: 
  1439 00:E73E: 85 D8        					STA	CRCLO	;CRCLO = branch offset
  1440 00:E740: 20 7C E1     					JSR	SPC	;Send a space to terminal
  1441 00:E743: 80 03        					BRA	BBX_REL	;Display branch target address then return
  1442                        ;
  1443                        ;RELATIVE BRANCH: two byte relative branch mode BBX_REL: three byte relative branch mode
  1444                        ; Both calculate then display relative branch target address
  1445 00:E745: 20 43 E6     REL_BRA		JSR	TWO_BYTE	;Display operand byte, then mnemonic
  1446 00:E748: 20 81 E1     BBX_REL		JSR	DOLLAR	;Send "$" to terminal
  1447 00:E74B: 20 57 E1     					JSR	INCINDEX	;Increment working address, ref for branch o
                    ffset
  1448 00:E74E: A5 D8        					LDA	CRCLO	;Get branch operand value
  1449 00:E750: 30 0A        					BMI	BRA_MINUS	;Check for $80 or higher (if branch is + or 
                    -)
  1450 00:E752: 18           					CLC	;Clear carry for add
  1451 00:E753: 65 C0        					ADC	INDEXL	;Add to Index lo
  1452 00:E755: A8           					TAY	;Xfer to Y reg
  1453 00:E756: A5 C1        					LDA	INDEXH	;Get Index Hi
  1454 00:E758: 69 00        					ADC	#$00	;Add result from Carry flag to A reg
  1455 00:E75A: 80 0F        					BRA	REL_EXT	;Print offset, cleanup, return
  1456 00:E75C: 49 FF        BRA_MINUS	EOR	#$FF	;Get 1's complement of offset
  1457 00:E75E: 1A           					INC	A	;Increment by 1
  1458 00:E75F: 85 D4        					STA  TEMP3	;Save result
  1459 00:E761: 38           					SEC	;Set carry for subtract
  1460 00:E762: A5 C0        					LDA	INDEXL	;Get address low
  1461 00:E764: E5 D4        					SBC	TEMP3	;Subtract branch offset
  1462 00:E766: A8           					TAY	;Xfer to Y reg
  1463 00:E767: A5 C1        					LDA	INDEXH	;Get address high
  1464 00:E769: E9 00        					SBC	#$00	;Subtract carry flag
  1465 00:E76B: 20 C4 E1     REL_EXT		JSR	PRWORD	;Send address to terminal
  1466 00:E76E: 4C 4E E1     					JMP	DECINDEX	;Decrement working address, return
  1467                        ;
  1468                        ;SRMB2 subroutine: display 2 operand bytes, mnemonic, isolate bit selector from opcode 
  1469                        ; SRMB subroutine: display 1 operand byte, mnemonic, isolate bit selector from opcode 
  1470 00:E771: B2 C0        SRMB2			LDA	(INDEXL)	;Read from working index
  1471 00:E773: 48           					PHA	;Save byte to stack
  1472 00:E774: 20 41 E6     					JSR	TRI_BYTE	;Display operand bytes and mnemonic 
  1473 00:E777: 80 06        					BRA	SRM	;Skip down
  1474 00:E779: B2 C0        SRMB			LDA	(INDEXL)	;Read from working index
  1475 00:E77B: 48           					PHA	;Save byte on STACK
  1476 00:E77C: 20 43 E6     					JSR	TWO_BYTE	;Display operand byte and mnemonic 
  1477 00:E77F: 20 71 E1     SRM				JSR	BSOUT2T	;Send 2 Backspaces
  1478 00:E782: 68           					PLA	;Restore byte from stack
  1479 00:E783: 4A           					LSR	A	;Shift high nibble to low nibble
  1480 00:E784: 4A           					LSR	A
  1481 00:E785: 4A           					LSR	A
  1482 00:E786: 4A           					LSR	A
  1483 00:E787: 60           NOCHAR		RTS	;Done SRMB2/SRMB, return
  1484                        ;END OF DISASSEMBLER CODE
  1485                        ;
  1486                        ;[CNTRL-V] Version command:
  1487 00:E788: A9 15        VER				LDA	#$15	;Get Intro substring (version)
  1488 00:E78A: 20 99 E7     					JSR	PROMPT	;Send to terminal
  1489 00:E78D: A0 FF        					LDY	#>BIOS_MSG	;Get high offset
  1490 00:E78F: A9 E0        					LDA	#<BIOS_MSG	;Get low offset
  1491 00:E791: 84 C7        PROMPTR		STY	PROMPTH	;Store hi byte
  1492 00:E793: 85 C6        					STA	PROMPTL	;Store lo byte
  1493 00:E795: 80 0E        					BRA	PROMPT2	;Print message
  1494                        ;
  1495                        ;[CNTRL-Q] Query command:
  1496 00:E797: A9 2D        QUERY			LDA	#$2D	;Get Query msg #
  1497                        ;
  Tue Dec  5 2017  6:27                                                                                                    Page 25


  1498                        ;PROMPT routine: Send indexed text string to terminal. Index is contained in A reg.
  1499                        ; String buffer address is stored in variable PROMPTL/PROMPTH. (placing here saves some space)
  1500 00:E799: 0A           PROMPT		ASL	A	;Multiply by two for msg table index
  1501 00:E79A: A8           					TAY	;Xfer to index
  1502 00:E79B: B9 1E EE     					LDA	MSG_TABLE,Y	;Get low byte address
  1503 00:E79E: 85 C6        					STA	PROMPTL	;Store in Buffer pointer
  1504 00:E7A0: B9 1F EE     					LDA	MSG_TABLE+1,Y	;Get high byte address
  1505 00:E7A3: 85 C7        					STA	PROMPTH	;Store in Buffer pointer
  1506                        ;					
  1507 00:E7A5: B2 C6        PROMPT2		LDA	(PROMPTL)	;Get string data
  1508 00:E7A7: F0 DE        					BEQ	NOCHAR	;If null character, exit (borrowed RTS)
  1509 00:E7A9: 20 3C FF     					JSR	B_CHROUT	;Send character to terminal
  1510 00:E7AC: E6 C6        					INC	PROMPTL	;Increment low byte index
  1511 00:E7AE: D0 F5        					BNE	PROMPT2	;Loop back for next character
  1512 00:E7B0: E6 C7        					INC	PROMPTH	;Increment high byte index
  1513 00:E7B2: 80 F1        					BRA	PROMPT2	;Loop back and continue printing
  1514                        ;
  1515                        ;[CNTL-T] UPTIME command: Sends a string to the console showing the uptime of the system since
  1516                        ; System Start. Displays RTC values for Days, Hours, Minutes and seconds.
  1517 00:E7B4: A9 1A        UPTIME		LDA	#$1A	;Get Uptime message
  1518 00:E7B6: 20 99 E7     					JSR	PROMPT	;Send to terminal
  1519                        ;
  1520 00:E7B9: A2 1B        					LDX	#$1B	;Get Days message
  1521 00:E7BB: A5 F3        					LDA	DAYSL	;Get Days low byte
  1522 00:E7BD: A4 F4        					LDY	DAYSH	;Get Days high byte
  1523 00:E7BF: 20 D6 E7     					JSR	DO16TIME	;Convert and send to terminal
  1524                        ;
  1525 00:E7C2: A2 1C        					LDX	#$1C	;Get Hours message
  1526 00:E7C4: A5 F2        					LDA	HOURS	;Get Current Hours (low byte)
  1527 00:E7C6: 20 D4 E7     					JSR	DO8TIME	;Convert and send to terminal
  1528                        ;
  1529 00:E7C9: A2 1D        					LDX	#$1D	;Get Minutes message
  1530 00:E7CB: A5 F1        					LDA	MINS	;Get Current Minutes (low byte)
  1531 00:E7CD: 20 D4 E7     					JSR	DO8TIME	;Convert and send to terminal
  1532                        ;
  1533 00:E7D0: A2 1E        					LDX	#$1E	;Get seconds message
  1534 00:E7D2: A5 F0        					LDA	SECS	;Get Current Seconds (low byte)
  1535                        ;
  1536 00:E7D4: A0 00        DO8TIME		LDY	#$00	;Zero high byte
  1537 00:E7D6: DA           DO16TIME	PHX	;Push message number to stack
  1538 00:E7D7: 20 BE E0     					JSR	HEX2ASC	;Convert and print ASCII string
  1539 00:E7DA: 68           					PLA	;Pull message number from stack
  1540 00:E7DB: 80 BC        					BRA	PROMPT	;Branch to Prompt
  1541                        ;
  1542                        ;[CNTRL-L] Xmodem/CRC Loader command: receives a file from console via Xmodem protocol. no cable
  1543                        ; swapping needed, uses Console port and buffer via the terminal program. Not a full blown Xmodem/CRC
  1544                        ; implementation, only does CRC-16 checking, no fallback. Designed specifically for direct attach to
  1545                        ; host machine via com port. Can handle full 8-bit binary transfers without errors. Tested with
  1546                        ; ExtraPutty and TeraTerm (Note: TeraTerm doesn't respond to CAN properly).
  1547                        ;
  1548                        ;Added support for Motorola S-Record formatted files automatically. Default load address is $0800.
  1549                        ; An input parameter is used as a Load Address (for non-S-Record files) or as a positive offset for
  1550                        ; any S-Record formatted file. The supported S-Record format is S19 as created by WDC Tools Linker.
  1551                        ; Note: this code supports the execution address in the final S9 record, but WDC Tools does not
  1552                        ; provide any ability to put this into their code build. WDC are aware of this.
  1553 00:E7DD: F7 D5        XMODEM		SMB7	CMDFLAG	;Set Command flag
  1554 00:E7DF: 64 D6        					STZ	OPXMDM	;Clear Xmodem flag
  1555 00:E7E1: A9 01        					LDA	#$01	;Set block count to one
  1556 00:E7E3: 85 DC        					STA	BLKNO	;Save it for starting block #
  1557 00:E7E5: A9 28        					LDA	#$28	;Get Xmodem intro msg
  1558 00:E7E7: 20 F6 E0     					JSR	HEX4	;Print Msg, get Hex load address/S-record Offset
  1559 00:E7EA: 20 89 E1     					JSR	CROUT	;Send a C/R to show input entered
  1560 00:E7ED: E0 00        					CPX	#$00	;Check for input entered (if non-zero, use new data)
  Tue Dec  5 2017  6:27                                                                                                    Page 26


  1561 00:E7EF: D0 03        					BNE	XLINE	;Branch if data entered
  1562 00:E7F1: 8A           					TXA	;Xfer to A reg (LDA #$00)
  1563 00:E7F2: A0 08        					LDY	#$08	;Set High byte ($0800)
  1564 00:E7F4: 85 DA        XLINE			STA	PTRL	;Store to Lo pointer
  1565 00:E7F6: 84 DB        					STY	PTRH	;Store to Hi pointer
  1566                        ;Wait for 5 seconds for user to setup xfer from terminal
  1567 00:E7F8: A9 01        					LDA	#$01	;Set milliseconds to 1(*10 ms)
  1568 00:E7FA: A2 01        					LDX	#$01	;Set 16-bit High multipler
  1569 00:E7FC: A0 F4        					LDY	#$F4	;to 500 decimal
  1570 00:E7FE: 20 3F FF     					JSR	B_SET_DLY	;Set Delay parameters
  1571 00:E801: 20 45 FF     					JSR	B_EXE_LGDLY	;Call long delay for 5 seconds
  1572                        ;
  1573 00:E804: A9 43        STRT_XFER	LDA	#"C"	;Send "C" character for CRC mode
  1574 00:E806: 20 3C FF     					JSR	B_CHROUT	;Send to terminal
  1575 00:E809: A0 32        					LDY	#50	;Set loop count to 50
  1576 00:E80B: 20 42 FF     CHR_DLY		JSR	B_EXE_MSDLY	;Delay 1*(10ms)
  1577 00:E80E: A5 E7        					LDA	ICNT	;Check input buffer count
  1578 00:E810: D0 38        					BNE	STRT_BLK	;If a character is in, branch
  1579 00:E812: 88           					DEY	;Decrement loop count
  1580 00:E813: D0 F6        					BNE	CHR_DLY	;Branch and check again
  1581 00:E815: 80 ED        					BRA	STRT_XFER	;Else, branch and send another "C"
  1582                        ;
  1583 00:E817: A9 06        XDONE			LDA	#ACK	;Last block, get ACK character
  1584 00:E819: 20 3C FF     					JSR	B_CHROUT	;Send final ACK
  1585 00:E81C: A0 02        					LDY	#$02	;Get delay count
  1586 00:E81E: A9 29        					LDA	#$29	;Get Good xfer message number
  1587 00:E820: 20 78 E2     FLSH_DLY	JSR NOLOOPS	;Zero input buffer pointers
  1588 00:E823: 48           					PHA	;Save Message number
  1589 00:E824: A9 19        					LDA	#$19	;Load milliseconds = 250 ms (25x10ms)
  1590 00:E826: A2 00        					LDX	#$00	;Load High multipler to 0 decimal
  1591 00:E828: 20 3F FF     					JSR	B_SET_DLY	;Set Delay parameters
  1592 00:E82B: 20 45 FF     					JSR	B_EXE_LGDLY	;Execute delay, (wait to get terminal back)
  1593 00:E82E: 68           					PLA	;Get message number back
  1594 00:E82F: C9 2A        					CMP	#$2A	;Check for error msg#
  1595 00:E831: F0 14        					BEQ	SHRT_EXIT	;Do only one message
  1596 00:E833: 48           					PHA	;Save MSG number
  1597 00:E834: 7F D6 0F     					BBR7	OPXMDM,END_LOAD	;Branch if no S-record
  1598 00:E837: A9 2B        					LDA	#$2B	;Get S-Record load address msg
  1599 00:E839: 20 99 E7     					JSR	PROMPT	;Printer header msg
  1600 00:E83C: A5 C9        					LDA	SRCH	;Get source high byte
  1601 00:E83E: A4 C8        					LDY	SRCL	;Get source low byte
  1602 00:E840: 20 C4 E1     					JSR	PRWORD	;Print Hex address
  1603 00:E843: 20 89 E1     					JSR	CROUT	;Print C/R and return
  1604 00:E846: 68           END_LOAD	PLA	;Get Message number
  1605 00:E847: 4C 99 E7     SHRT_EXIT	JMP	PROMPT	;Print Message and exit
  1606                        ;
  1607 00:E84A: 20 39 FF     STRT_BLK	JSR	B_CHRIN	;Get a character
  1608 00:E84D: C9 1B        					CMP	#$1B	;Is it escape - quit?
  1609 00:E84F: F0 0A        					BEQ	XM_END	;If yes, exit
  1610 00:E851: C9 01        					CMP	#SOH	;Start of header?
  1611 00:E853: F0 07        					BEQ	GET_BLK	;If yes, branch and receive block
  1612 00:E855: C9 04        					CMP	#EOT	;End of Transmission?
  1613 00:E857: F0 BE        					BEQ	XDONE	;If yes, branch and exit
  1614 00:E859: 80 5F        					BRA	STRT_ERR	;Else branch to error
  1615 00:E85B: 60           XM_END		RTS	;Cancelled by user, return
  1616                        ;
  1617 00:E85C: A2 00        GET_BLK		LDX	#$00	;Zero index for block receive
  1618                        ;
  1619 00:E85E: 20 39 FF     GET_BLK1	JSR	B_CHRIN	;Get a character
  1620 00:E861: 9D 7C 03     					STA	RBUFF,X	;Move into buffer
  1621 00:E864: E8           					INX	;Increment buffer index
  1622 00:E865: E0 84        					CPX	#$84	;Compare size (<01><FE><128 bytes><CRCH><CRCL>)
  1623 00:E867: D0 F5        					BNE	GET_BLK1	;If not done, loop back and continue
  Tue Dec  5 2017  6:27                                                                                                    Page 27


  1624                        ;
  1625 00:E869: AD 7C 03     					LDA	RBUFF	;Get block number from buffer
  1626 00:E86C: C5 DC        					CMP	BLKNO	;Compare to expected block number
  1627 00:E86E: D0 07        					BNE	RESTRT	;If not correct, restart the block
  1628 00:E870: 49 FF        					EOR	#$FF	;one's complement of block number
  1629 00:E872: CD 7D 03     					CMP	RBUFF+1	;Compare with expected one's complement of block num
                    ber
  1630 00:E875: F0 07        					BEQ	BLK_OKAY	;Branch if compare is good
  1631                        ;
  1632 00:E877: A9 15        RESTRT		LDA	#NAK	;Get NAK character
  1633 00:E879: 20 3C FF     RESTRT2		JSR	B_CHROUT	;Send to xfer program
  1634 00:E87C: 80 CC        					BRA	STRT_BLK	;Restart block transfer
  1635                        ;
  1636 00:E87E: A9 0A        BLK_OKAY	LDA	#$0A	;Set retry value to 10
  1637 00:E880: 85 D9        					STA	CRCCNT	;Save it to CRC retry count
  1638 00:E882: 64 D8        					STZ	CRCLO	;Reset the CRC value by (3)
  1639 00:E884: 64 D7        					STZ	CRCHI	;putting all bits off (3)
  1640 00:E886: A0 00        					LDY #$00	Set index for data offset (2)
  1641 00:E888: B9 7E 03     CALCCRC		LDA	RBUFF+2,Y	;Get first data byte (4)
  1642 00:E88B: 08           					PHP	;Save status reg (3)
  1643 00:E88C: A2 08        					LDX	#$08	;Load index for 8 bits (2)
  1644 00:E88E: 45 D7        					EOR	CRCHI	;XOR High CRC byte
  1645 00:E890: 06 D8        CRCLOOP		ASL	CRCLO	;Shift carry to CRC low byte (4)
  1646 00:E892: 2A           					ROL	A	;Shift bit to carry flag (2)
  1647 00:E893: 90 0A        					BCC	CRCLP1	;Branch if MSB is 1 (2/3)
  1648 00:E895: 49 10        					EOR	#$10	;Exclusive OR with polynomial (2)
  1649 00:E897: 48           					PHA	;Save result on stack (3)
  1650 00:E898: A5 D8        					LDA	CRCLO	;Get CRC low byte (3)
  1651 00:E89A: 49 21        					EOR	#$21	;Exclusive OR with polynomial (2)
  1652 00:E89C: 85 D8        					STA	CRCLO	;Save it back (3)
  1653 00:E89E: 68           					PLA	;Get previous result (4)
  1654 00:E89F: CA           CRCLP1		DEX	;Decrement index (2)
  1655 00:E8A0: D0 EE        					BNE	CRCLOOP	;Loop back for all 8 bits (2/3)
  1656 00:E8A2: 85 D7        					STA	CRCHI	;Update CRC high byte (3)
  1657 00:E8A4: 28           					PLP ;Restore status reg (4)
  1658 00:E8A5: C8           					INY	;Increment index to the next data byte (2)
  1659 00:E8A6: 10 E0        					BPL	CALCCRC	;Branch back until all 128 fed to CRC routine (2/3)
  1660 00:E8A8: B9 7E 03     					LDA	RBUFF+2,Y	;Get received CRC hi byte (4)
  1661 00:E8AB: C5 D7        					CMP	CRCHI	;Compare against calculated CRC hi byte (3)
  1662 00:E8AD: D0 07        					BNE	BADCRC	;If bad CRC, handle error (2/3)
  1663 00:E8AF: B9 7F 03     					LDA	RBUFF+3,Y	;Get CRC lo byte (4)
  1664 00:E8B2: C5 D8        					CMP	CRCLO	;Compare against calculated CRC lo byte (3)
  1665 00:E8B4: F0 15        					BEQ	GOODCRC	;If good, go move frame to memory (2/3)
  1666                        ;
  1667                        ;CRC was bad! Need to retry and receive the last frame again. Decrement the CRC retry count,
  1668                        ; send a NAK and try again. Count allows up to 10 retries, then cancels the transfer.
  1669 00:E8B6: C6 D9        BADCRC		DEC	CRCCNT	;Decrement retry count
  1670 00:E8B8: D0 0C        					BNE	CRCRTRY	;Retry again if count not zero
  1671 00:E8BA: A9 18        STRT_ERR	LDA	#CAN	;Else get Cancel code
  1672 00:E8BC: 20 3C FF     					JSR	B_CHROUT	;Send it to terminal program
  1673 00:E8BF: A0 08        					LDY	#$08	;Set delay multiplier
  1674 00:E8C1: A9 2A        					LDA	#$2A	;Get message for receive error
  1675 00:E8C3: 4C 20 E8     					JMP	FLSH_DLY	;Do a flush, delay and exit
  1676 00:E8C6: 20 78 E2     CRCRTRY		JSR	NOLOOPS	;Zero Input buffer pointers
  1677 00:E8C9: 80 AC        					BRA	RESTRT	;Send NAK and retry
  1678                        ;
  1679                        ;Block has been received, check for S19 record transfer
  1680 00:E8CB: FF D6 2D     GOODCRC		BBS7	OPXMDM,XFER_S19	;Branch if bit 7 set (active S-record)
  1681 00:E8CE: A5 DC        					LDA	BLKNO	;Else, check current block number
  1682 00:E8D0: 3A           					DEC	A	;Check for block 1 only (first time thru)
  1683 00:E8D1: F0 16        					BEQ	TEST_S19	;If yes, test for S19 record
  1684                        ;
  1685 00:E8D3: A2 00        MOVE_BLK	LDX	#$00	;Zero index offset to data
  Tue Dec  5 2017  6:27                                                                                                    Page 28


  1686 00:E8D5: BD 7E 03     COPYBLK		LDA	RBUFF+2,X	;Get data byte from buffer
  1687 00:E8D8: 92 DA        					STA	(PTRL)	;Store to target address
  1688 00:E8DA: E6 DA        					INC	PTRL	;Incrememnt low address byte
  1689 00:E8DC: D0 02        					BNE	COPYBLK2	;Check for hi byte loop
  1690 00:E8DE: E6 DB        					INC	PTRH	;Increment hi byte address
  1691 00:E8E0: E8           COPYBLK2	INX	;Point to next data byte
  1692 00:E8E1: 10 F2        					BPL	COPYBLK	;Loop back until done (128)
  1693 00:E8E3: E6 DC        INCBLK		INC	BLKNO	;Increment block number
  1694 00:E8E5: A9 06        					LDA	#ACK	;Get ACK character
  1695 00:E8E7: 80 90        					BRA	RESTRT2	;Send ACK and continue xfer
  1696                        ;
  1697 00:E8E9: AD 7E 03     TEST_S19	LDA	RBUFF+2	;Get first character
  1698 00:E8EC: C9 53        					CMP	#"S"	;Check for S character
  1699 00:E8EE: D0 E3        					BNE	MOVE_BLK	;If not equal, no S-record, move block
  1700 00:E8F0: AD 7F 03     					LDA	RBUFF+3	;Get second character
  1701 00:E8F3: C9 31        					CMP	#"1"	;Check for 1 character
  1702 00:E8F5: D0 DC        					BNE	MOVE_BLK	;If not equal, no S-record, move block
  1703 00:E8F7: F7 D6        					SMB7	OPXMDM	;Set bit 7 for S-record xfer
  1704 00:E8F9: 64 D1        					STZ	IDY	;Zero index for SRBUFF
  1705                        ;
  1706                        ;S-record transfer routine: Xmodem is a 128 byte data block, S-record is variable, up to 44 bytes
  1707                        ;	need to move a record at a time to the SRBUFF based on length, check as valid,	then calculate the
  1708                        ; address and transfer to that location. Once the Xmodem buffer is empty, loop back to get the next
  1709                        ; frame	and continue processing S-records until completed.
  1710                        ;
  1711                        ;At first entry here, pointer IDY is zero. At all entries here, a 128 byte block has been received
  1712                        ; The S-record length needs to be calculated, then the proper count moved to the SRBUFF location and
  1713                        ; both pointers (IDX/IDY) are updated.
  1714 00:E8FB: 64 D0        XFER_S19	STZ	IDX	;Zero offset to RBUFF
  1715 00:E8FD: A6 D0        S19_LOOP2	LDX	IDX	;Load current offset to RBUFF
  1716 00:E8FF: A4 D1        					LDY	IDY	;Get S-Record offset
  1717 00:E901: BD 7E 03     S19_LOOP	LDA	RBUFF+2,X	;Get S-Record data
  1718 00:E904: 99 50 03     					STA	SRBUFF,Y	;Save it to the S-record buffer
  1719 00:E907: E8           					INX	;Increment offset to RBUFF
  1720 00:E908: E0 81        					CPX	#$81	;Check for end of RBUFF data
  1721 00:E90A: F0 0E        					BEQ	NXT_FRAME	;If yes, go back and get another frame
  1722 00:E90C: C8           					INY	;Increment S-Rec size
  1723 00:E90D: C0 2C        					CPY	#$2C	;Check for size match
  1724 00:E90F: D0 F0        					BNE	S19_LOOP	;Branch back until done
  1725 00:E911: 86 D0        					STX	IDX	;Update running offset to RBUFF
  1726 00:E913: 64 D1        					STZ	IDY	;Reset SRBUFF index pointer
  1727 00:E915: 20 1E E9     					JSR	SREC_PROC	;Process the S-Record and store in memory
  1728 00:E918: 80 E3        					BRA	S19_LOOP2	;Branch back and get another record
  1729 00:E91A: 84 D1        NXT_FRAME	STY	IDY	;Save SRBUFF offset
  1730 00:E91C: 80 C5        INCBLK2		BRA	INCBLK	;Increment block and get next frame
  1731                        ;
  1732 00:E91E: AD 51 03     SREC_PROC	LDA	SRBUFF+1	;Get the Record type character
  1733 00:E921: C9 31        					CMP	#"1"	;Check for S1 record
  1734 00:E923: F0 6A        					BEQ	S1_PROC	;Process a S1 record
  1735 00:E925: C9 39        					CMP	#"9"	;Check for S9 (final) record
  1736 00:E927: F0 55        					BEQ	S9_PROC	;Process a S9 record
  1737 00:E929: 68           SREC_ERR	PLA	;Else, pull return address
  1738 00:E92A: 68           					PLA	;of two bytes from stack
  1739 00:E92B: 80 8D        					BRA	STRT_ERR	;Branch to Xmodem error/exit routine
  1740                        ;
  1741 00:E92D: AC 53 03     SR_PROC		LDY	SRBUFF+3	;Get record length LS character
  1742 00:E930: AD 52 03     					LDA	SRBUFF+2	;Get record length MS character
  1743 00:E933: 20 8E E0     					JSR	ASC2BIN	;Convert to single byte for length
  1744 00:E936: 1A           					INC	A	;Add one to length to include checksum
  1745 00:E937: 85 D4        					STA	TEMP3	;Save record length
  1746                        ;
  1747                        ;If record length is less, than the difference needs to be subtracted from IDX which reflects either
  1748                        ; the last record (S9) or a S1 record of a lesser length.
  Tue Dec  5 2017  6:27                                                                                                    Page 29


  1749 00:E939: 38           					SEC	;Set carry for subtract
  1750 00:E93A: A9 14        					LDA	#20	;Get default count
  1751 00:E93C: E5 D4        					SBC	TEMP3	;Subtract actual length
  1752 00:E93E: 0A           					ASL	A	;Multiply by two for characters pairs
  1753 00:E93F: 85 D3        					STA	TEMP2	;Save it to temp
  1754                        ;
  1755 00:E941: 38           					SEC	;Set carry for subtract
  1756 00:E942: A5 D0        					LDA	IDX	;Get RBUFF index
  1757 00:E944: E5 D3        					SBC	TEMP2	;Subtract difference
  1758 00:E946: 85 D0        					STA	IDX	;Update IDX
  1759                        ;
  1760 00:E948: A2 00        SR_COMP		LDX	#$00	;Zero Index
  1761 00:E94A: A0 00        					LDY	#$00	;Zero Index
  1762 00:E94C: 5A           SR_CMPLP	PHY	;Save Y reg index
  1763 00:E94D: BC 53 03     					LDY	SRBUFF+3,X	;get LS character
  1764 00:E950: BD 52 03     					LDA	SRBUFF+2,X	;Get MS character
  1765 00:E953: 20 8E E0     					JSR	ASC2BIN	;Convert two ASCII characters to HEX byte
  1766 00:E956: 7A           					PLY	;Restore Y reg index
  1767 00:E957: 99 50 03     					STA	SRBUFF,Y	;Store in SRBUFF starting at front
  1768 00:E95A: E8           					INX	;Increment X reg twice
  1769 00:E95B: E8           					INX	;points to next character pair
  1770 00:E95C: C8           					INY	;Increment Y reg once for offset to SRBUFF
  1771 00:E95D: C6 D4        					DEC	TEMP3	;Decrement character count
  1772 00:E95F: D0 EB        					BNE	SR_CMPLP	;Branch back until done
  1773                        ;
  1774                        ;SRBUFF now has the compressed HEX data, which is:
  1775                        ; 1 byte for length, 2 bytes for the load address, up to 16 bytes for data and 1 byte checksum
  1776                        ; Now calculate the checksum and ensure valid S-record content
  1777 00:E961: 64 D8        					STZ	CRCLO	;Zero Checksum location
  1778 00:E963: AE 50 03     					LDX	SRBUFF	;Load index with record length
  1779 00:E966: A0 00        					LDY	#$00	;Zero index
  1780 00:E968: 18           SR_CHKSM	CLC	;Clear carry for add
  1781 00:E969: B9 50 03     					LDA	SRBUFF,Y	;Get Srec byte
  1782 00:E96C: 65 D8        					ADC	CRCLO	;Add in checksum Temp
  1783 00:E96E: 85 D8        					STA	CRCLO	:Update checksum Temp
  1784 00:E970: C8           					INY	;Increment offset
  1785 00:E971: CA           					DEX	;Decrement count
  1786 00:E972: D0 F4        					BNE	SR_CHKSM	;Branch back until done
  1787                        ;
  1788 00:E974: A9 FF        					LDA	#$FF	;Get all bits on
  1789 00:E976: 45 D8        					EOR	CRCLO	;Exclusive OR TEMP for one's complement
  1790 00:E978: D9 50 03     					CMP	SRBUFF,Y	;Compare to last byte (which is checksum)
  1791 00:E97B: D0 AC        					BNE	SREC_ERR	;If bad, exit out
  1792 00:E97D: 60           					RTS	;Return to caller
  1793                        ;
  1794 00:E97E: 20 2D E9     S9_PROC		JSR	SR_PROC	;Process the S-Record and checksum
  1795 00:E981: AD 51 03     					LDA	SRBUFF+1	;Get MSB load address
  1796 00:E984: 85 BF        					STA	COMHI	;Store to execution pointer
  1797 00:E986: AD 52 03     					LDA	SRBUFF+2	;Get LSB load address
  1798 00:E989: 85 BE        					STA	COMLO	;Store to execution pointer
  1799 00:E98B: 68           					PLA	;Pull return address
  1800 00:E98C: 68           					PLA	;second byte
  1801 00:E98D: 80 8D        					BRA	INCBLK2	;Branch back to close out transfer
  1802                        ;
  1803 00:E98F: 20 2D E9     S1_PROC		JSR	SR_PROC	;Process the S-Record and checksum
  1804                        ;
  1805                        ;Valid binary S-Record decoded at SRBUFF. Calculate offset from input, add to specified load address
  1806                        ; and store into memory, then loop back until done. Offset is stored in PTR L/H from initial input.
  1807                        ; If no input entered, BUFIDX is zero and PTR L/H is preset to $0800, so checking for BUFIDX being
  1808                        ; zero bypasses adding the offset, if BUFIDX is non zero, then PTR L/H contains the offset address
  1809                        ; which is added to TGT L/H moving the S-record data to memory.
  1810 00:E992: AD 51 03     					LDA	SRBUFF+1	;Get MS load address
  1811 00:E995: 85 CB        					STA	TGTH	;Store to target pointer
  Tue Dec  5 2017  6:27                                                                                                    Page 30


  1812 00:E997: AD 52 03     					LDA	SRBUFF+2	;Get LS load address
  1813 00:E99A: 85 CA        					STA	TGTL	;Store to target pointer
  1814 00:E99C: A5 CE        					LDA	BUFIDX	;Check input count for offset required
  1815 00:E99E: F0 11        					BEQ	NO_OFFSET	;If Zero, no offset was entered
  1816                        ;
  1817                        ; Add in offset contained at PTR L/H to TGT L/H
  1818 00:E9A0: 18           					CLC	;Clear carry for add
  1819 00:E9A1: A5 DA        					LDA	PTRL	;Get LS offset
  1820 00:E9A3: 65 CA        					ADC	TGTL	;Add to TGTL address
  1821 00:E9A5: 90 02        					BCC	SKIP_HB	;Skip increment HB if no carry
  1822 00:E9A7: E6 CB        					INC	TGTH	;Else increment TGTH by one
  1823 00:E9A9: 85 CA        SKIP_HB		STA	TGTL	;Save TGTL
  1824 00:E9AB: A5 DB        					LDA	PTRH	;Get MS offset
  1825 00:E9AD: 65 CB        					ADC	TGTH	;Add to TGTH
  1826 00:E9AF: 85 CB        					STA	TGTH	;Save it
  1827                        ;
  1828                        ;Check for first Block and load SRC H/L with load address
  1829 00:E9B1: A5 DC        NO_OFFSET	LDA	BLKNO	;Get Block number
  1830 00:E9B3: 3A           					DEC	A	;Decrement to test for block one
  1831 00:E9B4: D0 0E        					BNE	NO_OFFST2	;If not first block, skip around
  1832 00:E9B6: A5 D0        					LDA	IDX	;Get running count for first block
  1833 00:E9B8: C9 2C        					CMP	#$2C	;First S-record?
  1834 00:E9BA: D0 08        					BNE	NO_OFFST2	;If yes, setup load address pointer
  1835 00:E9BC: A5 CA        					LDA	TGTL	;Get starting address Lo byte
  1836 00:E9BE: 85 C8        					STA	SRCL	;Save it as Source Lo byte
  1837 00:E9C0: A5 CB        					LDA	TGTH	;Get starting address Hi byte
  1838 00:E9C2: 85 C9        					STA	SRCH	;Save it as Source Hi byte
  1839                        ;
  1840 00:E9C4: AE 50 03     NO_OFFST2	LDX	SRBUFF	;Get record length
  1841 00:E9C7: CA           					DEX	;Decrement by 3
  1842 00:E9C8: CA           					DEX	; to only transfer the data
  1843 00:E9C9: CA           					DEX	; and not the count and load address
  1844 00:E9CA: A0 00        					LDY	#$00	;Zero index
  1845 00:E9CC: B9 53 03     MVE_SREC	LDA	SRBUFF+3,Y	;Get offset to data in record
  1846 00:E9CF: 91 CA        					STA	(TGTL),Y	;Store it to memory
  1847 00:E9D1: C8           					INY	;Increment index
  1848 00:E9D2: CA           					DEX	;Decrement record count
  1849 00:E9D3: D0 F7        					BNE	MVE_SREC	;Branch back until done
  1850 00:E9D5: 60           					RTS	;Return to caller
  1851                        ;
  1852                        ;[CNTL-R] Reset System command: Resets system by calling Coldstart routine. Page zero is cleared,
  1853                        ; vectors and config data re-initialized from ROM.	All I/O devices are reset from initial ROM
  1854                        ; parameters. Monitor cold start is entered.
  1855 00:E9D6: A9 20        SYS_RST		LDA	#$20	;Get msg "Reset System"
  1856 00:E9D8: 87 D5        					SMB0	CMDFLAG	;Set bit zero
  1857 00:E9DA: 80 02        					BRA	RST_ONLY	;Branch below and handle reset
  1858                        ;
  1859                        ;[CNTL-Z] Zero command: zero RAM from $0100-$7FFF and Reset
  1860 00:E9DC: A9 1F        ZERO			LDA	#$1F	;Get msg "Zero RAM/Reset System"
  1861 00:E9DE: 20 99 E7     RST_ONLY	JSR	PROMPT	;Send to terminal
  1862 00:E9E1: 20 1A E2     					JSR	CONTINUE	;Prompt for Continue
  1863 00:E9E4: 8F D5 12     					BBS0	CMDFLAG,DO_COLD	;Branch if reset only
  1864 00:E9E7: 78           					SEI	;Disable IRQs
  1865 00:E9E8: A9 01        					LDA	#$01	;Initialize address pointer to $0100
  1866 00:E9EA: 85 01        					STA	$01	;Store to pointer high byte
  1867 00:E9EC: 64 00        					STZ	$00	;Zero address low byte
  1868 00:E9EE: 3A           					DEC	A	;LDA #$00
  1869 00:E9EF: 92 00        ZEROLOOP	STA	($00)	;Write $00 to current address
  1870 00:E9F1: E6 00        					INC	$00	;Increment address pointer
  1871 00:E9F3: D0 FA        					BNE	ZEROLOOP
  1872 00:E9F5: E6 01        					INC	$01
  1873 00:E9F7: 10 F6        					BPL	ZEROLOOP	;LOOP back IF address pointer < $8000
  1874 00:E9F9: 4C 5D FF     DO_COLD		JMP	B_COLDSTRT	;Jump to coldstart vector
  Tue Dec  5 2017  6:27                                                                                                    Page 31


  1875                        ;
  1876                        ;END OF MONITOR CODE
  1877                        ;******************************************************************************
  1878                        ;START OF MONITOR DATA
  1879                        ;******************************************************************************
  1880                        ;Monitor command & jump table
  1881                        ; There are two parts to the monitor command and jump table; First is the list of commands, which
  1882                        ; are one byte each. Alpha command characters are upper case. Second is the 16-bit address table
  1883                        ; that correspond to the command routines for each command character.
  1884 00:E9FC: 04           MONCMD	.DB	$04	;[CNTRL-D]	Disassembler
  1885 00:E9FD: 0C           				.DB	$0C	;[CNTRL-L]	Xmodem/CRC Loader
  1886 00:E9FE: 10           				.DB	$10	;[CNTRL-P]	Program EEPROM
  1887 00:E9FF: 11           				.DB	$11	;[CNTRL-Q]	Query Monitor Commands
  1888 00:EA00: 12           				.DB	$12	;[CNTRL-R]	Reset - same as power up
  1889 00:EA01: 14           				.DB	$14	;[CNTRL-T]	Uptime display since reset
  1890 00:EA02: 16           				.DB	$16	;[CNTRL-V]	Display Monitor Version
  1891 00:EA03: 1A           				.DB	$1A	;[CNTRL-Z]	Zero Memory - calls reset
  1892 00:EA04: 28           				.DB	$28	;(	Init Macro
  1893 00:EA05: 29           				.DB	$29	;)	Run Macro
  1894 00:EA06: 2C           				.DB	$2C	;,	Setup Delay parameters	
  1895 00:EA07: 2E           				.DB	$2E	;.	Execute Millisecond Delay
  1896 00:EA08: 2F           				.DB	$2F	;/	Execute Long Delay
  1897 00:EA09: 5C           				.DB	$5C	;\	Load and Go Extra Long Delay
  1898 00:EA0A: 41           				.DB	$41	;A	Display/Edit A register
  1899 00:EA0B: 43           				.DB	$43	;C	Compare memory block
  1900 00:EA0C: 44           				.DB	$44	;D	Display Memory contents in HEX/TEXT
  1901 00:EA0D: 45           				.DB	$45	;E	Examine/Edit memory
  1902 00:EA0E: 46           				.DB	$46	;F	Fill memory block
  1903 00:EA0F: 47           				.DB	$47	;G	Go execute to <addr>
  1904 00:EA10: 48           				.DB	$48	;H	Hex byte string search
  1905 00:EA11: 49           				.DB	$49	;I	Input Text string
  1906 00:EA12: 4D           				.DB	$4D	;M	Move memory block
  1907 00:EA13: 50           				.DB	$50	;P	Display/Edit CPU status reg
  1908 00:EA14: 52           				.DB	$52	;R	Display Registers
  1909 00:EA15: 53           				.DB	$53	;S	Display/Edit stack pointer
  1910 00:EA16: 54           				.DB	$54	;T	Text character string search
  1911 00:EA17: 58           				.DB	$58	;X	Display/Edit X register
  1912 00:EA18: 59           				.DB	$59	;Y	Display/Edit Y register
  1913                        ;
  1914 00:EA19: ED E5        MONTAB	.DW	DSSMBLR	;[CNTRL-D] $04 Disassembler
  1915 00:EA1B: DD E7        				.DW	XMODEM	;[CNTL-L] $0C Xmodem Download. Uses Console Port.
  1916 00:EA1D: C4 E2        				.DW	PROGEE ;[CNTL-P] $10 Program the EEPROM
  1917 00:EA1F: 97 E7        				.DW	QUERY	;[CNTL-Q] $11 Query Monitor Commands
  1918 00:EA21: D6 E9        				.DW	SYS_RST	;[CNTL-R] $12 Reset CO2Monitor
  1919 00:EA23: B4 E7        				.DW	UPTIME	;[CNTL-T] $14 System uptime from Reset
  1920 00:EA25: 88 E7        				.DW	VER	;[CNTL-V] $16 Display Monitor Version level
  1921 00:EA27: DC E9        				.DW	ZERO	;[CNTL-Z] $1A Zero memory ($0100-$7FFF) then Reset
  1922 00:EA29: 56 E2        				.DW	INIMACRO	;( $28 Clear input buffer/reset pointers
  1923 00:EA2B: 7F E2        				.DW	RUNMACRO	;) $29 Run Macro from start of input buffer
  1924 00:EA2D: 36 E2        				.DW	SET_DELAY	;. $2C Setup Delay Parameters
  1925 00:EA2F: 42 FF        				.DW	B_EXE_MSDLY	;, $2E Perform Millisecond Delay
  1926 00:EA31: 45 FF        				.DW	B_EXE_LGDLY	;/ $2F Execute Long Delay
  1927 00:EA33: 47 E2        				.DW	SET_XLDLY	;\ $5C Load and Go Extra Long Delay
  1928 00:EA35: 51 E5        				.DW	ARG	;A $41 Examine/Edit ACCUMULATOR preset/result
  1929 00:EA37: B7 E2        				.DW	CPMVFL	;C $43 Compare command - new
  1930 00:EA39: B5 E3        				.DW	MDUMP	;D $44 HEX/TEXT dump from specified memory address
  1931 00:EA3B: 3A E4        				.DW	CHANGE	;E $45 Examine/change a memory location's contents
  1932 00:EA3D: B7 E2        				.DW	CPMVFL	;F $46 Fill specified memory range with a value
  1933 00:EA3F: 5B E4        				.DW	GO	;G $47 Execute program code at specified address
  1934 00:EA41: B1 E4        				.DW	SRCHBYT	;H $48 Search memory for a specified byte string
  1935 00:EA43: 9A E5        				.DW	TEXT	;I $49 Input text string into memory
  1936 00:EA45: B7 E2        				.DW	CPMVFL	;M $4D Copy memory from Source to Target space
  1937 00:EA47: 41 E5        				.DW	PRG	;P $50 Examine/Edit CPU STATUS REGISTER preset/result
  Tue Dec  5 2017  6:27                                                                                                    Page 32


  1938 00:EA49: 67 E5        				.DW	PRSTAT	;R $52 Display all preset/result contents
  1939 00:EA4B: 45 E5        				.DW	SRG	;S $53 Examine/Edit STACK POINTER preset/result
  1940 00:EA4D: 85 E4        				.DW	SRCHTXT	;T $54 Search memory for a specified text string
  1941 00:EA4F: 4D E5        				.DW	XRG	;X $58 Examine/Edit X-REGISTER preset/result
  1942 00:EA51: 49 E5        				.DW	YRG	;Y $59 Examine/Edit Y-REGISTER preset/result
  1943                        ;
  1944                        ;******************************************************************************
  1945                        ;C02Monitor message strings used with PROMPT routine, terminated with $00
  1946 00:EA53: 20 63 6F 6E  MSG_00	.DB " cont?"
       00:EA57: 74 3F 
  1947 00:EA59: 28 79 2F 6E  MSG_01	.DB	"(y/n)"
       00:EA5D: 29 
  1948 00:EA5E: 00           				.DB $00
  1949 00:EA5F: 0D 0A        MSG_02	.DB $0D,$0A
  1950 00:EA61: 20 20 20     				.DB	"   "
  1951 00:EA64: 20 61 64 64  MSG_03	.DB	" addr:"
       00:EA68: 72 3A 
  1952 00:EA6A: 00           				.DB $00
  1953 00:EA6B: 20 6C 65 6E  MSG_04	.DB " len:"
       00:EA6F: 3A 
  1954 00:EA70: 00           				.DB $00
  1955 00:EA71: 20 76 61 6C  MSG_05	.DB " val:"
       00:EA75: 3A 
  1956 00:EA76: 00           				.DB $00
  1957 00:EA77: 20 73 72 63  MSG_06	.DB " src:"
       00:EA7B: 3A 
  1958 00:EA7C: 00           				.DB $00
  1959 00:EA7D: 20 74 67 74  MSG_07	.DB " tgt:"
       00:EA81: 3A 
  1960 00:EA82: 00           				.DB $00
  1961 00:EA83: 20 66 69 6E  MSG_08	.DB " find txt:"
       00:EA87: 64 20 74 78 
       00:EA8B: 74 3A 
  1962 00:EA8D: 00           				.DB $00
  1963 00:EA8E: 20 66 69 6E  MSG_09	.DB " find bin:"
       00:EA92: 64 20 62 69 
       00:EA96: 6E 3A 
  1964 00:EA98: 00           				.DB $00
  1965 00:EA99: 6E 6F 74 20  MSG_0A	.DB "not "
  1966 00:EA9D: 66 6F 75 6E  MSG_0B	.DB "found"
       00:EAA1: 64 
  1967 00:EAA2: 00           				.DB $00
  1968 00:EAA3: 0D 0A        MSG_0C	.DB $0D,$0A
  1969 00:EAA5: 73 65 61 72  				.DB "search- "
       00:EAA9: 63 68 2D 20 
  1970 00:EAAD: 00           				.DB $00
  1971 00:EAAE: 0D 0A        MSG_0D	.DB $0D,$0A
  1972 00:EAB0: 28 6E 29 65  				.DB "(n)ext? "
       00:EAB4: 78 74 3F 20 
  1973 00:EAB8: 00           				.DB $00
  1974 00:EAB9: 53 52 3A 24  MSG_0E	.DB "SR:$"
  1975 00:EABD: 00           				.DB $00
  1976 00:EABE: 53 50 3A 24  MSG_0F	.DB "SP:$"
  1977 00:EAC2: 00           				.DB $00
  1978 00:EAC3: 59 52 3A 24  MSG_10	.DB "YR:$"
  1979 00:EAC7: 00           				.DB $00
  1980 00:EAC8: 58 52 3A 24  MSG_11	.DB "XR:$"
  1981 00:EACC: 00           				.DB $00
  1982 00:EACD: 41 43 3A 24  MSG_12	.DB "AC:$"
  1983 00:EAD1: 00           				.DB $00
  1984 00:EAD2: 0D 0A        MSG_13	.DB	$0D,$0A
  1985 00:EAD4: 20 20 20 50  				.DB "   PC  AC XR YR SP NV-BDIZC",$0D,$0A
       00:EAD8: 43 20 20 41 
  Tue Dec  5 2017  6:27                                                                                                    Page 33


       00:EADC: 43 20 58 52 
       00:EAE0: 20 59 52 20 
       00:EAE4: 53 50 20 4E 
       00:EAE8: 56 2D 42 44 
       00:EAEC: 49 5A 43 0D 
       00:EAF0: 0A 
  1986 00:EAF1: 3B 20        				.DB "; "
  1987 00:EAF3: 00           				.DB $00
  1988 00:EAF4: 0D 0A        MSG_14	.DB $0D,$0A
  1989 00:EAF6: 43 30 32 4D  				.DB "C02Monitor (c)2013-2017 K.E.Maier",$07
       00:EAFA: 6F 6E 69 74 
       00:EAFE: 6F 72 20 28 
       00:EB02: 63 29 32 30 
       00:EB06: 31 33 2D 32 
       00:EB0A: 30 31 37 20 
       00:EB0E: 4B 2E 45 2E 
       00:EB12: 4D 61 69 65 
       00:EB16: 72 07 
  1990 00:EB18: 0D 0A        				.DB $0D,$0A
  1991 00:EB1A: 43 54 52 4C  				.DB	"CTRL-Q for command list"
       00:EB1E: 2D 51 20 66 
       00:EB22: 6F 72 20 63 
       00:EB26: 6F 6D 6D 61 
       00:EB2A: 6E 64 20 6C 
       00:EB2E: 69 73 74 
  1992 00:EB31: 0D 0A        MSG_15	.DB $0D,$0A
  1993 00:EB33: 56 65 72 73  				.DB "Version 2.0"
       00:EB37: 69 6F 6E 20 
       00:EB3B: 32 2E 30 
  1994 00:EB3E: 00           				.DB $00
  1995 00:EB3F: 0D 0A        MSG_16	.DB $0D,$0A
  1996 00:EB41: 3B 2D        				.DB ";-"
  1997 00:EB43: 00           				.DB $00
  1998 00:EB44: 20 64 65 6C  MSG_17	.DB	" delay ms:"
       00:EB48: 61 79 20 6D 
       00:EB4C: 73 3A 
  1999 00:EB4E: 00           				.DB	$00
  2000 00:EB4F: 20 6D 75 6C  MSG_18	.DB	" mult:"
       00:EB53: 74 3A 
  2001 00:EB55: 00           				.DB	$00
  2002 00:EB56: 20 64 65 6C  MSG_19	.DB	" delay xl:"
       00:EB5A: 61 79 20 78 
       00:EB5E: 6C 3A 
  2003 00:EB60: 00           				.DB	$00
  2004 00:EB61: 55 70 74 69  MSG_1A	.DB	"Uptime: "
       00:EB65: 6D 65 3A 20 
  2005 00:EB69: 00           				.DB	$00
  2006 00:EB6A: 20 44 61 79  MSG_1B	.DB	" Days, "
       00:EB6E: 73 2C 20 
  2007 00:EB71: 00           				.DB	$00
  2008 00:EB72: 20 48 6F 75  MSG_1C	.DB	" Hours, "
       00:EB76: 72 73 2C 20 
  2009 00:EB7A: 00           				.DB	$00
  2010 00:EB7B: 20 4D 69 6E  MSG_1D	.DB	" Minutes, "
       00:EB7F: 75 74 65 73 
       00:EB83: 2C 20 
  2011 00:EB85: 00           				.DB	$00
  2012 00:EB86: 20 53 65 63  MSG_1E	.DB	" Seconds"
       00:EB8A: 6F 6E 64 73 
  2013 00:EB8E: 00           				.DB	$00
  2014 00:EB8F: 5A 65 72 6F  MSG_1F	.DB "Zero RAM/"
       00:EB93: 20 52 41 4D 
       00:EB97: 2F 
  Tue Dec  5 2017  6:27                                                                                                    Page 34


  2015 00:EB98: 52 65 73 65  MSG_20	.DB	"Reset,"
       00:EB9C: 74 2C 
  2016 00:EB9E: 00           				.DB	$00
  2017 00:EB9F: 50 72 6F 67  MSG_21	.DB	"Program EEPROM",$0D,$0A
       00:EBA3: 72 61 6D 20 
       00:EBA7: 45 45 50 52 
       00:EBAB: 4F 4D 0D 0A 
  2018 00:EBAF: 00           				.DB	$00
  2019 00:EBB0: 0D 0A        MSG_22	.DB	$0D,$0A
  2020 00:EBB2: 41 72 65 20  				.DB	"Are you sure? "
       00:EBB6: 79 6F 75 20 
       00:EBBA: 73 75 72 65 
       00:EBBE: 3F 20 
  2021 00:EBC0: 00           				.DB	$00
  2022 00:EBC1: 0D 0A        MSG_23	.DB	$0D,$0A
  2023 00:EBC3: 57 72 69 74  				.DB	"Writing EEPROM."
       00:EBC7: 69 6E 67 20 
       00:EBCB: 45 45 50 52 
       00:EBCF: 4F 4D 2E 
  2024 00:EBD2: 00           				.DB	$00
  2025 00:EBD3: 0D 0A        MSG_24	.DB	$0D,$0A
  2026 00:EBD5: 45 45 50 52  				.DB	"EEPROM Write Complete!"
       00:EBD9: 4F 4D 20 57 
       00:EBDD: 72 69 74 65 
       00:EBE1: 20 43 6F 6D 
       00:EBE5: 70 6C 65 74 
       00:EBE9: 65 21 
  2027 00:EBEB: 00           				.DB	$00
  2028 00:EBEC: 0D 0A        MSG_25	.DB	$0D,$0A
  2029 00:EBEE: 45 45 50 52  				.DB	"EEPROM Write Failed!",$0D,$0A
       00:EBF2: 4F 4D 20 57 
       00:EBF6: 72 69 74 65 
       00:EBFA: 20 46 61 69 
       00:EBFE: 6C 65 64 21 
       00:EC02: 0D 0A 
  2030 00:EC04: 48 61 72 64  				.DB	"Hardware or EEPROM jumper!"
       00:EC08: 77 61 72 65 
       00:EC0C: 20 6F 72 20 
       00:EC10: 45 45 50 52 
       00:EC14: 4F 4D 20 6A 
       00:EC18: 75 6D 70 65 
       00:EC1C: 72 21 
  2031 00:EC1E: 00           				.DB	$00
  2032 00:EC1F: 0D 0A        MSG_26	.DB	$0D,$0A
  2033 00:EC21: 53 68 6F 77  				.DB	"Show Loop count "
       00:EC25: 20 4C 6F 6F 
       00:EC29: 70 20 63 6F 
       00:EC2D: 75 6E 74 20 
  2034 00:EC31: 00           				.DB	$00
  2035 00:EC32: 0D 0A        MSG_27	.DB	$0D,$0A
  2036 00:EC34: 4C 6F 6F 70  				.DB	"Loops: "
       00:EC38: 73 3A 20 
  2037 00:EC3B: 00           				.DB	$00
  2038 00:EC3C: 58 4D 4F 44  MSG_28	.DB	"XMODEM Loader, <Esc> to abort, or",$0D,$0A
       00:EC40: 45 4D 20 4C 
       00:EC44: 6F 61 64 65 
       00:EC48: 72 2C 20 3C 
       00:EC4C: 45 73 63 3E 
       00:EC50: 20 74 6F 20 
       00:EC54: 61 62 6F 72 
       00:EC58: 74 2C 20 6F 
       00:EC5C: 72 0D 0A 
  2039 00:EC5F: 4C 6F 61 64  				.DB	"Load Address/S-Record Offset:"
  Tue Dec  5 2017  6:27                                                                                                    Page 35


       00:EC63: 20 41 64 64 
       00:EC67: 72 65 73 73 
       00:EC6B: 2F 53 2D 52 
       00:EC6F: 65 63 6F 72 
       00:EC73: 64 20 4F 66 
       00:EC77: 66 73 65 74 
       00:EC7B: 3A 
  2040 00:EC7C: 00           				.DB	$00
  2041 00:EC7D: 0D 0A        MSG_29	.DB	$0D,$0A
  2042 00:EC7F: 44 6F 77 6E  				.DB	"Download Complete!",$0A
       00:EC83: 6C 6F 61 64 
       00:EC87: 20 43 6F 6D 
       00:EC8B: 70 6C 65 74 
       00:EC8F: 65 21 0A 
  2043 00:EC92: 00           				.DB	$00
  2044 00:EC93: 0D 0A        MSG_2A	.DB	$0D,$0A
  2045 00:EC95: 44 6F 77 6E  				.DB	"Download Error!",$0A
       00:EC99: 6C 6F 61 64 
       00:EC9D: 20 45 72 72 
       00:ECA1: 6F 72 21 0A 
  2046 00:ECA5: 00           				.DB	$00
  2047 00:ECA6: 0D 0A        MSG_2B	.DB $0D,$0A
  2048 00:ECA8: 53 2D 52 65  				.DB "S-Record load at:$"
       00:ECAC: 63 6F 72 64 
       00:ECB0: 20 6C 6F 61 
       00:ECB4: 64 20 61 74 
       00:ECB8: 3A 24 
  2049 00:ECBA: 00           				.DB $00
  2050 00:ECBB: 0D 0A        MSG_2C	.DB	$0D,$0A
  2051 00:ECBD: 44 69 73 61  				.DB	"Disassembly from"
       00:ECC1: 73 73 65 6D 
       00:ECC5: 62 6C 79 20 
       00:ECC9: 66 72 6F 6D 
  2052 00:ECCD: 00           				.DB	$00
  2053 00:ECCE: 0D 0A 0A     MSG_2D	.DB	$0D,$0A,$0A
  2054 00:ECD1: 4D 65 6D 6F  				.DB	"Memory Ops: "
       00:ECD5: 72 79 20 4F 
       00:ECD9: 70 73 3A 20 
  2055 00:ECDD: 5B 43 5D 6F  				.DB	"[C]ompare, "
       00:ECE1: 6D 70 61 72 
       00:ECE5: 65 2C 20 
  2056 00:ECE8: 5B 44 5D 69  				.DB	"[D]isplay, "
       00:ECEC: 73 70 6C 61 
       00:ECF0: 79 2C 20 
  2057 00:ECF3: 5B 45 5D 64  				.DB	"[E]dit, "
       00:ECF7: 69 74 2C 20 
  2058 00:ECFB: 5B 46 5D 69  				.DB	"[F]ill, "
       00:ECFF: 6C 6C 2C 20 
  2059 00:ED03: 5B 47 5D 6F  				.DB	"[G]o Exec,",$0D,$0A
       00:ED07: 20 45 78 65 
       00:ED0B: 63 2C 0D 0A 
  2060 00:ED0F: 5B 48 5D 65  				.DB	"[H]ex Find, "
       00:ED13: 78 20 46 69 
       00:ED17: 6E 64 2C 20 
  2061 00:ED1B: 5B 49 5D 6E  				.DB	"[I]nput Text, "
       00:ED1F: 70 75 74 20 
       00:ED23: 54 65 78 74 
       00:ED27: 2C 20 
  2062 00:ED29: 5B 4D 5D 6F  				.DB	"[M]ove, "
       00:ED2D: 76 65 2C 20 
  2063 00:ED31: 5B 54 5D 65  				.DB	"[T]ext Find",$0D,$0A,$0A
       00:ED35: 78 74 20 46 
       00:ED39: 69 6E 64 0D 
  Tue Dec  5 2017  6:27                                                                                                    Page 36


       00:ED3D: 0A 0A 
  2064 00:ED3F: 52 65 67 69  				.DB	"Registers: "
       00:ED43: 73 74 65 72 
       00:ED47: 73 3A 20 
  2065 00:ED4A: 52 2C 41 2C  				.DB	"R,A,X,Y,S,P",$0D,$0A,$0A
       00:ED4E: 58 2C 59 2C 
       00:ED52: 53 2C 50 0D 
       00:ED56: 0A 0A 
  2066 00:ED58: 54 69 6D 65  				.DB	"Timer: "
       00:ED5C: 72 3A 20 
  2067 00:ED5F: 2C 3D 20 73  				.DB	",= set ms|mult, "
       00:ED63: 65 74 20 6D 
       00:ED67: 73 7C 6D 75 
       00:ED6B: 6C 74 2C 20 
  2068 00:ED6F: 2E 3D 20 65  				.DB	".= exe ms, "
       00:ED73: 78 65 20 6D 
       00:ED77: 73 2C 20 
  2069 00:ED7A: 2F 3D 20 65  				.DB	"/= exe ms*mult, "
       00:ED7E: 78 65 20 6D 
       00:ED82: 73 2A 6D 75 
       00:ED86: 6C 74 2C 20 
  2070 00:ED8A: 5C 3D 20 65  				.DB	"\= exe (?)*ms*mult",$0D,$0A,$0A
       00:ED8E: 78 65 20 28 
       00:ED92: 3F 29 2A 6D 
       00:ED96: 73 2A 6D 75 
       00:ED9A: 6C 74 0D 0A 
       00:ED9E: 0A 
  2071 00:ED9F: 4D 61 63 72  				.DB	"Macro: "
       00:EDA3: 6F 3A 20 
  2072 00:EDA6: 28 3D 20 49  				.DB	"(= Init "
       00:EDAA: 6E 69 74 20 
  2073 00:EDAE: 29 3D 20 52  				.DB	")= Run",$0D,$0A,$0A
       00:EDB2: 75 6E 0D 0A 
       00:EDB6: 0A 
  2074 00:EDB7: 43 54 52 4C  				.DB	"CTRL[?]: "
       00:EDBB: 5B 3F 5D 3A 
       00:EDBF: 20 
  2075 00:EDC0: 5B 44 5D 69  				.DB	"[D]isassemble, "
       00:EDC4: 73 61 73 73 
       00:EDC8: 65 6D 62 6C 
       00:EDCC: 65 2C 20 
  2076 00:EDCF: 5B 4C 5D 6F  				.DB	"[L]oader, "
       00:EDD3: 61 64 65 72 
       00:EDD7: 2C 20 
  2077 00:EDD9: 5B 50 5D 72  				.DB	"[P]rogram, "
       00:EDDD: 6F 67 72 61 
       00:EDE1: 6D 2C 20 
  2078 00:EDE4: 5B 51 5D 75  				.DB	"[Q]uery Cmds,",$0D,$0A
       00:EDE8: 65 72 79 20 
       00:EDEC: 43 6D 64 73 
       00:EDF0: 2C 0D 0A 
  2079 00:EDF3: 5B 52 5D 65  				.DB	"[R]eset, "
       00:EDF7: 73 65 74 2C 
       00:EDFB: 20 
  2080 00:EDFC: 5B 54 5D 69  				.DB	"[T]ime up, "
       00:EE00: 6D 65 20 75 
       00:EE04: 70 2C 20 
  2081 00:EE07: 5B 56 5D 65  				.DB	"[V]ersion, "
       00:EE0B: 72 73 69 6F 
       00:EE0F: 6E 2C 20 
  2082 00:EE12: 5B 5A 5D 65  				.DB	"[Z]ero RAM",$0A
       00:EE16: 72 6F 20 52 
       00:EE1A: 41 4D 0A 
  Tue Dec  5 2017  6:27                                                                                                    Page 37


  2083 00:EE1D: 00           				.DB	$00
  2084                        ;
  2085                        MSG_TABLE	;Message table - contains addresses as words of each message sent via the PROMPT routine
  2086 00:EE1E: 53 EA 59 EA  				.DW MSG_00, MSG_01, MSG_02, MSG_03, MSG_04, MSG_05, MSG_06, MSG_07
       00:EE22: 5F EA 64 EA 
       00:EE26: 6B EA 71 EA 
       00:EE2A: 77 EA 7D EA 
  2087 00:EE2E: 83 EA 8E EA  				.DW	MSG_08, MSG_09, MSG_0A, MSG_0B, MSG_0C, MSG_0D, MSG_0E, MSG_0F
       00:EE32: 99 EA 9D EA 
       00:EE36: A3 EA AE EA 
       00:EE3A: B9 EA BE EA 
  2088 00:EE3E: C3 EA C8 EA  				.DW	MSG_10, MSG_11, MSG_12, MSG_13, MSG_14, MSG_15, MSG_16, MSG_17
       00:EE42: CD EA D2 EA 
       00:EE46: F4 EA 31 EB 
       00:EE4A: 3F EB 44 EB 
  2089 00:EE4E: 4F EB 56 EB  				.DW	MSG_18, MSG_19, MSG_1A, MSG_1B, MSG_1C, MSG_1D, MSG_1E, MSG_1F
       00:EE52: 61 EB 6A EB 
       00:EE56: 72 EB 7B EB 
       00:EE5A: 86 EB 8F EB 
  2090 00:EE5E: 98 EB 9F EB  				.DW	MSG_20, MSG_21, MSG_22, MSG_23, MSG_24, MSG_25, MSG_26, MSG_27
       00:EE62: B0 EB C1 EB 
       00:EE66: D3 EB EC EB 
       00:EE6A: 1F EC 32 EC 
  2091 00:EE6E: 3C EC 7D EC  				.DW	MSG_28, MSG_29, MSG_2A, MSG_2B, MSG_2C, MSG_2D
       00:EE72: 93 EC A6 EC 
       00:EE76: BB EC CE EC 
  2092                        ;
  2093                        ;******************************************************************************
  2094                        ;START OF DISASSEMBLER DATA
  2095                        ; Pointer for address mode handlers. Each byte contains handler pointer for two opcodes;
  2096                        ; Upper nibble for odd, lower nibble for even
  2097                        HDLR_IDX
  2098 00:EE7A: 26 00 33 3E  				.DB	$26,$00,$33,$3E,$02,$10,$88,$8F
       00:EE7E: 02 10 88 8F 
  2099 00:EE82: C7 B0 34 4E  				.DB	$C7,$B0,$34,$4E,$0A,$10,$89,$9F
       00:EE86: 0A 10 89 9F 
  2100 00:EE8A: 86 00 33 3E  				.DB	$86,$00,$33,$3E,$02,$10,$88,$8F
       00:EE8E: 02 10 88 8F 
  2101 00:EE92: C7 B0 44 4E  				.DB	$C7,$B0,$44,$4E,$0A,$10,$99,$9F
       00:EE96: 0A 10 99 9F 
  2102 00:EE9A: 06 00 03 3E  				.DB	$06,$00,$03,$3E,$02,$10,$88,$8F
       00:EE9E: 02 10 88 8F 
  2103 00:EEA2: C7 B0 04 4E  				.DB	$C7,$B0,$04,$4E,$0A,$00,$09,$9F
       00:EEA6: 0A 00 09 9F 
  2104 00:EEAA: 06 00 33 3E  				.DB	$06,$00,$33,$3E,$02,$10,$B8,$8F
       00:EEAE: 02 10 B8 8F 
  2105 00:EEB2: C7 B0 44 4E  				.DB	$C7,$B0,$44,$4E,$0A,$00,$D9,$9F
       00:EEB6: 0A 00 D9 9F 
  2106 00:EEBA: C6 00 33 3E  				.DB	$C6,$00,$33,$3E,$02,$00,$88,$8F
       00:EEBE: 02 00 88 8F 
  2107 00:EEC2: C7 B0 44 5E  				.DB	$C7,$B0,$44,$5E,$0A,$00,$89,$9F
       00:EEC6: 0A 00 89 9F 
  2108 00:EECA: 26 20 33 3E  				.DB	$26,$20,$33,$3E,$02,$00,$88,$8F
       00:EECE: 02 00 88 8F 
  2109 00:EED2: C7 B0 44 5E  				.DB	$C7,$B0,$44,$5E,$0A,$00,$99,$AF
       00:EED6: 0A 00 99 AF 
  2110 00:EEDA: 26 00 33 3E  				.DB	$26,$00,$33,$3E,$02,$00,$88,$8F
       00:EEDE: 02 00 88 8F 
  2111 00:EEE2: C7 B0 04 4E  				.DB	$C7,$B0,$04,$4E,$0A,$00,$09,$9F
       00:EEE6: 0A 00 09 9F 
  2112 00:EEEA: 26 00 33 3E  				.DB	$26,$00,$33,$3E,$02,$00,$88,$8F
       00:EEEE: 02 00 88 8F 
  2113 00:EEF2: C7 B0 04 4E  				.DB	$C7,$B0,$04,$4E,$0A,$00,$09,$9F
  Tue Dec  5 2017  6:27                                                                                                    Page 38


       00:EEF6: 0A 00 09 9F 
  2114                        ;
  2115                        ;Disassembler handler table: Handler address index: (referenced in table HDLR_IDX)
  2116                        HDLR_TAB
  2117 00:EEFA: 52 E6        				.DW	IMPLIED	;$00
  2118 00:EEFC: 99 E6        				.DW	ACC_MODE	;$01   
  2119 00:EEFE: 8F E6        				.DW	ZP_IMED	;$02
  2120 00:EF00: B1 E6        				.DW	ZP_ABS	;$03
  2121 00:EF02: D9 E6        				.DW	ZP_ABS_X	;$04
  2122 00:EF04: E5 E6        				.DW	ZP_ABS_Y	;$05
  2123 00:EF06: FE E6        				.DW	ZP_IND_X	;$06
  2124 00:EF08: 06 E7        				.DW	ZP_IND_Y	;$07
  2125 00:EF0A: A1 E6        				.DW	ABSOLUTE	;$08
  2126 00:EF0C: F3 E6        				.DW	ABS_X	;$09
  2127 00:EF0E: F1 E6        				.DW	ABS_Y	;$0A
  2128 00:EF10: B9 E6        				.DW	INDIRECT	;$0B
  2129 00:EF12: 45 E7        				.DW	REL_BRA	;$0C
  2130 00:EF14: 0E E7        				.DW	IND_ABS_X	;$0D
  2131 00:EF16: 1C E7        				.DW	ZP_XMB	;$0E
  2132 00:EF18: 30 E7        				.DW	ZP_BBX	;$0F
  2133                        ;
  2134                        ;Disassembler mnemonic pointer table. This is indexed by the instruction opcode.
  2135                        ; The values in this table are an index to the mnemonic data used to print: 
  2136                        MNE_PTAB	;Mnemonic pointer index table
  2137 00:EF1A: 1C 4C 00 00  			.DB	$1C,$4C,$00,$00,$82,$4C,$06,$5E,$50,$4C,$06,$00,$82,$4C,$06,$08
       00:EF1E: 82 4C 06 5E 
       00:EF22: 50 4C 06 00 
       00:EF26: 82 4C 06 08 
  2138 00:EF2A: 18 4C 4C 00  			.DB	$18,$4C,$4C,$00,$80,$4C,$06,$5E,$22,$4C,$38,$00,$80,$4C,$06,$08
       00:EF2E: 80 4C 06 5E 
       00:EF32: 22 4C 38 00 
       00:EF36: 80 4C 06 08 
  2139 00:EF3A: 40 04 00 00  			.DB	$40,$04,$00,$00,$12,$04,$60,$5E,$58,$04,$60,$00,$12,$04,$60,$08
       00:EF3E: 12 04 60 5E 
       00:EF42: 58 04 60 00 
       00:EF46: 12 04 60 08 
  2140 00:EF4A: 14 04 04 00  			.DB	$14,$04,$04,$00,$12,$04,$60,$5E,$6A,$04,$30,$00,$12,$04,$60,$08
       00:EF4E: 12 04 60 5E 
       00:EF52: 6A 04 30 00 
       00:EF56: 12 04 60 08 
  2141 00:EF5A: 64 36 00 00  			.DB	$64,$36,$00,$00,$00,$36,$48,$5E,$4E,$36,$48,$00,$3E,$36,$48,$08
       00:EF5E: 00 36 48 5E 
       00:EF62: 4E 36 48 00 
       00:EF66: 3E 36 48 08 
  2142 00:EF6A: 1E 36 36 00  			.DB	$1E,$36,$36,$00,$00,$36,$48,$5E,$26,$36,$54,$00,$00,$36,$48,$08
       00:EF6E: 00 36 48 5E 
       00:EF72: 26 36 54 00 
       00:EF76: 00 36 48 08 
  2143 00:EF7A: 66 02 00 00  			.DB	$66,$02,$00,$00,$7A,$02,$62,$5E,$56,$02,$62,$00,$3E,$02,$62,$08
       00:EF7E: 7A 02 62 5E 
       00:EF82: 56 02 62 00 
       00:EF86: 3E 02 62 08 
  2144 00:EF8A: 20 02 02 00  			.DB	$20,$02,$02,$00,$7A,$02,$62,$5E,$6E,$02,$5C,$00,$3E,$02,$62,$08
       00:EF8E: 7A 02 62 5E 
       00:EF92: 6E 02 5C 00 
       00:EF96: 3E 02 62 08 
  2145 00:EF9A: 1A 72 00 00  			.DB	$1A,$72,$00,$00,$78,$72,$76,$70,$34,$12,$86,$00,$78,$72,$76,$0A
       00:EF9E: 78 72 76 70 
       00:EFA2: 34 12 86 00 
       00:EFA6: 78 72 76 0A 
  2146 00:EFAA: 0C 72 72 00  			.DB	$0C,$72,$72,$00,$78,$72,$76,$70,$8A,$72,$88,$00,$7A,$72,$7A,$0A
       00:EFAE: 78 72 76 70 
       00:EFB2: 8A 72 88 00 
  Tue Dec  5 2017  6:27                                                                                                    Page 39


       00:EFB6: 7A 72 7A 0A 
  2147 00:EFBA: 46 42 44 00  			.DB	$46,$42,$44,$00,$46,$42,$44,$70,$7E,$42,$7C,$00,$46,$42,$44,$0A
       00:EFBE: 46 42 44 70 
       00:EFC2: 7E 42 7C 00 
       00:EFC6: 46 42 44 0A 
  2148 00:EFCA: 0E 42 42 00  			.DB	$0E,$42,$42,$00,$46,$42,$44,$70,$28,$42,$84,$00,$46,$42,$44,$0A
       00:EFCE: 46 42 44 70 
       00:EFD2: 28 42 84 00 
       00:EFD6: 46 42 44 0A 
  2149 00:EFDA: 2E 2A 00 00  			.DB	$2E,$2A,$00,$00,$2E,$2A,$30,$70,$3C,$2A,$32,$8C,$2E,$2A,$30,$0A
       00:EFDE: 2E 2A 30 70 
       00:EFE2: 3C 2A 32 8C 
       00:EFE6: 2E 2A 30 0A 
  2150 00:EFEA: 16 2A 2A 00  			.DB	$16,$2A,$2A,$00,$00,$2A,$30,$70,$24,$2A,$52,$74,$00,$2A,$30,$0A
       00:EFEE: 00 2A 30 70 
       00:EFF2: 24 2A 52 74 
       00:EFF6: 00 2A 30 0A 
  2151 00:EFFA: 2C 68 00 00  			.DB	$2C,$68,$00,$00,$2C,$68,$38,$70,$3A,$68,$4A,$00,$2C,$68,$38,$0A
       00:EFFE: 2C 68 38 70 
       00:F002: 3A 68 4A 00 
       00:F006: 2C 68 38 0A 
  2152 00:F00A: 10 68 68 00  			.DB	$10,$68,$68,$00,$00,$68,$38,$70,$6C,$68,$5A,$00,$00,$68,$38,$0A
       00:F00E: 00 68 38 70 
       00:F012: 6C 68 5A 00 
       00:F016: 00 68 38 0A 
  2153                        ;
  2154                        DIS_NMEM	;Mnemonic compressed table
  2155                        ;	Uses two bytes per 3-character Mnemonic. 5-bits per character uses 15-bit total
  2156                        ;	Characters are left to right. 5-bits shifted into A reg, add in $3F and print
  2157                        ;	"?" starts with "00000", "A" starts with "00010", "B" starts with "00011", etc.
  2158                        ;
  2159                        ; A-00010 B-00011 C-00100 D-00101 E-00110 F-00111 G-01000 H-01001 I-01010
  2160                        ; J-01011 K-01100 L-01101 M-01110 N-01111 O-10000 P-10001 Q-10010 R-10011
  2161                        ; S-10100 T-10101 U-10110 V-10111 W-11000 X-11001 Y-11010 Z-11011
  2162 00:F01A: 00 00        			.DBYTE	%0000000000000000	;???	$00
  2163 00:F01C: 11 48        			.DBYTE	%0001000101001000	;ADC	$02
  2164 00:F01E: 13 CA        			.DBYTE	%0001001111001010	;AND	$04
  2165 00:F020: 15 1A        			.DBYTE	%0001010100011010	;ASL	$06
  2166 00:F022: 18 E6        			.DBYTE	%0001100011100110	;BBR	$08
  2167 00:F024: 18 E8        			.DBYTE	%0001100011101000	;BBS	$0A
  2168 00:F026: 19 08        			.DBYTE	%0001100100001000	;BCC	$0C
  2169 00:F028: 19 28        			.DBYTE	%0001100100101000	;BCS	$0E
  2170 00:F02A: 19 A4        			.DBYTE	%0001100110100100	;BEQ	$10
  2171 00:F02C: 1A AA        			.DBYTE	%0001101010101010	;BIT	$12
  2172 00:F02E: 1B 94        			.DBYTE	%0001101110010100	;BMI	$14
  2173 00:F030: 1B CC        			.DBYTE	%0001101111001100	;BNE	$16
  2174 00:F032: 1C 5A        			.DBYTE	%0001110001011010	;BPL	$18
  2175 00:F034: 1C C4        			.DBYTE	%0001110011000100	;BRA	$1A
  2176 00:F036: 1C D8        			.DBYTE	%0001110011011000	;BRK	$1C
  2177 00:F038: 1D C8        			.DBYTE	%0001110111001000	;BVC	$1E
  2178 00:F03A: 1D E8        			.DBYTE	%0001110111101000	;BVS	$20
  2179 00:F03C: 23 48        			.DBYTE	%0010001101001000	;CLC	$22
  2180 00:F03E: 23 4A        			.DBYTE	%0010001101001010	;CLD	$24
  2181 00:F040: 23 54        			.DBYTE	%0010001101010100	;CLI	$26
  2182 00:F042: 23 6E        			.DBYTE	%0010001101101110	;CLV	$28
  2183 00:F044: 23 A2        			.DBYTE	%0010001110100010	;CMP	$2A
  2184 00:F046: 24 72        			.DBYTE	%0010010001110010	;CPX	$2C
  2185 00:F048: 24 74        			.DBYTE	%0010010001110100	;CPY	$2E
  2186 00:F04A: 29 88        			.DBYTE	%0010100110001000	;DEC	$30
  2187 00:F04C: 29 B2        			.DBYTE	%0010100110110010	;DEX	$32
  2188 00:F04E: 29 B4        			.DBYTE	%0010100110110100	;DEY	$34
  2189 00:F050: 34 26        			.DBYTE	%0011010000100110	;EOR	$36
  2190 00:F052: 53 C8        			.DBYTE	%0101001111001000	;INC	$38
  Tue Dec  5 2017  6:27                                                                                                    Page 40


  2191 00:F054: 53 F2        			.DBYTE	%0101001111110010	;INX	$3A
  2192 00:F056: 53 F4        			.DBYTE	%0101001111110100	;INY	$3C
  2193 00:F058: 5B A2        			.DBYTE	%0101101110100010	;JMP	$3E
  2194 00:F05A: 5D 26        			.DBYTE	%0101110100100110	;JSR	$40
  2195 00:F05C: 69 44        			.DBYTE	%0110100101000100	;LDA	$42
  2196 00:F05E: 69 72        			.DBYTE	%0110100101110010	;LDX	$44
  2197 00:F060: 69 74        			.DBYTE	%0110100101110100	;LDY	$46
  2198 00:F062: 6D 26        			.DBYTE	%0110110100100110	;LSR	$48
  2199 00:F064: 7C 22        			.DBYTE	%0111110000100010	;NOP	$4A
  2200 00:F066: 84 C4        			.DBYTE	%1000010011000100	;ORA	$4C
  2201 00:F068: 8A 44        			.DBYTE	%1000101001000100	;PHA	$4E
  2202 00:F06A: 8A 62        			.DBYTE	%1000101001100010	;PHP	$50
  2203 00:F06C: 8A 72        			.DBYTE	%1000101001110010	;PHX	$52
  2204 00:F06E: 8A 74        			.DBYTE	%1000101001110100	;PHY	$54
  2205 00:F070: 8B 44        			.DBYTE	%1000101101000100	;PLA	$56
  2206 00:F072: 8B 62        			.DBYTE	%1000101101100010	;PLP	$58
  2207 00:F074: 8B 72        			.DBYTE	%1000101101110010	;PLX	$5A
  2208 00:F076: 8B 74        			.DBYTE	%1000101101110100	;PLY	$5C
  2209 00:F078: 9B 86        			.DBYTE	%1001101110000110	;RMB	$5E
  2210 00:F07A: 9C 1A        			.DBYTE	%1001110000011010	;ROL	$60
  2211 00:F07C: 9C 26        			.DBYTE	%1001110000100110	;ROR	$62
  2212 00:F07E: 9D 54        			.DBYTE	%1001110101010100	;RTI	$64
  2213 00:F080: 9D 68        			.DBYTE	%1001110101101000	;RTS	$66
  2214 00:F082: A0 C8        			.DBYTE	%1010000011001000	;SBC	$68
  2215 00:F084: A1 88        			.DBYTE	%1010000110001000	;SEC	$6A
  2216 00:F086: A1 8A        			.DBYTE	%1010000110001010	;SED	$6C
  2217 00:F088: A1 94        			.DBYTE	%1010000110010100	;SEI	$6E
  2218 00:F08A: A3 86        			.DBYTE	%1010001110000110	;SMB	$70
  2219 00:F08C: A5 44        			.DBYTE	%1010010101000100	;STA	$72
  2220 00:F08E: A5 62        			.DBYTE	%1010010101100010	;STP	$74
  2221 00:F090: A5 72        			.DBYTE	%1010010101110010	;STX	$76
  2222 00:F092: A5 74        			.DBYTE	%1010010101110100	;STY	$78
  2223 00:F094: A5 76        			.DBYTE	%1010010101110110	;STZ	$7A
  2224 00:F096: A8 B2        			.DBYTE	%1010100010110010	;TAX	$7C
  2225 00:F098: A8 B4        			.DBYTE	%1010100010110100	;TAY	$7E
  2226 00:F09A: AC E8        			.DBYTE	%1010110011101000	;TRB	$80
  2227 00:F09C: AD 06        			.DBYTE	%1010110100000110	;TSB	$82
  2228 00:F09E: AD 32        			.DBYTE	%1010110100110010	;TSX	$84
  2229 00:F0A0: AE 44        			.DBYTE	%1010111001000100	;TXA	$86
  2230 00:F0A2: AE 68        			.DBYTE	%1010111001101000	;TXS	$88
  2231 00:F0A4: AE 84        			.DBYTE	%1010111010000100	;TYA	$8A
  2232 00:F0A6: C0 94        			.DBYTE	%1100000010010100	;WAI	$8C
  2233                        ;
  2234                        ;END OF DISASSEMBLER DATA
  2235                        ;******************************************************************************
  2236                        ;END OF MONITOR DATA
  2237                        					.END


      Lines assembled: 2237
      Errors: 0
