  Thu Sep 26 2019 15:30                                                                                                    Page 1


                                               ***************************************
                                               **      WDC 65C02 Macro Assembler    **
                                               **                                   **
                                               **     Version 3.49.1- Feb  6 2006    **
                                               ***************************************

     1                        ;
     2                        ; Enhanced BASIC for the C02 Pocket SBC, Version 2.22p4C
     3                        ; Original version/source by Lee Davison w/updates to Version 2.22
     4                        ; Patches and updates by Klaus Dorman Version 2.22p4
     5                        ; "C" is appended to define CMOS instructions/addressing modes used
     6                        ; Modified source code to assemble with WDC Tools package
     7                        ; Changes by K. E. Maier - July-November 2018
     8                        ;   minor changes and cleanup as of 13th November 2018
     9                        ;
    10                        ; Additional functions added 25th September 2019
    11                        ;   LOAD/SAVE functions via Xmodem-CRC routines in C02Monitor Version 2.03
    12                        ;
    13                        ;       Assembler/Linker directives for WDC Tools
    14                        ;
    15                                PL      66      ;Page Length
    16                                PW      132     ;Page Width (# of char/line)
    17                                CHIP    W65C02S ;Enable WDC 65C02 instructions/addressing modes
    18                                INCLIST ON      ;Include listing file
    19                                PASS1   OFF     ;Set ON when used for debug
    20                        ;
    21                        ; Code changes include:
    22                        ;  Use ROM based CHRGET/CHRGOT routine with Page Zero pointer
    23                        ;  All Page zero usage is from the bottom ($00) up ($AF is max available)
    24                        ;  CMOS opcodes/addressing modes are used! tested with WDC65C02 only!
    25                        ;  Version renamed to Ver 2.22p4C (concurrency with Klaus' patched version)
    26                        ; The following functions and all associated code (interrupt related)
    27                        ;  have been removed as they aren't needed with the C02 Pocket SBC:
    28                        ; - IRQ
    29                        ; - RETIRQ
    30                        ; - NMI
    31                        ; - RETNMI
    32                        ; - OFF
    33                        ;
    34                        ; An EXIT primary command has been added
    35                        ;  The EXIT command performs a JMP to the C02Monitor Warm start vector
    36                        ;  EhBasic can be re-entered via Warm start unless pages zero/four are changed
    37                        ;
    38                        ; 2.00      new revision numbers start here
    39                        ; 2.01      fixed LCASE$() and UCASE$()
    40                        ; 2.02      new get value routine done
    41                        ; 2.03      changed RND() to galoise method
    42                        ; 2.04      fixed SPC()
    43                        ; 2.05      new get value routine fixed
    44                        ; 2.06      changed USR() code
    45                        ; 2.07      fixed STR$()
    46                        ; 2.08      changed INPUT and READ to remove need for $00 start to input buffer
    47                        ; 2.09      fixed RND()
    48                        ; 2.10      integrated missed changes from an earlier version
    49                        ; 2.20      added ELSE to IF .. THEN and fixed IF .. GOTO <statement> to cause error
    50                        ; 2.21      fixed IF .. THEN RETURN to not cause error
    51                        ; 2.22      fixed RND() breaking the get byte routine
    52                        ; 2.22p     patched to disable use of decimal mode and fix Ibuff issues
    53                        ;              (bugsnquirks.txt notes 2, 4 and 5)
    54                        ;              tabs converted to spaces, tabwidth=6
    55                        ; 2.22p2    fixed can't continue error on 1st statement after direct mode
    56                        ;              changed INPUT to throw "break in line ##" on empty line input
    57                        ; 2.22p3    fixed RAM above code / Ibuff above EhBASIC patch breaks STR$()
  Thu Sep 26 2019 15:30                                                                                                    Page 2


    58                        ;              fix provided by github user mgcaret
    59                        ;              fixed string compare of equal strings in direct mode returns FALSE
    60                        ; 2.22p4    fixed FALSE stored to a variable after a string compare
    61                        ;                 is > 0 and < 1E-16
    62                        ;              added additional stack floor protection for background interrupts
    63                        ;              fixed conditional LOOP & NEXT cannot find their data strucure on stack
    64                        ; 2.22p4C   Port to C02 Pocket SBC - SCC2691 UART Console, 32KB RAM / 32KB ROM, 6MHz CPU
    65                        ;
    66             00000000   ZPSTART         .EQU $00        ; Start of zero page workspace
    67                        ;
    68             00000000   LAB_WARM        .EQU ZPSTART    ; $00=BASIC warm start entry point
    69             00000001   Wrmjpl          .EQU LAB_WARM+1 ; BASIC warm start vector jump low byte
    70             00000002   Wrmjph          .EQU LAB_WARM+2 ; BASIC warm start vector jump high byte
    71                        
    72             00000003   Usrjmp          .EQU Wrmjph+1   ; USR function JMP address
    73             00000004   Usrjpl          .EQU Usrjmp+1   ; USR function JMP vector low byte
    74             00000005   Usrjph          .EQU Usrjmp+2   ; USR function JMP vector high byte
    75                        
    76             00000006   Nullct          .EQU Usrjph+1   ; nulls output after each line
    77             00000007   TPos            .EQU Nullct+1   ; BASIC terminal position byte
    78             00000008   TWidth          .EQU TPos+1     ; BASIC terminal width byte
    79             00000009   Iclim           .EQU TWidth+1   ; input column limit
    80             0000000A   Itempl          .EQU Iclim+1    ; temporary integer low byte
    81             0000000B   Itemph          .EQU Itempl+1   ; temporary integer high byte
    82                        
    83             0000000A   nums_1          .EQU Itempl     ; number to bin/hex string convert MSB
    84             0000000B   nums_2          .EQU nums_1+1   ; number to bin/hex string convert
    85             0000000C   nums_3          .EQU nums_1+2   ; number to bin/hex string convert LSB
    86                        
    87             0000000D   Srchc           .EQU nums_3+1   ; search character
    88             0000000D   Temp3           .EQU Srchc      ; temp byte used in number routines
    89             0000000E   Scnquo          .EQU Srchc+1    ; scan-between-quotes flag
    90             0000000E   Asrch           .EQU Scnquo     ; alt search character
    91                        
    92             0000000D   XOAw_l          .EQU Srchc      ; eXclusive OR, OR and AND word low byte
    93             0000000E   XOAw_h          .EQU Scnquo     ; eXclusive OR, OR and AND word high byte
    94                        
    95             0000000F   Ibptr           .EQU Scnquo+1   ; input buffer pointer
    96             0000000F   Dimcnt          .EQU Ibptr      ; # of dimensions
    97             0000000F   Tindx           .EQU Ibptr      ; token index
    98                        
    99             00000010   Defdim          .EQU Ibptr+1    ; default DIM flag
   100             00000011   Dtypef          .EQU Defdim+1   ; data type flag, $FF=string, $00=numeric
   101             00000012   Oquote          .EQU Dtypef+1   ; open quote flag (b7) (Flag: DATA scan; LIST quote; memory)
   102             00000012   Gclctd          .EQU Oquote     ; garbage collected flag
   103             00000013   Sufnxf          .EQU Gclctd+1   ; subscript/FNX flag, 1xxx xxx = FN(0xxx xxx)
   104             00000014   Imode           .EQU Sufnxf+1   ; input mode flag, $00=INPUT, $80=READ
   105                        
   106             00000015   Cflag           .EQU Imode+1    ; comparison evaluation flag
   107                        
   108             00000016   TabSiz          .EQU Cflag+1    ; TAB step size (was input flag)
   109                        
   110             00000017   next_s          .EQU TabSiz+1   ; next descriptor stack address
   111                        
   112                        ; these two bytes form a word pointer to the item
   113                        ; currently on top of the descriptor stack
   114                        
   115             00000018   last_sl         .EQU next_s+1   ; last descriptor stack address low byte
   116             00000019   last_sh         .EQU last_sl+1  ; last descriptor stack address high byte (always $00)
   117                        
   118             0000001A   des_sk          .EQU last_sh+1  ; descriptor stack start address (temp strings)
   119                        
   120             00000023   ut1_pl          .EQU des_sk+9   ; utility pointer 1 low byte
  Thu Sep 26 2019 15:30                                                                                                    Page 3


   121             00000024   ut1_ph          .EQU ut1_pl+1   ; utility pointer 1 high byte
   122             00000025   ut2_pl          .EQU ut1_ph+1   ; utility pointer 2 low byte
   123             00000026   ut2_ph          .EQU ut2_pl+1   ; utility pointer 2 high byte
   124                        
   125             00000023   Temp_2          .EQU ut1_pl     ; temp byte for block move
   126                        
   127             00000027   FACt_1          .EQU ut2_ph+1   ; FAC temp mantissa1
   128             00000028   FACt_2          .EQU FACt_1+1   ; FAC temp mantissa2
   129             00000029   FACt_3          .EQU FACt_2+1   ; FAC temp mantissa3
   130                        
   131             00000028   dims_l          .EQU FACt_2     ; array dimension size low byte
   132             00000029   dims_h          .EQU FACt_3     ; array dimension size high byte
   133                        
   134             0000002A   TempB           .EQU FACt_1+3   ; temp page 0 byte
   135                        
   136             0000002B   Smeml           .EQU TempB+1    ; start of mem low byte         (Start-of-Basic)
   137             0000002C   Smemh           .EQU Smeml+1    ; start of mem high byte        (Start-of-Basic)
   138             0000002D   Svarl           .EQU Smemh+1    ; start of vars low byte        (Start-of-Variables)
   139             0000002E   Svarh           .EQU Svarl+1    ; start of vars high byte       (Start-of-Variables)
   140             0000002F   Sarryl          .EQU Svarh+1    ; var mem end low byte          (Start-of-Arrays)
   141             00000030   Sarryh          .EQU Sarryl+1   ; var mem end high byte         (Start-of-Arrays)
   142             00000031   Earryl          .EQU Sarryh+1   ; array mem end low byte        (End-of-Arrays)
   143             00000032   Earryh          .EQU Earryl+1   ; array mem end high byte       (End-of-Arrays)
   144             00000033   Sstorl          .EQU Earryh+1   ; string storage low byte       (String storage (moving down))
   145             00000034   Sstorh          .EQU Sstorl+1   ; string storage high byte      (String storage (moving down))
   146             00000035   Sutill          .EQU Sstorh+1   ; string utility ptr low byte
   147             00000036   Sutilh          .EQU Sutill+1   ; string utility ptr high byte
   148             00000037   Ememl           .EQU Sutilh+1   ; end of mem low byte           (Limit-of-memory)
   149             00000038   Ememh           .EQU Ememl+1    ; end of mem high byte          (Limit-of-memory)
   150             00000039   Clinel          .EQU Ememh+1    ; current line low byte         (Basic line number)
   151             0000003A   Clineh          .EQU Clinel+1   ; current line high byte        (Basic line number)
   152             0000003B   Blinel          .EQU Clineh+1   ; break line low byte           (Previous Basic line number)
   153             0000003C   Blineh          .EQU Blinel+1   ; break line high byte          (Previous Basic line number)
   154                        
   155             0000003D   Cpntrl          .EQU Blineh+1   ; continue pointer low byte
   156             0000003E   Cpntrh          .EQU Cpntrl+1   ; continue pointer high byte
   157                        
   158             0000003F   Dlinel          .EQU Cpntrh+1   ; current DATA line low byte
   159             00000040   Dlineh          .EQU Dlinel+1   ; current DATA line high byte
   160                        
   161             00000041   Dptrl           .EQU Dlineh+1   ; DATA pointer low byte
   162             00000042   Dptrh           .EQU Dptrl+1    ; DATA pointer high byte
   163                        
   164             00000043   Rdptrl          .EQU Dptrh+1    ; read pointer low byte
   165             00000044   Rdptrh          .EQU Rdptrl+1   ; read pointer high byte
   166                        
   167             00000045   Varnm1          .EQU Rdptrh+1   ; current var name 1st byte
   168             00000046   Varnm2          .EQU Varnm1+1   ; current var name 2nd byte
   169                        
   170             00000047   Cvaral          .EQU Varnm2+1   ; current var address low byte
   171             00000048   Cvarah          .EQU Cvaral+1   ; current var address high byte
   172                        
   173             00000049   Frnxtl          .EQU Cvarah+1   ; var pointer for FOR/NEXT low byte
   174             0000004A   Frnxth          .EQU Frnxtl+1   ; var pointer for FOR/NEXT high byte
   175                        
   176             00000049   Tidx1           .EQU Frnxtl     ; temp line index
   177                        
   178             00000049   Lvarpl          .EQU Frnxtl     ; let var pointer low byte
   179             0000004A   Lvarph          .EQU Frnxth     ; let var pointer high byte
   180                        
   181             0000004B   prstk           .EQU Frnxtl+2   ; precedence stacked flag
   182                        
   183             0000004D   comp_f          .EQU prstk+2    ; compare function flag, bits 0,1 and 2 used
  Thu Sep 26 2019 15:30                                                                                                    Page 4


   184                                                        ; bit 2 set if >
   185                                                        ; bit 1 set if =
   186                                                        ; bit 0 set if <
   187                        
   188             0000004E   func_l          .EQU comp_f+1   ; function pointer low byte
   189             0000004F   func_h          .EQU func_l+1   ; function pointer high byte
   190                        
   191             0000004E   garb_l          .EQU func_l     ; garbage collection working pointer low byte
   192             0000004F   garb_h          .EQU func_h     ; garbage collection working pointer high byte
   193                        
   194             00000050   des_2l          .EQU func_h+1   ; string descriptor_2 pointer low byte
   195             00000051   des_2h          .EQU des_2l+1   ; string descriptor_2 pointer high byte
   196                        
   197             00000052   g_step          .EQU des_2l+2   ; garbage collect step size
   198                        
   199             00000053   Fnxjmp          .EQU g_step+1   ; jump vector for functions
   200             00000054   Fnxjpl          .EQU Fnxjmp+1   ; functions jump vector low byte
   201             00000055   Fnxjph          .EQU Fnxjmp+2   ; functions jump vector high byte
   202                        
   203             00000054   g_indx          .EQU Fnxjpl     ; garbage collect temp index
   204                        
   205             00000055   FAC2_r          .EQU Fnxjmp+2   ; FAC2 rounding byte
   206                        
   207             00000056   Adatal          .EQU FAC2_r+1   ; array data pointer low byte
   208             00000057   Adatah          .EQU Adatal+1   ; array data pointer high byte
   209                        
   210             00000056   Nbendl          .EQU Adatal     ; new block end pointer low byte
   211             00000057   Nbendh          .EQU Adatah     ; new block end pointer high byte
   212                        
   213             00000058   Obendl          .EQU Adatah+1   ; old block end pointer low byte
   214             00000059   Obendh          .EQU Obendl+1   ; old block end pointer high byte
   215                        
   216             0000005A   numexp          .EQU Obendh+1   ; string to float number exponent count
   217             0000005B   expcnt          .EQU numexp+1   ; string to float exponent count
   218                        
   219             0000005A   numbit          .EQU numexp     ; bit count for array element calculations
   220                        
   221             0000005C   numdpf          .EQU expcnt+1   ; string to float decimal point flag
   222             0000005D   expneg          .EQU numdpf+1   ; string to float eval exponent -ve flag
   223                        
   224             0000005C   Astrtl          .EQU numdpf     ; array start pointer low byte
   225             0000005D   Astrth          .EQU expneg     ; array start pointer high byte
   226                        
   227             0000005C   Histrl          .EQU numdpf     ; highest string low byte
   228             0000005D   Histrh          .EQU expneg     ; highest string high byte
   229                        
   230             0000005C   Baslnl          .EQU numdpf     ; BASIC search line pointer low byte
   231             0000005D   Baslnh          .EQU expneg     ; BASIC search line pointer high byte
   232                        
   233             0000005C   Fvar_l          .EQU numdpf     ; find/found variable pointer low byte
   234             0000005D   Fvar_h          .EQU expneg     ; find/found variable pointer high byte
   235                        
   236             0000005C   Ostrtl          .EQU numdpf     ; old block start pointer low byte
   237             0000005D   Ostrth          .EQU expneg     ; old block start pointer high byte
   238                        
   239             0000005C   Vrschl          .EQU numdpf     ; variable search pointer low byte
   240             0000005D   Vrschh          .EQU expneg     ; variable search pointer high byte
   241                        
   242             0000005E   FAC1_e          .EQU expneg+1   ; FAC1 exponent
   243             0000005F   FAC1_1          .EQU FAC1_e+1   ; FAC1 mantissa1
   244             00000060   FAC1_2          .EQU FAC1_e+2   ; FAC1 mantissa2
   245             00000061   FAC1_3          .EQU FAC1_e+3   ; FAC1 mantissa3
   246             00000062   FAC1_s          .EQU FAC1_e+4   ; FAC1 sign (b7)
  Thu Sep 26 2019 15:30                                                                                                    Page 5


   247                        
   248             0000005E   str_ln          .EQU FAC1_e     ; string length
   249             0000005F   str_pl          .EQU FAC1_1     ; string pointer low byte
   250             00000060   str_ph          .EQU FAC1_2     ; string pointer high byte
   251                        
   252             00000060   des_pl          .EQU FAC1_2     ; string descriptor pointer low byte
   253             00000061   des_ph          .EQU FAC1_3     ; string descriptor pointer high byte
   254                        
   255             00000061   mids_l          .EQU FAC1_3     ; MID$ string temp length byte
   256                        
   257             00000063   negnum          .EQU FAC1_e+5   ; string to float eval -ve flag
   258             00000063   numcon          .EQU negnum     ; series evaluation constant count
   259                        
   260             00000064   FAC1_o          .EQU negnum+1   ; FAC1 overflow byte
   261                        
   262             00000065   FAC2_e          .EQU FAC1_o+1   ; FAC2 exponent
   263             00000066   FAC2_1          .EQU FAC2_e+1   ; FAC2 mantissa1
   264             00000067   FAC2_2          .EQU FAC2_e+2   ; FAC2 mantissa2
   265             00000068   FAC2_3          .EQU FAC2_e+3   ; FAC2 mantissa3
   266             00000069   FAC2_s          .EQU FAC2_e+4   ; FAC2 sign (b7)
   267                        
   268             0000006A   FAC_sc          .EQU FAC2_e+5   ; FAC sign comparison, Acc#1 vs #2
   269             0000006B   FAC1_r          .EQU FAC_sc+1   ; FAC1 rounding byte
   270                        
   271             0000006A   ssptr_l         .EQU FAC_sc     ; string start pointer low byte
   272             0000006B   ssptr_h         .EQU FAC1_r     ; string start pointer high byte
   273                        
   274             0000006A   sdescr          .EQU FAC_sc     ; string descriptor pointer
   275                        
   276             0000006C   csidx           .EQU FAC1_r+1   ; line crunch save index
   277             0000006C   Asptl           .EQU csidx      ; array size/pointer low byte
   278             0000006D   Aspth           .EQU csidx+1    ; array size/pointer high byte
   279                        
   280             0000006C   Btmpl           .EQU Asptl      ; BASIC pointer temp low byte
   281             0000006D   Btmph           .EQU Aspth      ; BASIC pointer temp low byte
   282                        
   283             0000006C   Cptrl           .EQU Asptl      ; BASIC pointer temp low byte
   284             0000006D   Cptrh           .EQU Aspth      ; BASIC pointer temp low byte
   285                        
   286             0000006C   Sendl           .EQU Asptl      ; BASIC pointer temp low byte
   287             0000006D   Sendh           .EQU Aspth      ; BASIC pointer temp low byte
   288                        ;
   289                        ; CHRGET/CHRGOT routine now located in ROM
   290                        ; The two pointers below are accessed via ROM
   291                        ; Reduces Page zero usage by quite a bit with a minor performance penalty
   292                        ; CMOS addressing mode used, saves memory and execution time
   293                        ;
   294             0000006E   Bpntrl          .EQU Sendh+1    ; BASIC execute (get byte) pointer low byte
   295             0000006F   Bpntrh          .EQU Bpntrl+1   ; BASIC execute (get byte) pointer high byte
   296                        
   297             00000070   Rbyte4          .EQU Bpntrh+1   ; extra PRNG byte
   298                        
   299             00000071   Rbyte1          .EQU Rbyte4+1   ; most significant PRNG byte
   300             00000072   Rbyte2          .EQU Rbyte4+2   ; middle PRNG byte
   301             00000073   Rbyte3          .EQU Rbyte4+3   ; least significant PRNG byte
   302                        
   303             00000074   Decss           .EQU Rbyte3+1   ; number to decimal string start
   304             00000075   Decssp1         .EQU Decss+1    ; number to decimal string start
   305             00000085   ZPLastByte      .EQU Decss+17   ; last declared byte in Page Zero
   306                        
   307                        ; Note: C02BIOS uses Page Zero locations from $E0 - $FF
   308                        ; C02Monitor uses Page Zero locations from $B0 - $DF
   309                        
  Thu Sep 26 2019 15:30                                                                                                    Page 6


   310                        ; add page zero variables for Xmodem transfer using the C02 Monitor routines
   311                        
   312             000000B0   PGZERO_ST       .EQU $B0               ;Start of Page Zero usage (C02 Monitor)
   313                        
   314             000000C8   SRCL            .EQU PGZERO_ST+24      ;Source address for memory operations
   315             000000C9   SRCH            .EQU PGZERO_ST+25
   316             000000CA   TGTL            .EQU PGZERO_ST+26      ;Target address for memory operations
   317             000000CB   TGTH            .EQU PGZERO_ST+27
   318             000000CC   LENL            .EQU PGZERO_ST+28      ;Length address for memory operations
   319             000000CD   LENH            .EQU PGZERO_ST+29
   320                        
   321             000000D6   OPXMDM          .EQU PGZERO_ST+38      ;Saved Opcode/Xmodem Flag variable
   322             000000DA   PTRL            .EQU PGZERO_ST+42      ;Data pointer lo byte
   323             000000DB   PTRH            .EQU PGZERO_ST+43      ;Data pointer hi byte
   324             000000DC   BLKNO           .EQU PGZERO_ST+44      ;Block number
   325                        
   326                        ; Note: C02BIOS uses Page Zero locations from $E0 - $FF
   327                        ; C02Monitor uses Page Zero locations from $B0 - $DF
   328                        
   329                        ; token values needed for BASIC
   330                        
   331                        ; primary command tokens (can start a statement)
   332                        
   333             00000080   TK_END            .EQU $80             ; END token
   334             00000081   TK_FOR            .EQU TK_END+1        ; FOR token
   335             00000082   TK_NEXT           .EQU TK_FOR+1        ; NEXT token
   336             00000083   TK_DATA           .EQU TK_NEXT+1       ; DATA token
   337             00000084   TK_INPUT          .EQU TK_DATA+1       ; INPUT token
   338             00000085   TK_DIM            .EQU TK_INPUT+1      ; DIM token
   339             00000086   TK_READ           .EQU TK_DIM+1        ; READ token
   340             00000087   TK_LET            .EQU TK_READ+1       ; LET token
   341             00000088   TK_DEC            .EQU TK_LET+1        ; DEC token
   342             00000089   TK_GOTO           .EQU TK_DEC+1        ; GOTO token
   343             0000008A   TK_RUN            .EQU TK_GOTO+1       ; RUN token
   344             0000008B   TK_IF             .EQU TK_RUN+1        ; IF token
   345             0000008C   TK_RESTORE        .EQU TK_IF+1         ; RESTORE token
   346             0000008D   TK_GOSUB          .EQU TK_RESTORE+1    ; GOSUB token
   347             0000008E   TK_RETURN         .EQU TK_GOSUB+1      ; RETURN token
   348             0000008F   TK_REM            .EQU TK_RETURN+1     ; REM token
   349             00000090   TK_STOP           .EQU TK_REM+1        ; STOP token
   350             00000091   TK_ON             .EQU TK_STOP+1       ; ON token
   351             00000092   TK_NULL           .EQU TK_ON+1         ; NULL token
   352             00000093   TK_INC            .EQU TK_NULL+1       ; INC token
   353             00000094   TK_WAIT           .EQU TK_INC+1        ; WAIT token
   354             00000095   TK_LOAD           .EQU TK_WAIT+1       ; LOAD token
   355             00000096   TK_SAVE           .EQU TK_LOAD+1       ; SAVE token
   356             00000097   TK_DEF            .EQU TK_SAVE+1       ; DEF token
   357             00000098   TK_POKE           .EQU TK_DEF+1        ; POKE token
   358             00000099   TK_DOKE           .EQU TK_POKE+1       ; DOKE token
   359             0000009A   TK_CALL           .EQU TK_DOKE+1       ; CALL token
   360             0000009B   TK_DO             .EQU TK_CALL+1       ; DO token
   361             0000009C   TK_LOOP           .EQU TK_DO+1         ; LOOP token
   362             0000009D   TK_PRINT          .EQU TK_LOOP+1       ; PRINT token
   363             0000009E   TK_CONT           .EQU TK_PRINT+1      ; CONT token
   364             0000009F   TK_LIST           .EQU TK_CONT+1       ; LIST token
   365             000000A0   TK_CLEAR          .EQU TK_LIST+1       ; CLEAR token
   366             000000A1   TK_NEW            .EQU TK_CLEAR+1      ; NEW token
   367             000000A2   TK_WIDTH          .EQU TK_NEW+1        ; WIDTH token
   368             000000A3   TK_GET            .EQU TK_WIDTH+1      ; GET token
   369             000000A4   TK_SWAP           .EQU TK_GET+1        ; SWAP token
   370             000000A5   TK_BITSET         .EQU TK_SWAP+1       ; BITSET token
   371             000000A6   TK_BITCLR         .EQU TK_BITSET+1     ; BITCLR token
   372             000000A7   TK_EXIT           .EQU TK_BITCLR+1     ; EXIT token
  Thu Sep 26 2019 15:30                                                                                                    Page 7


   373                        
   374                        ; secondary command tokens, can't start a statement
   375                        
   376             000000A8   TK_TAB            .EQU TK_EXIT+1       ; TAB token
   377             000000A9   TK_ELSE           .EQU TK_TAB+1        ; ELSE token
   378             000000AA   TK_TO             .EQU TK_ELSE+1       ; TO token
   379             000000AB   TK_FN             .EQU TK_TO+1         ; FN token
   380             000000AC   TK_SPC            .EQU TK_FN+1         ; SPC token
   381             000000AD   TK_THEN           .EQU TK_SPC+1        ; THEN token
   382             000000AE   TK_NOT            .EQU TK_THEN+1       ; NOT token
   383             000000AF   TK_STEP           .EQU TK_NOT+1        ; STEP token
   384             000000B0   TK_UNTIL          .EQU TK_STEP+1       ; UNTIL token
   385             000000B1   TK_WHILE          .EQU TK_UNTIL+1      ; WHILE token
   386                        
   387                        ; operator tokens
   388                        
   389             000000B2   TK_PLUS           .EQU TK_WHILE+1      ; + token
   390             000000B3   TK_MINUS          .EQU TK_PLUS+1       ; - token
   391             000000B4   TK_MUL            .EQU TK_MINUS+1      ; * token
   392             000000B5   TK_DIV            .EQU TK_MUL+1        ; / token
   393             000000B6   TK_POWER          .EQU TK_DIV+1        ; ^ token
   394             000000B7   TK_AND            .EQU TK_POWER+1      ; AND token
   395             000000B8   TK_EOR            .EQU TK_AND+1        ; EOR token
   396             000000B9   TK_OR             .EQU TK_EOR+1        ; OR token
   397             000000BA   TK_RSHIFT         .EQU TK_OR+1         ; RSHIFT token
   398             000000BB   TK_LSHIFT         .EQU TK_RSHIFT+1     ; LSHIFT token
   399             000000BC   TK_GT             .EQU TK_LSHIFT+1     ; > token
   400             000000BD   TK_EQUAL          .EQU TK_GT+1         ; = token
   401             000000BE   TK_LT             .EQU TK_EQUAL+1      ; < token
   402                        
   403                        ; function tokens
   404                        
   405             000000BF   TK_SGN            .EQU TK_LT+1         ; SGN token
   406             000000C0   TK_INT            .EQU TK_SGN+1        ; INT token
   407             000000C1   TK_ABS            .EQU TK_INT+1        ; ABS token
   408             000000C2   TK_USR            .EQU TK_ABS+1        ; USR token
   409             000000C3   TK_FRE            .EQU TK_USR+1        ; FRE token
   410             000000C4   TK_POS            .EQU TK_FRE+1        ; POS token
   411             000000C5   TK_SQR            .EQU TK_POS+1        ; SQR token
   412             000000C6   TK_RND            .EQU TK_SQR+1        ; RND token
   413             000000C7   TK_LOG            .EQU TK_RND+1        ; LOG token
   414             000000C8   TK_EXP            .EQU TK_LOG+1        ; EXP token
   415             000000C9   TK_COS            .EQU TK_EXP+1        ; COS token
   416             000000CA   TK_SIN            .EQU TK_COS+1        ; SIN token
   417             000000CB   TK_TAN            .EQU TK_SIN+1        ; TAN token
   418             000000CC   TK_ATN            .EQU TK_TAN+1        ; ATN token
   419             000000CD   TK_PEEK           .EQU TK_ATN+1        ; PEEK token
   420             000000CE   TK_DEEK           .EQU TK_PEEK+1       ; DEEK token
   421             000000CF   TK_SADD           .EQU TK_DEEK+1       ; SADD token
   422             000000D0   TK_LEN            .EQU TK_SADD+1       ; LEN token
   423             000000D1   TK_STRS           .EQU TK_LEN+1        ; STR$ token
   424             000000D2   TK_VAL            .EQU TK_STRS+1       ; VAL token
   425             000000D3   TK_ASC            .EQU TK_VAL+1        ; ASC token
   426             000000D4   TK_UCASES         .EQU TK_ASC+1        ; UCASE$ token
   427             000000D5   TK_LCASES         .EQU TK_UCASES+1     ; LCASE$ token
   428             000000D6   TK_CHRS           .EQU TK_LCASES+1     ; CHR$ token
   429             000000D7   TK_HEXS           .EQU TK_CHRS+1       ; HEX$ token
   430             000000D8   TK_BINS           .EQU TK_HEXS+1       ; BIN$ token
   431             000000D9   TK_BITTST         .EQU TK_BINS+1       ; BITTST token
   432             000000DA   TK_MAX            .EQU TK_BITTST+1     ; MAX token
   433             000000DB   TK_MIN            .EQU TK_MAX+1        ; MIN token
   434             000000DC   TK_PI             .EQU TK_MIN+1        ; PI token
   435             000000DD   TK_TWOPI          .EQU TK_PI+1         ; TWOPI token
  Thu Sep 26 2019 15:30                                                                                                    Page 8


   436             000000DE   TK_VPTR           .EQU TK_TWOPI+1      ; VARPTR token
   437             000000DF   TK_LEFTS          .EQU TK_VPTR+1       ; LEFT$ token
   438             000000E0   TK_RIGHTS         .EQU TK_LEFTS+1      ; RIGHT$ token
   439             000000E1   TK_MIDS           .EQU TK_RIGHTS+1     ; MID$ token
   440                        
   441                        ; offsets from a base of X or Y
   442                        
   443             00000000   PLUS_0            .EQU $00       ; X or Y plus 0
   444             00000001   PLUS_1            .EQU $01       ; X or Y plus 1
   445             00000002   PLUS_2            .EQU $02       ; X or Y plus 2
   446             00000003   PLUS_3            .EQU $03       ; X or Y plus 3
   447                        
   448             00000014   STACK_RES         .EQU #20       ; reserved stack space
   449                        
   450             00000100   LAB_STAK          .EQU $0100     ; stack bottom, no offset
   451                        
   452             000001FE   LAB_SKFE          .EQU LAB_STAK+$FE
   453                                                         ; flushed stack address
   454             000001FF   LAB_SKFF          .EQU LAB_STAK+$FF
   455                                                         ; flushed stack address
   456                        
   457                        ; Ibuffs can now be anywhere in RAM, ensure that the max length is < $80,
   458                        ; the input buffer must not cross a page boundary and must not overlap with
   459                        ; program RAM pages!
   460                        
   461             00000400   Ibuffs            .EQU $0400     ; Start of input buffer
   462             0000047E   Ibuffe            .EQU $0400+$7E ; end of input buffer (127 bytes)
   463                        
   464             0000047F   ccflag            .EQU Ibuffe+1  ; BASIC CTRL-C flag, 00 = enabled, 01 = dis
   465             00000480   ccbyte            .EQU ccflag+1  ; BASIC CTRL-C byte
   466             00000481   ccnull            .EQU ccbyte+1  ; BASIC CTRL-C byte timeout
   467                        
   468             00000482   VEC_CC            .EQU ccnull+1  ; CTRL-C check vector
   469                        
   470             00000484   VEC_IN            .EQU VEC_CC+2  ; input vector
   471             00000486   VEC_OUT           .EQU VEC_IN+2  ; output vector
   472             00000488   VEC_LD            .EQU VEC_OUT+2 ; load vector
   473             0000048A   VEC_SV            .EQU VEC_LD+2  ; save vector
   474             0000048C   VEC_EXIT          .EQU VEC_SV+2  ; exit vector
   475                        
   476             00000800   Ram_base          .EQU $0800     ; start of user RAM (1st 2KB used/reserved)
   477             00008000   Ram_top           .EQU $8000     ; end of user RAM+1 ($8000 is start of ROM)
   478                        
   479                        ; The start address can be changed, noting the BIOS/Monitor locations
   480                        
   481                              .ORG    $B000              ; Start of Basic in ROM
   482                                                         ; C02Monitor starts at $E000
   483                                                         ; C02BIOS starts at $F800
   484                        
   485                        ; BASIC cold start entry point
   486                        
   487                        ; new page $04 initialisation, copy ROM data to RAM
   488                        ; consists of the vectors Input/Output/Load/Save/Exit
   489                        ; and Control-C flags, pointers
   490                        
   491                        LAB_COLD
   492 00:B000: A2 0E              LDX   #PG4_TABE-PG4_TABS-1 ; byte count-1
   493                        LAB_2D13
   494 00:B002: BD 46 D0           LDA   PG4_TABS,X           ; get byte
   495 00:B005: 9D 7F 04           STA   ccflag,X             ; store in page 4
   496 00:B008: CA                 DEX                        ; decrement count
   497 00:B009: 10 F7              BPL   LAB_2D13             ; loop if not done
   498                        
  Thu Sep 26 2019 15:30                                                                                                    Page 9


   499 00:B00B: 9A                 TXS                        ; reset stack pointer (X Reg = $FF from above)
   500 00:B00C: 86 3A              STX   Clineh               ; set current line high byte (set immediate mode)
   501                        
   502 00:B00E: A9 4C              LDA   #$4C                 ; code for JMP
   503 00:B010: 85 53              STA   Fnxjmp               ; save for jump vector for functions
   504                        
   505                        ; copy block from StrTab to $0000 - $0012
   506                        
   507                        LAB_GMEM
   508 00:B012: A2 0B              LDX   #EndTab-StrTab-1  ; set byte count-1
   509                        TabLoop
   510 00:B014: BD 55 D0           LDA   StrTab,X          ; get byte from table
   511 00:B017: 95 00              STA   PLUS_0,X          ; save byte in page zero
   512 00:B019: CA                 DEX                     ; decrement count
   513 00:B01A: 10 F8              BPL   TabLoop           ; loop until done
   514                        
   515                        ; set-up start values
   516                        
   517 00:B01C: 64 64              STZ   FAC1_o            ; clear FAC1 overflow byte
   518 00:B01E: 64 19              STZ   last_sh           ; clear descriptor stack top item pointer high byte
   519                        
   520 00:B020: A9 0E              LDA   #$0E              ; set default tab size
   521 00:B022: 85 16              STA   TabSiz            ; save it
   522 00:B024: A9 03              LDA   #$03              ; set garbage collect step size for descriptor stack
   523 00:B026: 85 52              STA   g_step            ; save it
   524 00:B028: A2 1A              LDX   #des_sk           ; descriptor stack start
   525 00:B02A: 86 17              STX   next_s            ; set descriptor stack pointer
   526                        
   527                        ; bypass user memory prompt, just test, show and go
   528                        ; we get here with Itempl/h = Ram_base
   529                        
   530                        LAB_2D93
   531 00:B02C: A9 55              LDA   #$55              ; set test byte
   532 00:B02E: 92 0A              STA   (Itempl)          ; save via temporary integer
   533 00:B030: D2 0A              CMP   (Itempl)          ; compare via temporary integer
   534 00:B032: D0 1B              BNE   LAB_2DB6          ; branch if fail
   535                        
   536 00:B034: 0A                 ASL                     ; shift test byte left (now $AA)
   537 00:B035: 92 0A              STA   (Itempl)          ; save via temporary integer
   538 00:B037: D2 0A              CMP   (Itempl)          ; compare via temporary integer
   539 00:B039: D0 14              BNE   LAB_2DB6          ; branch if fail
   540                        
   541 00:B03B: A9 00              LDA   #$00              ; get zero
   542 00:B03D: 92 0A              STA   (Itempl)          ; clear tested byte
   543 00:B03F: D2 0A              CMP   (Itempl)          ; compare via temporary integer
   544 00:B041: D0 0C              BNE   LAB_2DB6          ; branch if fail
   545                        
   546 00:B043: E6 0A              INC   Itempl            ; increment temporary integer low byte
   547 00:B045: D0 E5              BNE   LAB_2D93          ; branch if no overflow
   548                        
   549 00:B047: E6 0B              INC   Itemph            ; increment temporary integer high byte
   550 00:B049: A5 0B              LDA   Itemph            ; get high byte
   551 00:B04B: C9 80              CMP   #>Ram_top         ; compare with top of RAM+1
   552 00:B04D: D0 DD              BNE   LAB_2D93          ; branch and continue testing RAM
   553                        
   554                        LAB_2DB6
   555 00:B04F: A5 0A              LDA   Itempl            ; get temporary integer low byte
   556 00:B051: A4 0B              LDY   Itemph            ; get temporary integer high byte ($00)
   557                        
   558 00:B053: 85 37              STA   Ememl             ; set end of mem low byte
   559 00:B055: 84 38              STY   Ememh             ; set end of mem high byte
   560 00:B057: 85 33              STA   Sstorl            ; set bottom of string space low byte
   561 00:B059: 84 34              STY   Sstorh            ; set bottom of string space high byte
  Thu Sep 26 2019 15:30                                                                                                    Page 10


   562                        
   563 00:B05B: A0 00              LDY   #<Ram_base        ; set start addr low byte
   564 00:B05D: A2 08              LDX   #>Ram_base        ; set start addr high byte
   565 00:B05F: 84 2B              STY   Smeml             ; save start of mem low byte
   566 00:B061: 86 2C              STX   Smemh             ; save start of mem high byte
   567 00:B063: E6 2B              INC   Smeml             ; increment start of mem low byte
   568                        
   569 00:B065: 20 37 B8           JSR   LAB_CRLF          ; print CR/LF
   570 00:B068: 20 24 B3           JSR   LAB_1463          ; do "NEW" and "CLEAR"
   571 00:B06B: A5 37              LDA   Ememl             ; get end of mem low byte
   572 00:B06D: 38                 SEC                     ; set carry for subtract
   573 00:B06E: E5 2B              SBC   Smeml             ; subtract start of mem low byte
   574 00:B070: AA                 TAX                     ; copy to X
   575 00:B071: A5 38              LDA   Ememh             ; get end of mem high byte
   576 00:B073: E5 2C              SBC   Smemh             ; subtract start of mem high byte
   577 00:B075: 20 F4 C9           JSR   LAB_295E          ; print XA as unsigned integer (bytes free)
   578 00:B078: A9 61              LDA   #<LAB_SMSG        ; point to sign-on message (low addr)
   579 00:B07A: A0 D0              LDY   #>LAB_SMSG        ; point to sign-on message (high addr)
   580 00:B07C: 20 78 B8           JSR   LAB_18C3          ; print null terminated string from memory
   581 00:B07F: A9 25              LDA   #<LAB_1274        ; warm start vector low byte
   582 00:B081: A0 B1              LDY   #>LAB_1274        ; warm start vector high byte
   583 00:B083: 85 01              STA   Wrmjpl            ; save warm start vector low byte
   584 00:B085: 84 02              STY   Wrmjph            ; save warm start vector high byte
   585 00:B087: 6C 01 00           JMP   (Wrmjpl)          ; jump to warm start
   586                        
   587                        ; open up space in memory
   588                        ; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
   589                        
   590                        ; Nbendl,Nbendh - new block end address (A/Y)
   591                        ; Obendl,Obendh - old block end address
   592                        ; Ostrtl,Ostrth - old block start address
   593                        
   594                        ; returns with ..
   595                        
   596                        ; Nbendl,Nbendh - new block start address (high byte - $100)
   597                        ; Obendl,Obendh - old block start address (high byte - $100)
   598                        ; Ostrtl,Ostrth - old block start address (unchanged)
   599                        
   600                        LAB_11CF
   601 00:B08A: 20 D7 B0           JSR   LAB_121F          ; check available memory, "Out of memory" error if no room
   602                                                      ; addr to check is in AY (low/high)
   603 00:B08D: 85 31              STA   Earryl            ; save new array mem end low byte
   604 00:B08F: 84 32              STY   Earryh            ; save new array mem end high byte
   605                        
   606                        ; open up space in memory
   607                        ; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
   608                        ; don't set array end
   609                        
   610                        LAB_11D6
   611 00:B091: 38                 SEC                     ; set carry for subtract
   612 00:B092: A5 58              LDA   Obendl            ; get block end low byte
   613 00:B094: E5 5C              SBC   Ostrtl            ; subtract block start low byte
   614 00:B096: A8                 TAY                     ; copy MOD(block length/$100) byte to Y
   615 00:B097: A5 59              LDA   Obendh            ; get block end high byte
   616 00:B099: E5 5D              SBC   Ostrth            ; subtract block start high byte
   617 00:B09B: AA                 TAX                     ; copy block length high byte to X
   618 00:B09C: E8                 INX                     ; +1 to allow for count=0 exit
   619 00:B09D: 98                 TYA                     ; copy block length low byte to A
   620 00:B09E: F0 24              BEQ   LAB_120A          ; branch if length low byte=0
   621                        
   622                                                      ; block is (X-1)*256+Y bytes, do the Y bytes first
   623 00:B0A0: 38                 SEC                     ; set carry for add + 1, two's complement
   624 00:B0A1: 49 FF              EOR   #$FF              ; invert low byte for subtract
  Thu Sep 26 2019 15:30                                                                                                    Page 11


   625 00:B0A3: 65 58              ADC   Obendl            ; add block end low byte
   626 00:B0A5: 85 58              STA   Obendl            ; save corrected old block end low byte
   627 00:B0A7: B0 03              BCS   LAB_11F3          ; branch if no underflow
   628 00:B0A9: C6 59              DEC   Obendh            ; else decrement block end high byte
   629 00:B0AB: 38                 SEC                     ; set carry for add + 1, two's complement
   630                        LAB_11F3
   631 00:B0AC: 98                 TYA                     ; get MOD(block length/$100) byte
   632 00:B0AD: 49 FF              EOR   #$FF              ; invert low byte for subtract
   633 00:B0AF: 65 56              ADC   Nbendl            ; add destination end low byte
   634 00:B0B1: 85 56              STA   Nbendl            ; save modified new block end low byte
   635 00:B0B3: B0 08              BCS   LAB_1203          ; branch if no underflow
   636 00:B0B5: C6 57              DEC   Nbendh            ; else decrement block end high byte
   637 00:B0B7: 80 04              BRA   LAB_1203          ; branch always
   638                        
   639                        LAB_11FF
   640 00:B0B9: B1 58              LDA   (Obendl),Y        ; get byte from source
   641 00:B0BB: 91 56              STA   (Nbendl),Y        ; copy byte to destination
   642                        LAB_1203
   643 00:B0BD: 88                 DEY                     ; decrement index
   644 00:B0BE: D0 F9              BNE   LAB_11FF          ; loop until Y=0
   645                                                      ; now do Y=0 indexed byte
   646 00:B0C0: B1 58              LDA   (Obendl),Y        ; get byte from source
   647 00:B0C2: 91 56              STA   (Nbendl),Y        ; save byte to destination
   648                        LAB_120A
   649 00:B0C4: C6 59              DEC   Obendh            ; decrement source pointer high byte
   650 00:B0C6: C6 57              DEC   Nbendh            ; decrement destination pointer high byte
   651 00:B0C8: CA                 DEX                     ; decrement block count
   652 00:B0C9: D0 F2              BNE   LAB_1203          ; loop until count = $0
   653 00:B0CB: 60                 RTS
   654                        
   655                        ; check room on stack for A bytes
   656                        ; stack too deep? do OM error
   657                        
   658                        LAB_1212                      ; patched for stack floor
   659 00:B0CC: 18                 CLC                     ; prep ADC
   660 00:B0CD: 69 14              ADC   #STACK_RES        ; stack pointer lower limit before interrupts
   661 00:B0CF: 85 2A              STA   TempB             ; save result in temp byte
   662 00:B0D1: BA                 TSX                     ; copy stack
   663 00:B0D2: E4 2A              CPX   TempB             ; compare new "limit" with stack
   664 00:B0D4: 90 2F              BCC   LAB_OMER          ; if stack < limit do "Out of memory" error then warm start
   665 00:B0D6: 60                 RTS
   666                        
   667                        ; check available memory, "Out of memory" error if no room
   668                        ; addr to check is in AY (low/high)
   669                        
   670                        LAB_121F
   671 00:B0D7: C4 34              CPY   Sstorh            ; compare bottom of string mem high byte
   672 00:B0D9: 90 29              BCC   LAB_124B          ; if less then exit (is ok)
   673                        
   674 00:B0DB: D0 04              BNE   LAB_1229          ; skip next test if greater (tested <)
   675                        
   676                                                      ; high byte was =, now do low byte
   677 00:B0DD: C5 33              CMP   Sstorl            ; compare with bottom of string mem low byte
   678 00:B0DF: 90 23              BCC   LAB_124B          ; if less then exit (is ok)
   679                        
   680                                                      ; addr is > string storage ptr (oops!)
   681                        LAB_1229
   682 00:B0E1: 48                 PHA                     ; push addr low byte
   683 00:B0E2: A2 08              LDX   #$08              ; set index to save Adatal to expneg inclusive
   684 00:B0E4: 98                 TYA                     ; copy addr high byte (to push on stack)
   685                        
   686                                                      ; save misc numeric work area
   687                        LAB_122D
  Thu Sep 26 2019 15:30                                                                                                    Page 12


   688 00:B0E5: 48                 PHA                     ; push byte
   689 00:B0E6: B5 55              LDA   Adatal-1,X        ; get byte from Adatal to expneg ( ,$00 not pushed)
   690 00:B0E8: CA                 DEX                     ; decrement index
   691 00:B0E9: 10 FA              BPL   LAB_122D          ; loop until all done
   692                        
   693 00:B0EB: 20 73 C1           JSR   LAB_GARB          ; garbage collection routine
   694                        
   695                                                      ; restore misc numeric work area
   696 00:B0EE: A2 00              LDX   #$00              ; clear the index to restore bytes
   697                        LAB_1238
   698 00:B0F0: 68                 PLA                     ; pop byte
   699 00:B0F1: 95 56              STA   Adatal,X          ; save byte to Adatal to expneg
   700 00:B0F3: E8                 INX                     ; increment index
   701 00:B0F4: E0 08              CPX   #$08              ; compare with end + 1
   702 00:B0F6: 30 F8              BMI   LAB_1238          ; loop if more to do
   703                        
   704 00:B0F8: 7A                 PLY                     ; pop addr high byte
   705 00:B0F9: 68                 PLA                     ; pop addr low byte
   706 00:B0FA: C4 34              CPY   Sstorh            ; compare bottom of string mem high byte
   707 00:B0FC: 90 06              BCC   LAB_124B          ; if less then exit (is ok)
   708                        
   709 00:B0FE: D0 05              BNE   LAB_OMER          ; if greater do "Out of memory" error then warm start
   710                        
   711                                                      ; high byte was =, now do low byte
   712 00:B100: C5 33              CMP   Sstorl            ; compare with bottom of string mem low byte
   713 00:B102: B0 01              BCS   LAB_OMER          ; if >= do "Out of memory" error then warm start
   714                                                      ; ok exit, carry clear
   715                        LAB_124B
   716 00:B104: 60                 RTS
   717                        
   718                        ; do "Out of memory" error then warm start
   719                        
   720                        LAB_OMER
   721 00:B105: A2 0C              LDX   #$0C              ; error code $0C ("Out of memory" error)
   722                        
   723                        ; do error #X, then warm start
   724                        
   725                        LAB_XERR
   726 00:B107: 20 37 B8           JSR   LAB_CRLF          ; print CR/LF
   727                        
   728 00:B10A: BD 93 D5           LDA   LAB_BAER,X        ; get error message pointer low byte
   729 00:B10D: BC 94 D5           LDY   LAB_BAER+1,X      ; get error message pointer high byte
   730 00:B110: 20 78 B8           JSR   LAB_18C3          ; print null terminated string from memory
   731                        
   732 00:B113: 20 5D B3           JSR   LAB_1491          ; flush stack and clear continue flag
   733 00:B116: A9 C1              LDA   #<LAB_EMSG        ; point to " Error" low addr
   734 00:B118: A0 D6              LDY   #>LAB_EMSG        ; point to " Error" high addr
   735                        LAB_1269
   736 00:B11A: 20 78 B8           JSR   LAB_18C3          ; print null terminated string from memory
   737 00:B11D: A4 3A              LDY   Clineh            ; get current line high byte
   738 00:B11F: C8                 INY                     ; increment it
   739 00:B120: F0 03              BEQ   LAB_1274          ; go do warm start (was immediate mode)
   740                        
   741                                                      ; else print line number
   742 00:B122: 20 E9 C9           JSR   LAB_2953          ; print " in line [LINE #]"
   743                        
   744                        ; BASIC warm start entry point
   745                        ; wait for Basic command
   746                        
   747                        LAB_1274
   748 00:B125: A9 D2              LDA   #<LAB_RMSG        ; point to "Ready" message low byte
   749 00:B127: A0 D6              LDY   #>LAB_RMSG        ; point to "Ready" message high byte
   750                        
  Thu Sep 26 2019 15:30                                                                                                    Page 13


   751 00:B129: 20 78 B8           JSR   LAB_18C3          ; go do print string
   752                        
   753                        ; wait for Basic command (no "Ready")
   754                        
   755                        LAB_127D
   756 00:B12C: 20 1B B2           JSR   LAB_1357          ; call for BASIC input
   757                        LAB_1280
   758 00:B12F: 86 6E              STX   Bpntrl            ; set BASIC execute pointer low byte
   759 00:B131: 84 6F              STY   Bpntrh            ; set BASIC execute pointer high byte
   760 00:B133: 20 B4 CF           JSR   LAB_GBYT          ; scan memory
   761 00:B136: F0 F4              BEQ   LAB_127D          ; loop while null
   762                        
   763                        ; got to interpret input line now ..
   764                        
   765 00:B138: A2 FF              LDX   #$FF              ; current line to null value
   766 00:B13A: 86 3A              STX   Clineh            ; set current line high byte
   767 00:B13C: 90 06              BCC   LAB_1295          ; branch if numeric character (handle new BASIC line)
   768                        
   769                                                      ; no line number .. immediate mode
   770 00:B13E: 20 4C B2           JSR   LAB_13A6          ; crunch keywords into Basic tokens
   771 00:B141: 4C BE B4           JMP   LAB_15F6          ; go scan and interpret code
   772                        
   773                        ; handle new BASIC line
   774                        
   775                        LAB_1295
   776 00:B144: 20 05 B7           JSR   LAB_GFPN          ; get fixed-point number into temp integer
   777 00:B147: 20 4C B2           JSR   LAB_13A6          ; crunch keywords into Basic tokens
   778 00:B14A: 84 0F              STY   Ibptr             ; save index pointer to end of crunched line
   779 00:B14C: 20 F8 B2           JSR   LAB_SSLN          ; search BASIC for temp integer line number
   780 00:B14F: 90 44              BCC   LAB_12E6          ; branch if not found
   781                        
   782                                                      ; aroooogah! line # already exists! delete it
   783 00:B151: A0 01              LDY   #$01              ; set index to next line pointer high byte
   784 00:B153: B1 5C              LDA   (Baslnl),Y        ; get next line pointer high byte
   785 00:B155: 85 24              STA   ut1_ph            ; save it
   786 00:B157: A5 2D              LDA   Svarl             ; get start of vars low byte
   787 00:B159: 85 23              STA   ut1_pl            ; save it
   788 00:B15B: A5 5D              LDA   Baslnh            ; get found line pointer high byte
   789 00:B15D: 85 26              STA   ut2_ph            ; save it
   790 00:B15F: A5 5C              LDA   Baslnl            ; get found line pointer low byte
   791 00:B161: 88                 DEY                     ; decrement index
   792 00:B162: F1 5C              SBC   (Baslnl),Y        ; subtract next line pointer low byte
   793 00:B164: 18                 CLC                     ; clear carry for add
   794 00:B165: 65 2D              ADC   Svarl             ; add start of vars low byte
   795 00:B167: 85 2D              STA   Svarl             ; save new start of vars low byte
   796 00:B169: 85 25              STA   ut2_pl            ; save destination pointer low byte
   797 00:B16B: A5 2E              LDA   Svarh             ; get start of vars high byte
   798 00:B16D: 69 FF              ADC   #$FF              ; -1 + carry
   799 00:B16F: 85 2E              STA   Svarh             ; save start of vars high byte
   800 00:B171: E5 5D              SBC   Baslnh            ; subtract found line pointer high byte
   801 00:B173: AA                 TAX                     ; copy to block count
   802 00:B174: 38                 SEC                     ; set carry for subtract
   803 00:B175: A5 5C              LDA   Baslnl            ; get found line pointer low byte
   804 00:B177: E5 2D              SBC   Svarl             ; subtract start of vars low byte
   805 00:B179: A8                 TAY                     ; copy to bytes in first block count
   806 00:B17A: B0 03              BCS   LAB_12D0          ; branch if overflow
   807                        
   808 00:B17C: E8                 INX                     ; increment block count (correct for =0 loop exit)
   809 00:B17D: C6 26              DEC   ut2_ph            ; decrement destination high byte
   810                        LAB_12D0
   811 00:B17F: 18                 CLC                     ; clear carry for add
   812 00:B180: 65 23              ADC   ut1_pl            ; add source pointer low byte
   813 00:B182: 90 03              BCC   LAB_12D8          ; branch if no overflow
  Thu Sep 26 2019 15:30                                                                                                    Page 14


   814                        
   815 00:B184: C6 24              DEC   ut1_ph            ; else decrement source pointer high byte
   816 00:B186: 18                 CLC                     ; clear carry
   817                        
   818                                                      ; close up memory to delete old line
   819                        LAB_12D8
   820 00:B187: B1 23              LDA   (ut1_pl),Y        ; get byte from source
   821 00:B189: 91 25              STA   (ut2_pl),Y        ; copy to destination
   822 00:B18B: C8                 INY                     ; increment index
   823 00:B18C: D0 F9              BNE   LAB_12D8          ; while <> 0 do this block
   824                        
   825 00:B18E: E6 24              INC   ut1_ph            ; increment source pointer high byte
   826 00:B190: E6 26              INC   ut2_ph            ; increment destination pointer high byte
   827 00:B192: CA                 DEX                     ; decrement block count
   828 00:B193: D0 F2              BNE   LAB_12D8          ; loop until all done
   829                        
   830                                                      ; got new line in buffer and no existing same #
   831                        LAB_12E6
   832 00:B195: AD 00 04           LDA   Ibuffs            ; get byte from start of input buffer
   833 00:B198: F0 3F              BEQ   LAB_1319          ; if null line just go flush stack/vars and exit
   834                        
   835                                                      ; got new line and it isn't empty line
   836 00:B19A: A5 37              LDA   Ememl             ; get end of mem low byte
   837 00:B19C: A4 38              LDY   Ememh             ; get end of mem high byte
   838 00:B19E: 85 33              STA   Sstorl            ; set bottom of string space low byte
   839 00:B1A0: 84 34              STY   Sstorh            ; set bottom of string space high byte
   840 00:B1A2: A5 2D              LDA   Svarl             ; get start of vars low byte (end of BASIC)
   841 00:B1A4: 85 58              STA   Obendl            ; save old block end low byte
   842 00:B1A6: A4 2E              LDY   Svarh             ; get start of vars high byte (end of BASIC)
   843 00:B1A8: 84 59              STY   Obendh            ; save old block end high byte
   844 00:B1AA: 65 0F              ADC   Ibptr             ; add input buffer pointer (also buffer length)
   845 00:B1AC: 90 01              BCC   LAB_1301          ; branch if no overflow from add
   846 00:B1AE: C8                 INY                     ; else increment high byte
   847                        LAB_1301
   848 00:B1AF: 85 56              STA   Nbendl            ; save new block end low byte (move to, low byte)
   849 00:B1B1: 84 57              STY   Nbendh            ; save new block end high byte
   850 00:B1B3: 20 8A B0           JSR   LAB_11CF          ; open up space in memory
   851                                                      ; old start pointer Ostrtl,Ostrth set by the find line call
   852 00:B1B6: A5 31              LDA   Earryl            ; get array mem end low byte
   853 00:B1B8: A4 32              LDY   Earryh            ; get array mem end high byte
   854 00:B1BA: 85 2D              STA   Svarl             ; save start of vars low byte
   855 00:B1BC: 84 2E              STY   Svarh             ; save start of vars high byte
   856 00:B1BE: A4 0F              LDY   Ibptr             ; get input buffer pointer (also buffer length)
   857 00:B1C0: 88                 DEY                     ; adjust for loop type
   858                        LAB_1311
   859 00:B1C1: B9 FC 03           LDA   Ibuffs-4,Y        ; get byte from crunched line
   860 00:B1C4: 91 5C              STA   (Baslnl),Y        ; save it to program memory
   861 00:B1C6: 88                 DEY                     ; decrement count
   862 00:B1C7: C0 03              CPY   #$03              ; compare with first byte-1
   863 00:B1C9: D0 F6              BNE   LAB_1311          ; continue while count <> 3
   864                        
   865 00:B1CB: A5 0B              LDA   Itemph            ; get line # high byte
   866 00:B1CD: 91 5C              STA   (Baslnl),Y        ; save it to program memory
   867 00:B1CF: 88                 DEY                     ; decrement count
   868 00:B1D0: A5 0A              LDA   Itempl            ; get line # low byte
   869 00:B1D2: 91 5C              STA   (Baslnl),Y        ; save it to program memory
   870 00:B1D4: 88                 DEY                     ; decrement count
   871 00:B1D5: A9 FF              LDA   #$FF              ; set byte to allow chain rebuild. if you didn't set this
   872                                                      ; byte then a zero already here would stop the chain rebuild
   873                                                      ; as it would think it was the [EOT] marker.
   874 00:B1D7: 91 5C              STA   (Baslnl),Y        ; save it to program memory
   875                        
   876                        LAB_1319
  Thu Sep 26 2019 15:30                                                                                                    Page 15


   877 00:B1D9: 20 39 B3           JSR   LAB_1477          ; reset execution to start, clear vars and flush stack
   878 00:B1DC: A6 2B              LDX   Smeml             ; get start of mem low byte
   879 00:B1DE: A5 2C              LDA   Smemh             ; get start of mem high byte
   880 00:B1E0: A0 01              LDY   #$01              ; index to high byte of next line pointer
   881                        LAB_1325
   882 00:B1E2: 86 23              STX   ut1_pl            ; set line start pointer low byte
   883 00:B1E4: 85 24              STA   ut1_ph            ; set line start pointer high byte
   884 00:B1E6: B1 23              LDA   (ut1_pl),Y        ; get it
   885 00:B1E8: F0 18              BEQ   LAB_133E          ; exit if end of program
   886                        
   887                        ; rebuild chaining of Basic lines
   888                        
   889 00:B1EA: A0 04              LDY   #$04              ; point to first code byte of line
   890                                                      ; there is always 1 byte + [EOL] as null entries are deleted
   891                        LAB_1330
   892 00:B1EC: C8                 INY                     ; next code byte
   893 00:B1ED: B1 23              LDA   (ut1_pl),Y        ; get byte
   894 00:B1EF: D0 FB              BNE   LAB_1330          ; loop if not [EOL]
   895                        
   896 00:B1F1: 38                 SEC                     ; set carry for add + 1
   897 00:B1F2: 98                 TYA                     ; copy end index
   898 00:B1F3: 65 23              ADC   ut1_pl            ; add to line start pointer low byte
   899 00:B1F5: AA                 TAX                     ; copy to X
   900 00:B1F6: A0 00              LDY   #$00              ; clear index, point to this line's next line pointer
   901 00:B1F8: 91 23              STA   (ut1_pl),Y        ; set next line pointer low byte
   902 00:B1FA: 98                 TYA                     ; clear A
   903 00:B1FB: 65 24              ADC   ut1_ph            ; add line start pointer high byte + carry
   904 00:B1FD: C8                 INY                     ; increment index to high byte
   905 00:B1FE: 91 23              STA   (ut1_pl),Y        ; save next line pointer low byte
   906 00:B200: 80 E0              BRA   LAB_1325          ; go do next line, branch always, carry clear
   907                        
   908                        LAB_133E
   909 00:B202: FF D6 03           BBS7  OPXMDM, DO_RDY    ; test to see if LOAD was executed
   910 00:B205: 4C 2C B1           JMP   LAB_127D          ; else we just wait for Basic command, no "Ready"
   911                        DO_RDY
   912 00:B208: 77 D6              RMB7  OPXMDM            ; reset flag bit to zero
   913 00:B20A: 4C 25 B1           JMP   LAB_1274          ; print Ready msg and wait for Basic command
   914                        
   915                        ; print "? " and get BASIC input
   916                        
   917                        LAB_INLN
   918 00:B20D: 20 91 B8           JSR   LAB_18E3          ; print "?" character
   919 00:B210: 20 8D B8           JSR   LAB_18E0          ; print " "
   920 00:B213: 80 06              BRA   LAB_1357          ; call for BASIC input and return
   921                        
   922                        ; receive line from keyboard
   923                        
   924                                                      ; $08 as delete key (BACKSPACE on standard keyboard)
   925                        LAB_134B
   926 00:B215: 20 93 B8           JSR   LAB_PRNA          ; go print the character
   927 00:B218: CA                 DEX                     ; decrement the buffer counter (delete)
   928 00:B219: 80 02              BRA   LAB_1359          ; branch over next instruction, save 1 clock cycle
   929                        
   930                        ; call for BASIC input (main entry point)
   931                        
   932                        LAB_1357
   933 00:B21B: A2 00              LDX   #$00              ; clear BASIC line buffer pointer
   934                        LAB_1359
   935 00:B21D: 20 37 D0           JSR   V_INPT            ; call scan input device
   936 00:B220: 90 FB              BCC   LAB_1359          ; loop if no byte
   937                        
   938 00:B222: F0 F9              BEQ   LAB_1359          ; loop until valid input (ignore NULLs)
   939                        
  Thu Sep 26 2019 15:30                                                                                                    Page 16


   940 00:B224: C9 07              CMP   #$07              ; compare with [BELL]
   941 00:B226: F0 10              BEQ   LAB_1378          ; branch if [BELL]
   942                        
   943 00:B228: C9 0D              CMP   #$0D              ; compare with [CR]
   944 00:B22A: F0 19              BEQ   LAB_1384          ; do CR/LF exit if [CR]
   945                        
   946 00:B22C: E0 00              CPX   #$00              ; compare pointer with $00
   947 00:B22E: D0 04              BNE   LAB_1374          ; branch if not empty
   948                        
   949                        ; next two lines ignore any non print character and [SPACE] if input buffer empty
   950                        
   951 00:B230: C9 21              CMP   #$21              ; compare with [SP]+1
   952 00:B232: 90 E9              BCC   LAB_1359          ; if < ignore character
   953                        
   954                        LAB_1374
   955 00:B234: C9 08              CMP   #$08              ; compare with [BACKSPACE] (delete last character)
   956 00:B236: F0 DD              BEQ   LAB_134B          ; go delete last character
   957                        
   958                        LAB_1378
   959 00:B238: E0 7E              CPX   #Ibuffe-Ibuffs    ; compare character count with max
   960 00:B23A: B0 0C              BCS   LAB_138E          ; skip store and do [BELL] if buffer full
   961                        
   962 00:B23C: 9D 00 04           STA   Ibuffs,X          ; else store in buffer
   963 00:B23F: E8                 INX                     ; increment pointer
   964                        LAB_137F
   965 00:B240: 20 93 B8           JSR   LAB_PRNA          ; go print the character
   966 00:B243: 80 D8              BRA   LAB_1359          ; always loop for next character
   967                        
   968                        LAB_1384
   969 00:B245: 4C 30 B8           JMP   LAB_1866          ; do CR/LF exit to BASIC
   970                        
   971                        ; announce buffer full
   972                        
   973                        LAB_138E
   974 00:B248: A9 07              LDA   #$07              ; [BELL] character into A
   975 00:B24A: 80 F4              BRA   LAB_137F          ; go print the [BELL] but ignore input character
   976                                                      ; branch always
   977                        
   978                        ; crunch keywords into Basic tokens
   979                        ; position independent buffer version ..
   980                        ; faster, dictionary search version ....
   981                        
   982                        LAB_13A6
   983 00:B24C: A0 FF              LDY   #$FF              ; set save index (makes for easy math later)
   984 00:B24E: 38                 SEC                     ; set carry for subtract
   985 00:B24F: A5 6E              LDA   Bpntrl            ; get basic execute pointer low byte
   986 00:B251: E9 00              SBC   #<Ibuffs          ; subtract input buffer start pointer
   987 00:B253: AA                 TAX                     ; copy result to X (index past line # if any)
   988 00:B254: 86 12              STX   Oquote            ; clear open quote/DATA flag
   989                        LAB_13AC
   990 00:B256: BD 00 04           LDA   Ibuffs,X          ; get byte from input buffer
   991 00:B259: F0 51              BEQ   LAB_13EC          ; if null save byte then exit
   992                        
   993 00:B25B: C9 5F              CMP   #'_'              ; compare with "_"
   994 00:B25D: B0 4D              BCS   LAB_13EC          ; if >= go save byte then continue crunching
   995                        
   996 00:B25F: C9 3C              CMP   #'<'              ; compare with "<"
   997 00:B261: B0 0E              BCS   LAB_13CC          ; if >= go crunch now
   998                        
   999 00:B263: C9 30              CMP   #'0'              ; compare with "0"
  1000 00:B265: B0 45              BCS   LAB_13EC          ; if >= go save byte then continue crunching
  1001                        
  1002 00:B267: 85 0E              STA   Scnquo            ; save buffer byte as search character
  Thu Sep 26 2019 15:30                                                                                                    Page 17


  1003 00:B269: C9 22              CMP   #$22              ; is it quote character?
  1004 00:B26B: F0 61              BEQ   LAB_1410          ; branch if so (copy quoted string)
  1005                        
  1006 00:B26D: C9 2A              CMP   #'*'              ; compare with "*"
  1007 00:B26F: 90 3B              BCC   LAB_13EC          ; if < go save byte then continue crunching
  1008                                                      ; else crunch now
  1009                        LAB_13CC
  1010 00:B271: 24 12              BIT   Oquote            ; get open quote/DATA token flag
  1011 00:B273: 70 37              BVS   LAB_13EC          ; branch if b6 of Oquote set (was DATA)
  1012                                                      ; go save byte then continue crunching
  1013 00:B275: 86 2A              STX   TempB             ; save buffer read index
  1014 00:B277: 84 6C              STY   csidx             ; copy buffer save index
  1015 00:B279: A0 1B              LDY   #<TAB_1STC        ; get keyword first character table low address
  1016 00:B27B: 84 25              STY   ut2_pl            ; save pointer low byte
  1017 00:B27D: A0 D2              LDY   #>TAB_1STC        ; get keyword first character table high address
  1018 00:B27F: 84 26              STY   ut2_ph            ; save pointer high byte
  1019 00:B281: A0 00              LDY   #$00              ; clear table pointer
  1020                        
  1021                        LAB_13D0
  1022 00:B283: D1 25              CMP   (ut2_pl),Y        ; compare with keyword first character table byte
  1023 00:B285: F0 05              BEQ   LAB_13D1          ; go do word_table_chr if match
  1024                        
  1025 00:B287: 90 21              BCC   LAB_13EA          ; if < keyword first character table byte go restore
  1026                                                      ; Y and save to crunched
  1027                        
  1028 00:B289: C8                 INY                     ; else increment pointer
  1029 00:B28A: 80 F7              BRA   LAB_13D0          ; and loop (branch always)
  1030                        
  1031                        ; have matched first character of some keyword
  1032                        
  1033                        LAB_13D1
  1034 00:B28C: 98                 TYA                     ; copy matching index
  1035 00:B28D: 0A                 ASL                     ; *2 (bytes per pointer)
  1036 00:B28E: AA                 TAX                     ; copy to new index
  1037 00:B28F: BD 39 D2           LDA   TAB_CHRT,X        ; get keyword table pointer low byte
  1038 00:B292: 85 25              STA   ut2_pl            ; save pointer low byte
  1039 00:B294: BD 3A D2           LDA   TAB_CHRT+1,X      ; get keyword table pointer high byte
  1040 00:B297: 85 26              STA   ut2_ph            ; save pointer high byte
  1041 00:B299: A0 FF              LDY   #$FF              ; clear table pointer (make -1 for start)
  1042 00:B29B: A6 2A              LDX   TempB             ; restore buffer read index
  1043                        
  1044                        LAB_13D6
  1045 00:B29D: C8                 INY                     ; next table byte
  1046 00:B29E: B1 25              LDA   (ut2_pl),Y        ; get byte from table
  1047                        LAB_13D8
  1048 00:B2A0: 30 08              BMI   LAB_13EA          ; all bytes matched so go save token
  1049 00:B2A2: E8                 INX                     ; next buffer byte
  1050 00:B2A3: DD 00 04           CMP   Ibuffs,X          ; compare with byte from input buffer
  1051 00:B2A6: F0 F5              BEQ   LAB_13D6          ; go compare next if match
  1052 00:B2A8: 80 2B              BRA   LAB_1417          ; branch if >< (not found keyword)
  1053                        
  1054                        LAB_13EA
  1055 00:B2AA: A4 6C              LDY   csidx             ; restore save index
  1056                                                      ; save crunched to output
  1057                        LAB_13EC
  1058 00:B2AC: E8                 INX                     ; increment buffer index (to next input byte)
  1059 00:B2AD: C8                 INY                     ; increment save index (to next output byte)
  1060 00:B2AE: 99 00 04           STA   Ibuffs,Y          ; save byte to output
  1061 00:B2B1: C9 00              CMP   #$00              ; set the flags, set carry
  1062 00:B2B3: F0 32              BEQ   LAB_142A          ; do exit if was null [EOL]
  1063                        
  1064                                                      ; A holds token or byte here
  1065 00:B2B5: E9 3A              SBC   #':'              ; subtract ":" (carry set by CMP #00)
  Thu Sep 26 2019 15:30                                                                                                    Page 18


  1066 00:B2B7: F0 04              BEQ   LAB_13FF          ; branch if it was ":" (is now $00)
  1067                        
  1068                                                      ; A now holds token-$3A
  1069 00:B2B9: C9 49              CMP   #TK_DATA-$3A      ; compare with DATA token - $3A
  1070 00:B2BB: D0 02              BNE   LAB_1401          ; branch if not DATA
  1071                        
  1072                                                      ; token was : or DATA
  1073                        LAB_13FF
  1074 00:B2BD: 85 12              STA   Oquote            ; save token-$3A (clear for ":", TK_DATA-$3A for DATA)
  1075                        LAB_1401
  1076 00:B2BF: 49 55              EOR   #TK_REM-$3A       ; effectively subtract REM token offset
  1077 00:B2C1: D0 93              BNE   LAB_13AC          ; If wasn't REM then go crunch rest of line
  1078 00:B2C3: 85 0E              STA   Asrch             ; else was REM so set search for [EOL]
  1079                                                      ; loop for REM, "..." etc.
  1080                        LAB_1408
  1081 00:B2C5: BD 00 04           LDA   Ibuffs,X          ; get byte from input buffer
  1082 00:B2C8: F0 E2              BEQ   LAB_13EC          ; branch if null [EOL]
  1083 00:B2CA: C5 0E              CMP   Asrch             ; compare with stored character
  1084 00:B2CC: F0 DE              BEQ   LAB_13EC          ; branch if match (end quote)
  1085                                                      ; entry for copy string in quotes, don't crunch
  1086                        LAB_1410
  1087 00:B2CE: C8                 INY                     ; increment buffer save index
  1088 00:B2CF: 99 00 04           STA   Ibuffs,Y          ; save byte to output
  1089 00:B2D2: E8                 INX                     ; increment buffer read index
  1090 00:B2D3: D0 F0              BNE   LAB_1408          ; loop while <> 0 (should never be 0!)
  1091                                                      ; not found keyword this go
  1092                        LAB_1417
  1093 00:B2D5: A6 2A              LDX   TempB             ; compare has failed, restore buffer index (start byte!)
  1094                        
  1095                                                      ; now find the end of this word in the table
  1096                        LAB_141B
  1097 00:B2D7: B1 25              LDA   (ut2_pl),Y        ; get table byte
  1098 00:B2D9: 08                 PHP                     ; save status
  1099 00:B2DA: C8                 INY                     ; increment table index
  1100 00:B2DB: 28                 PLP                     ; restore byte status
  1101 00:B2DC: 10 F9              BPL   LAB_141B          ; if not end of keyword go do next
  1102                        
  1103 00:B2DE: B1 25              LDA   (ut2_pl),Y        ; get byte from keyword table
  1104 00:B2E0: D0 BE              BNE   LAB_13D8          ; go test next word if not zero byte (end of table)
  1105                        
  1106                                                      ; reached end of table with no match
  1107 00:B2E2: BD 00 04           LDA   Ibuffs,X          ; restore byte from input buffer
  1108 00:B2E5: 80 C3              BRA   LAB_13EA          ; branch always (all bytes in buffer are $00-$7F)
  1109                                                      ; go save byte in output and continue crunching
  1110                                                      ; reached [EOL]
  1111                        LAB_142A
  1112 00:B2E7: C8                 INY                     ; increment pointer
  1113 00:B2E8: C8                 INY                     ; increment pointer (makes it next line pointer high byte)
  1114 00:B2E9: 99 00 04           STA   Ibuffs,Y          ; save [EOL] (marks [EOT] in immediate mode)
  1115 00:B2EC: C8                 INY                     ; adjust for line copy
  1116 00:B2ED: C8                 INY                     ; adjust for line copy
  1117 00:B2EE: C8                 INY                     ; adjust for line copy
  1118 00:B2EF: A5 6E              LDA   Bpntrl            ; test for $00
  1119 00:B2F1: D0 02              BNE   LAB_142P          ; not $00
  1120 00:B2F3: C6 6F              DEC   Bpntrh            ; allow for increment when $xx00
  1121                        LAB_142P
  1122 00:B2F5: C6 6E              DEC   Bpntrl            ; allow for increment
  1123 00:B2F7: 60                 RTS
  1124                        
  1125                        ; search Basic for temp integer line number from start of mem
  1126                        
  1127                        LAB_SSLN
  1128 00:B2F8: A5 2B              LDA   Smeml             ; get start of mem low byte
  Thu Sep 26 2019 15:30                                                                                                    Page 19


  1129 00:B2FA: A6 2C              LDX   Smemh             ; get start of mem high byte
  1130                        
  1131                        ; search Basic for temp integer line number from AX
  1132                        ; returns carry set if found
  1133                        ; returns Baslnl/Baslnh pointer to found or next higher (not found) line
  1134                        
  1135                        LAB_SHLN
  1136 00:B2FC: A0 01              LDY   #$01              ; set index
  1137 00:B2FE: 85 5C              STA   Baslnl            ; save low byte as current
  1138 00:B300: 86 5D              STX   Baslnh            ; save high byte as current
  1139 00:B302: B1 5C              LDA   (Baslnl),Y        ; get pointer high byte from addr
  1140 00:B304: F0 1A              BEQ   LAB_145F          ; pointer was zero so we're done, do 'not found' exit
  1141                        
  1142 00:B306: A0 03              LDY   #$03              ; set index to line # high byte
  1143 00:B308: B1 5C              LDA   (Baslnl),Y        ; get line # high byte
  1144 00:B30A: 88                 DEY                     ; decrement index (point to low byte)
  1145 00:B30B: C5 0B              CMP   Itemph            ; compare with temporary integer high byte
  1146 00:B30D: D0 04              BNE   LAB_1455          ; if <> skip low byte check
  1147                        
  1148 00:B30F: B1 5C              LDA   (Baslnl),Y        ; get line # low byte
  1149 00:B311: C5 0A              CMP   Itempl            ; compare with temporary integer low byte
  1150                        LAB_1455
  1151 00:B313: B0 09              BCS   LAB_145E          ; else if temp < this line, exit (passed line#)
  1152                        
  1153                        LAB_1456
  1154 00:B315: 88                 DEY                     ; decrement index to next line ptr high byte
  1155 00:B316: B1 5C              LDA   (Baslnl),Y        ; get next line pointer high byte
  1156 00:B318: AA                 TAX                     ; copy to X
  1157 00:B319: 88                 DEY                     ; decrement index to next line ptr low byte
  1158 00:B31A: B1 5C              LDA   (Baslnl),Y        ; get next line pointer low byte
  1159 00:B31C: 80 DE              BRA   LAB_SHLN          ; go search for line # in temp (Itempl/Itemph) from AX
  1160                                                      ; (carry always clear)
  1161                        
  1162                        LAB_145E
  1163 00:B31E: F0 01              BEQ   LAB_1460          ; exit if temp = found line #, carry is set
  1164                        
  1165                        LAB_145F
  1166 00:B320: 18                 CLC                     ; clear found flag
  1167                        LAB_1460
  1168 00:B321: 60                 RTS
  1169                        
  1170                        ; perform NEW
  1171                        
  1172                        LAB_NEW
  1173 00:B322: D0 FD              BNE   LAB_1460          ; exit if not end of statement (to do syntax error)
  1174                        
  1175                        LAB_1463
  1176 00:B324: A9 00              LDA   #$00              ; clear A
  1177 00:B326: A8                 TAY                     ; clear Y
  1178 00:B327: 91 2B              STA   (Smeml),Y         ; clear first line, next line pointer, low byte
  1179 00:B329: C8                 INY                     ; increment index
  1180 00:B32A: 91 2B              STA   (Smeml),Y         ; clear first line, next line pointer, high byte
  1181 00:B32C: 18                 CLC                     ; clear carry
  1182 00:B32D: A5 2B              LDA   Smeml             ; get start of mem low byte
  1183 00:B32F: 69 02              ADC   #$02              ; calculate end of BASIC low byte
  1184 00:B331: 85 2D              STA   Svarl             ; save start of vars low byte
  1185 00:B333: A5 2C              LDA   Smemh             ; get start of mem high byte
  1186 00:B335: 69 00              ADC   #$00              ; add any carry
  1187 00:B337: 85 2E              STA   Svarh             ; save start of vars high byte
  1188                        
  1189                        ; reset execution to start, clear vars and flush stack
  1190                        
  1191                        LAB_1477
  Thu Sep 26 2019 15:30                                                                                                    Page 20


  1192 00:B339: 18                 CLC                     ; clear carry
  1193 00:B33A: A5 2B              LDA   Smeml             ; get start of mem low byte
  1194 00:B33C: 69 FF              ADC   #$FF              ; -1
  1195 00:B33E: 85 6E              STA   Bpntrl            ; save BASIC execute pointer low byte
  1196 00:B340: A5 2C              LDA   Smemh             ; get start of mem high byte
  1197 00:B342: 69 FF              ADC   #$FF              ; -1+carry
  1198 00:B344: 85 6F              STA   Bpntrh            ; save BASIC execute pointer high byte
  1199                        
  1200                        ; "CLEAR" command gets here
  1201                        
  1202                        LAB_147A
  1203 00:B346: A5 37              LDA   Ememl             ; get end of mem low byte
  1204 00:B348: A4 38              LDY   Ememh             ; get end of mem high byte
  1205 00:B34A: 85 33              STA   Sstorl            ; set bottom of string space low byte
  1206 00:B34C: 84 34              STY   Sstorh            ; set bottom of string space high byte
  1207 00:B34E: A5 2D              LDA   Svarl             ; get start of vars low byte
  1208 00:B350: A4 2E              LDY   Svarh             ; get start of vars high byte
  1209 00:B352: 85 2F              STA   Sarryl            ; save var mem end low byte
  1210 00:B354: 84 30              STY   Sarryh            ; save var mem end high byte
  1211 00:B356: 85 31              STA   Earryl            ; save array mem end low byte
  1212 00:B358: 84 32              STY   Earryh            ; save array mem end high byte
  1213 00:B35A: 20 08 B5           JSR   LAB_161A          ; perform RESTORE command
  1214                        
  1215                        ; flush stack and clear continue flag
  1216                        
  1217                        LAB_1491
  1218 00:B35D: A2 1A              LDX   #des_sk           ; set descriptor stack pointer
  1219 00:B35F: 86 17              STX   next_s            ; save descriptor stack pointer
  1220 00:B361: FA                 PLX                     ; pull return address low byte
  1221 00:B362: 68                 PLA                     ; pull return address high byte
  1222 00:B363: 8E FE 01           STX   LAB_SKFE          ; save to cleared stack
  1223 00:B366: 8D FF 01           STA   LAB_SKFF          ; save to cleared stack
  1224 00:B369: A2 FD              LDX   #$FD              ; new stack pointer
  1225 00:B36B: 9A                 TXS                     ; reset stack
  1226 00:B36C: 64 13              STZ   Sufnxf            ; clear subscript/FNX flag
  1227                        LAB_14A6
  1228 00:B36E: 60                 RTS
  1229                        
  1230                        ; perform CLEAR
  1231                        
  1232                        LAB_CLEAR
  1233 00:B36F: F0 D5              BEQ   LAB_147A          ; if no following token go do "CLEAR"
  1234                                                      ; else there was a following token (go do syntax error)
  1235 00:B371: 60                 RTS
  1236                        
  1237                        ; perform LIST [n][-m]
  1238                        ; bigger, faster version (a _lot_ faster)
  1239                        
  1240                        LAB_LIST
  1241 00:B372: 90 06              BCC   LAB_14BD          ; branch if next character numeric (LIST n..)
  1242 00:B374: F0 04              BEQ   LAB_14BD          ; branch if next character [NULL] (LIST)
  1243                        
  1244 00:B376: C9 B3              CMP   #TK_MINUS         ; compare with token for -
  1245 00:B378: D0 F4              BNE   LAB_14A6          ; exit if not - (LIST -m)
  1246                        
  1247                                                      ; LIST [[n][-m]]
  1248                                                      ; this bit sets the n , if present, as the start and end
  1249                        LAB_14BD
  1250 00:B37A: 20 05 B7           JSR   LAB_GFPN          ; get fixed-point number into temp integer
  1251 00:B37D: 20 F8 B2           JSR   LAB_SSLN          ; search BASIC for temp integer line number
  1252                                                      ; (pointer in Baslnl/Baslnh)
  1253 00:B380: 20 B4 CF           JSR   LAB_GBYT          ; scan memory
  1254 00:B383: F0 0C              BEQ   LAB_14D4          ; branch if no more characters
  Thu Sep 26 2019 15:30                                                                                                    Page 21


  1255                        
  1256                                                      ; this bit checks the - is present
  1257 00:B385: C9 B3              CMP   #TK_MINUS         ; compare with token for -
  1258 00:B387: D0 98              BNE   LAB_1460          ; return if not "-" (will be Syntax error)
  1259                        
  1260                                                      ; LIST [n]-m
  1261                                                      ; the - was there so set m as the end value
  1262 00:B389: 20 AE CF           JSR   LAB_IGBY          ; increment and scan memory
  1263 00:B38C: 20 05 B7           JSR   LAB_GFPN          ; get fixed-point number into temp integer
  1264 00:B38F: D0 90              BNE   LAB_1460          ; exit if not ok
  1265                        
  1266                        LAB_14D4
  1267 00:B391: A5 0A              LDA   Itempl            ; get temporary integer low byte
  1268 00:B393: 05 0B              ORA   Itemph            ; OR temporary integer high byte
  1269 00:B395: D0 06              BNE   LAB_14E2          ; branch if start set
  1270                        
  1271 00:B397: A9 FF              LDA   #$FF              ; set for -1
  1272 00:B399: 85 0A              STA   Itempl            ; set temporary integer low byte
  1273 00:B39B: 85 0B              STA   Itemph            ; set temporary integer high byte
  1274                        LAB_14E2
  1275 00:B39D: A0 01              LDY   #$01              ; set index for line
  1276 00:B39F: 84 12              STY   Oquote            ; clear open quote flag
  1277 00:B3A1: 20 37 B8           JSR   LAB_CRLF          ; print CR/LF
  1278 00:B3A4: B1 5C              LDA   (Baslnl),Y        ; get next line pointer high byte
  1279                                                      ; pointer initially set by search at LAB_14BD
  1280 00:B3A6: F0 3E              BEQ   LAB_152B          ; if null all done so exit
  1281 00:B3A8: 20 DE B4           JSR   LAB_1629          ; do CRTL-C check vector
  1282                        
  1283 00:B3AB: C8                 INY                     ; increment index for line
  1284 00:B3AC: B1 5C              LDA   (Baslnl),Y        ; get line # low byte
  1285 00:B3AE: AA                 TAX                     ; copy to X
  1286 00:B3AF: C8                 INY                     ; increment index
  1287 00:B3B0: B1 5C              LDA   (Baslnl),Y        ; get line # high byte
  1288 00:B3B2: C5 0B              CMP   Itemph            ; compare with temporary integer high byte
  1289 00:B3B4: D0 04              BNE   LAB_14FF          ; branch if no high byte match
  1290                        
  1291 00:B3B6: E4 0A              CPX   Itempl            ; compare with temporary integer low byte
  1292 00:B3B8: F0 02              BEQ   LAB_1501          ; branch if = last line to do (< will pass next branch)
  1293                        
  1294                        LAB_14FF                      ; else ..
  1295 00:B3BA: B0 2A              BCS   LAB_152B          ; if greater all done so exit
  1296                        
  1297                        LAB_1501
  1298 00:B3BC: 84 49              STY   Tidx1             ; save index for line
  1299 00:B3BE: 20 F4 C9           JSR   LAB_295E          ; print XA as unsigned integer
  1300 00:B3C1: A9 20              LDA   #$20              ; space is the next character
  1301                        LAB_1508
  1302 00:B3C3: A4 49              LDY   Tidx1             ; get index for line
  1303 00:B3C5: 29 7F              AND   #$7F              ; mask top out bit of character
  1304                        LAB_150C
  1305 00:B3C7: 20 93 B8           JSR   LAB_PRNA          ; go print the character
  1306 00:B3CA: C9 22              CMP   #$22              ; was it " character
  1307 00:B3CC: D0 06              BNE   LAB_1519          ; branch if not
  1308                                                      ; we are either entering or leaving a pair of quotes
  1309 00:B3CE: A5 12              LDA   Oquote            ; get open quote flag
  1310 00:B3D0: 49 FF              EOR   #$FF              ; toggle it
  1311 00:B3D2: 85 12              STA   Oquote            ; save it back
  1312                        LAB_1519
  1313 00:B3D4: C8                 INY                     ; increment index
  1314 00:B3D5: B1 5C              LDA   (Baslnl),Y        ; get next byte
  1315 00:B3D7: D0 0E              BNE   LAB_152E          ; branch if not [EOL] (go print character)
  1316 00:B3D9: A8                 TAY                     ; else clear index
  1317 00:B3DA: B1 5C              LDA   (Baslnl),Y        ; get next line pointer low byte
  Thu Sep 26 2019 15:30                                                                                                    Page 22


  1318 00:B3DC: AA                 TAX                     ; copy to X
  1319 00:B3DD: C8                 INY                     ; increment index
  1320 00:B3DE: B1 5C              LDA   (Baslnl),Y        ; get next line pointer high byte
  1321 00:B3E0: 86 5C              STX   Baslnl            ; set pointer to line low byte
  1322 00:B3E2: 85 5D              STA   Baslnh            ; set pointer to line high byte
  1323 00:B3E4: D0 B7              BNE   LAB_14E2          ; go do next line if not [EOT]
  1324                                                      ; else ..
  1325                        LAB_152B
  1326 00:B3E6: 60                 RTS
  1327                        
  1328                        LAB_152E
  1329 00:B3E7: 10 DE              BPL   LAB_150C          ; just go print it if not token byte
  1330                                                      ; else was token byte so uncrunch it (maybe)
  1331 00:B3E9: 24 12              BIT   Oquote            ; test the open quote flag
  1332 00:B3EB: 30 DA              BMI   LAB_150C          ; just go print character if open quote set
  1333                        
  1334 00:B3ED: A2 D4              LDX   #>LAB_KEYT        ; get table address high byte
  1335 00:B3EF: 0A                 ASL                     ; *2
  1336 00:B3F0: 0A                 ASL                     ; *4
  1337 00:B3F1: 90 02              BCC   LAB_152F          ; branch if no carry
  1338                        
  1339 00:B3F3: E8                 INX                     ; else increment high byte
  1340 00:B3F4: 18                 CLC                     ; clear carry for add
  1341                        LAB_152F
  1342 00:B3F5: 69 0B              ADC   #<LAB_KEYT        ; add low byte
  1343 00:B3F7: 90 01              BCC   LAB_1530          ; branch if no carry
  1344 00:B3F9: E8                 INX                     ; else increment high byte
  1345                        
  1346                        LAB_1530
  1347 00:B3FA: 85 25              STA   ut2_pl            ; save table pointer low byte
  1348 00:B3FC: 86 26              STX   ut2_ph            ; save table pointer high byte
  1349 00:B3FE: 84 49              STY   Tidx1             ; save index for line
  1350 00:B400: A0 00              LDY   #$00              ; clear index
  1351 00:B402: B1 25              LDA   (ut2_pl),Y        ; get length
  1352 00:B404: AA                 TAX                     ; copy length
  1353 00:B405: C8                 INY                     ; increment index
  1354 00:B406: B1 25              LDA   (ut2_pl),Y        ; get 1st character
  1355 00:B408: CA                 DEX                     ; decrement length
  1356 00:B409: F0 B8              BEQ   LAB_1508          ; if no more characters exit and print
  1357                        
  1358 00:B40B: 20 93 B8           JSR   LAB_PRNA          ; go print the character
  1359 00:B40E: C8                 INY                     ; increment index
  1360 00:B40F: B1 25              LDA   (ut2_pl),Y        ; get keyword address low byte
  1361 00:B411: 48                 PHA                     ; save it for now
  1362 00:B412: C8                 INY                     ; increment index
  1363 00:B413: B1 25              LDA   (ut2_pl),Y        ; get keyword address high byte
  1364 00:B415: A0 00              LDY   #$00
  1365 00:B417: 85 26              STA   ut2_ph            ; save keyword pointer high byte
  1366 00:B419: 68                 PLA                     ; pull low byte
  1367 00:B41A: 85 25              STA   ut2_pl            ; save keyword pointer low byte
  1368                        LAB_1540
  1369 00:B41C: B1 25              LDA   (ut2_pl),Y        ; get character
  1370 00:B41E: CA                 DEX                     ; decrement character count
  1371 00:B41F: F0 A2              BEQ   LAB_1508          ; if last character exit and print
  1372                        
  1373 00:B421: 20 93 B8           JSR   LAB_PRNA          ; go print the character
  1374 00:B424: C8                 INY                     ; increment index
  1375 00:B425: D0 F5              BNE   LAB_1540          ; loop for next character
  1376                        
  1377                        ; perform FOR
  1378                        
  1379                        LAB_FOR
  1380 00:B427: A9 80              LDA   #$80              ; set FNX
  Thu Sep 26 2019 15:30                                                                                                    Page 23


  1381 00:B429: 85 13              STA   Sufnxf            ; set subscript/FNX flag
  1382 00:B42B: 20 63 B7           JSR   LAB_LET           ; go do LET
  1383 00:B42E: 68                 PLA                     ; pull return address
  1384 00:B42F: 68                 PLA                     ; pull return address
  1385 00:B430: A9 10              LDA   #$10              ; we need 16d bytes !
  1386 00:B432: 20 CC B0           JSR   LAB_1212          ; check room on stack for A bytes
  1387 00:B435: 20 59 B6           JSR   LAB_SNBS          ; scan for next BASIC statement ([:] or [EOL])
  1388 00:B438: 18                 CLC                     ; clear carry for add
  1389 00:B439: 98                 TYA                     ; copy index to A
  1390 00:B43A: 65 6E              ADC   Bpntrl            ; add BASIC execute pointer low byte
  1391 00:B43C: 48                 PHA                     ; push onto stack
  1392 00:B43D: A5 6F              LDA   Bpntrh            ; get BASIC execute pointer high byte
  1393 00:B43F: 69 00              ADC   #$00              ; add carry
  1394 00:B441: 48                 PHA                     ; push onto stack
  1395 00:B442: A5 3A              LDA   Clineh            ; get current line high byte
  1396 00:B444: 48                 PHA                     ; push onto stack
  1397 00:B445: A5 39              LDA   Clinel            ; get current line low byte
  1398 00:B447: 48                 PHA                     ; push onto stack
  1399 00:B448: A9 AA              LDA   #TK_TO            ; get "TO" token
  1400 00:B44A: 20 91 BB           JSR   LAB_SCCA          ; scan for CHR$(A) , else do syntax error then warm start
  1401 00:B44D: 20 72 BA           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
  1402 00:B450: 20 6F BA           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
  1403                                                      ; else do type mismatch
  1404 00:B453: A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
  1405 00:B455: 09 7F              ORA   #$7F              ; set all non sign bits
  1406 00:B457: 25 5F              AND   FAC1_1            ; and FAC1 mantissa1
  1407 00:B459: 85 5F              STA   FAC1_1            ; save FAC1 mantissa1
  1408 00:B45B: A9 66              LDA   #<LAB_159F        ; set return address low byte
  1409 00:B45D: A0 B4              LDY   #>LAB_159F        ; set return address high byte
  1410 00:B45F: 85 23              STA   ut1_pl            ; save return address low byte
  1411 00:B461: 84 24              STY   ut1_ph            ; save return address high byte
  1412 00:B463: 4C 24 BB           JMP   LAB_1B66          ; round FAC1 and put on stack (returns to next instruction)
  1413                        
  1414                        LAB_159F
  1415 00:B466: A9 F1              LDA   #<LAB_259C        ; set 1 pointer low addr (default step size)
  1416 00:B468: A0 D0              LDY   #>LAB_259C        ; set 1 pointer high addr
  1417 00:B46A: 20 FB C7           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
  1418 00:B46D: 20 B4 CF           JSR   LAB_GBYT          ; scan memory
  1419 00:B470: C9 AF              CMP   #TK_STEP          ; compare with STEP token
  1420 00:B472: D0 06              BNE   LAB_15B3          ; jump if not "STEP"
  1421                        
  1422                                                      ; was step so ..
  1423 00:B474: 20 AE CF           JSR   LAB_IGBY          ; increment and scan memory
  1424 00:B477: 20 6F BA           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
  1425                                                      ; else do type mismatch
  1426                        LAB_15B3
  1427 00:B47A: 20 67 C8           JSR   LAB_27CA          ; return A=FF,C=1/-ve A=01,C=0/+ve
  1428 00:B47D: 85 62              STA   FAC1_s            ; set FAC1 sign (b7)
  1429                                                      ; this is +1 for +ve step and -1 for -ve step, in NEXT we
  1430                                                      ; compare the FOR value and the TO value and return +1 if
  1431                                                      ; FOR > TO, 0 if FOR = TO and -1 if FOR < TO. the value
  1432                                                      ; here (+/-1) is then compared to that result and if they
  1433                                                      ; are the same (+ve and FOR > TO or -ve and FOR < TO) then
  1434                                                      ; the loop is done
  1435 00:B47F: 20 19 BB           JSR   LAB_1B5B          ; push sign, round FAC1 and put on stack
  1436 00:B482: A5 4A              LDA   Frnxth            ; get var pointer for FOR/NEXT high byte
  1437 00:B484: 48                 PHA                     ; push on stack
  1438 00:B485: A5 49              LDA   Frnxtl            ; get var pointer for FOR/NEXT low byte
  1439 00:B487: 48                 PHA                     ; push on stack
  1440 00:B488: A9 81              LDA   #TK_FOR           ; get FOR token
  1441 00:B48A: 48                 PHA                     ; push on stack
  1442                        
  1443                        ; interpreter inner loop
  Thu Sep 26 2019 15:30                                                                                                    Page 24


  1444                        
  1445                        LAB_15C2
  1446 00:B48B: 20 DE B4           JSR   LAB_1629          ; do CRTL-C check vector
  1447 00:B48E: A5 6E              LDA   Bpntrl            ; get BASIC execute pointer low byte
  1448 00:B490: A4 6F              LDY   Bpntrh            ; get BASIC execute pointer high byte
  1449 00:B492: A6 3A              LDX   Clineh            ; continue line is $FFxx for immediate mode
  1450                                                      ; ($00xx for RUN from immediate mode)
  1451 00:B494: E8                 INX                     ; increment it (now $00 if immediate mode)
  1452 00:B495: 85 3D              STA   Cpntrl            ; save continue pointer low byte
  1453 00:B497: 84 3E              STY   Cpntrh            ; save continue pointer high byte
  1454                        LAB_15D1
  1455 00:B499: B2 6E              LDA   (Bpntrl)          ; get next byte
  1456 00:B49B: F0 07              BEQ   LAB_15DC          ; branch if null [EOL]
  1457                        
  1458 00:B49D: C9 3A              CMP   #':'              ; compare with ":"
  1459 00:B49F: F0 1D              BEQ   LAB_15F6          ; branch if = (statement separator)
  1460                        
  1461                        LAB_15D9
  1462 00:B4A1: 4C A0 BB           JMP   LAB_SNER          ; else syntax error then warm start
  1463                                                      ; have reached [EOL]
  1464                        LAB_15DC
  1465 00:B4A4: A0 02              LDY   #$02              ; set index
  1466 00:B4A6: B1 6E              LDA   (Bpntrl),Y        ; get next line pointer high byte
  1467 00:B4A8: 18                 CLC                     ; clear carry for no "BREAK" message
  1468 00:B4A9: F0 4F              BEQ   LAB_1651          ; if null go to immediate mode (was immediate or [EOT]
  1469                                                      ; marker)
  1470 00:B4AB: C8                 INY                     ; increment index
  1471 00:B4AC: B1 6E              LDA   (Bpntrl),Y        ; get line # low byte
  1472 00:B4AE: 85 39              STA   Clinel            ; save current line low byte
  1473 00:B4B0: C8                 INY                     ; increment index
  1474 00:B4B1: B1 6E              LDA   (Bpntrl),Y        ; get line # high byte
  1475 00:B4B3: 85 3A              STA   Clineh            ; save current line high byte
  1476 00:B4B5: 98                 TYA                     ; A now = 4
  1477 00:B4B6: 65 6E              ADC   Bpntrl            ; add BASIC execute pointer low byte
  1478 00:B4B8: 85 6E              STA   Bpntrl            ; save BASIC execute pointer low byte
  1479 00:B4BA: 90 02              BCC   LAB_15F6          ; branch if no overflow
  1480                        
  1481 00:B4BC: E6 6F              INC   Bpntrh            ; else increment BASIC execute pointer high byte
  1482                        LAB_15F6
  1483 00:B4BE: 20 AE CF           JSR   LAB_IGBY          ; increment and scan memory
  1484                        
  1485                        LAB_15F9
  1486 00:B4C1: 20 C6 B4           JSR   LAB_15FF          ; go interpret BASIC code from (Bpntrl)
  1487                        
  1488                        LAB_15FC
  1489 00:B4C4: 80 C5              BRA   LAB_15C2          ; loop
  1490                        
  1491                        ; interpret BASIC code from (Bpntrl)
  1492                        
  1493                        LAB_15FF
  1494 00:B4C6: F0 4E              BEQ   LAB_1628          ; exit if zero [EOL]
  1495                        
  1496                        LAB_1602
  1497 00:B4C8: 0A                 ASL                     ; *2 bytes per vector and normalise token
  1498 00:B4C9: B0 03              BCS   LAB_1609          ; branch if was token
  1499 00:B4CB: 4C 63 B7           JMP   LAB_LET           ; else go do implied LET
  1500                        
  1501                        LAB_1609
  1502 00:B4CE: C9 50              CMP   #(TK_TAB-$80)*2   ; compare normalised token * 2 with TAB
  1503 00:B4D0: B0 CF              BCS   LAB_15D9          ; branch if A>=TAB (do syntax error then warm start)
  1504                                                      ; only tokens before TAB can start a line
  1505 00:B4D2: A8                 TAY                     ; copy to index
  1506 00:B4D3: B9 19 D1           LDA   LAB_CTBL+1,Y      ; get vector high byte
  Thu Sep 26 2019 15:30                                                                                                    Page 25


  1507 00:B4D6: 48                 PHA                     ; onto stack
  1508 00:B4D7: B9 18 D1           LDA   LAB_CTBL,Y        ; get vector low byte
  1509 00:B4DA: 48                 PHA                     ; onto stack
  1510 00:B4DB: 4C AE CF           JMP   LAB_IGBY          ; jump to increment and scan memory
  1511                                                      ; then "return" to vector
  1512                        
  1513                        ; CTRL-C check jump. this is called as a subroutine but exits back via a jump if a
  1514                        ; key press is detected.
  1515                        
  1516                        LAB_1629
  1517 00:B4DE: 6C 82 04           JMP   (VEC_CC)          ; ctrl-c check vector
  1518                        
  1519                        ; if there was a key press it gets back here ..
  1520                        
  1521                        LAB_1636
  1522 00:B4E1: C9 03              CMP   #$03              ; compare with CTRL-C
  1523                        
  1524                        ; perform STOP
  1525                        
  1526                        LAB_STOP
  1527 00:B4E3: B0 01              BCS   LAB_163B          ; branch if token follows STOP
  1528                                                      ; else just END
  1529                        ; END
  1530                        
  1531                        LAB_END
  1532 00:B4E5: 18                 CLC                     ; clear the carry, indicate a normal program end
  1533                        LAB_163B
  1534 00:B4E6: D0 61              BNE   LAB_167A          ; if wasn't CTRL-C or there is a following byte return
  1535                        
  1536 00:B4E8: A5 6F              LDA   Bpntrh            ; get the BASIC execute pointer high byte
  1537 00:B4EA: A4 6E              LDY   Bpntrl            ; get BASIC execute pointer low byte
  1538 00:B4EC: 84 3D              STY   Cpntrl            ; save continue pointer low byte
  1539 00:B4EE: 85 3E              STA   Cpntrh            ; save continue pointer high byte
  1540                        LAB_1647
  1541 00:B4F0: A5 39              LDA   Clinel            ; get current line low byte
  1542 00:B4F2: A4 3A              LDY   Clineh            ; get current line high byte
  1543 00:B4F4: 85 3B              STA   Blinel            ; save break line low byte
  1544 00:B4F6: 84 3C              STY   Blineh            ; save break line high byte
  1545                        LAB_164F
  1546 00:B4F8: 68                 PLA                     ; pull return address low
  1547 00:B4F9: 68                 PLA                     ; pull return address high
  1548                        LAB_1651
  1549 00:B4FA: 90 07              BCC   LAB_165E          ; if was program end just do warm start
  1550                                                      ; else ..
  1551 00:B4FC: A9 B9              LDA   #<LAB_BMSG        ; point to "Break" low byte
  1552 00:B4FE: A0 D6              LDY   #>LAB_BMSG        ; point to "Break" high byte
  1553 00:B500: 4C 1A B1           JMP   LAB_1269          ; print "Break" and do warm start
  1554                        
  1555                        LAB_165E
  1556 00:B503: 4C 25 B1           JMP   LAB_1274          ; go do warm start
  1557                        
  1558                        ; perform RESTORE
  1559                        
  1560                        LAB_RESTORE
  1561 00:B506: D0 0F              BNE   LAB_RESTOREn      ; branch if next character not null (RESTORE n)
  1562                        
  1563                        LAB_161A
  1564 00:B508: 38                 SEC                     ; set carry for subtract
  1565 00:B509: A5 2B              LDA   Smeml             ; get start of mem low byte
  1566 00:B50B: E9 01              SBC   #$01              ; -1
  1567 00:B50D: A4 2C              LDY   Smemh             ; get start of mem high byte
  1568 00:B50F: B0 01              BCS   LAB_1624          ; branch if no underflow
  1569                        
  Thu Sep 26 2019 15:30                                                                                                    Page 26


  1570                        LAB_uflow
  1571 00:B511: 88                 DEY                     ; else decrement high byte
  1572                        LAB_1624
  1573 00:B512: 85 41              STA   Dptrl             ; save DATA pointer low byte
  1574 00:B514: 84 42              STY   Dptrh             ; save DATA pointer high byte
  1575                        LAB_1628
  1576 00:B516: 60                 RTS
  1577                                                      ; is RESTORE n
  1578                        LAB_RESTOREn
  1579 00:B517: 20 05 B7           JSR   LAB_GFPN          ; get fixed-point number into temp integer
  1580 00:B51A: 20 5D B6           JSR   LAB_SNBL          ; scan for next BASIC line
  1581 00:B51D: A5 3A              LDA   Clineh            ; get current line high byte
  1582 00:B51F: C5 0B              CMP   Itemph            ; compare with temporary integer high byte
  1583 00:B521: B0 0B              BCS   LAB_reset_search  ; branch if >= (start search from beginning)
  1584                        
  1585 00:B523: 98                 TYA                     ; else copy line index to A
  1586 00:B524: 38                 SEC                     ; set carry (+1)
  1587 00:B525: 65 6E              ADC   Bpntrl            ; add BASIC execute pointer low byte
  1588 00:B527: A6 6F              LDX   Bpntrh            ; get BASIC execute pointer high byte
  1589 00:B529: 90 07              BCC   LAB_go_search     ; branch if no overflow to high byte
  1590                        
  1591 00:B52B: E8                 INX                     ; increment high byte
  1592 00:B52C: 80 04              BRA   LAB_go_search     ; branch always (can never be carry clear)
  1593                        
  1594                        ; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)
  1595                        
  1596                        LAB_reset_search
  1597 00:B52E: A5 2B              LDA   Smeml             ; get start of mem low byte
  1598 00:B530: A6 2C              LDX   Smemh             ; get start of mem high byte
  1599                        
  1600                        ; search for line # in temp (Itempl/Itemph) from (AX)
  1601                        
  1602                        LAB_go_search
  1603                        
  1604 00:B532: 20 FC B2           JSR   LAB_SHLN          ; search Basic for temp integer line number from AX
  1605 00:B535: B0 03              BCS   LAB_line_found    ; if carry set go set pointer
  1606                        
  1607 00:B537: 4C 2E B6           JMP   LAB_16F7          ; else go do "Undefined statement" error
  1608                        
  1609                        LAB_line_found
  1610                                                      ; carry already set for subtract
  1611 00:B53A: A5 5C              LDA   Baslnl            ; get pointer low byte
  1612 00:B53C: E9 01              SBC   #$01              ; -1
  1613 00:B53E: A4 5D              LDY   Baslnh            ; get pointer high byte
  1614 00:B540: B0 D0              BCS   LAB_1624          ; branch if no underflow (save DATA pointer and return)
  1615 00:B542: 80 CD              BRA   LAB_uflow         ; else decrement high byte then save DATA pointer and
  1616                                                      ; return (branch always)
  1617                        ; perform NULL
  1618                        
  1619                        LAB_NULL
  1620 00:B544: 20 15 C4           JSR   LAB_GTBY          ; get byte parameter
  1621 00:B547: 86 06              STX   Nullct            ; save new NULL count
  1622                        LAB_167A
  1623 00:B549: 60                 RTS
  1624                        
  1625                        ; perform CONT
  1626                        
  1627                        LAB_CONT
  1628 00:B54A: D0 FD              BNE   LAB_167A          ; if following byte exit to do syntax error
  1629                        
  1630 00:B54C: A4 3E              LDY   Cpntrh            ; get continue pointer high byte
  1631 00:B54E: C0 04              CPY   #>Ibuffs          ; *** fix p2: test direct mode
  1632 00:B550: D0 05              BNE   LAB_166C          ; go do continue if we can
  Thu Sep 26 2019 15:30                                                                                                    Page 27


  1633                        
  1634 00:B552: A2 1E              LDX   #$1E              ; error code $1E ("Can't continue" error)
  1635 00:B554: 4C 07 B1           JMP   LAB_XERR          ; do error #X, then warm start
  1636                                                      ; we can continue so ..
  1637                        LAB_166C
  1638 00:B557: 84 6F              STY   Bpntrh            ; save BASIC execute pointer high byte
  1639 00:B559: A5 3D              LDA   Cpntrl            ; get continue pointer low byte
  1640 00:B55B: 85 6E              STA   Bpntrl            ; save BASIC execute pointer low byte
  1641 00:B55D: A5 3B              LDA   Blinel            ; get break line low byte
  1642 00:B55F: A4 3C              LDY   Blineh            ; get break line high byte
  1643 00:B561: 85 39              STA   Clinel            ; set current line low byte
  1644 00:B563: 84 3A              STY   Clineh            ; set current line high byte
  1645 00:B565: 60                 RTS
  1646                        
  1647                        ; perform RUN
  1648                        
  1649                        LAB_RUN
  1650 00:B566: D0 03              BNE   LAB_1696          ; branch if RUN n
  1651 00:B568: 4C 39 B3           JMP   LAB_1477          ; reset execution to start, clear variables, flush stack, return
  1652                        
  1653                        ; does RUN n
  1654                        
  1655                        LAB_1696
  1656 00:B56B: 20 46 B3           JSR   LAB_147A          ; go do "CLEAR"
  1657 00:B56E: 80 2E              BRA   LAB_16B0          ; get n and do GOTO n (branch always as CLEAR sets Z=1)
  1658                        
  1659                        ; perform DO
  1660                        
  1661                        LAB_DO
  1662 00:B570: A9 05              LDA   #$05              ; need 5 bytes for DO
  1663 00:B572: 20 CC B0           JSR   LAB_1212          ; check room on stack for A bytes
  1664 00:B575: A5 6F              LDA   Bpntrh            ; get BASIC execute pointer high byte
  1665 00:B577: 48                 PHA                     ; push on stack
  1666 00:B578: A5 6E              LDA   Bpntrl            ; get BASIC execute pointer low byte
  1667 00:B57A: 48                 PHA                     ; push on stack
  1668 00:B57B: A5 3A              LDA   Clineh            ; get current line high byte
  1669 00:B57D: 48                 PHA                     ; push on stack
  1670 00:B57E: A5 39              LDA   Clinel            ; get current line low byte
  1671 00:B580: 48                 PHA                     ; push on stack
  1672 00:B581: A9 9B              LDA   #TK_DO            ; token for DO
  1673 00:B583: 48                 PHA                     ; push on stack
  1674 00:B584: 20 B4 CF           JSR   LAB_GBYT          ; scan memory
  1675 00:B587: 4C 8B B4           JMP   LAB_15C2          ; go do interpreter inner loop
  1676                        
  1677                        ; perform GOSUB
  1678                        
  1679                        LAB_GOSUB
  1680 00:B58A: A9 05              LDA   #$05              ; need 5 bytes for GOSUB
  1681 00:B58C: 20 CC B0           JSR   LAB_1212          ; check room on stack for A bytes
  1682 00:B58F: A5 6F              LDA   Bpntrh            ; get BASIC execute pointer high byte
  1683 00:B591: 48                 PHA                     ; push on stack
  1684 00:B592: A5 6E              LDA   Bpntrl            ; get BASIC execute pointer low byte
  1685 00:B594: 48                 PHA                     ; push on stack
  1686 00:B595: A5 3A              LDA   Clineh            ; get current line high byte
  1687 00:B597: 48                 PHA                     ; push on stack
  1688 00:B598: A5 39              LDA   Clinel            ; get current line low byte
  1689 00:B59A: 48                 PHA                     ; push on stack
  1690 00:B59B: A9 8D              LDA   #TK_GOSUB         ; token for GOSUB
  1691 00:B59D: 48                 PHA                     ; push on stack
  1692                        LAB_16B0
  1693 00:B59E: 20 B4 CF           JSR   LAB_GBYT          ; scan memory
  1694 00:B5A1: 20 A7 B5           JSR   LAB_GOTO          ; perform GOTO n
  1695 00:B5A4: 4C 8B B4           JMP   LAB_15C2          ; go do interpreter inner loop, return
  Thu Sep 26 2019 15:30                                                                                                    Page 28


  1696                        
  1697                        ; perform GOTO
  1698                        
  1699                        LAB_GOTO
  1700 00:B5A7: 20 05 B7           JSR   LAB_GFPN          ; get fixed-point number into temp integer
  1701 00:B5AA: 20 5D B6           JSR   LAB_SNBL          ; scan for next BASIC line
  1702 00:B5AD: A5 3A              LDA   Clineh            ; get current line high byte
  1703 00:B5AF: C5 0B              CMP   Itemph            ; compare with temporary integer high byte
  1704 00:B5B1: B0 0B              BCS   LAB_16D0          ; branch if >= (start search from beginning)
  1705                        
  1706 00:B5B3: 98                 TYA                     ; else copy line index to A
  1707 00:B5B4: 38                 SEC                     ; set carry (+1)
  1708 00:B5B5: 65 6E              ADC   Bpntrl            ; add BASIC execute pointer low byte
  1709 00:B5B7: A6 6F              LDX   Bpntrh            ; get BASIC execute pointer high byte
  1710 00:B5B9: 90 07              BCC   LAB_16D4          ; branch if no overflow to high byte
  1711                        
  1712 00:B5BB: E8                 INX                     ; increment high byte
  1713 00:B5BC: 80 04              BRA   LAB_16D4          ; branch always (can never be carry)
  1714                        
  1715                        ; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)
  1716                        
  1717                        LAB_16D0
  1718 00:B5BE: A5 2B              LDA   Smeml             ; get start of mem low byte
  1719 00:B5C0: A6 2C              LDX   Smemh             ; get start of mem high byte
  1720                        
  1721                        ; search for line # in temp (Itempl/Itemph) from (AX)
  1722                        
  1723                        LAB_16D4
  1724 00:B5C2: 20 FC B2           JSR   LAB_SHLN          ; search Basic for temp integer line number from AX
  1725 00:B5C5: 90 67              BCC   LAB_16F7          ; if carry clear go do "Undefined statement" error
  1726                                                      ; (unspecified statement)
  1727                                                      ; carry already set for subtract
  1728 00:B5C7: A5 5C              LDA   Baslnl            ; get pointer low byte
  1729 00:B5C9: E9 01              SBC   #$01              ; -1
  1730 00:B5CB: 85 6E              STA   Bpntrl            ; save BASIC execute pointer low byte
  1731 00:B5CD: A5 5D              LDA   Baslnh            ; get pointer high byte
  1732 00:B5CF: E9 00              SBC   #$00              ; subtract carry
  1733 00:B5D1: 85 6F              STA   Bpntrh            ; save BASIC execute pointer high byte
  1734                        LAB_16E5
  1735 00:B5D3: 60                 RTS
  1736                        
  1737                        LAB_DONOK
  1738 00:B5D4: A2 22              LDX   #$22              ; error code $22 ("LOOP without DO" error)
  1739 00:B5D6: 4C 07 B1           JMP   LAB_XERR          ; do error #X, then warm start
  1740                        
  1741                        ; perform LOOP
  1742                        
  1743                        LAB_LOOP
  1744 00:B5D9: A8                 TAY                     ; save following token
  1745 00:B5DA: BA                 TSX                     ; copy stack pointer
  1746 00:B5DB: BD 03 01           LDA   LAB_STAK+3,X      ; get token byte from stack
  1747 00:B5DE: C9 9B              CMP   #TK_DO            ; compare with DO token
  1748 00:B5E0: D0 F2              BNE   LAB_DONOK         ; branch if no matching DO
  1749                        
  1750 00:B5E2: E8                 INX                     ; dump calling routine return address
  1751 00:B5E3: E8                 INX                     ; dump calling routine return address
  1752 00:B5E4: 9A                 TXS                     ; correct stack
  1753 00:B5E5: 98                 TYA                     ; get saved following token back
  1754 00:B5E6: F0 20              BEQ   LoopAlways        ; if no following token loop forever
  1755                                                      ; (stack pointer in X)
  1756                        
  1757 00:B5E8: C9 3A              CMP   #':'              ; could be ':'
  1758 00:B5EA: F0 1C              BEQ   LoopAlways        ; if :... loop forever
  Thu Sep 26 2019 15:30                                                                                                    Page 29


  1759                        
  1760 00:B5EC: E9 B0              SBC   #TK_UNTIL         ; subtract token for UNTIL, we know carry is set here
  1761 00:B5EE: AA                 TAX                     ; copy to X (if it was UNTIL then Y will be correct)
  1762 00:B5EF: F0 04              BEQ   DoRest            ; branch if was UNTIL
  1763                        
  1764 00:B5F1: CA                 DEX                     ; decrement result
  1765 00:B5F2: D0 62              BNE   LAB_16FC          ; if not WHILE go do syntax error and warm start
  1766                                                      ; only if the token was WHILE will this fail
  1767                        
  1768 00:B5F4: CA                 DEX                     ; set invert result byte
  1769                        DoRest
  1770 00:B5F5: 86 4A              STX   Frnxth            ; save invert result byte
  1771 00:B5F7: 20 AE CF           JSR   LAB_IGBY          ; increment and scan memory
  1772 00:B5FA: 20 84 BA           JSR   LAB_EVEX          ; evaluate expression
  1773 00:B5FD: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  1774 00:B5FF: F0 02              BEQ   DoCmp             ; if =0 go do straight compare
  1775                        
  1776 00:B601: A9 FF              LDA   #$FF              ; else set all bits
  1777                        DoCmp
  1778 00:B603: BA                 TSX                     ; copy stack pointer
  1779 00:B604: 45 4A              EOR   Frnxth            ; EOR with invert byte
  1780 00:B606: D0 1A              BNE   LoopDone          ; if <> 0 clear stack and back to interpreter loop
  1781                                                      ; loop condition wasn't met so do it again
  1782                        LoopAlways
  1783 00:B608: BD 02 01           LDA   LAB_STAK+2,X      ; get current line low byte
  1784 00:B60B: 85 39              STA   Clinel            ; save current line low byte
  1785 00:B60D: BD 03 01           LDA   LAB_STAK+3,X      ; get current line high byte
  1786 00:B610: 85 3A              STA   Clineh            ; save current line high byte
  1787 00:B612: BD 04 01           LDA   LAB_STAK+4,X      ; get BASIC execute pointer low byte
  1788 00:B615: 85 6E              STA   Bpntrl            ; save BASIC execute pointer low byte
  1789 00:B617: BD 05 01           LDA   LAB_STAK+5,X      ; get BASIC execute pointer high byte
  1790 00:B61A: 85 6F              STA   Bpntrh            ; save BASIC execute pointer high byte
  1791 00:B61C: 20 B4 CF           JSR   LAB_GBYT          ; scan memory
  1792 00:B61F: 4C 8B B4           JMP   LAB_15C2          ; go do interpreter inner loop
  1793                        
  1794                                                      ; clear stack and back to interpreter loop
  1795                        LoopDone
  1796 00:B622: E8                 INX                     ; dump DO token
  1797 00:B623: E8                 INX                     ; dump current line low byte
  1798 00:B624: E8                 INX                     ; dump current line high byte
  1799 00:B625: E8                 INX                     ; dump BASIC execute pointer low byte
  1800 00:B626: E8                 INX                     ; dump BASIC execute pointer high byte
  1801 00:B627: 9A                 TXS                     ; correct stack
  1802 00:B628: 80 1E              BRA   LAB_DATA          ; go perform DATA (find : or [EOL])
  1803                        
  1804                        ; do the return without gosub error
  1805                        
  1806                        LAB_16F4
  1807 00:B62A: A2 04              LDX   #$04              ; error code $04 ("RETURN without GOSUB" error)
  1808 00:B62C: 80 02              BRA   LAB_16F7b         ; branch around next instruction, save one clock cycle
  1809                        
  1810                        LAB_16F7                      ; do undefined statement error
  1811 00:B62E: A2 0E              LDX   #$0E              ; error code $0E ("Undefined statement" error)
  1812                        LAB_16F7b
  1813 00:B630: 4C 07 B1           JMP   LAB_XERR          ; do error #X, then warm start
  1814                        
  1815                        ; perform RETURN
  1816                        
  1817                        LAB_RETURN
  1818 00:B633: D0 9E              BNE   LAB_16E5          ; exit if following token (to allow syntax error)
  1819                        
  1820                        LAB_16E8
  1821 00:B635: 68                 PLA                     ; dump calling routine return address
  Thu Sep 26 2019 15:30                                                                                                    Page 30


  1822 00:B636: 68                 PLA                     ; dump calling routine return address
  1823 00:B637: 68                 PLA                     ; pull token
  1824 00:B638: C9 8D              CMP   #TK_GOSUB         ; compare with GOSUB token
  1825 00:B63A: D0 EE              BNE   LAB_16F4          ; branch if no matching GOSUB
  1826                        
  1827                        LAB_16FF
  1828 00:B63C: 68                 PLA                     ; pull current line low byte
  1829 00:B63D: 85 39              STA   Clinel            ; save current line low byte
  1830 00:B63F: 68                 PLA                     ; pull current line high byte
  1831 00:B640: 85 3A              STA   Clineh            ; save current line high byte
  1832 00:B642: 68                 PLA                     ; pull BASIC execute pointer low byte
  1833 00:B643: 85 6E              STA   Bpntrl            ; save BASIC execute pointer low byte
  1834 00:B645: 68                 PLA                     ; pull BASIC execute pointer high byte
  1835 00:B646: 85 6F              STA   Bpntrh            ; save BASIC execute pointer high byte
  1836                        
  1837                                                      ; now do the DATA statement as we could be returning into
  1838                                                      ; the middle of an ON <var> GOSUB n,m,p,q line
  1839                                                      ; (the return address used by the DATA statement is the one
  1840                                                      ; pushed before the GOSUB was executed!)
  1841                        
  1842                        ; perform DATA
  1843                        
  1844                        LAB_DATA
  1845 00:B648: 20 59 B6           JSR   LAB_SNBS          ; scan for next BASIC statement ([:] or [EOL])
  1846                        
  1847                                                      ; set BASIC execute pointer
  1848                        LAB_170F
  1849 00:B64B: 98                 TYA                     ; copy index to A
  1850 00:B64C: 18                 CLC                     ; clear carry for add
  1851 00:B64D: 65 6E              ADC   Bpntrl            ; add BASIC execute pointer low byte
  1852 00:B64F: 85 6E              STA   Bpntrl            ; save BASIC execute pointer low byte
  1853 00:B651: 90 02              BCC   LAB_1719          ; skip next if no carry
  1854                        
  1855 00:B653: E6 6F              INC   Bpntrh            ; else increment BASIC execute pointer high byte
  1856                        LAB_1719
  1857 00:B655: 60                 RTS
  1858                        
  1859                        LAB_16FC
  1860 00:B656: 4C A0 BB           JMP   LAB_SNER          ; do syntax error then warm start
  1861                        
  1862                        ; scan for next BASIC statement ([:] or [EOL])
  1863                        ; returns Y as index to [:] or [EOL]
  1864                        
  1865                        LAB_SNBS
  1866 00:B659: A2 3A              LDX   #':'              ; set look for character = ":"
  1867 00:B65B: 80 02              BRA   LAB_SNBLb         ; branch around next instruction, save one clock cycle
  1868                        
  1869                        ; scan for next BASIC line
  1870                        ; returns Y as index to [EOL]
  1871                        
  1872                        LAB_SNBL
  1873 00:B65D: A2 00              LDX   #$00              ; set alt search character = [EOL]
  1874                        LAB_SNBLb
  1875 00:B65F: A0 00              LDY   #$00              ; set search character = [EOL]
  1876 00:B661: 84 0E              STY   Asrch             ; store search character
  1877                        LAB_1725
  1878 00:B663: 8A                 TXA                     ; get alt search character
  1879 00:B664: 45 0E              EOR   Asrch             ; toggle search character, effectively swap with $00
  1880 00:B666: 85 0E              STA   Asrch             ; save swapped search character
  1881                        LAB_172D
  1882 00:B668: B1 6E              LDA   (Bpntrl),Y        ; get next byte
  1883 00:B66A: F0 E9              BEQ   LAB_1719          ; exit if null [EOL]
  1884                        
  Thu Sep 26 2019 15:30                                                                                                    Page 31


  1885 00:B66C: C5 0E              CMP   Asrch             ; compare with search character
  1886 00:B66E: F0 E5              BEQ   LAB_1719          ; exit if found
  1887                        
  1888 00:B670: C8                 INY                     ; increment index
  1889 00:B671: C9 22              CMP   #$22              ; compare current character with open quote
  1890 00:B673: D0 F3              BNE   LAB_172D          ; if not open quote go get next character
  1891 00:B675: 80 EC              BRA   LAB_1725          ; if found go swap search character for alt search character
  1892                        
  1893                        ; perform IF
  1894                        
  1895                        LAB_IF
  1896 00:B677: 20 84 BA           JSR   LAB_EVEX          ; evaluate the expression
  1897 00:B67A: 20 B4 CF           JSR   LAB_GBYT          ; scan memory
  1898 00:B67D: C9 AD              CMP   #TK_THEN          ; compare with THEN token
  1899 00:B67F: F0 11              BEQ   LAB_174B          ; if it was THEN go do IF
  1900                        
  1901                                                      ; wasn't IF .. THEN so must be IF .. GOTO
  1902 00:B681: C9 89              CMP   #TK_GOTO          ; compare with GOTO token
  1903 00:B683: D0 D1              BNE   LAB_16FC          ; if it wasn't GOTO go do syntax error
  1904                        
  1905 00:B685: A6 6E              LDX   Bpntrl            ; save the basic pointer low byte
  1906 00:B687: A4 6F              LDY   Bpntrh            ; save the basic pointer high byte
  1907 00:B689: 20 AE CF           JSR   LAB_IGBY          ; increment and scan memory
  1908 00:B68C: B0 C8              BCS   LAB_16FC          ; if not numeric go do syntax error
  1909                        
  1910 00:B68E: 86 6E              STX   Bpntrl            ; restore the basic pointer low byte
  1911 00:B690: 84 6F              STY   Bpntrh            ; restore the basic pointer high byte
  1912                        LAB_174B
  1913 00:B692: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  1914 00:B694: F0 1C              BEQ   LAB_174E          ; if the result was zero go look for an ELSE
  1915                        
  1916 00:B696: 20 AE CF           JSR   LAB_IGBY          ; else increment and scan memory
  1917 00:B699: B0 03              BCS   LAB_174D          ; if not numeric go do var or keyword
  1918                        
  1919                        LAB_174C
  1920 00:B69B: 4C A7 B5           JMP   LAB_GOTO          ; else was numeric so do GOTO n
  1921                        
  1922                                                      ; is var or keyword
  1923                        LAB_174D
  1924 00:B69E: 68                 PLA                     ; discard interpreter loop return address
  1925 00:B69F: 68                 PLA                     ; so data structures are at the correct stack offset
  1926 00:B6A0: 20 B4 CF           JSR   LAB_GBYT          ; restore token or variable
  1927 00:B6A3: 20 C6 B4           JSR   LAB_15FF          ; interpret BASIC code from (Bpntrl)
  1928                        
  1929                        ; the IF was executed and there may be a following ELSE so the code needs to return
  1930                        ; here to check and ignore the ELSE if present
  1931                        
  1932 00:B6A6: B2 6E              LDA   (Bpntrl)          ; get the next BASIC byte
  1933 00:B6A8: C9 A9              CMP   #TK_ELSE          ; compare it with the token for ELSE
  1934 00:B6AA: D0 03              BNE   LAB_no_ELSE       ; no - continue on this line
  1935 00:B6AC: 20 48 B6           JSR   LAB_DATA          ; yes - skip the rest of the line
  1936                        
  1937                        ; there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
  1938                        ; following ELSE will, correctly, cause a syntax error
  1939                        
  1940                        LAB_no_ELSE
  1941 00:B6AF: 4C 8B B4           JMP LAB_15C2            ; return to the interpreter inner loop
  1942                        
  1943                        ; perform ELSE after IF
  1944                        
  1945                        LAB_174E
  1946 00:B6B2: A0 00              LDY   #$00              ; clear the BASIC byte index
  1947 00:B6B4: A2 01              LDX   #$01              ; clear the nesting depth
  Thu Sep 26 2019 15:30                                                                                                    Page 32


  1948                        LAB_1750
  1949 00:B6B6: C8                 INY                     ; increment the BASIC byte index
  1950 00:B6B7: B1 6E              LDA   (Bpntrl),Y        ; get the next BASIC byte
  1951 00:B6B9: F0 0F              BEQ   LAB_1753          ; if EOL go add the pointer and return
  1952                        
  1953 00:B6BB: C9 8B              CMP   #TK_IF            ; compare the byte with the token for IF
  1954 00:B6BD: D0 03              BNE   LAB_1752          ; if not IF token skip the depth increment
  1955                        
  1956 00:B6BF: E8                 INX                     ; else increment the nesting depth,
  1957 00:B6C0: D0 F4              BNE   LAB_1750          ; and continue looking
  1958                        
  1959                        LAB_1752
  1960 00:B6C2: C9 A9              CMP   #TK_ELSE          ; compare the byte with the token for ELSE
  1961 00:B6C4: D0 F0              BNE   LAB_1750          ; if not ELSE token continue looking
  1962                        
  1963 00:B6C6: CA                 DEX                     ; was ELSE so decrement the nesting depth
  1964 00:B6C7: D0 ED              BNE   LAB_1750          ; loop if still nested
  1965                        
  1966 00:B6C9: C8                 INY                     ; increment the BASIC byte index past the ELSE
  1967                        
  1968                        ; found the matching ELSE, now do <{n|statement}>
  1969                        
  1970                        LAB_1753
  1971 00:B6CA: 98                 TYA                     ; else copy line index to A
  1972 00:B6CB: 18                 CLC                     ; clear carry for add
  1973 00:B6CC: 65 6E              ADC   Bpntrl            ; add the BASIC execute pointer low byte
  1974 00:B6CE: 85 6E              STA   Bpntrl            ; save the BASIC execute pointer low byte
  1975 00:B6D0: 90 02              BCC   LAB_1754          ; branch if no overflow to high byte
  1976                        
  1977 00:B6D2: E6 6F              INC   Bpntrh            ; else increment the BASIC execute pointer high byte
  1978                        LAB_1754
  1979 00:B6D4: 20 B4 CF           JSR   LAB_GBYT          ; scan memory
  1980 00:B6D7: 90 C2              BCC   LAB_174C          ; if numeric do GOTO n
  1981                                                      ; the code will return to the interpreter loop at the
  1982                                                      ; tail end of the GOTO <n>
  1983                        
  1984 00:B6D9: 4C C6 B4           JMP   LAB_15FF          ; interpret BASIC code from (Bpntrl)
  1985                                                      ; the code will return to the interpreter loop at the
  1986                                                      ; tail end of the <statement>
  1987                        
  1988                        ; perform REM, skip (rest of) line
  1989                        
  1990                        LAB_REM
  1991 00:B6DC: 20 5D B6           JSR   LAB_SNBL          ; scan for next BASIC line
  1992 00:B6DF: 4C 4B B6           JMP   LAB_170F          ; go set BASIC execute pointer and return
  1993                        
  1994                        LAB_16FD
  1995 00:B6E2: 4C A0 BB           JMP   LAB_SNER          ; do syntax error then warm start
  1996                        
  1997                        ; perform ON
  1998                        
  1999                        LAB_ON
  2000 00:B6E5: 20 15 C4           JSR   LAB_GTBY          ; get byte parameter
  2001 00:B6E8: 48                 PHA                     ; push GOTO/GOSUB token
  2002 00:B6E9: C9 8D              CMP   #TK_GOSUB         ; compare with GOSUB token
  2003 00:B6EB: F0 04              BEQ   LAB_176B          ; branch if GOSUB
  2004                        
  2005 00:B6ED: C9 89              CMP   #TK_GOTO          ; compare with GOTO token
  2006                        LAB_1767
  2007 00:B6EF: D0 F1              BNE   LAB_16FD          ; if not GOTO do syntax error then warm start
  2008                        
  2009                        ; next character was GOTO or GOSUB
  2010                        
  Thu Sep 26 2019 15:30                                                                                                    Page 33


  2011                        LAB_176B
  2012 00:B6F1: C6 61              DEC   FAC1_3            ; decrement index (byte value)
  2013 00:B6F3: D0 04              BNE   LAB_1773          ; branch if not zero
  2014                        
  2015 00:B6F5: 68                 PLA                     ; pull GOTO/GOSUB token
  2016 00:B6F6: 4C C8 B4           JMP   LAB_1602          ; go execute it
  2017                        
  2018                        LAB_1773
  2019 00:B6F9: 20 AE CF           JSR   LAB_IGBY          ; increment and scan memory
  2020 00:B6FC: 20 05 B7           JSR   LAB_GFPN          ; get fixed-point number into temp integer (skip this n)
  2021                                                      ; (we could LDX #',' and JSR LAB_SNBL+2, then we
  2022                                                      ; just BNE LAB_176B for the loop. should be quicker ..
  2023                                                      ; no we can't, what if we meet a colon or [EOL]?)
  2024 00:B6FF: C9 2C              CMP   #$2C              ; compare next character with ","
  2025 00:B701: F0 EE              BEQ   LAB_176B          ; loop if ","
  2026                        
  2027                        LAB_177E
  2028 00:B703: 68                 PLA                     ; else pull keyword token (run out of options)
  2029                                                      ; also dump +/-1 pointer low byte and exit
  2030                        LAB_177F
  2031 00:B704: 60                 RTS
  2032                        
  2033                        ; takes n * 106 + 11 cycles where n is the number of digits
  2034                        
  2035                        ; get fixed-point number into temp integer
  2036                        
  2037                        LAB_GFPN
  2038 00:B705: A2 00              LDX   #$00              ; clear reg
  2039 00:B707: 86 0A              STX   Itempl            ; clear temporary integer low byte
  2040                        LAB_1785
  2041 00:B709: 86 0B              STX   Itemph            ; save temporary integer high byte
  2042 00:B70B: B0 F7              BCS   LAB_177F          ; return if carry set, end of scan, character was
  2043                                                      ; not 0-9
  2044                        
  2045 00:B70D: E0 19              CPX   #$19              ; compare high byte with $19
  2046 00:B70F: A8                 TAY                     ; ensure Zb = 0 if the branch is taken
  2047 00:B710: B0 DD              BCS   LAB_1767          ; branch if >=, makes max line # 63999 because next
  2048                                                      ; bit does *$0A, = 64000, compare at target will fail
  2049                                                      ; and do syntax error
  2050                        
  2051 00:B712: E9 2F              SBC   #'0'-1            ; subtract "0", $2F + carry, from byte
  2052 00:B714: A8                 TAY                     ; copy binary digit
  2053 00:B715: A5 0A              LDA   Itempl            ; get temporary integer low byte
  2054 00:B717: 0A                 ASL                     ; *2 low byte
  2055 00:B718: 26 0B              ROL   Itemph            ; *2 high byte
  2056 00:B71A: 0A                 ASL                     ; *2 low byte
  2057 00:B71B: 26 0B              ROL   Itemph            ; *2 high byte, *4
  2058 00:B71D: 65 0A              ADC   Itempl            ; + low byte, *5
  2059 00:B71F: 85 0A              STA   Itempl            ; save it
  2060 00:B721: 8A                 TXA                     ; get high byte copy to A
  2061 00:B722: 65 0B              ADC   Itemph            ; + high byte, *5
  2062 00:B724: 06 0A              ASL   Itempl            ; *2 low byte, *10d
  2063 00:B726: 2A                 ROL                     ; *2 high byte, *10d
  2064 00:B727: AA                 TAX                     ; copy high byte back to X
  2065 00:B728: 98                 TYA                     ; get binary digit back
  2066 00:B729: 65 0A              ADC   Itempl            ; add number low byte
  2067 00:B72B: 85 0A              STA   Itempl            ; save number low byte
  2068 00:B72D: 90 01              BCC   LAB_17B3          ; if no overflow to high byte get next character
  2069                        
  2070 00:B72F: E8                 INX                     ; else increment high byte
  2071                        LAB_17B3
  2072 00:B730: 20 AE CF           JSR   LAB_IGBY          ; increment and scan memory
  2073 00:B733: 80 D4              BRA   LAB_1785          ; loop for next character
  Thu Sep 26 2019 15:30                                                                                                    Page 34


  2074                        
  2075                        ; perform DEC
  2076                        
  2077                        LAB_DEC
  2078 00:B735: A9 F5              LDA   #<LAB_2AFD        ; set -1 pointer low byte
  2079 00:B737: 80 02              BRA   LAB_17B5          ; branch around next instruction, saves one clock cycle
  2080                        
  2081                        ; perform INC
  2082                        
  2083                        LAB_INC
  2084 00:B739: A9 F1              LDA   #<LAB_259C        ; set 1 pointer low byte
  2085                        LAB_17B5
  2086 00:B73B: 48                 PHA                     ; save +/-1 pointer low byte
  2087                        LAB_17B7
  2088 00:B73C: 20 42 BD           JSR   LAB_GVAR          ; get var address
  2089 00:B73F: A6 11              LDX   Dtypef            ; get data type flag, $FF=string, $00=numeric
  2090 00:B741: 30 1D              BMI   IncrErr           ; exit if string
  2091                        
  2092 00:B743: 85 49              STA   Lvarpl            ; save var address low byte
  2093 00:B745: 84 4A              STY   Lvarph            ; save var address high byte
  2094 00:B747: 20 FB C7           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
  2095 00:B74A: 68                 PLA                     ; get +/-1 pointer low byte
  2096 00:B74B: 48                 PHA                     ; save +/-1 pointer low byte
  2097 00:B74C: A0 D0              LDY   #>LAB_259C        ; set +/-1 pointer high byte (both the same)
  2098 00:B74E: 20 43 C5           JSR   LAB_246C          ; add (AY) to FAC1
  2099 00:B751: 20 21 C8           JSR   LAB_PFAC          ; pack FAC1 into variable (Lvarpl)
  2100                        
  2101 00:B754: 20 B4 CF           JSR   LAB_GBYT          ; scan memory
  2102 00:B757: C9 2C              CMP   #','              ; compare with ","
  2103 00:B759: D0 A8              BNE   LAB_177E          ; exit if not "," (either end or error)
  2104                        
  2105                                                      ; was "," so another INCR variable to do
  2106 00:B75B: 20 AE CF           JSR   LAB_IGBY          ; increment and scan memory
  2107 00:B75E: 80 DC              BRA   LAB_17B7          ; go do next var
  2108                        
  2109                        IncrErr
  2110 00:B760: 4C 7F BA           JMP   LAB_1ABC          ; do "Type mismatch" error then warm start
  2111                        
  2112                        ; perform LET
  2113                        
  2114                        LAB_LET
  2115 00:B763: 20 42 BD           JSR   LAB_GVAR          ; get var address
  2116 00:B766: 85 49              STA   Lvarpl            ; save var address low byte
  2117 00:B768: 84 4A              STY   Lvarph            ; save var address high byte
  2118 00:B76A: A9 BD              LDA   #TK_EQUAL         ; get = token
  2119 00:B76C: 20 91 BB           JSR   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
  2120 00:B76F: A5 11              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
  2121 00:B771: 48                 PHA                     ; push data type flag
  2122 00:B772: 20 84 BA           JSR   LAB_EVEX          ; evaluate expression
  2123 00:B775: 68                 PLA                     ; pop data type flag
  2124 00:B776: 2A                 ROL                     ; set carry if type = string
  2125 00:B777: 20 76 BA           JSR   LAB_CKTM          ; type match check, set C for string
  2126 00:B77A: D0 03              BNE   LAB_17D5          ; branch if string
  2127 00:B77C: 4C 21 C8           JMP   LAB_PFAC          ; pack FAC1 into variable (Lvarpl) and return
  2128                        
  2129                        ; string LET
  2130                        
  2131                        LAB_17D5
  2132 00:B77F: A0 02              LDY   #$02              ; set index to pointer high byte
  2133 00:B781: B1 60              LDA   (des_pl),Y        ; get string pointer high byte
  2134 00:B783: C5 34              CMP   Sstorh            ; compare bottom of string space high byte
  2135 00:B785: 90 17              BCC   LAB_17F4          ; if less assign value and exit (was in program memory)
  2136                        
  Thu Sep 26 2019 15:30                                                                                                    Page 35


  2137 00:B787: D0 07              BNE   LAB_17E6          ; branch if >
  2138                                                      ; else was equal so compare low bytes
  2139 00:B789: 88                 DEY                     ; decrement index
  2140 00:B78A: B1 60              LDA   (des_pl),Y        ; get pointer low byte
  2141 00:B78C: C5 33              CMP   Sstorl            ; compare bottom of string space low byte
  2142 00:B78E: 90 0E              BCC   LAB_17F4          ; if less assign value and exit (was in program memory)
  2143                        
  2144                                                      ; pointer was >= to bottom of string space pointer
  2145                        LAB_17E6
  2146 00:B790: A4 61              LDY   des_ph            ; get descriptor pointer high byte
  2147 00:B792: C4 2E              CPY   Svarh             ; compare start of vars high byte
  2148 00:B794: 90 08              BCC   LAB_17F4          ; branch if less (descriptor is on stack)
  2149 00:B796: D0 0C              BNE   LAB_17FB          ; branch if greater (descriptor is not on stack)
  2150                                                      ; else high bytes were equal so ..
  2151 00:B798: A5 60              LDA   des_pl            ; get descriptor pointer low byte
  2152 00:B79A: C5 2D              CMP   Svarl             ; compare start of vars low byte
  2153 00:B79C: B0 06              BCS   LAB_17FB          ; branch if >= (descriptor is not on stack)
  2154                        
  2155                        LAB_17F4
  2156 00:B79E: A5 60              LDA   des_pl            ; get descriptor pointer low byte
  2157 00:B7A0: A4 61              LDY   des_ph            ; get descriptor pointer high byte
  2158 00:B7A2: 80 14              BRA   LAB_1811          ; clean stack, copy descriptor to variable and return
  2159                        
  2160                                                      ; make space and copy string
  2161                        LAB_17FB
  2162 00:B7A4: B2 60              LDA   (des_pl)          ; get string length
  2163 00:B7A6: 20 C5 C0           JSR   LAB_209C          ; copy string
  2164 00:B7A9: A5 50              LDA   des_2l            ; get descriptor pointer low byte
  2165 00:B7AB: A4 51              LDY   des_2h            ; get descriptor pointer high byte
  2166 00:B7AD: 85 6A              STA   ssptr_l           ; save descriptor pointer low byte
  2167 00:B7AF: 84 6B              STY   ssptr_h           ; save descriptor pointer high byte
  2168 00:B7B1: 20 A1 C2           JSR   LAB_228A          ; copy string from descriptor (sdescr) to (Sutill)
  2169 00:B7B4: A9 5E              LDA   #<FAC1_e          ; set descriptor pointer low byte
  2170 00:B7B6: A0 00              LDY   #>FAC1_e          ; get descriptor pointer high byte
  2171                        
  2172                                                      ; clean stack and assign value to string variable
  2173                        LAB_1811
  2174 00:B7B8: 85 50              STA   des_2l            ; save descriptor_2 pointer low byte
  2175 00:B7BA: 84 51              STY   des_2h            ; save descriptor_2 pointer high byte
  2176 00:B7BC: 20 03 C3           JSR   LAB_22EB          ; clean descriptor stack, YA = pointer
  2177 00:B7BF: A0 00              LDY   #$00              ; index to length
  2178 00:B7C1: B1 50              LDA   (des_2l),Y        ; get string length
  2179 00:B7C3: 91 49              STA   (Lvarpl),Y        ; copy to let string variable
  2180 00:B7C5: C8                 INY                     ; index to string pointer low byte
  2181 00:B7C6: B1 50              LDA   (des_2l),Y        ; get string pointer low byte
  2182 00:B7C8: 91 49              STA   (Lvarpl),Y        ; copy to let string variable
  2183 00:B7CA: C8                 INY                     ; index to string pointer high byte
  2184 00:B7CB: B1 50              LDA   (des_2l),Y        ; get string pointer high byte
  2185 00:B7CD: 91 49              STA   (Lvarpl),Y        ; copy to let string variable
  2186 00:B7CF: 60                 RTS
  2187                        
  2188                        ; perform GET
  2189                        
  2190                        LAB_GET
  2191 00:B7D0: 20 42 BD           JSR   LAB_GVAR          ; get var address
  2192 00:B7D3: 85 49              STA   Lvarpl            ; save var address low byte
  2193 00:B7D5: 84 4A              STY   Lvarph            ; save var address high byte
  2194 00:B7D7: 20 31 CE           JSR   INGET             ; get input byte
  2195 00:B7DA: A6 11              LDX   Dtypef            ; get data type flag, $FF=string, $00=numeric
  2196 00:B7DC: 30 07              BMI   LAB_GETS          ; go get string character
  2197                                                      ; was numeric get
  2198 00:B7DE: A8                 TAY                     ; copy character to Y
  2199 00:B7DF: 20 FB BF           JSR   LAB_1FD0          ; convert Y to byte in FAC1
  Thu Sep 26 2019 15:30                                                                                                    Page 36


  2200 00:B7E2: 4C 21 C8           JMP   LAB_PFAC          ; pack FAC1 into variable (Lvarpl) and return
  2201                        
  2202                        LAB_GETS
  2203 00:B7E5: 48                 PHA                     ; save character
  2204 00:B7E6: A9 01              LDA   #$01              ; string is single byte
  2205 00:B7E8: B0 01              BCS   LAB_IsByte        ; branch if byte received
  2206                        
  2207 00:B7EA: 68                 PLA                     ; string is null
  2208                        LAB_IsByte
  2209 00:B7EB: 20 CD C0           JSR   LAB_MSSP          ; make string space A bytes long A=$AC=length,
  2210                                                      ; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
  2211 00:B7EE: F0 03              BEQ   LAB_NoSt          ; skip store if null string
  2212                        
  2213 00:B7F0: 68                 PLA                     ; get character back
  2214 00:B7F1: 92 5F              STA   (str_pl)          ; save byte in string (byte IS string!)
  2215                        LAB_NoSt
  2216 00:B7F3: 20 1A C1           JSR   LAB_RTST          ; check for space on descriptor stack then put address
  2217                                                      ; and length on descriptor stack and update stack pointers
  2218 00:B7F6: 80 87              BRA   LAB_17D5          ; do string LET and return
  2219                        
  2220                        ; perform PRINT
  2221                        
  2222                        LAB_1829
  2223 00:B7F8: 20 7B B8           JSR   LAB_18C6          ; print string from Sutill/Sutilh
  2224                        LAB_182C
  2225 00:B7FB: 20 B4 CF           JSR   LAB_GBYT          ; scan memory
  2226                        
  2227                        ; PRINT
  2228                        
  2229                        LAB_PRINT
  2230 00:B7FE: F0 37              BEQ   LAB_CRLF          ; if nothing following just print CR/LF
  2231                        
  2232                        LAB_1831
  2233 00:B800: C9 A8              CMP   #TK_TAB           ; compare with TAB( token
  2234 00:B802: F0 52              BEQ   LAB_18A2          ; go do TAB/SPC
  2235                        
  2236 00:B804: C9 AC              CMP   #TK_SPC           ; compare with SPC( token
  2237 00:B806: F0 4E              BEQ   LAB_18A2          ; go do TAB/SPC
  2238                        
  2239 00:B808: C9 2C              CMP   #','              ; compare with ","
  2240 00:B80A: F0 34              BEQ   LAB_188B          ; go do move to next TAB mark
  2241                        
  2242 00:B80C: C9 3B              CMP   #';'              ; compare with ";"
  2243 00:B80E: F0 62              BEQ   LAB_18BD          ; if ";" continue with PRINT processing
  2244                        
  2245 00:B810: 20 84 BA           JSR   LAB_EVEX          ; evaluate expression
  2246 00:B813: 24 11              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
  2247 00:B815: 30 E1              BMI   LAB_1829          ; branch if string
  2248                        
  2249 00:B817: 20 07 CA           JSR   LAB_296E          ; convert FAC1 to string
  2250 00:B81A: 20 D7 C0           JSR   LAB_20AE          ; print " terminated string to Sutill/Sutilh
  2251                        
  2252                        ; don't check fit if terminal width byte is zero
  2253                        
  2254 00:B81D: A5 08              LDA   TWidth            ; get terminal width byte
  2255 00:B81F: F0 0A              BEQ   LAB_185E          ; skip check if zero
  2256                        
  2257 00:B821: 38                 SEC                     ; set carry for subtract
  2258 00:B822: E5 07              SBC   TPos              ; subtract terminal position
  2259 00:B824: F2 60              SBC   (des_pl)          ; subtract string length
  2260 00:B826: B0 03              BCS   LAB_185E          ; branch if less than terminal width
  2261                        
  2262 00:B828: 20 37 B8           JSR   LAB_CRLF          ; else print CR/LF
  Thu Sep 26 2019 15:30                                                                                                    Page 37


  2263                        LAB_185E
  2264 00:B82B: 20 7B B8           JSR   LAB_18C6          ; print string from Sutill/Sutilh
  2265 00:B82E: 80 CB              BRA   LAB_182C          ; always go continue processing line
  2266                        
  2267                        ; CR/LF return to BASIC from BASIC input handler
  2268                        
  2269                        LAB_1866
  2270 00:B830: 9E 00 04           STZ   Ibuffs,X          ; null terminate input
  2271 00:B833: A2 00              LDX   #<Ibuffs          ; set X to buffer start-1 low byte
  2272 00:B835: A0 04              LDY   #>Ibuffs          ; set Y to buffer start-1 high byte
  2273                        
  2274                        ; print CR/LF
  2275                        
  2276                        LAB_CRLF
  2277 00:B837: A9 0D              LDA   #$0D              ; load [CR]
  2278 00:B839: 20 93 B8           JSR   LAB_PRNA          ; go print the character
  2279 00:B83C: A9 0A              LDA   #$0A              ; load [LF]
  2280 00:B83E: 80 53              BRA   LAB_PRNA          ; go print the character and return, branch always
  2281                        
  2282                        LAB_188B
  2283 00:B840: A5 07              LDA   TPos              ; get terminal position
  2284 00:B842: C5 09              CMP   Iclim             ; compare with input column limit
  2285 00:B844: 90 05              BCC   LAB_1897          ; branch if less
  2286                        
  2287 00:B846: 20 37 B8           JSR   LAB_CRLF          ; else print CR/LF (next line)
  2288 00:B849: 80 27              BRA   LAB_18BD          ; continue with PRINT processing (branch always)
  2289                        
  2290                        LAB_1897
  2291 00:B84B: 38                 SEC                     ; set carry for subtract
  2292                        LAB_1898
  2293 00:B84C: E5 16              SBC   TabSiz            ; subtract TAB size
  2294 00:B84E: B0 FC              BCS   LAB_1898          ; loop if result was +ve
  2295                        
  2296 00:B850: 49 FF              EOR   #$FF              ; complement it
  2297 00:B852: 69 01              ADC   #$01              ; +1 (twos complement)
  2298 00:B854: 80 12              BRA   LAB_18B6          ; always print A spaces (result is never $00)
  2299                        
  2300                                                      ; do TAB/SPC
  2301                        LAB_18A2
  2302 00:B856: 48                 PHA                     ; save token
  2303 00:B857: 20 12 C4           JSR   LAB_SGBY          ; scan and get byte parameter
  2304 00:B85A: C9 29              CMP   #$29              ; is next character )
  2305 00:B85C: D0 7C              BNE   LAB_1910          ; if not do syntax error then warm start
  2306                        
  2307 00:B85E: 68                 PLA                     ; get token back
  2308 00:B85F: C9 A8              CMP   #TK_TAB           ; was it TAB ?
  2309 00:B861: D0 06              BNE   LAB_18B7          ; if not go do SPC
  2310                        
  2311                                                      ; calculate TAB offset
  2312 00:B863: 8A                 TXA                     ; copy integer value to A
  2313 00:B864: E5 07              SBC   TPos              ; subtract terminal position
  2314 00:B866: 90 0A              BCC   LAB_18BD          ; branch if result was < 0 (can't TAB backwards)
  2315                        
  2316                                                      ; print A spaces
  2317                        LAB_18B6
  2318 00:B868: AA                 TAX                     ; copy result to X
  2319                        LAB_18B7
  2320 00:B869: 8A                 TXA                     ; set flags on size for SPC
  2321 00:B86A: F0 06              BEQ   LAB_18BD          ; branch if result was = $0, already here
  2322                        
  2323                                                      ; print X spaces
  2324                        LAB_18BA
  2325 00:B86C: 20 8D B8           JSR   LAB_18E0          ; print " "
  Thu Sep 26 2019 15:30                                                                                                    Page 38


  2326 00:B86F: CA                 DEX                     ; decrement count
  2327 00:B870: D0 FA              BNE   LAB_18BA          ; loop if not all done
  2328                        
  2329                                                      ; continue with PRINT processing
  2330                        LAB_18BD
  2331 00:B872: 20 AE CF           JSR   LAB_IGBY          ; increment and scan memory
  2332 00:B875: D0 89              BNE   LAB_1831          ; if more to print go do it
  2333                        
  2334 00:B877: 60                 RTS
  2335                        
  2336                        ; print null terminated string from memory
  2337                        
  2338                        LAB_18C3
  2339 00:B878: 20 D7 C0           JSR   LAB_20AE          ; print " terminated string to Sutill/Sutilh
  2340                        
  2341                        ; print string from Sutill/Sutilh
  2342                        
  2343                        LAB_18C6
  2344 00:B87B: 20 CE C2           JSR   LAB_22B6          ; pop string off descriptor stack, or from top of string
  2345                                                      ; space returns with A = length, X=$71=pointer low byte,
  2346                                                      ; Y=$72=pointer high byte
  2347 00:B87E: A0 00              LDY   #$00              ; reset index
  2348 00:B880: AA                 TAX                     ; copy length to X
  2349 00:B881: F0 4A              BEQ   LAB_188C          ; exit (RTS) if null string
  2350                        
  2351                        LAB_18CD
  2352                        
  2353 00:B883: B1 23              LDA   (ut1_pl),Y        ; get next byte
  2354 00:B885: 20 93 B8           JSR   LAB_PRNA          ; go print the character
  2355 00:B888: C8                 INY                     ; increment index
  2356 00:B889: CA                 DEX                     ; decrement count
  2357 00:B88A: D0 F7              BNE   LAB_18CD          ; loop if not done yet
  2358 00:B88C: 60                 RTS
  2359                        
  2360                                                      ; Print single format character
  2361                        ; print " "
  2362                        
  2363                        LAB_18E0
  2364 00:B88D: A9 20              LDA   #$20              ; load " "
  2365 00:B88F: 80 02              BRA   LAB_PRNA          ; branch around next instruction, saves one clock cycle
  2366                        
  2367                        ; print "?" character
  2368                        
  2369                        LAB_18E3
  2370 00:B891: A9 3F              LDA   #$3F              ; load "?" character
  2371                        
  2372                        ; print character in A
  2373                        ; now includes the null handler
  2374                        ; also includes infinite line length code
  2375                        ; note! some routines expect this one to exit with Zb=0
  2376                        
  2377                        LAB_PRNA
  2378 00:B893: C9 20              CMP   #' '              ; compare with " "
  2379 00:B895: 90 19              BCC   LAB_18F9          ; branch if less (non printing)
  2380                        
  2381                                                      ; else printable character
  2382 00:B897: 48                 PHA                     ; save the character
  2383                        
  2384                        ; don't check fit if terminal width byte is zero
  2385                        
  2386 00:B898: A5 08              LDA   TWidth            ; get terminal width
  2387 00:B89A: D0 0A              BNE   LAB_18F0          ; branch if not zero (not infinite length)
  2388                        
  Thu Sep 26 2019 15:30                                                                                                    Page 39


  2389                        ; is "infinite line" so check TAB position
  2390                        
  2391 00:B89C: A5 07              LDA   TPos              ; get position
  2392 00:B89E: E5 16              SBC   TabSiz            ; subtract TAB size, carry set by CMP #$20 above
  2393 00:B8A0: D0 0B              BNE   LAB_18F7          ; skip reset if different
  2394                        
  2395 00:B8A2: 85 07              STA   TPos              ; else reset position
  2396 00:B8A4: F0 07              BEQ   LAB_18F7          ; go print character
  2397                        
  2398                        LAB_18F0
  2399 00:B8A6: C5 07              CMP   TPos              ; compare with terminal character position
  2400 00:B8A8: D0 03              BNE   LAB_18F7          ; branch if not at end of line
  2401                        
  2402 00:B8AA: 20 37 B8           JSR   LAB_CRLF          ; else print CR/LF
  2403                        LAB_18F7
  2404 00:B8AD: E6 07              INC   TPos              ; increment terminal position
  2405 00:B8AF: 68                 PLA                     ; get character back
  2406                        LAB_18F9
  2407 00:B8B0: 20 3A D0           JSR   V_OUTP            ; output byte via output vector
  2408 00:B8B3: C9 0D              CMP   #$0D              ; compare with [CR]
  2409 00:B8B5: D0 14              BNE   LAB_188A          ; branch if not [CR]
  2410                        
  2411                                                      ; else print nullct nulls after the [CR]
  2412 00:B8B7: 86 2A              STX   TempB             ; save buffer index
  2413 00:B8B9: A6 06              LDX   Nullct            ; get null count
  2414 00:B8BB: F0 0A              BEQ   LAB_1886          ; branch if no nulls
  2415                        
  2416 00:B8BD: A9 00              LDA   #$00              ; load [NULL]
  2417                        LAB_1880
  2418 00:B8BF: 20 93 B8           JSR   LAB_PRNA          ; go print the character
  2419 00:B8C2: CA                 DEX                     ; decrement count
  2420 00:B8C3: D0 FA              BNE   LAB_1880          ; loop if not all done
  2421                        
  2422 00:B8C5: A9 0D              LDA   #$0D              ; restore the character (and set the flags)
  2423                        LAB_1886
  2424 00:B8C7: 86 07              STX   TPos              ; clear terminal position (X always = zero when we get here)
  2425 00:B8C9: A6 2A              LDX   TempB             ; restore buffer index
  2426                        LAB_188A
  2427 00:B8CB: 29 FF              AND   #$FF              ; set the flags
  2428                        LAB_188C
  2429 00:B8CD: 60                 RTS
  2430                        
  2431                        ; handle bad input data
  2432                        
  2433                        LAB_1904
  2434 00:B8CE: A5 14              LDA   Imode             ; get input mode flag, $00=INPUT, $00=READ
  2435 00:B8D0: 10 0B              BPL   LAB_1913          ; branch if INPUT (go do redo)
  2436                        
  2437 00:B8D2: A5 3F              LDA   Dlinel            ; get current DATA line low byte
  2438 00:B8D4: A4 40              LDY   Dlineh            ; get current DATA line high byte
  2439 00:B8D6: 85 39              STA   Clinel            ; save current line low byte
  2440 00:B8D8: 84 3A              STY   Clineh            ; save current line high byte
  2441                        LAB_1910
  2442 00:B8DA: 4C A0 BB           JMP   LAB_SNER          ; do syntax error then warm start
  2443                        
  2444                                                      ; mode was INPUT
  2445                        LAB_1913
  2446 00:B8DD: A9 ED              LDA   #<LAB_REDO        ; point to redo message (low addr)
  2447 00:B8DF: A0 D6              LDY   #>LAB_REDO        ; point to redo message (high addr)
  2448 00:B8E1: 20 78 B8           JSR   LAB_18C3          ; print null terminated string from memory
  2449 00:B8E4: A5 3D              LDA   Cpntrl            ; get continue pointer low byte
  2450 00:B8E6: A4 3E              LDY   Cpntrh            ; get continue pointer high byte
  2451 00:B8E8: 85 6E              STA   Bpntrl            ; save BASIC execute pointer low byte
  Thu Sep 26 2019 15:30                                                                                                    Page 40


  2452 00:B8EA: 84 6F              STY   Bpntrh            ; save BASIC execute pointer high byte
  2453 00:B8EC: 60                 RTS
  2454                        
  2455                        ; perform INPUT
  2456                        
  2457                        LAB_INPUT
  2458 00:B8ED: C9 22              CMP   #$22              ; compare next byte with open quote
  2459 00:B8EF: D0 0B              BNE   LAB_1934          ; branch if no prompt string
  2460                        
  2461 00:B8F1: 20 5E BB           JSR   LAB_1BC1          ; print "..." string
  2462 00:B8F4: A9 3B              LDA   #$3B              ; load A with ";"
  2463 00:B8F6: 20 91 BB           JSR   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
  2464 00:B8F9: 20 7B B8           JSR   LAB_18C6          ; print string from Sutill/Sutilh
  2465                        
  2466                                                      ; done with prompt, now get data
  2467                        LAB_1934
  2468 00:B8FC: 20 FF BF           JSR   LAB_CKRN          ; check not Direct, back here if ok
  2469 00:B8FF: 20 0D B2           JSR   LAB_INLN          ; print "? " and get BASIC input
  2470 00:B902: A9 00              LDA   #$00              ; set mode = INPUT
  2471 00:B904: CD 00 04           CMP   Ibuffs            ; test first byte in buffer
  2472 00:B907: D0 09              BNE   LAB_1953          ; branch if not null input
  2473 00:B909: 4C F0 B4           JMP   LAB_1647          ; go do BREAK exit
  2474                        
  2475                        ; perform READ
  2476                        
  2477                        LAB_READ
  2478 00:B90C: A6 41              LDX   Dptrl             ; get DATA pointer low byte
  2479 00:B90E: A4 42              LDY   Dptrh             ; get DATA pointer high byte
  2480 00:B910: A9 80              LDA   #$80              ; set mode = READ
  2481                        
  2482                        LAB_1953
  2483 00:B912: 85 14              STA   Imode             ; set input mode flag, $00=INPUT, $80=READ
  2484 00:B914: 86 43              STX   Rdptrl            ; save READ pointer low byte
  2485 00:B916: 84 44              STY   Rdptrh            ; save READ pointer high byte
  2486                        
  2487                                                      ; READ or INPUT next variable from list
  2488                        LAB_195B
  2489 00:B918: 20 42 BD           JSR   LAB_GVAR          ; get (var) address
  2490 00:B91B: 85 49              STA   Lvarpl            ; save address low byte
  2491 00:B91D: 84 4A              STY   Lvarph            ; save address high byte
  2492 00:B91F: A5 6E              LDA   Bpntrl            ; get BASIC execute pointer low byte
  2493 00:B921: A4 6F              LDY   Bpntrh            ; get BASIC execute pointer high byte
  2494 00:B923: 85 0A              STA   Itempl            ; save as temporary integer low byte
  2495 00:B925: 84 0B              STY   Itemph            ; save as temporary integer high byte
  2496 00:B927: A6 43              LDX   Rdptrl            ; get READ pointer low byte
  2497 00:B929: A4 44              LDY   Rdptrh            ; get READ pointer high byte
  2498 00:B92B: 86 6E              STX   Bpntrl            ; set BASIC execute pointer low byte
  2499 00:B92D: 84 6F              STY   Bpntrh            ; set BASIC execute pointer high byte
  2500 00:B92F: 20 B4 CF           JSR   LAB_GBYT          ; scan memory
  2501 00:B932: D0 11              BNE   LAB_1988          ; branch if not null
  2502                        
  2503                                                      ; pointer was to null entry
  2504 00:B934: 24 14              BIT   Imode             ; test input mode flag, $00=INPUT, $80=READ
  2505 00:B936: 30 64              BMI   LAB_19DD          ; branch if READ
  2506                        
  2507                                                      ; mode was INPUT
  2508 00:B938: 20 91 B8           JSR   LAB_18E3          ; print "?" character (double ? for extended input)
  2509 00:B93B: 20 0D B2           JSR   LAB_INLN          ; print "? " and get BASIC input
  2510 00:B93E: 86 6E              STX   Bpntrl            ; set BASIC execute pointer low byte
  2511 00:B940: 84 6F              STY   Bpntrh            ; set BASIC execute pointer high byte
  2512                        LAB_1985
  2513 00:B942: 20 B4 CF           JSR   LAB_GBYT          ; scan memory
  2514                        LAB_1988
  Thu Sep 26 2019 15:30                                                                                                    Page 41


  2515 00:B945: 24 11              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
  2516 00:B947: 10 23              BPL   LAB_19B0          ; branch if numeric
  2517                        
  2518                                                      ; else get string
  2519 00:B949: 85 0D              STA   Srchc             ; save search character
  2520 00:B94B: C9 22              CMP   #$22              ; was it " ?
  2521 00:B94D: F0 07              BEQ   LAB_1999          ; branch if so
  2522                        
  2523 00:B94F: A9 3A              LDA   #':'              ; else search character is ":"
  2524 00:B951: 85 0D              STA   Srchc             ; set new search character
  2525 00:B953: A9 2C              LDA   #','              ; other search character is ","
  2526 00:B955: 18                 CLC                     ; clear carry for add
  2527                        LAB_1999
  2528 00:B956: 85 0E              STA   Asrch             ; set second search character
  2529 00:B958: A5 6E              LDA   Bpntrl            ; get BASIC execute pointer low byte
  2530 00:B95A: A4 6F              LDY   Bpntrh            ; get BASIC execute pointer high byte
  2531                        
  2532 00:B95C: 69 00              ADC   #$00              ; c is =1 if we came via the BEQ LAB_1999, else =0
  2533 00:B95E: 90 01              BCC   LAB_19A4          ; branch if no execute pointer low byte rollover
  2534                        
  2535 00:B960: C8                 INY                     ; else increment high byte
  2536                        LAB_19A4
  2537 00:B961: 20 DD C0           JSR   LAB_20B4          ; print Srchc or Asrch terminated string to Sutill/Sutilh
  2538 00:B964: 20 55 C4           JSR   LAB_23F3          ; restore BASIC execute pointer from temp (Btmpl/Btmph)
  2539 00:B967: 20 7F B7           JSR   LAB_17D5          ; go do string LET
  2540 00:B96A: 80 06              BRA   LAB_19B6          ; go check string terminator
  2541                        
  2542                                                      ; get numeric INPUT
  2543                        LAB_19B0
  2544 00:B96C: 20 1F C9           JSR   LAB_2887          ; get FAC1 from string
  2545 00:B96F: 20 21 C8           JSR   LAB_PFAC          ; pack FAC1 into (Lvarpl)
  2546                        LAB_19B6
  2547 00:B972: 20 B4 CF           JSR   LAB_GBYT          ; scan memory
  2548 00:B975: F0 0A              BEQ   LAB_19C5          ; branch if null (last entry)
  2549                        
  2550 00:B977: C9 2C              CMP   #','              ; else compare with ","
  2551 00:B979: F0 03              BEQ   LAB_19C2          ; branch if ","
  2552                        
  2553 00:B97B: 4C CE B8           JMP   LAB_1904          ; else go handle bad input data
  2554                        
  2555                                                      ; got good input data
  2556                        LAB_19C2
  2557 00:B97E: 20 AE CF           JSR   LAB_IGBY          ; increment and scan memory
  2558                        LAB_19C5
  2559 00:B981: A5 6E              LDA   Bpntrl            ; get BASIC execute pointer low byte (temp READ/INPUT ptr)
  2560 00:B983: A4 6F              LDY   Bpntrh            ; get BASIC execute pointer high byte (temp READ/INPUT ptr)
  2561 00:B985: 85 43              STA   Rdptrl            ; save for now
  2562 00:B987: 84 44              STY   Rdptrh            ; save for now
  2563 00:B989: A5 0A              LDA   Itempl            ; get temporary integer low byte (temp BASIC execute ptr)
  2564 00:B98B: A4 0B              LDY   Itemph            ; get temporary integer high byte (temp BASIC execute ptr)
  2565 00:B98D: 85 6E              STA   Bpntrl            ; set BASIC execute pointer low byte
  2566 00:B98F: 84 6F              STY   Bpntrh            ; set BASIC execute pointer high byte
  2567 00:B991: 20 B4 CF           JSR   LAB_GBYT          ; scan memory
  2568 00:B994: F0 2C              BEQ   LAB_1A03          ; if null go do extra ignored message
  2569                        
  2570 00:B996: 20 9C BB           JSR   LAB_1C01          ; else scan for "," , else do syntax error then warm start
  2571 00:B999: 4C 18 B9           JMP   LAB_195B          ; go INPUT next variable from list
  2572                        
  2573                                                      ; find next DATA statement or do "Out of DATA" error
  2574                        LAB_19DD
  2575 00:B99C: 20 59 B6           JSR   LAB_SNBS          ; scan for next BASIC statement ([:] or [EOL])
  2576 00:B99F: C8                 INY                     ; increment index
  2577 00:B9A0: AA                 TAX                     ; copy character ([:] or [EOL])
  Thu Sep 26 2019 15:30                                                                                                    Page 42


  2578 00:B9A1: D0 12              BNE   LAB_19F6          ; branch if [:]
  2579                        
  2580 00:B9A3: A2 06              LDX   #$06              ; set for "Out of DATA" error
  2581 00:B9A5: C8                 INY                     ; increment index, now points to next line pointer high byte
  2582 00:B9A6: B1 6E              LDA   (Bpntrl),Y        ; get next line pointer high byte
  2583 00:B9A8: F0 71              BEQ   LAB_1A54          ; branch if end (eventually does error X)
  2584                        
  2585 00:B9AA: C8                 INY                     ; increment index
  2586 00:B9AB: B1 6E              LDA   (Bpntrl),Y        ; get next line # low byte
  2587 00:B9AD: 85 3F              STA   Dlinel            ; save current DATA line low byte
  2588 00:B9AF: C8                 INY                     ; increment index
  2589 00:B9B0: B1 6E              LDA   (Bpntrl),Y        ; get next line # high byte
  2590 00:B9B2: C8                 INY                     ; increment index
  2591 00:B9B3: 85 40              STA   Dlineh            ; save current DATA line high byte
  2592                        LAB_19F6
  2593 00:B9B5: B1 6E              LDA   (Bpntrl),Y        ; get byte
  2594 00:B9B7: C8                 INY                     ; increment index
  2595 00:B9B8: AA                 TAX                     ; copy to X
  2596 00:B9B9: 20 4B B6           JSR   LAB_170F          ; set BASIC execute pointer
  2597 00:B9BC: E0 83              CPX   #TK_DATA          ; compare with "DATA" token
  2598 00:B9BE: F0 82              BEQ   LAB_1985          ; was "DATA" so go do next READ
  2599 00:B9C0: 80 DA              BRA   LAB_19DD          ; go find next statement if not "DATA"
  2600                        
  2601                        ; end of INPUT/READ routine
  2602                        
  2603                        LAB_1A03
  2604 00:B9C2: A5 43              LDA   Rdptrl            ; get temp READ pointer low byte
  2605 00:B9C4: A4 44              LDY   Rdptrh            ; get temp READ pointer high byte
  2606 00:B9C6: A6 14              LDX   Imode             ; get input mode flag, $00=INPUT, $80=READ
  2607 00:B9C8: 10 03              BPL   LAB_1A0E          ; branch if INPUT
  2608 00:B9CA: 4C 12 B5           JMP   LAB_1624          ; save AY as DATA pointer and return
  2609                        
  2610                                                      ; we were getting INPUT
  2611                        LAB_1A0E
  2612 00:B9CD: B2 43              LDA   (Rdptrl)          ; get next byte
  2613 00:B9CF: D0 01              BNE   LAB_1A1B          ; error if not end of INPUT
  2614 00:B9D1: 60                 RTS
  2615                        
  2616                                                      ; user typed too much
  2617                        LAB_1A1B
  2618 00:B9D2: A9 DC              LDA   #<LAB_IMSG        ; point to extra ignored message (low addr)
  2619 00:B9D4: A0 D6              LDY   #>LAB_IMSG        ; point to extra ignored message (high addr)
  2620 00:B9D6: 4C 78 B8           JMP   LAB_18C3          ; print null terminated string from memory and return
  2621                        
  2622                        ; search the stack for FOR activity
  2623                        ; exit with z=1 if FOR else exit with z=0
  2624                        
  2625                        LAB_11A1
  2626 00:B9D9: BA                 TSX                     ; copy stack pointer
  2627 00:B9DA: E8                 INX                     ; +1 pass return address
  2628 00:B9DB: E8                 INX                     ; +2 pass return address
  2629 00:B9DC: E8                 INX                     ; +3 pass calling routine return address
  2630 00:B9DD: E8                 INX                     ; +4 pass calling routine return address
  2631                        LAB_11A6
  2632 00:B9DE: BD 01 01           LDA   LAB_STAK+1,X      ; get token byte from stack
  2633 00:B9E1: C9 81              CMP   #TK_FOR           ; is it FOR token
  2634 00:B9E3: D0 21              BNE   LAB_11CE          ; exit if not FOR token
  2635                        
  2636                                                      ; was FOR token
  2637 00:B9E5: A5 4A              LDA   Frnxth            ; get var pointer for FOR/NEXT high byte
  2638 00:B9E7: D0 0A              BNE   LAB_11BB          ; branch if not null
  2639                        
  2640 00:B9E9: BD 02 01           LDA   LAB_STAK+2,X      ; get FOR variable pointer low byte
  Thu Sep 26 2019 15:30                                                                                                    Page 43


  2641 00:B9EC: 85 49              STA   Frnxtl            ; save var pointer for FOR/NEXT low byte
  2642 00:B9EE: BD 03 01           LDA   LAB_STAK+3,X      ; get FOR variable pointer high byte
  2643 00:B9F1: 85 4A              STA   Frnxth            ; save var pointer for FOR/NEXT high byte
  2644                        LAB_11BB
  2645 00:B9F3: DD 03 01           CMP   LAB_STAK+3,X      ; compare var pointer with stacked var pointer (high byte)
  2646 00:B9F6: D0 07              BNE   LAB_11C7          ; branch if no match
  2647                        
  2648 00:B9F8: A5 49              LDA   Frnxtl            ; get var pointer for FOR/NEXT low byte
  2649 00:B9FA: DD 02 01           CMP   LAB_STAK+2,X      ; compare var pointer with stacked var pointer (low byte)
  2650 00:B9FD: F0 07              BEQ   LAB_11CE          ; exit if match found
  2651                        
  2652                        LAB_11C7
  2653 00:B9FF: 8A                 TXA                     ; copy index
  2654 00:BA00: 18                 CLC                     ; clear carry for add
  2655 00:BA01: 69 10              ADC   #$10              ; add FOR stack use size
  2656 00:BA03: AA                 TAX                     ; copy back to index
  2657 00:BA04: D0 D8              BNE   LAB_11A6          ; loop if not at start of stack
  2658                        
  2659                        LAB_11CE
  2660 00:BA06: 60                 RTS
  2661                        
  2662                        ; perform NEXT
  2663                        
  2664                        LAB_NEXT
  2665 00:BA07: D0 04              BNE   LAB_1A46          ; branch if NEXT var
  2666                        
  2667 00:BA09: A0 00              LDY   #$00              ; else clear Y
  2668 00:BA0B: 80 03              BRA   LAB_1A49          ; branch always (no variable to search for)
  2669                        
  2670                        ; NEXT var
  2671                        
  2672                        LAB_1A46
  2673 00:BA0D: 20 42 BD           JSR   LAB_GVAR          ; get variable address
  2674                        LAB_1A49
  2675 00:BA10: 85 49              STA   Frnxtl            ; store variable pointer low byte
  2676 00:BA12: 84 4A              STY   Frnxth            ; store variable pointer high byte
  2677                                                      ; (both cleared if no variable defined)
  2678 00:BA14: 20 D9 B9           JSR   LAB_11A1          ; search the stack for FOR activity
  2679 00:BA17: F0 04              BEQ   LAB_1A56          ; branch if found
  2680                        
  2681 00:BA19: A2 00              LDX   #$00              ; else set error $00 ("NEXT without FOR" error)
  2682                        LAB_1A54
  2683 00:BA1B: F0 64              BEQ   LAB_1ABE          ; do error #X, then warm start
  2684                        
  2685                        LAB_1A56
  2686 00:BA1D: 9A                 TXS                     ; set stack pointer, X set by search, dumps return addresses
  2687                        
  2688 00:BA1E: 8A                 TXA                     ; copy stack pointer
  2689 00:BA1F: 38                 SEC                     ; set carry for subtract
  2690 00:BA20: E9 F7              SBC   #$F7              ; point to TO var
  2691 00:BA22: 85 25              STA   ut2_pl            ; save pointer to TO var for compare
  2692 00:BA24: 69 FB              ADC   #$FB              ; point to STEP var
  2693                        
  2694 00:BA26: A0 01              LDY   #>LAB_STAK        ; point to stack page high byte
  2695 00:BA28: 20 FB C7           JSR   LAB_UFAC          ; unpack memory (STEP value) into FAC1
  2696 00:BA2B: BA                 TSX                     ; get stack pointer back
  2697 00:BA2C: BD 08 01           LDA   LAB_STAK+8,X      ; get step sign
  2698 00:BA2F: 85 62              STA   FAC1_s            ; save FAC1 sign (b7)
  2699 00:BA31: A5 49              LDA   Frnxtl            ; get FOR variable pointer low byte
  2700 00:BA33: A4 4A              LDY   Frnxth            ; get FOR variable pointer high byte
  2701 00:BA35: 20 43 C5           JSR   LAB_246C          ; add (FOR variable) to FAC1
  2702 00:BA38: 20 21 C8           JSR   LAB_PFAC          ; pack FAC1 into (FOR variable)
  2703 00:BA3B: A0 01              LDY   #>LAB_STAK        ; point to stack page high byte
  Thu Sep 26 2019 15:30                                                                                                    Page 44


  2704 00:BA3D: 20 93 C8           JSR   LAB_27FA          ; compare FAC1 with (Y,ut2_pl) (TO value)
  2705 00:BA40: BA                 TSX                     ; get stack pointer back
  2706 00:BA41: DD 08 01           CMP   LAB_STAK+8,X      ; compare step sign
  2707 00:BA44: F0 17              BEQ   LAB_1A9B          ; branch if = (loop complete)
  2708                        
  2709                                                      ; loop back and do it all again
  2710 00:BA46: BD 0D 01           LDA   LAB_STAK+$0D,X    ; get FOR line low byte
  2711 00:BA49: 85 39              STA   Clinel            ; save current line low byte
  2712 00:BA4B: BD 0E 01           LDA   LAB_STAK+$0E,X    ; get FOR line high byte
  2713 00:BA4E: 85 3A              STA   Clineh            ; save current line high byte
  2714 00:BA50: BD 10 01           LDA   LAB_STAK+$10,X    ; get BASIC execute pointer low byte
  2715 00:BA53: 85 6E              STA   Bpntrl            ; save BASIC execute pointer low byte
  2716 00:BA55: BD 0F 01           LDA   LAB_STAK+$0F,X    ; get BASIC execute pointer high byte
  2717 00:BA58: 85 6F              STA   Bpntrh            ; save BASIC execute pointer high byte
  2718                        LAB_1A98
  2719 00:BA5A: 4C 8B B4           JMP   LAB_15C2          ; go do interpreter inner loop
  2720                        
  2721                                                      ; loop complete so carry on
  2722                        LAB_1A9B
  2723 00:BA5D: 8A                 TXA                     ; stack copy to A
  2724 00:BA5E: 69 0F              ADC   #$0F              ; add $10 ($0F+carry) to dump FOR structure
  2725 00:BA60: AA                 TAX                     ; copy back to index
  2726 00:BA61: 9A                 TXS                     ; copy to stack pointer
  2727 00:BA62: 20 B4 CF           JSR   LAB_GBYT          ; scan memory
  2728 00:BA65: C9 2C              CMP   #','              ; compare with ","
  2729 00:BA67: D0 F1              BNE   LAB_1A98          ; branch if not "," (go do interpreter inner loop)
  2730                        
  2731                                                      ; was "," so another NEXT variable to do
  2732 00:BA69: 20 AE CF           JSR   LAB_IGBY          ; else increment and scan memory
  2733 00:BA6C: 20 0D BA           JSR   LAB_1A46          ; do NEXT (var)
  2734                        
  2735                        ; evaluate expression and check is numeric, else do type mismatch
  2736                        
  2737                        LAB_EVNM
  2738 00:BA6F: 20 84 BA           JSR   LAB_EVEX          ; evaluate expression
  2739                        
  2740                        ; check if source is numeric, else do type mismatch
  2741                        
  2742                        LAB_CTNM
  2743 00:BA72: 18                 CLC                     ; destination is numeric
  2744 00:BA73: 80 01              BRA   LAB_CKTM          ; branch around SEC
  2745                        
  2746                        ; check if source is string, else do type mismatch
  2747                        
  2748                        LAB_CTST
  2749 00:BA75: 38                 SEC                     ; required type is string
  2750                        
  2751                        ; type match check, set C for string, clear C for numeric
  2752                        
  2753                        LAB_CKTM
  2754 00:BA76: 24 11              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
  2755 00:BA78: 30 03              BMI   LAB_1ABA          ; branch if data type is string
  2756                                                      ; else data type was numeric
  2757 00:BA7A: B0 03              BCS   LAB_1ABC          ; if required type is string do type mismatch error
  2758                        LAB_1AB9
  2759 00:BA7C: 60                 RTS
  2760                        
  2761                                                      ; data type was string, now check required type
  2762                        LAB_1ABA
  2763 00:BA7D: B0 FD              BCS   LAB_1AB9          ; exit if required type is string
  2764                        
  2765                                                      ; else do type mismatch error
  2766                        LAB_1ABC
  Thu Sep 26 2019 15:30                                                                                                    Page 45


  2767 00:BA7F: A2 18              LDX   #$18              ; error code $18 ("Type mismatch" error)
  2768                        LAB_1ABE
  2769 00:BA81: 4C 07 B1           JMP   LAB_XERR          ; do error #X, then warm start
  2770                        
  2771                        ; evaluate expression
  2772                        
  2773                        LAB_EVEX
  2774 00:BA84: A6 6E              LDX   Bpntrl            ; get BASIC execute pointer low byte
  2775 00:BA86: D0 02              BNE   LAB_1AC7          ; skip next if not zero
  2776                        
  2777 00:BA88: C6 6F              DEC   Bpntrh            ; else decrement BASIC execute pointer high byte
  2778                        LAB_1AC7
  2779 00:BA8A: C6 6E              DEC   Bpntrl            ; decrement BASIC execute pointer low byte
  2780                        
  2781                        LAB_EVEZ
  2782 00:BA8C: A9 00              LDA   #$00              ; set null precedence (flag done)
  2783                        LAB_1ACC
  2784 00:BA8E: 48                 PHA                     ; push precedence byte
  2785 00:BA8F: A9 02              LDA   #$02              ; 2 bytes
  2786 00:BA91: 20 CC B0           JSR   LAB_1212          ; check room on stack for A bytes
  2787 00:BA94: 20 6D BB           JSR   LAB_GVAL          ; get value from line
  2788 00:BA97: 64 4D              STZ   comp_f            ; clear compare function flag
  2789                        LAB_1ADB
  2790 00:BA99: 20 B4 CF           JSR   LAB_GBYT          ; scan memory
  2791                        LAB_1ADE
  2792 00:BA9C: 38                 SEC                     ; set carry for subtract
  2793 00:BA9D: E9 BC              SBC   #TK_GT            ; subtract token for > (lowest comparison function)
  2794 00:BA9F: 90 16              BCC   LAB_1AFA          ; branch if < TK_GT
  2795                        
  2796 00:BAA1: C9 03              CMP   #$03              ; compare with ">" to "<" tokens
  2797 00:BAA3: B0 12              BCS   LAB_1AFA          ; branch if >= TK_SGN (highest evaluation function +1)
  2798                        
  2799                                                      ; was token for > = or < (A = 0, 1 or 2)
  2800 00:BAA5: C9 01              CMP   #$01              ; compare with token for =
  2801 00:BAA7: 2A                 ROL                     ; *2, b0 = carry (=1 if token was = or <)
  2802                                                      ; (A = 0, 3 or 5)
  2803 00:BAA8: 49 01              EOR   #$01              ; toggle b0
  2804                                                      ; (A = 1, 2 or 4. 1 if >, 2 if =, 4 if <)
  2805 00:BAAA: 45 4D              EOR   comp_f            ; EOR with compare function flag bits
  2806 00:BAAC: C5 4D              CMP   comp_f            ; compare with compare function flag
  2807 00:BAAE: 90 66              BCC   LAB_1B53          ; if <(comp_f) do syntax error then warm start
  2808                                                      ; was more than one <, = or >)
  2809                        
  2810 00:BAB0: 85 4D              STA   comp_f            ; save new compare function flag
  2811 00:BAB2: 20 AE CF           JSR   LAB_IGBY          ; increment and scan memory
  2812 00:BAB5: 80 E5              BRA   LAB_1ADE          ; go do next character
  2813                        
  2814                                                      ; token is < ">" or > "<" tokens
  2815                        LAB_1AFA
  2816 00:BAB7: A6 4D              LDX   comp_f            ; get compare function flag
  2817 00:BAB9: D0 2C              BNE   LAB_1B2A          ; branch if compare function
  2818 00:BABB: B0 79              BCS   LAB_1B78          ; go do functions
  2819                        
  2820                                                      ; else was <  TK_GT so is operator or lower
  2821 00:BABD: 69 0A              ADC   #TK_GT-TK_PLUS    ; add # of operators (+, -, *, /, ^, AND, OR or EOR)
  2822 00:BABF: 90 75              BCC   LAB_1B78          ; branch if < + operator
  2823                                                      ; carry was set so token was +, -, *, /, ^, AND, OR or EOR
  2824 00:BAC1: D0 07              BNE   LAB_1B0B          ; branch if not + token
  2825                        
  2826 00:BAC3: 24 11              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
  2827 00:BAC5: 10 03              BPL   LAB_1B0B          ; branch if not string
  2828                        
  2829                                                      ; will only be $00 if type is string and token was +
  Thu Sep 26 2019 15:30                                                                                                    Page 46


  2830 00:BAC7: 4C 66 C2           JMP   LAB_224D          ; add strings, string 1 is in descriptor des_pl, string 2
  2831                                                      ; is in line, and return
  2832                        
  2833                        LAB_1B0B
  2834 00:BACA: 85 23              STA   ut1_pl            ; save it
  2835 00:BACC: 0A                 ASL                     ; *2
  2836 00:BACD: 65 23              ADC   ut1_pl            ; *3
  2837 00:BACF: A8                 TAY                     ; copy to index
  2838                        LAB_1B13
  2839 00:BAD0: 68                 PLA                     ; pull previous precedence
  2840 00:BAD1: D9 F4 D1           CMP   LAB_OPPT,Y        ; compare with precedence byte
  2841 00:BAD4: B0 65              BCS   LAB_1B7D          ; branch if A >=
  2842                        
  2843 00:BAD6: 20 72 BA           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
  2844                        LAB_1B1C
  2845 00:BAD9: 48                 PHA                     ; save precedence
  2846                        LAB_1B1D
  2847 00:BADA: 20 02 BB           JSR   LAB_1B43          ; get vector, execute function then continue evaluation
  2848 00:BADD: 68                 PLA                     ; restore precedence
  2849 00:BADE: A4 4B              LDY   prstk             ; get precedence stacked flag
  2850 00:BAE0: 10 19              BPL   LAB_1B3C          ; branch if stacked values
  2851                        
  2852 00:BAE2: AA                 TAX                     ; copy precedence (set flags)
  2853 00:BAE3: F0 76              BEQ   LAB_1B9D          ; exit if done
  2854 00:BAE5: 80 5D              BRA   LAB_1B86          ; else pop FAC2 and return, branch always
  2855                        
  2856                        LAB_1B2A
  2857 00:BAE7: 26 11              ROL   Dtypef            ; shift data type flag into Cb
  2858 00:BAE9: 8A                 TXA                     ; copy compare function flag
  2859 00:BAEA: 85 11              STA   Dtypef            ; clear data type flag, X is 0xxx xxxx
  2860 00:BAEC: 2A                 ROL                     ; shift data type into compare function byte b0
  2861 00:BAED: A6 6E              LDX   Bpntrl            ; get BASIC execute pointer low byte
  2862 00:BAEF: D0 02              BNE   LAB_1B34          ; branch if no underflow
  2863                        
  2864 00:BAF1: C6 6F              DEC   Bpntrh            ; else decrement BASIC execute pointer high byte
  2865                        LAB_1B34
  2866 00:BAF3: C6 6E              DEC   Bpntrl            ; decrement BASIC execute pointer low byte
  2867             0000000C   TK_LT_PLUS  .EQU TK_LT-TK_PLUS
  2868 00:BAF5: A0 24              LDY   #TK_LT_PLUS*3     ; set offset to last operator entry
  2869 00:BAF7: 85 4D              STA   comp_f            ; save new compare function flag
  2870 00:BAF9: 80 D5              BRA   LAB_1B13          ; branch always
  2871                        
  2872                        LAB_1B3C
  2873 00:BAFB: D9 F4 D1           CMP   LAB_OPPT,Y        ; compare with stacked function precedence
  2874 00:BAFE: B0 44              BCS   LAB_1B86          ; branch if A >=, pop FAC2 and return
  2875 00:BB00: 80 D7              BRA   LAB_1B1C          ; branch always
  2876                        
  2877                        ;.get vector, execute function then continue evaluation
  2878                        
  2879                        LAB_1B43
  2880 00:BB02: B9 F6 D1           LDA   LAB_OPPT+2,Y      ; get function vector high byte
  2881 00:BB05: 48                 PHA                     ; onto stack
  2882 00:BB06: B9 F5 D1           LDA   LAB_OPPT+1,Y      ; get function vector low byte
  2883 00:BB09: 48                 PHA                     ; onto stack
  2884                                                      ; now push sign, round FAC1 and put on stack
  2885 00:BB0A: 20 19 BB           JSR   LAB_1B5B          ; function will return here, then the next RTS will call
  2886                                                      ; the function
  2887 00:BB0D: A5 4D              LDA   comp_f            ; get compare function flag
  2888 00:BB0F: 48                 PHA                     ; push compare evaluation byte
  2889 00:BB10: B9 F4 D1           LDA   LAB_OPPT,Y        ; get precedence byte
  2890 00:BB13: 4C 8E BA           JMP   LAB_1ACC          ; continue evaluating expression
  2891                        
  2892                        LAB_1B53
  Thu Sep 26 2019 15:30                                                                                                    Page 47


  2893 00:BB16: 4C A0 BB           JMP   LAB_SNER          ; do syntax error then warm start
  2894                        
  2895                        ; push sign, round FAC1 and put on stack
  2896                        
  2897                        LAB_1B5B
  2898 00:BB19: 68                 PLA                     ; get return addr low byte
  2899 00:BB1A: 85 23              STA   ut1_pl            ; save it
  2900 00:BB1C: E6 23              INC   ut1_pl            ; increment it (was ret-1 pushed? yes!)
  2901                                                      ; note! no check is made on the high byte! if the calling
  2902                                                      ; routine assembles to a page edge then this all goes
  2903                                                      ; horribly wrong !!!
  2904 00:BB1E: 68                 PLA                     ; get return addr high byte
  2905 00:BB1F: 85 24              STA   ut1_ph            ; save it
  2906 00:BB21: A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
  2907 00:BB23: 48                 PHA                     ; push sign
  2908                        
  2909                        ; round FAC1 and put on stack
  2910                        
  2911                        LAB_1B66
  2912 00:BB24: 20 57 C8           JSR   LAB_27BA          ; round FAC1
  2913 00:BB27: A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
  2914 00:BB29: 48                 PHA                     ; push on stack
  2915 00:BB2A: A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
  2916 00:BB2C: 48                 PHA                     ; push on stack
  2917 00:BB2D: A5 5F              LDA   FAC1_1            ; get FAC1 mantissa1
  2918 00:BB2F: 48                 PHA                     ; push on stack
  2919 00:BB30: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  2920 00:BB32: 48                 PHA                     ; push on stack
  2921 00:BB33: 6C 23 00           JMP   (ut1_pl)          ; return, sort of
  2922                        
  2923                        ; do functions
  2924                        
  2925                        LAB_1B78
  2926 00:BB36: A0 FF              LDY   #$FF              ; flag function
  2927 00:BB38: 68                 PLA                     ; pull precedence byte
  2928                        LAB_1B7B
  2929 00:BB39: F0 20              BEQ   LAB_1B9D          ; exit if done
  2930                        
  2931                        LAB_1B7D
  2932 00:BB3B: C9 64              CMP   #$64              ; compare previous precedence with $64
  2933 00:BB3D: F0 03              BEQ   LAB_1B84          ; branch if was $64 (< function)
  2934                        
  2935 00:BB3F: 20 72 BA           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
  2936                        LAB_1B84
  2937 00:BB42: 84 4B              STY   prstk             ; save precedence stacked flag
  2938                        
  2939                                                      ; pop FAC2 and return
  2940                        LAB_1B86
  2941 00:BB44: 68                 PLA                     ; pop byte
  2942 00:BB45: 4A                 LSR                     ; shift out comparison evaluation lowest bit
  2943 00:BB46: 85 15              STA   Cflag             ; save comparison evaluation flag
  2944 00:BB48: 68                 PLA                     ; pop exponent
  2945 00:BB49: 85 65              STA   FAC2_e            ; save FAC2 exponent
  2946 00:BB4B: 68                 PLA                     ; pop mantissa1
  2947 00:BB4C: 85 66              STA   FAC2_1            ; save FAC2 mantissa1
  2948 00:BB4E: 68                 PLA                     ; pop mantissa2
  2949 00:BB4F: 85 67              STA   FAC2_2            ; save FAC2 mantissa2
  2950 00:BB51: 68                 PLA                     ; pop mantissa3
  2951 00:BB52: 85 68              STA   FAC2_3            ; save FAC2 mantissa3
  2952 00:BB54: 68                 PLA                     ; pop sign
  2953 00:BB55: 85 69              STA   FAC2_s            ; save FAC2 sign (b7)
  2954 00:BB57: 45 62              EOR   FAC1_s            ; EOR FAC1 sign (b7)
  2955 00:BB59: 85 6A              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
  Thu Sep 26 2019 15:30                                                                                                    Page 48


  2956                        LAB_1B9D
  2957 00:BB5B: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  2958 00:BB5D: 60                 RTS
  2959                        
  2960                        ; print "..." string to string util area
  2961                        
  2962                        LAB_1BC1
  2963 00:BB5E: A5 6E              LDA   Bpntrl            ; get BASIC execute pointer low byte
  2964 00:BB60: A4 6F              LDY   Bpntrh            ; get BASIC execute pointer high byte
  2965 00:BB62: 69 00              ADC   #$00              ; add carry to low byte
  2966 00:BB64: 90 01              BCC   LAB_1BCA          ; branch if no overflow
  2967                        
  2968 00:BB66: C8                 INY                     ; increment high byte
  2969                        LAB_1BCA
  2970 00:BB67: 20 D7 C0           JSR   LAB_20AE          ; print " terminated string to Sutill/Sutilh
  2971 00:BB6A: 4C 55 C4           JMP   LAB_23F3          ; restore BASIC execute pointer from temp and return
  2972                        
  2973                        ; get value from line
  2974                        
  2975                        LAB_GVAL
  2976 00:BB6D: 20 AE CF           JSR   LAB_IGBY          ; increment and scan memory
  2977 00:BB70: B0 03              BCS   LAB_1BAC          ; branch if not numeric character
  2978                        
  2979                                                      ; else numeric string found (e.g. 123)
  2980                        LAB_1BA9
  2981 00:BB72: 4C 1F C9           JMP   LAB_2887          ; get FAC1 from string and return
  2982                        
  2983                        ; get value from line .. continued
  2984                        
  2985                                                      ; wasn't a number so ..
  2986                        LAB_1BAC
  2987 00:BB75: AA                 TAX                     ; set the flags
  2988 00:BB76: 30 2D              BMI   LAB_1BD0          ; if -ve go test token values
  2989                        
  2990                                                      ; else it is either a string, number, variable or (<expr>)
  2991 00:BB78: C9 24              CMP   #'$'              ; compare with "$"
  2992 00:BB7A: F0 F6              BEQ   LAB_1BA9          ; branch if "$", hex number
  2993                        
  2994 00:BB7C: C9 25              CMP   #'%'              ; else compare with "%"
  2995 00:BB7E: F0 F2              BEQ   LAB_1BA9          ; branch if "%", binary number
  2996                        
  2997 00:BB80: C9 2E              CMP   #'.'              ; compare with "."
  2998 00:BB82: F0 EE              BEQ   LAB_1BA9          ; if so get FAC1 from string and return (e.g. was .123)
  2999                        
  3000                                                      ; it wasn't any sort of number so ..
  3001 00:BB84: C9 22              CMP   #$22              ; compare with "
  3002 00:BB86: F0 D6              BEQ   LAB_1BC1          ; branch if open quote
  3003                        
  3004                                                      ; wasn't any sort of number so ..
  3005                        
  3006                        ; evaluate expression within parentheses
  3007                        
  3008 00:BB88: C9 28              CMP   #'('              ; compare with "("
  3009 00:BB8A: D0 4C              BNE   LAB_1C18          ; if not "(" get (var), return value in FAC1 and $ flag
  3010                        
  3011                        LAB_1BF7
  3012 00:BB8C: 20 8C BA           JSR   LAB_EVEZ          ; evaluate expression, no decrement
  3013                        
  3014                        ; all the 'scan for' routines return the character after the sought character
  3015                        
  3016                        ; scan for ")" , else do syntax error then warm start
  3017                        
  3018                        LAB_1BFB
  Thu Sep 26 2019 15:30                                                                                                    Page 49


  3019 00:BB8F: A9 29              LDA   #$29              ; load A with ")"
  3020                        
  3021                        ; scan for CHR$(A) , else do syntax error then warm start
  3022                        
  3023                        LAB_SCCA
  3024 00:BB91: D2 6E              CMP   (Bpntrl)          ; check next byte is = A
  3025 00:BB93: D0 0B              BNE   LAB_SNER          ; if not do syntax error then warm start
  3026                        
  3027 00:BB95: 4C AE CF           JMP   LAB_IGBY          ; increment and scan memory then return
  3028                        
  3029                        ; scan for "(" , else do syntax error then warm start
  3030                        
  3031                        LAB_1BFE
  3032 00:BB98: A9 28              LDA   #$28              ; load A with "("
  3033 00:BB9A: 80 F5              BRA   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
  3034                        
  3035                        ; scan for "," , else do syntax error then warm start
  3036                        
  3037                        LAB_1C01
  3038 00:BB9C: A9 2C              LDA   #$2C              ; load A with ","
  3039 00:BB9E: 80 F1              BRA   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
  3040                        
  3041                        ; syntax error then warm start
  3042                        
  3043                        LAB_SNER
  3044 00:BBA0: A2 02              LDX   #$02              ; error code $02 ("Syntax" error)
  3045 00:BBA2: 4C 07 B1           JMP   LAB_XERR          ; do error #X, then warm start
  3046                        
  3047                        ; get value from line .. continued
  3048                        ; do tokens
  3049                        
  3050                        LAB_1BD0
  3051 00:BBA5: C9 B3              CMP   #TK_MINUS         ; compare with token for -
  3052 00:BBA7: F0 28              BEQ   LAB_1C11          ; branch if - token (do set-up for functions)
  3053                        
  3054                                                      ; wasn't -n so ..
  3055 00:BBA9: C9 B2              CMP   #TK_PLUS          ; compare with token for +
  3056 00:BBAB: F0 C0              BEQ   LAB_GVAL          ; branch if + token (+n = n so ignore leading +)
  3057                        
  3058 00:BBAD: C9 AE              CMP   #TK_NOT           ; compare with token for NOT
  3059 00:BBAF: D0 13              BNE   LAB_1BE7          ; branch if not token for NOT
  3060                        
  3061                                                      ; was NOT token
  3062             0000000B   TK_EQUAL_PLUS     .EQU TK_EQUAL-TK_PLUS
  3063 00:BBB1: A0 21              LDY   #TK_EQUAL_PLUS*3  ; offset to NOT function
  3064 00:BBB3: 80 1E              BRA   LAB_1C13          ; do set-up for function then execute (branch always)
  3065                        
  3066                        ; do = compare
  3067                        
  3068                        LAB_EQUAL
  3069 00:BBB5: 20 3C BE           JSR   LAB_EVIR          ; evaluate integer expression (no sign check)
  3070 00:BBB8: A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
  3071 00:BBBA: 49 FF              EOR   #$FF              ; invert it
  3072 00:BBBC: A8                 TAY                     ; copy it
  3073 00:BBBD: A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
  3074 00:BBBF: 49 FF              EOR   #$FF              ; invert it
  3075 00:BBC1: 4C EE BF           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
  3076                        
  3077                        ; get value from line .. continued
  3078                        
  3079                                                      ; wasn't +, -, or NOT so ..
  3080                        LAB_1BE7
  3081 00:BBC4: C9 AB              CMP   #TK_FN            ; compare with token for FN
  Thu Sep 26 2019 15:30                                                                                                    Page 50


  3082 00:BBC6: D0 03              BNE   LAB_1BEE          ; branch if not token for FN
  3083                        
  3084 00:BBC8: 4C 48 C0           JMP   LAB_201E          ; go evaluate FNx
  3085                        
  3086                        ; get value from line .. continued
  3087                        
  3088                                                      ; wasn't +, -, NOT or FN so ..
  3089                        LAB_1BEE
  3090 00:BBCB: E9 BF              SBC   #TK_SGN           ; subtract with token for SGN
  3091 00:BBCD: B0 18              BCS   LAB_1C27          ; if a function token go do it
  3092 00:BBCF: 80 CF              BRA   LAB_SNER          ; else do syntax error
  3093                        
  3094                        ; set-up for functions
  3095                        
  3096                        LAB_1C11
  3097             0000000A   TK_GT_PLUS  .EQU TK_GT-TK_PLUS
  3098 00:BBD1: A0 1E              LDY   #TK_GT_PLUS*3     ; set offset from base to > operator
  3099                        LAB_1C13
  3100 00:BBD3: 68                 PLA                     ; dump return address low byte
  3101 00:BBD4: 68                 PLA                     ; dump return address high byte
  3102 00:BBD5: 4C DA BA           JMP   LAB_1B1D          ; execute function then continue evaluation
  3103                        
  3104                        ; variable name set-up
  3105                        ; get (var), return value in FAC_1 and $ flag
  3106                        
  3107                        LAB_1C18
  3108 00:BBD8: 20 42 BD           JSR   LAB_GVAR          ; get (var) address
  3109 00:BBDB: 85 60              STA   FAC1_2            ; save address low byte in FAC1 mantissa2
  3110 00:BBDD: 84 61              STY   FAC1_3            ; save address high byte in FAC1 mantissa3
  3111 00:BBDF: A6 11              LDX   Dtypef            ; get data type flag, $FF=string, $00=numeric
  3112 00:BBE1: 30 03              BMI   LAB_1C25          ; if string then return (does RTS)
  3113                        
  3114                        LAB_1C24
  3115 00:BBE3: 4C FB C7           JMP   LAB_UFAC          ; unpack memory (AY) into FAC1
  3116                        
  3117                        LAB_1C25
  3118 00:BBE6: 60                 RTS
  3119                        
  3120                        ; get value from line .. continued
  3121                        ; only functions left so ..
  3122                        
  3123                        ; set up function references
  3124                        
  3125                        ; new for V2.0+ this replaces a lot of IF .. THEN .. ELSEIF .. THEN .. that was needed
  3126                        ; to process function calls. now the function vector is computed and pushed on the stack
  3127                        ; and the preprocess offset is read. if the preprocess offset is non zero then the vector
  3128                        ; is calculated and the routine called, if not this routine just does RTS. whichever
  3129                        ; happens the RTS at the end of this routine, or the end of the preprocess routine, calls
  3130                        ; the function code
  3131                        
  3132                        ; this also removes some less than elegant code that was used to bypass type checking
  3133                        ; for functions that returned strings
  3134                        
  3135                        LAB_1C27
  3136 00:BBE7: 0A                 ASL                     ; *2 (2 bytes per function address)
  3137 00:BBE8: A8                 TAY                     ; copy to index
  3138                        
  3139 00:BBE9: B9 AF D1           LDA   LAB_FTBM,Y        ; get function jump vector high byte
  3140 00:BBEC: 48                 PHA                     ; push functions jump vector high byte
  3141 00:BBED: B9 AE D1           LDA   LAB_FTBL,Y        ; get function jump vector low byte
  3142 00:BBF0: 48                 PHA                     ; push functions jump vector low byte
  3143                        
  3144 00:BBF1: B9 69 D1           LDA   LAB_FTPM,Y        ; get function pre process vector high byte
  Thu Sep 26 2019 15:30                                                                                                    Page 51


  3145 00:BBF4: F0 05              BEQ   LAB_1C56          ; skip pre process if null vector
  3146                        
  3147 00:BBF6: 48                 PHA                     ; push functions pre process vector high byte
  3148 00:BBF7: B9 68 D1           LDA   LAB_FTPL,Y        ; get function pre process vector low byte
  3149 00:BBFA: 48                 PHA                     ; push functions pre process vector low byte
  3150                        
  3151                        LAB_1C56
  3152 00:BBFB: 60                 RTS                     ; do function, or pre process, call
  3153                        
  3154                        ; process string expression in parenthesis
  3155                        
  3156                        LAB_PPFS
  3157 00:BBFC: 20 8C BB           JSR   LAB_1BF7          ; process expression in parenthesis
  3158 00:BBFF: 4C 75 BA           JMP   LAB_CTST          ; check if source is string then do function,
  3159                                                      ; else do type mismatch
  3160                        
  3161                        ; process numeric expression in parenthesis
  3162                        
  3163                        LAB_PPFN
  3164 00:BC02: 20 8C BB           JSR   LAB_1BF7          ; process expression in parenthesis
  3165 00:BC05: 4C 72 BA           JMP   LAB_CTNM          ; check if source is numeric then do function,
  3166                                                      ; else do type mismatch
  3167                        
  3168                        ; set numeric data type and increment BASIC execute pointer
  3169                        
  3170                        LAB_PPBI
  3171 00:BC08: 46 11              LSR   Dtypef            ; clear data type flag, $FF=string, $00=numeric
  3172 00:BC0A: 4C AE CF           JMP   LAB_IGBY          ; increment and scan memory then do function
  3173                        
  3174                        ; process string for LEFT$, RIGHT$ or MID$
  3175                        
  3176                        LAB_LRMS
  3177 00:BC0D: 20 8C BA           JSR   LAB_EVEZ          ; evaluate (should be string) expression
  3178 00:BC10: 20 9C BB           JSR   LAB_1C01          ; scan for ",", else do syntax error then warm start
  3179 00:BC13: 20 75 BA           JSR   LAB_CTST          ; check if source is string, else do type mismatch
  3180 00:BC16: FA                 PLX                     ; get function jump vector low byte
  3181 00:BC17: 7A                 PLY                     ; get function jump vector high byte
  3182 00:BC18: A5 61              LDA   des_ph            ; get descriptor pointer high byte
  3183 00:BC1A: 48                 PHA                     ; push string pointer high byte
  3184 00:BC1B: A5 60              LDA   des_pl            ; get descriptor pointer low byte
  3185 00:BC1D: 48                 PHA                     ; push string pointer low byte
  3186 00:BC1E: 5A                 PHY                     ; save function jump vector high byte
  3187 00:BC1F: DA                 PHX                     ; save function jump vector low byte
  3188 00:BC20: 20 15 C4           JSR   LAB_GTBY          ; get byte parameter
  3189 00:BC23: 8A                 TXA                     ; copy byte parameter to A
  3190 00:BC24: 60                 RTS                     ; go do function
  3191                        
  3192                        ; process numeric expression(s) for BIN$ or HEX$
  3193                        
  3194                        LAB_BHSS
  3195 00:BC25: 20 8C BA           JSR   LAB_EVEZ          ; process expression
  3196 00:BC28: 20 72 BA           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
  3197 00:BC2B: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  3198 00:BC2D: C9 98              CMP   #$98              ; compare with exponent = 2^24
  3199 00:BC2F: B0 20              BCS   LAB_BHER          ; branch if n>=2^24 (is too big)
  3200                        
  3201 00:BC31: 20 C9 C8           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
  3202 00:BC34: A2 02              LDX   #$02              ; 3 bytes to do
  3203                        LAB_CFAC
  3204 00:BC36: B5 5F              LDA   FAC1_1,X          ; get byte from FAC1
  3205 00:BC38: 95 0A              STA   nums_1,X          ; save byte to temp
  3206 00:BC3A: CA                 DEX                     ; decrement index
  3207 00:BC3B: 10 F9              BPL   LAB_CFAC          ; copy FAC1 mantissa to temp
  Thu Sep 26 2019 15:30                                                                                                    Page 52


  3208                        
  3209 00:BC3D: 20 B4 CF           JSR   LAB_GBYT          ; get next BASIC byte
  3210 00:BC40: A2 00              LDX   #$00              ; set default to no leading "0"s
  3211 00:BC42: C9 29              CMP   #')'              ; compare with close bracket
  3212 00:BC44: F0 0A              BEQ   LAB_1C54          ; if ")" go do rest of function
  3213                        
  3214 00:BC46: 20 64 C4           JSR   LAB_SCGB          ; scan for "," and get byte
  3215 00:BC49: 20 B4 CF           JSR   LAB_GBYT          ; get last byte back
  3216 00:BC4C: C9 29              CMP   #')'              ; is next character )
  3217 00:BC4E: D0 01              BNE   LAB_BHER          ; if not ")" go do error
  3218                        
  3219                        LAB_1C54
  3220 00:BC50: 60                 RTS                     ; else do function
  3221                        
  3222                        LAB_BHER
  3223 00:BC51: 4C BE BE           JMP   LAB_FCER          ; do function call error then warm start
  3224                        
  3225                        ; perform EOR
  3226                        
  3227                        ; added operator format is the same as AND or OR, precedence is the same as OR
  3228                        
  3229                        ; this bit worked first time but it took a while to sort out the operator table
  3230                        ; pointers and offsets afterwards!
  3231                        
  3232                        LAB_EOR
  3233 00:BC54: 20 7B BC           JSR   GetFirst          ; get first integer expression (no sign check)
  3234 00:BC57: 45 0D              EOR   XOAw_l            ; EOR with expression 1 low byte
  3235 00:BC59: A8                 TAY                     ; save in Y
  3236 00:BC5A: A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
  3237 00:BC5C: 45 0E              EOR   XOAw_h            ; EOR with expression 1 high byte
  3238 00:BC5E: 4C EE BF           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
  3239                        
  3240                        ; perform OR
  3241                        
  3242                        LAB_OR
  3243 00:BC61: 20 7B BC           JSR   GetFirst          ; get first integer expression (no sign check)
  3244 00:BC64: 05 0D              ORA   XOAw_l            ; OR with expression 1 low byte
  3245 00:BC66: A8                 TAY                     ; save in Y
  3246 00:BC67: A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
  3247 00:BC69: 05 0E              ORA   XOAw_h            ; OR with expression 1 high byte
  3248 00:BC6B: 4C EE BF           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
  3249                        
  3250                        ; perform AND
  3251                        
  3252                        LAB_AND
  3253 00:BC6E: 20 7B BC           JSR   GetFirst          ; get first integer expression (no sign check)
  3254 00:BC71: 25 0D              AND   XOAw_l            ; AND with expression 1 low byte
  3255 00:BC73: A8                 TAY                     ; save in Y
  3256 00:BC74: A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
  3257 00:BC76: 25 0E              AND   XOAw_h            ; AND with expression 1 high byte
  3258 00:BC78: 4C EE BF           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
  3259                        
  3260                        ; get first value for OR, AND or EOR
  3261                        
  3262                        GetFirst
  3263 00:BC7B: 20 3C BE           JSR   LAB_EVIR          ; evaluate integer expression (no sign check)
  3264 00:BC7E: A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
  3265 00:BC80: 85 0E              STA   XOAw_h            ; save it
  3266 00:BC82: A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
  3267 00:BC84: 85 0D              STA   XOAw_l            ; save it
  3268 00:BC86: 20 48 C5           JSR   LAB_279B          ; copy FAC2 to FAC1 (get 2nd value in expression)
  3269 00:BC89: 20 3C BE           JSR   LAB_EVIR          ; evaluate integer expression (no sign check)
  3270 00:BC8C: A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
  Thu Sep 26 2019 15:30                                                                                                    Page 53


  3271                        LAB_1C95
  3272 00:BC8E: 60                 RTS
  3273                        
  3274                        ; perform comparisons
  3275                        
  3276                        ; do < compare
  3277                        
  3278                        LAB_LTHAN
  3279 00:BC8F: 20 76 BA           JSR   LAB_CKTM          ; type match check, set C for string
  3280 00:BC92: B0 12              BCS   LAB_1CAE          ; branch if string
  3281                        
  3282                                                      ; do numeric < compare
  3283 00:BC94: A5 69              LDA   FAC2_s            ; get FAC2 sign (b7)
  3284 00:BC96: 09 7F              ORA   #$7F              ; set all non sign bits
  3285 00:BC98: 25 66              AND   FAC2_1            ; and FAC2 mantissa1 (AND in sign bit)
  3286 00:BC9A: 85 66              STA   FAC2_1            ; save FAC2 mantissa1
  3287 00:BC9C: A9 65              LDA   #<FAC2_e          ; set pointer low byte to FAC2
  3288 00:BC9E: A0 00              LDY   #>FAC2_e          ; set pointer high byte to FAC2
  3289 00:BCA0: 20 91 C8           JSR   LAB_27F8          ; compare FAC1 with FAC2 (AY)
  3290 00:BCA3: AA                 TAX                     ; copy result
  3291 00:BCA4: 80 31              BRA   LAB_1CE1          ; go evaluate result
  3292                        
  3293                                                      ; do string < compare
  3294                        LAB_1CAE
  3295 00:BCA6: 46 11              LSR   Dtypef            ; clear data type flag, $FF=string, $00=numeric
  3296 00:BCA8: C6 4D              DEC   comp_f            ; clear < bit in compare function flag
  3297 00:BCAA: 20 CE C2           JSR   LAB_22B6          ; pop string off descriptor stack, or from top of string
  3298                                                      ; space returns with A = length, X=pointer low byte,
  3299                                                      ; Y=pointer high byte
  3300 00:BCAD: 85 5E              STA   str_ln            ; save length
  3301 00:BCAF: 86 5F              STX   str_pl            ; save string pointer low byte
  3302 00:BCB1: 84 60              STY   str_ph            ; save string pointer high byte
  3303 00:BCB3: A5 67              LDA   FAC2_2            ; get descriptor pointer low byte
  3304 00:BCB5: A4 68              LDY   FAC2_3            ; get descriptor pointer high byte
  3305 00:BCB7: 20 D2 C2           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
  3306                                                      ; returns with A = length, X=pointer low byte,
  3307                                                      ; Y=pointer high byte
  3308 00:BCBA: 86 67              STX   FAC2_2            ; save string pointer low byte
  3309 00:BCBC: 84 68              STY   FAC2_3            ; save string pointer high byte
  3310 00:BCBE: AA                 TAX                     ; copy length
  3311 00:BCBF: 38                 SEC                     ; set carry for subtract
  3312 00:BCC0: E5 5E              SBC   str_ln            ; subtract string 1 length
  3313 00:BCC2: F0 08              BEQ   LAB_1CD6          ; branch if str 1 length = string 2 length
  3314                        
  3315 00:BCC4: A9 01              LDA   #$01              ; set str 1 length > string 2 length
  3316 00:BCC6: 90 04              BCC   LAB_1CD6          ; branch if so
  3317                        
  3318 00:BCC8: A6 5E              LDX   str_ln            ; get string 1 length
  3319 00:BCCA: A9 FF              LDA   #$FF              ; set str 1 length < string 2 length
  3320                        LAB_1CD6
  3321 00:BCCC: 85 62              STA   FAC1_s            ; save length compare
  3322 00:BCCE: A0 FF              LDY   #$FF              ; set index
  3323 00:BCD0: E8                 INX                     ; adjust for loop
  3324                        LAB_1CDB
  3325 00:BCD1: C8                 INY                     ; increment index
  3326 00:BCD2: CA                 DEX                     ; decrement count
  3327 00:BCD3: D0 07              BNE   LAB_1CE6          ; branch if still bytes to do
  3328                        
  3329 00:BCD5: A6 62              LDX   FAC1_s            ; get length compare back
  3330                        LAB_1CE1
  3331 00:BCD7: 30 0F              BMI   LAB_1CF2          ; branch if str 1 < str 2
  3332                        
  3333 00:BCD9: 18                 CLC                     ; flag str 1 <= str 2
  Thu Sep 26 2019 15:30                                                                                                    Page 54


  3334 00:BCDA: 90 0C              BCC   LAB_1CF2          ; go evaluate result
  3335                        
  3336                        LAB_1CE6
  3337 00:BCDC: B1 67              LDA   (FAC2_2),Y        ; get string 2 byte
  3338 00:BCDE: D1 5F              CMP   (FAC1_1),Y        ; compare with string 1 byte
  3339 00:BCE0: F0 EF              BEQ   LAB_1CDB          ; loop if bytes =
  3340                        
  3341 00:BCE2: A2 FF              LDX   #$FF              ; set str 1 < string 2
  3342 00:BCE4: B0 02              BCS   LAB_1CF2          ; branch if so
  3343                        
  3344 00:BCE6: A2 01              LDX   #$01              ; set str 1 > string 2
  3345                        LAB_1CF2
  3346 00:BCE8: E8                 INX                     ; x = 0, 1 or 2
  3347 00:BCE9: 8A                 TXA                     ; copy to A
  3348 00:BCEA: 2A                 ROL                     ; *2 (1, 2 or 4)
  3349 00:BCEB: 25 15              AND   Cflag             ; AND with comparison evaluation flag
  3350 00:BCED: F0 02              BEQ   LAB_1CFB          ; branch if 0 (compare is false)
  3351                        
  3352 00:BCEF: A9 FF              LDA   #$FF              ; else set result true
  3353                        LAB_1CFB
  3354 00:BCF1: 4C 78 C8           JMP   LAB_27DB          ; save A as integer byte and return
  3355                        
  3356                        LAB_1CFE
  3357 00:BCF4: 20 9C BB           JSR   LAB_1C01          ; scan for ",", else do syntax error then warm start
  3358                        
  3359                        ; perform DIM
  3360                        
  3361                        LAB_DIM
  3362 00:BCF7: AA                 TAX                     ; copy "DIM" flag to X
  3363 00:BCF8: 20 47 BD           JSR   LAB_1D10          ; search for variable
  3364 00:BCFB: 20 B4 CF           JSR   LAB_GBYT          ; scan memory
  3365 00:BCFE: D0 F4              BNE   LAB_1CFE          ; scan for "," and loop if not null
  3366 00:BD00: 60                 RTS
  3367                        
  3368                        ; perform << (left shift)
  3369                        
  3370                        LAB_LSHIFT
  3371 00:BD01: 20 37 BD           JSR   GetPair           ; get integer expression and byte (no sign check)
  3372 00:BD04: A5 60              LDA   FAC1_2            ; get expression high byte
  3373 00:BD06: A6 2A              LDX   TempB             ; get shift count
  3374 00:BD08: F0 22              BEQ   NoShift           ; branch if zero
  3375                        
  3376 00:BD0A: E0 10              CPX   #$10              ; compare bit count with 16d
  3377 00:BD0C: B0 23              BCS   TooBig            ; branch if >=
  3378                        
  3379                        Ls_loop
  3380 00:BD0E: 06 61              ASL   FAC1_3            ; shift low byte
  3381 00:BD10: 2A                 ROL                     ; shift high byte
  3382 00:BD11: CA                 DEX                     ; decrement bit count
  3383 00:BD12: D0 FA              BNE   Ls_loop           ; loop if shift not complete
  3384                        
  3385 00:BD14: A4 61              LDY   FAC1_3            ; get expression low byte
  3386 00:BD16: 4C EE BF           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
  3387                        
  3388                        ; perform >> (right shift)
  3389                        
  3390                        LAB_RSHIFT
  3391 00:BD19: 20 37 BD           JSR   GetPair           ; get integer expression and byte (no sign check)
  3392 00:BD1C: A5 60              LDA   FAC1_2            ; get expression high byte
  3393 00:BD1E: A6 2A              LDX   TempB             ; get shift count
  3394 00:BD20: F0 0A              BEQ   NoShift           ; branch if zero
  3395                        
  3396 00:BD22: E0 10              CPX   #$10              ; compare bit count with 16d
  Thu Sep 26 2019 15:30                                                                                                    Page 55


  3397 00:BD24: B0 0B              BCS   TooBig            ; branch if >=
  3398                        
  3399                        Rs_loop
  3400 00:BD26: 4A                 LSR                     ; shift high byte
  3401 00:BD27: 66 61              ROR   FAC1_3            ; shift low byte
  3402 00:BD29: CA                 DEX                     ; decrement bit count
  3403 00:BD2A: D0 FA              BNE   Rs_loop           ; loop if shift not complete
  3404                        
  3405                        NoShift
  3406 00:BD2C: A4 61              LDY   FAC1_3            ; get expression low byte
  3407 00:BD2E: 4C EE BF           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
  3408                        
  3409                        TooBig
  3410 00:BD31: A9 00              LDA   #$00              ; clear high byte
  3411 00:BD33: A8                 TAY                     ; copy to low byte
  3412 00:BD34: 4C EE BF           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
  3413                        
  3414                        GetPair
  3415 00:BD37: 20 18 C4           JSR   LAB_EVBY          ; evaluate byte expression, result in X
  3416 00:BD3A: 86 2A              STX   TempB             ; save it
  3417 00:BD3C: 20 48 C5           JSR   LAB_279B          ; copy FAC2 to FAC1 (get 2nd value in expression)
  3418 00:BD3F: 4C 3C BE           JMP   LAB_EVIR          ; evaluate integer expression (no sign check)
  3419                        
  3420                        ; search for variable
  3421                        
  3422                        ; return pointer to variable in Cvaral/Cvarah
  3423                        
  3424                        LAB_GVAR
  3425 00:BD42: A2 00              LDX   #$00              ; set DIM flag = $00
  3426 00:BD44: 20 B4 CF           JSR   LAB_GBYT          ; scan memory (1st character)
  3427                        LAB_1D10
  3428 00:BD47: 86 10              STX   Defdim            ; save DIM flag
  3429                        LAB_1D12
  3430 00:BD49: 85 45              STA   Varnm1            ; save 1st character
  3431 00:BD4B: 29 7F              AND   #$7F              ; clear FN flag bit
  3432 00:BD4D: 20 B4 BD           JSR   LAB_CASC          ; check byte, return C=0 if<"A" or >"Z"
  3433 00:BD50: B0 03              BCS   LAB_1D1F          ; branch if ok
  3434                        
  3435 00:BD52: 4C A0 BB           JMP   LAB_SNER          ; else syntax error then warm start
  3436                        
  3437                                                      ; was variable name so ..
  3438                        LAB_1D1F
  3439 00:BD55: A2 00              LDX   #$00              ; set DIM flag = $00
  3440 00:BD57: 86 11              STX   Dtypef            ; clear data type flag, $FF=string, $00=numeric
  3441 00:BD59: 20 AE CF           JSR   LAB_IGBY          ; increment and scan memory (2nd character)
  3442 00:BD5C: 90 05              BCC   LAB_1D2D          ; branch if character = "0"-"9" (ok)
  3443                        
  3444                                                      ; 2nd character wasn't "0" to "9" so ..
  3445 00:BD5E: 20 B4 BD           JSR   LAB_CASC          ; check byte, return C=0 if<"A" or >"Z"
  3446 00:BD61: 90 0B              BCC   LAB_1D38          ; branch if <"A" or >"Z" (go check if string)
  3447                        
  3448                        LAB_1D2D
  3449 00:BD63: AA                 TAX                     ; copy 2nd character
  3450                        
  3451                                                      ; ignore further (valid) characters in the variable name
  3452                        LAB_1D2E
  3453 00:BD64: 20 AE CF           JSR   LAB_IGBY          ; increment and scan memory (3rd character)
  3454 00:BD67: 90 FB              BCC   LAB_1D2E          ; loop if character = "0"-"9" (ignore)
  3455                        
  3456 00:BD69: 20 B4 BD           JSR   LAB_CASC          ; check byte, return C=0 if<"A" or >"Z"
  3457 00:BD6C: B0 F6              BCS   LAB_1D2E          ; loop if character = "A"-"Z" (ignore)
  3458                        
  3459                                                      ; check if string variable
  Thu Sep 26 2019 15:30                                                                                                    Page 56


  3460                        LAB_1D38
  3461 00:BD6E: C9 24              CMP   #'$'              ; compare with "$"
  3462 00:BD70: D0 0B              BNE   LAB_1D47          ; branch if not string
  3463                        
  3464                        ; to introduce a new variable type (% suffix for integers say) then this branch
  3465                        ; will need to go to that check and then that branch, if it fails, go to LAB_1D47
  3466                        
  3467                                                      ; type is string
  3468 00:BD72: A9 FF              LDA   #$FF              ; set data type = string
  3469 00:BD74: 85 11              STA   Dtypef            ; set data type flag, $FF=string, $00=numeric
  3470 00:BD76: 8A                 TXA                     ; get 2nd character back
  3471 00:BD77: 09 80              ORA   #$80              ; set top bit (indicate string var)
  3472 00:BD79: AA                 TAX                     ; copy back to 2nd character temp
  3473 00:BD7A: 20 AE CF           JSR   LAB_IGBY          ; increment and scan memory
  3474                        
  3475                        ; after we have determined the variable type we need to come back here to determine
  3476                        ; if it's an array of type. this would plug in a%(b[,c[,d]])) integer arrays nicely
  3477                        
  3478                        LAB_1D47                      ; gets here with character after var name in A
  3479 00:BD7D: 86 46              STX   Varnm2            ; save 2nd character
  3480 00:BD7F: 05 13              ORA   Sufnxf            ; or with subscript/FNX flag (or FN name)
  3481 00:BD81: C9 28              CMP   #'('              ; compare with "("
  3482 00:BD83: D0 03              BNE   LAB_1D53          ; branch if not "("
  3483 00:BD85: 4C 4E BE           JMP   LAB_1E17          ; go find, or make, array
  3484                        
  3485                        ; either find or create var
  3486                        ; var name (1st two characters only!) is in Varnm1,Varnm2
  3487                        
  3488                                                      ; variable name wasn't var(... so look for plain var
  3489                        LAB_1D53
  3490 00:BD88: 64 13              STZ   Sufnxf            ; clear subscript/FNX flag
  3491 00:BD8A: A5 2D              LDA   Svarl             ; get start of vars low byte
  3492 00:BD8C: A6 2E              LDX   Svarh             ; get start of vars high byte
  3493 00:BD8E: A0 00              LDY   #$00              ; clear index
  3494                        LAB_1D5D
  3495 00:BD90: 86 5D              STX   Vrschh            ; save search address high byte
  3496                        LAB_1D5F
  3497 00:BD92: 85 5C              STA   Vrschl            ; save search address low byte
  3498 00:BD94: E4 30              CPX   Sarryh            ; compare high address with var space end
  3499 00:BD96: D0 04              BNE   LAB_1D69          ; skip next compare if <>
  3500                        
  3501                                                      ; high addresses were = so compare low addresses
  3502 00:BD98: C5 2F              CMP   Sarryl            ; compare low address with var space end
  3503 00:BD9A: F0 2C              BEQ   LAB_1D8B          ; if not found go make new var
  3504                        
  3505                        LAB_1D69
  3506 00:BD9C: A5 45              LDA   Varnm1            ; get 1st character of var to find
  3507 00:BD9E: D1 5C              CMP   (Vrschl),Y        ; compare with variable name 1st character
  3508 00:BDA0: D0 08              BNE   LAB_1D77          ; branch if no match
  3509                        
  3510                                                      ; 1st characters match so compare 2nd characters
  3511 00:BDA2: A5 46              LDA   Varnm2            ; get 2nd character of var to find
  3512 00:BDA4: C8                 INY                     ; index to point to variable name 2nd character
  3513 00:BDA5: D1 5C              CMP   (Vrschl),Y        ; compare with variable name 2nd character
  3514 00:BDA7: F0 69              BEQ   LAB_1DD7          ; branch if match (found var)
  3515                        
  3516 00:BDA9: 88                 DEY                     ; else decrement index (now = $00)
  3517                        LAB_1D77
  3518 00:BDAA: 18                 CLC                     ; clear carry for add
  3519 00:BDAB: A5 5C              LDA   Vrschl            ; get search address low byte
  3520 00:BDAD: 69 06              ADC   #$06              ; +6 (offset to next var name)
  3521 00:BDAF: 90 E1              BCC   LAB_1D5F          ; loop if no overflow to high byte
  3522                        
  Thu Sep 26 2019 15:30                                                                                                    Page 57


  3523 00:BDB1: E8                 INX                     ; else increment high byte
  3524 00:BDB2: 80 DC              BRA   LAB_1D5D          ; loop always (RAM doesn't extend to $FFFF !)
  3525                        
  3526                        ; check byte, return C=0 if<"A" or >"Z" or "a" to "z"
  3527                        
  3528                        LAB_CASC
  3529 00:BDB4: C9 61              CMP   #'a'              ; compare with "a"
  3530 00:BDB6: B0 0A              BCS   LAB_1D83          ; go check <"z"+1
  3531                        
  3532                        ; check byte, return C=0 if<"A" or >"Z"
  3533                        
  3534                        LAB_1D82
  3535 00:BDB8: C9 41              CMP   #'A'              ; compare with "A"
  3536 00:BDBA: 90 05              BCC   LAB_1D8A          ; exit if less
  3537                        
  3538                                                      ; carry is set
  3539 00:BDBC: E9 5B              SBC   #$5B              ; subtract "Z"+1
  3540 00:BDBE: 38                 SEC                     ; set carry
  3541 00:BDBF: E9 A5              SBC   #$A5              ; subtract $A5 (restore byte)
  3542                                                      ; carry clear if byte>$5A
  3543                        LAB_1D8A
  3544 00:BDC1: 60                 RTS
  3545                        
  3546                        LAB_1D83
  3547 00:BDC2: E9 7B              SBC   #$7B              ; subtract "z"+1
  3548 00:BDC4: 38                 SEC                     ; set carry
  3549 00:BDC5: E9 85              SBC   #$85              ; subtract $85 (restore byte)
  3550                                                      ; carry clear if byte>$7A
  3551 00:BDC7: 60                 RTS
  3552                        
  3553                                                      ; reached end of variable mem without match
  3554                                                      ; .. so create new variable
  3555                        LAB_1D8B
  3556 00:BDC8: 68                 PLA                     ; pop return address low byte
  3557 00:BDC9: 48                 PHA                     ; push return address low byte
  3558             0000BBDA   LAB_1C18p2  .EQU LAB_1C18+2
  3559 00:BDCA: C9 DA              CMP   #<LAB_1C18p2      ; compare with expected calling routine return low byte
  3560 00:BDCC: D0 05              BNE   LAB_1D98          ; if not get (var) go create new var
  3561                        
  3562                        ; This will only drop through if the call was from LAB_1C18 and is only called
  3563                        ; from there if it is searching for a variable from the RHS of a LET a=b statement
  3564                        ; it prevents the creation of variables not assigned a value.
  3565                        
  3566                        ; value returned by this is either numeric zero (exponent byte is $00) or null string
  3567                        ; (descriptor length byte is $00). in fact a pointer to any $00 byte would have done.
  3568                        
  3569                        ; doing this saves 6 bytes of variable memory and 168 machine cycles of time
  3570                        
  3571                        ; this is where you would put the undefined variable error call e.g.
  3572                        
  3573                        ;                             ; variable doesn't exist so flag error
  3574                        ;     LDX   #$24              ; error code $24 ("undefined variable" error)
  3575                        ;     JMP   LAB_XERR          ; do error #X then warm start
  3576                        
  3577                        ; the above code has been tested and works a treat! (it replaces the three code lines
  3578                        ; below)
  3579                        
  3580                                                      ; else return dummy null value
  3581 00:BDCE: A9 F2              LDA   #<LAB_1D96        ; low byte point to $00,$00
  3582                                                      ; (uses part of misc constants table)
  3583 00:BDD0: A0 D0              LDY   #>LAB_1D96        ; high byte point to $00,$00
  3584 00:BDD2: 60                 RTS
  3585                        
  Thu Sep 26 2019 15:30                                                                                                    Page 58


  3586                                                      ; create new numeric variable
  3587                        LAB_1D98
  3588 00:BDD3: A5 2F              LDA   Sarryl            ; get var mem end low byte
  3589 00:BDD5: A4 30              LDY   Sarryh            ; get var mem end high byte
  3590 00:BDD7: 85 5C              STA   Ostrtl            ; save old block start low byte
  3591 00:BDD9: 84 5D              STY   Ostrth            ; save old block start high byte
  3592 00:BDDB: A5 31              LDA   Earryl            ; get array mem end low byte
  3593 00:BDDD: A4 32              LDY   Earryh            ; get array mem end high byte
  3594 00:BDDF: 85 58              STA   Obendl            ; save old block end low byte
  3595 00:BDE1: 84 59              STY   Obendh            ; save old block end high byte
  3596 00:BDE3: 18                 CLC                     ; clear carry for add
  3597 00:BDE4: 69 06              ADC   #$06              ; +6 (space for one var)
  3598 00:BDE6: 90 01              BCC   LAB_1DAE          ; branch if no overflow to high byte
  3599                        
  3600 00:BDE8: C8                 INY                     ; else increment high byte
  3601                        LAB_1DAE
  3602 00:BDE9: 85 56              STA   Nbendl            ; set new block end low byte
  3603 00:BDEB: 84 57              STY   Nbendh            ; set new block end high byte
  3604 00:BDED: 20 8A B0           JSR   LAB_11CF          ; open up space in memory
  3605 00:BDF0: A5 56              LDA   Nbendl            ; get new start low byte
  3606 00:BDF2: A4 57              LDY   Nbendh            ; get new start high byte (-$100)
  3607 00:BDF4: C8                 INY                     ; correct high byte
  3608 00:BDF5: 85 2F              STA   Sarryl            ; save new var mem end low byte
  3609 00:BDF7: 84 30              STY   Sarryh            ; save new var mem end high byte
  3610 00:BDF9: A0 00              LDY   #$00              ; clear index
  3611 00:BDFB: A5 45              LDA   Varnm1            ; get var name 1st character
  3612 00:BDFD: 91 5C              STA   (Vrschl),Y        ; save var name 1st character
  3613 00:BDFF: C8                 INY                     ; increment index
  3614 00:BE00: A5 46              LDA   Varnm2            ; get var name 2nd character
  3615 00:BE02: 91 5C              STA   (Vrschl),Y        ; save var name 2nd character
  3616 00:BE04: A9 00              LDA   #$00              ; clear A
  3617 00:BE06: C8                 INY                     ; increment index
  3618 00:BE07: 91 5C              STA   (Vrschl),Y        ; initialise var byte
  3619 00:BE09: C8                 INY                     ; increment index
  3620 00:BE0A: 91 5C              STA   (Vrschl),Y        ; initialise var byte
  3621 00:BE0C: C8                 INY                     ; increment index
  3622 00:BE0D: 91 5C              STA   (Vrschl),Y        ; initialise var byte
  3623 00:BE0F: C8                 INY                     ; increment index
  3624 00:BE10: 91 5C              STA   (Vrschl),Y        ; initialise var byte
  3625                        
  3626                                                      ; found a match for var ((Vrschl) = ptr)
  3627                        LAB_1DD7
  3628 00:BE12: A5 5C              LDA   Vrschl            ; get var address low byte
  3629 00:BE14: 18                 CLC                     ; clear carry for add
  3630 00:BE15: 69 02              ADC   #$02              ; +2 (offset past var name bytes)
  3631 00:BE17: A4 5D              LDY   Vrschh            ; get var address high byte
  3632 00:BE19: 90 01              BCC   LAB_1DE1          ; branch if no overflow from add
  3633                        
  3634 00:BE1B: C8                 INY                     ; else increment high byte
  3635                        LAB_1DE1
  3636 00:BE1C: 85 47              STA   Cvaral            ; save current var address low byte
  3637 00:BE1E: 84 48              STY   Cvarah            ; save current var address high byte
  3638 00:BE20: 60                 RTS
  3639                        
  3640                        ; set-up array pointer (Adatal/h) to first element in array
  3641                        ; set Adatal,Adatah to Astrtl,Astrth+2*Dimcnt+#$05
  3642                        
  3643                        LAB_1DE6
  3644 00:BE21: A5 0F              LDA   Dimcnt            ; get # of dimensions (1, 2 or 3)
  3645 00:BE23: 0A                 ASL                     ; *2 (also clears the carry !)
  3646 00:BE24: 69 05              ADC   #$05              ; +5 (result is 7, 9 or 11 here)
  3647 00:BE26: 65 5C              ADC   Astrtl            ; add array start pointer low byte
  3648 00:BE28: A4 5D              LDY   Astrth            ; get array pointer high byte
  Thu Sep 26 2019 15:30                                                                                                    Page 59


  3649 00:BE2A: 90 01              BCC   LAB_1DF2          ; branch if no overflow
  3650                        
  3651 00:BE2C: C8                 INY                     ; else increment high byte
  3652                        LAB_1DF2
  3653 00:BE2D: 85 56              STA   Adatal            ; save array data pointer low byte
  3654 00:BE2F: 84 57              STY   Adatah            ; save array data pointer high byte
  3655 00:BE31: 60                 RTS
  3656                        
  3657                        ; evaluate integer expression
  3658                        
  3659                        LAB_EVIN
  3660 00:BE32: 20 AE CF           JSR   LAB_IGBY          ; increment and scan memory
  3661 00:BE35: 20 6F BA           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
  3662                                                      ; else do type mismatch
  3663                        
  3664                        ; evaluate integer expression (no check)
  3665                        
  3666                        LAB_EVPI
  3667 00:BE38: A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
  3668 00:BE3A: 30 0D              BMI   LAB_1E12          ; do function call error if -ve
  3669                        
  3670                        ; evaluate integer expression (no sign check)
  3671                        
  3672                        LAB_EVIR
  3673 00:BE3C: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  3674 00:BE3E: C9 90              CMP   #$90              ; compare with exponent = 2^16 (n>2^15)
  3675 00:BE40: 90 09              BCC   LAB_1E14          ; branch if n<2^16 (is ok)
  3676                        
  3677 00:BE42: A9 F9              LDA   #<LAB_1DF7        ; set pointer low byte to -32768
  3678 00:BE44: A0 D0              LDY   #>LAB_1DF7        ; set pointer high byte to -32768
  3679 00:BE46: 20 91 C8           JSR   LAB_27F8          ; compare FAC1 with (AY)
  3680                        LAB_1E12
  3681 00:BE49: D0 73              BNE   LAB_FCER          ; if <> do function call error then warm start
  3682                        
  3683                        LAB_1E14
  3684 00:BE4B: 4C C9 C8           JMP   LAB_2831          ; convert FAC1 floating-to-fixed and return
  3685                        
  3686                        ; find or make array
  3687                        
  3688                        LAB_1E17
  3689 00:BE4E: A5 10              LDA   Defdim            ; get DIM flag
  3690 00:BE50: 48                 PHA                     ; push it
  3691 00:BE51: A5 11              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
  3692 00:BE53: 48                 PHA                     ; push it
  3693 00:BE54: A0 00              LDY   #$00              ; clear dimensions count
  3694                        
  3695                        ; now get the array dimension(s) and stack it (them) before the data type and DIM flag
  3696                        
  3697                        LAB_1E1F
  3698 00:BE56: 5A                 PHY                     ; save dimensions count
  3699 00:BE57: A5 46              LDA   Varnm2            ; get array name 2nd byte
  3700 00:BE59: 48                 PHA                     ; save it
  3701 00:BE5A: A5 45              LDA   Varnm1            ; get array name 1st byte
  3702 00:BE5C: 48                 PHA                     ; save it
  3703 00:BE5D: 20 32 BE           JSR   LAB_EVIN          ; evaluate integer expression
  3704 00:BE60: 68                 PLA                     ; pull array name 1st byte
  3705 00:BE61: 85 45              STA   Varnm1            ; restore array name 1st byte
  3706 00:BE63: 68                 PLA                     ; pull array name 2nd byte
  3707 00:BE64: 85 46              STA   Varnm2            ; restore array name 2nd byte
  3708 00:BE66: 7A                 PLY                     ; restore dimensions count
  3709 00:BE67: BA                 TSX                     ; copy stack pointer
  3710 00:BE68: BD 02 01           LDA   LAB_STAK+2,X      ; get DIM flag
  3711 00:BE6B: 48                 PHA                     ; push it
  Thu Sep 26 2019 15:30                                                                                                    Page 60


  3712 00:BE6C: BD 01 01           LDA   LAB_STAK+1,X      ; get data type flag
  3713 00:BE6F: 48                 PHA                     ; push it
  3714 00:BE70: A5 60              LDA   FAC1_2            ; get this dimension size high byte
  3715 00:BE72: 9D 02 01           STA   LAB_STAK+2,X      ; stack before flag bytes
  3716 00:BE75: A5 61              LDA   FAC1_3            ; get this dimension size low byte
  3717 00:BE77: 9D 01 01           STA   LAB_STAK+1,X      ; stack before flag bytes
  3718 00:BE7A: C8                 INY                     ; increment dimensions count
  3719 00:BE7B: 20 B4 CF           JSR   LAB_GBYT          ; scan memory
  3720 00:BE7E: C9 2C              CMP   #','              ; compare with ","
  3721 00:BE80: F0 D4              BEQ   LAB_1E1F          ; if found go do next dimension
  3722                        
  3723 00:BE82: 84 0F              STY   Dimcnt            ; store dimensions count
  3724 00:BE84: 20 8F BB           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
  3725 00:BE87: 68                 PLA                     ; pull data type flag
  3726 00:BE88: 85 11              STA   Dtypef            ; restore data type flag, $FF=string, $00=numeric
  3727 00:BE8A: 68                 PLA                     ; pull DIM flag
  3728 00:BE8B: 85 10              STA   Defdim            ; restore DIM flag
  3729 00:BE8D: A6 2F              LDX   Sarryl            ; get array mem start low byte
  3730 00:BE8F: A5 30              LDA   Sarryh            ; get array mem start high byte
  3731                        
  3732                        ; now check to see if we are at the end of array memory (we would be if there were
  3733                        ; no arrays).
  3734                        
  3735                        LAB_1E5C
  3736 00:BE91: 86 5C              STX   Astrtl            ; save as array start pointer low byte
  3737 00:BE93: 85 5D              STA   Astrth            ; save as array start pointer high byte
  3738 00:BE95: C5 32              CMP   Earryh            ; compare with array mem end high byte
  3739 00:BE97: D0 04              BNE   LAB_1E68          ; branch if not reached array mem end
  3740                        
  3741 00:BE99: E4 31              CPX   Earryl            ; else compare with array mem end low byte
  3742 00:BE9B: F0 3A              BEQ   LAB_1EA1          ; go build array if not found
  3743                        
  3744                                                      ; search for array
  3745                        LAB_1E68
  3746 00:BE9D: A0 00              LDY   #$00              ; clear index
  3747 00:BE9F: B1 5C              LDA   (Astrtl),Y        ; get array name first byte
  3748 00:BEA1: C8                 INY                     ; increment index to second name byte
  3749 00:BEA2: C5 45              CMP   Varnm1            ; compare with this array name first byte
  3750 00:BEA4: D0 06              BNE   LAB_1E77          ; branch if no match
  3751                        
  3752 00:BEA6: A5 46              LDA   Varnm2            ; else get this array name second byte
  3753 00:BEA8: D1 5C              CMP   (Astrtl),Y        ; compare with array name second byte
  3754 00:BEAA: F0 17              BEQ   LAB_1E8D          ; array found so branch
  3755                        
  3756                                                      ; no match
  3757                        LAB_1E77
  3758 00:BEAC: C8                 INY                     ; increment index
  3759 00:BEAD: B1 5C              LDA   (Astrtl),Y        ; get array size low byte
  3760 00:BEAF: 18                 CLC                     ; clear carry for add
  3761 00:BEB0: 65 5C              ADC   Astrtl            ; add array start pointer low byte
  3762 00:BEB2: AA                 TAX                     ; copy low byte to X
  3763 00:BEB3: C8                 INY                     ; increment index
  3764 00:BEB4: B1 5C              LDA   (Astrtl),Y        ; get array size high byte
  3765 00:BEB6: 65 5D              ADC   Astrth            ; add array mem pointer high byte
  3766 00:BEB8: 90 D7              BCC   LAB_1E5C          ; if no overflow go check next array
  3767                        
  3768                        ; do array bounds error
  3769                        
  3770                        LAB_1E85
  3771 00:BEBA: A2 10              LDX   #$10              ; error code $10 ("Array bounds" error)
  3772 00:BEBC: 80 02              BRA   LAB_1E8A          ; branch around next instruction, saves on clock cycle
  3773                        
  3774                        ; do function call error
  Thu Sep 26 2019 15:30                                                                                                    Page 61


  3775                        
  3776                        LAB_FCER
  3777 00:BEBE: A2 08              LDX   #$08              ; error code $08 ("Function call" error)
  3778                        LAB_1E8A
  3779 00:BEC0: 4C 07 B1           JMP   LAB_XERR          ; do error #X, then warm start
  3780                        
  3781                                                      ; found array, are we trying to dimension it?
  3782                        LAB_1E8D
  3783 00:BEC3: A2 12              LDX   #$12              ; set error $12 ("Double dimension" error)
  3784 00:BEC5: A5 10              LDA   Defdim            ; get DIM flag
  3785 00:BEC7: D0 F7              BNE   LAB_1E8A          ; if we are trying to dimension it do error #X, then warm
  3786                                                      ; start
  3787                        
  3788                        ; found the array and we're not dimensioning it so we must find an element in it
  3789                        
  3790 00:BEC9: 20 21 BE           JSR   LAB_1DE6          ; set-up array pointer (Adatal/h) to first element in array
  3791                                                      ; (Astrtl,Astrth points to start of array)
  3792 00:BECC: A5 0F              LDA   Dimcnt            ; get dimensions count
  3793 00:BECE: A0 04              LDY   #$04              ; set index to array's # of dimensions
  3794 00:BED0: D1 5C              CMP   (Astrtl),Y        ; compare with no of dimensions
  3795 00:BED2: D0 E6              BNE   LAB_1E85          ; if wrong do array bounds error, could do "Wrong
  3796                                                      ; dimensions" error here .. if we want a different
  3797                                                      ; error message
  3798                        
  3799 00:BED4: 4C 5A BF           JMP   LAB_1F28          ; found array so go get element
  3800                                                      ; (could jump to LAB_1F28 as all LAB_1F24 does is take
  3801                                                      ; Dimcnt and save it at (Astrtl),Y which is already the
  3802                                                      ; same or we would have taken the BNE)
  3803                        
  3804                                                      ; array not found, so build it
  3805                        LAB_1EA1
  3806 00:BED7: 20 21 BE           JSR   LAB_1DE6          ; set-up array pointer (Adatal/h) to first element in array
  3807                                                      ; (Astrtl,Astrth points to start of array)
  3808 00:BEDA: 20 D7 B0           JSR   LAB_121F          ; check available memory, "Out of memory" error if no room
  3809                                                      ; addr to check is in AY (low/high)
  3810 00:BEDD: A0 00              LDY   #$00              ; clear Y (don't need to clear A)
  3811 00:BEDF: 84 6D              STY   Aspth             ; clear array data size high byte
  3812 00:BEE1: A5 45              LDA   Varnm1            ; get variable name 1st byte
  3813 00:BEE3: 91 5C              STA   (Astrtl),Y        ; save array name 1st byte
  3814 00:BEE5: C8                 INY                     ; increment index
  3815 00:BEE6: A5 46              LDA   Varnm2            ; get variable name 2nd byte
  3816 00:BEE8: 91 5C              STA   (Astrtl),Y        ; save array name 2nd byte
  3817 00:BEEA: A5 0F              LDA   Dimcnt            ; get dimensions count
  3818 00:BEEC: A0 04              LDY   #$04              ; index to dimension count
  3819 00:BEEE: 84 6C              STY   Asptl             ; set array data size low byte (four bytes per element)
  3820 00:BEF0: 91 5C              STA   (Astrtl),Y        ; set array's dimensions count
  3821                        
  3822                                                      ; now calculate the size of the data space for the array
  3823 00:BEF2: 18                 CLC                     ; clear carry for add (clear on subsequent loops)
  3824                        LAB_1EC0
  3825 00:BEF3: A2 0B              LDX   #$0B              ; set default dimension value low byte
  3826 00:BEF5: A9 00              LDA   #$00              ; set default dimension value high byte
  3827 00:BEF7: 24 10              BIT   Defdim            ; test default DIM flag
  3828 00:BEF9: 50 07              BVC   LAB_1ED0          ; branch if b6 of Defdim is clear
  3829                        
  3830 00:BEFB: 68                 PLA                     ; else pull dimension value low byte
  3831 00:BEFC: 69 01              ADC   #$01              ; +1 (allow for zeroeth element)
  3832 00:BEFE: AA                 TAX                     ; copy low byte to X
  3833 00:BEFF: 68                 PLA                     ; pull dimension value high byte
  3834 00:BF00: 69 00              ADC   #$00              ; add carry from low byte
  3835                        
  3836                        LAB_1ED0
  3837 00:BF02: C8                 INY                     ; index to dimension value high byte
  Thu Sep 26 2019 15:30                                                                                                    Page 62


  3838 00:BF03: 91 5C              STA   (Astrtl),Y        ; save dimension value high byte
  3839 00:BF05: C8                 INY                     ; index to dimension value high byte
  3840 00:BF06: 8A                 TXA                     ; get dimension value low byte
  3841 00:BF07: 91 5C              STA   (Astrtl),Y        ; save dimension value low byte
  3842 00:BF09: 20 A9 BF           JSR   LAB_1F7C          ; does XY = (Astrtl),Y * (Asptl)
  3843 00:BF0C: 86 6C              STX   Asptl             ; save array data size low byte
  3844 00:BF0E: 85 6D              STA   Aspth             ; save array data size high byte
  3845 00:BF10: A4 23              LDY   ut1_pl            ; restore index (saved by subroutine)
  3846 00:BF12: C6 0F              DEC   Dimcnt            ; decrement dimensions count
  3847 00:BF14: D0 DD              BNE   LAB_1EC0          ; loop while not = 0
  3848                        
  3849 00:BF16: 65 57              ADC   Adatah            ; add size high byte to first element high byte
  3850                                                      ; (carry is always clear here)
  3851 00:BF18: B0 5D              BCS   LAB_1F45          ; if overflow go do "Out of memory" error
  3852                        
  3853 00:BF1A: 85 57              STA   Adatah            ; save end of array high byte
  3854 00:BF1C: A8                 TAY                     ; copy end high byte to Y
  3855 00:BF1D: 8A                 TXA                     ; get array size low byte
  3856 00:BF1E: 65 56              ADC   Adatal            ; add array start low byte
  3857 00:BF20: 90 03              BCC   LAB_1EF3          ; branch if no carry
  3858                        
  3859 00:BF22: C8                 INY                     ; else increment end of array high byte
  3860 00:BF23: F0 52              BEQ   LAB_1F45          ; if overflow go do "Out of memory" error
  3861                        
  3862                                                      ; set-up mostly complete, now zero the array
  3863                        LAB_1EF3
  3864 00:BF25: 20 D7 B0           JSR   LAB_121F          ; check available memory, "Out of memory" error if no room
  3865                                                      ; addr to check is in AY (low/high)
  3866 00:BF28: 85 31              STA   Earryl            ; save array mem end low byte
  3867 00:BF2A: 84 32              STY   Earryh            ; save array mem end high byte
  3868 00:BF2C: A9 00              LDA   #$00              ; clear byte for array clear
  3869 00:BF2E: E6 6D              INC   Aspth             ; increment array size high byte (now block count)
  3870 00:BF30: A4 6C              LDY   Asptl             ; get array size low byte (now index to block)
  3871 00:BF32: F0 05              BEQ   LAB_1F07          ; branch if low byte = $00
  3872                        
  3873                        LAB_1F02
  3874 00:BF34: 88                 DEY                     ; decrement index (do 0 to n-1)
  3875 00:BF35: 91 56              STA   (Adatal),Y        ; zero byte
  3876 00:BF37: D0 FB              BNE   LAB_1F02          ; loop until this block done
  3877                        
  3878                        LAB_1F07
  3879 00:BF39: C6 57              DEC   Adatah            ; decrement array pointer high byte
  3880 00:BF3B: C6 6D              DEC   Aspth             ; decrement block count high byte
  3881 00:BF3D: D0 F5              BNE   LAB_1F02          ; loop until all blocks done
  3882                        
  3883 00:BF3F: E6 57              INC   Adatah            ; correct for last loop
  3884 00:BF41: 38                 SEC                     ; set carry for subtract
  3885 00:BF42: A0 02              LDY   #$02              ; index to array size low byte
  3886 00:BF44: A5 31              LDA   Earryl            ; get array mem end low byte
  3887 00:BF46: E5 5C              SBC   Astrtl            ; subtract array start low byte
  3888 00:BF48: 91 5C              STA   (Astrtl),Y        ; save array size low byte
  3889 00:BF4A: C8                 INY                     ; index to array size high byte
  3890 00:BF4B: A5 32              LDA   Earryh            ; get array mem end high byte
  3891 00:BF4D: E5 5D              SBC   Astrth            ; subtract array start high byte
  3892 00:BF4F: 91 5C              STA   (Astrtl),Y        ; save array size high byte
  3893 00:BF51: A5 10              LDA   Defdim            ; get default DIM flag
  3894 00:BF53: D0 53              BNE   LAB_1F7B          ; exit (RET) if this was a DIM command
  3895                        
  3896                                                      ; else, find element
  3897 00:BF55: C8                 INY                     ; index to # of dimensions
  3898                        
  3899                        LAB_1F24
  3900 00:BF56: B1 5C              LDA   (Astrtl),Y        ; get array's dimension count
  Thu Sep 26 2019 15:30                                                                                                    Page 63


  3901 00:BF58: 85 0F              STA   Dimcnt            ; save it
  3902                        
  3903                        ; we have found, or built, the array. now we need to find the element
  3904                        
  3905                        LAB_1F28
  3906 00:BF5A: A9 00              LDA   #$00              ; clear byte
  3907 00:BF5C: 85 6C              STA   Asptl             ; clear array data pointer low byte
  3908                        LAB_1F2C
  3909 00:BF5E: 85 6D              STA   Aspth             ; save array data pointer high byte
  3910 00:BF60: C8                 INY                     ; increment index (point to array bound high byte)
  3911 00:BF61: 68                 PLA                     ; pull array index low byte
  3912 00:BF62: AA                 TAX                     ; copy to X
  3913 00:BF63: 85 60              STA   FAC1_2            ; save index low byte to FAC1 mantissa2
  3914 00:BF65: 68                 PLA                     ; pull array index high byte
  3915 00:BF66: 85 61              STA   FAC1_3            ; save index high byte to FAC1 mantissa3
  3916 00:BF68: D1 5C              CMP   (Astrtl),Y        ; compare with array bound high byte
  3917 00:BF6A: 90 0E              BCC   LAB_1F48          ; branch if within bounds
  3918 00:BF6C: D0 06              BNE   LAB_1F42          ; if outside bounds do array bounds error
  3919                        
  3920                                                      ; else high byte was = so test low bytes
  3921 00:BF6E: C8                 INY                     ; index to array bound low byte
  3922 00:BF6F: 8A                 TXA                     ; get array index low byte
  3923 00:BF70: D1 5C              CMP   (Astrtl),Y        ; compare with array bound low byte
  3924 00:BF72: 90 07              BCC   LAB_1F49          ; branch if within bounds
  3925                        
  3926                        LAB_1F42
  3927 00:BF74: 4C BA BE           JMP   LAB_1E85          ; else do array bounds error
  3928                        
  3929                        LAB_1F45
  3930 00:BF77: 4C 05 B1           JMP   LAB_OMER          ; do "Out of memory" error then warm start
  3931                        
  3932                        LAB_1F48
  3933 00:BF7A: C8                 INY                     ; index to array bound low byte
  3934                        LAB_1F49
  3935 00:BF7B: A5 6D              LDA   Aspth             ; get array data pointer high byte
  3936 00:BF7D: 05 6C              ORA   Asptl             ; OR with array data pointer low byte
  3937 00:BF7F: F0 0A              BEQ   LAB_1F5A          ; branch if array data pointer = null (skip multiply)
  3938                        
  3939 00:BF81: 20 A9 BF           JSR   LAB_1F7C          ; does XY = (Astrtl),Y * (Asptl)
  3940 00:BF84: 8A                 TXA                     ; get result low byte
  3941 00:BF85: 65 60              ADC   FAC1_2            ; add index low byte from FAC1 mantissa2
  3942 00:BF87: AA                 TAX                     ; save result low byte
  3943 00:BF88: 98                 TYA                     ; get result high byte
  3944 00:BF89: A4 23              LDY   ut1_pl            ; restore index
  3945                        LAB_1F5A
  3946 00:BF8B: 65 61              ADC   FAC1_3            ; add index high byte from FAC1 mantissa3
  3947 00:BF8D: 86 6C              STX   Asptl             ; save array data pointer low byte
  3948 00:BF8F: C6 0F              DEC   Dimcnt            ; decrement dimensions count
  3949 00:BF91: D0 CB              BNE   LAB_1F2C          ; loop if dimensions still to do
  3950                        
  3951 00:BF93: 06 6C              ASL   Asptl             ; array data pointer low byte * 2
  3952 00:BF95: 2A                 ROL                     ; array data pointer high byte * 2
  3953 00:BF96: 06 6C              ASL   Asptl             ; array data pointer low byte * 4
  3954 00:BF98: 2A                 ROL                     ; array data pointer high byte * 4
  3955 00:BF99: A8                 TAY                     ; copy high byte
  3956 00:BF9A: A5 6C              LDA   Asptl             ; get low byte
  3957 00:BF9C: 65 56              ADC   Adatal            ; add array data start pointer low byte
  3958 00:BF9E: 85 47              STA   Cvaral            ; save as current var address low byte
  3959 00:BFA0: 98                 TYA                     ; get high byte back
  3960 00:BFA1: 65 57              ADC   Adatah            ; add array data start pointer high byte
  3961 00:BFA3: 85 48              STA   Cvarah            ; save as current var address high byte
  3962 00:BFA5: A8                 TAY                     ; copy high byte to Y
  3963 00:BFA6: A5 47              LDA   Cvaral            ; get current var address low byte
  Thu Sep 26 2019 15:30                                                                                                    Page 64


  3964                        LAB_1F7B
  3965 00:BFA8: 60                 RTS
  3966                        
  3967                        ; does XY = (Astrtl),Y * (Asptl)
  3968                        
  3969                        LAB_1F7C
  3970 00:BFA9: 84 23              STY   ut1_pl            ; save index
  3971 00:BFAB: B1 5C              LDA   (Astrtl),Y        ; get dimension size low byte
  3972 00:BFAD: 85 28              STA   dims_l            ; save dimension size low byte
  3973 00:BFAF: 88                 DEY                     ; decrement index
  3974 00:BFB0: B1 5C              LDA   (Astrtl),Y        ; get dimension size high byte
  3975 00:BFB2: 85 29              STA   dims_h            ; save dimension size high byte
  3976                        
  3977 00:BFB4: A9 10              LDA   #$10              ; count = $10 (16 bit multiply)
  3978 00:BFB6: 85 5A              STA   numbit            ; save bit count
  3979 00:BFB8: A2 00              LDX   #$00              ; clear result low byte
  3980 00:BFBA: A0 00              LDY   #$00              ; clear result high byte
  3981                        LAB_1F8F
  3982 00:BFBC: 8A                 TXA                     ; get result low byte
  3983 00:BFBD: 0A                 ASL                     ; *2
  3984 00:BFBE: AA                 TAX                     ; save result low byte
  3985 00:BFBF: 98                 TYA                     ; get result high byte
  3986 00:BFC0: 2A                 ROL                     ; *2
  3987 00:BFC1: A8                 TAY                     ; save result high byte
  3988 00:BFC2: B0 B3              BCS   LAB_1F45          ; if overflow go do "Out of memory" error
  3989                        
  3990 00:BFC4: 06 6C              ASL   Asptl             ; shift multiplier low byte
  3991 00:BFC6: 26 6D              ROL   Aspth             ; shift multiplier high byte
  3992 00:BFC8: 90 0B              BCC   LAB_1FA8          ; skip add if no carry
  3993                        
  3994 00:BFCA: 18                 CLC                     ; else clear carry for add
  3995 00:BFCB: 8A                 TXA                     ; get result low byte
  3996 00:BFCC: 65 28              ADC   dims_l            ; add dimension size low byte
  3997 00:BFCE: AA                 TAX                     ; save result low byte
  3998 00:BFCF: 98                 TYA                     ; get result high byte
  3999 00:BFD0: 65 29              ADC   dims_h            ; add dimension size high byte
  4000 00:BFD2: A8                 TAY                     ; save result high byte
  4001 00:BFD3: B0 A2              BCS   LAB_1F45          ; if overflow go do "Out of memory" error
  4002                        
  4003                        LAB_1FA8
  4004 00:BFD5: C6 5A              DEC   numbit            ; decrement bit count
  4005 00:BFD7: D0 E3              BNE   LAB_1F8F          ; loop until all done
  4006 00:BFD9: 60                 RTS
  4007                        
  4008                        ; perform FRE()
  4009                        
  4010                        LAB_FRE
  4011 00:BFDA: A5 11              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
  4012 00:BFDC: 10 03              BPL   LAB_1FB4          ; branch if numeric
  4013                        
  4014 00:BFDE: 20 CE C2           JSR   LAB_22B6          ; pop string off descriptor stack, or from top of string
  4015                                                      ; space returns with A = length, X=$71=pointer low byte,
  4016                                                      ; Y=$72=pointer high byte
  4017                        
  4018                                                      ; FRE(n) was numeric so do this
  4019                        LAB_1FB4
  4020 00:BFE1: 20 73 C1           JSR   LAB_GARB          ; go do garbage collection
  4021 00:BFE4: 38                 SEC                     ; set carry for subtract
  4022 00:BFE5: A5 33              LDA   Sstorl            ; get bottom of string space low byte
  4023 00:BFE7: E5 31              SBC   Earryl            ; subtract array mem end low byte
  4024 00:BFE9: A8                 TAY                     ; copy result to Y
  4025 00:BFEA: A5 34              LDA   Sstorh            ; get bottom of string space high byte
  4026 00:BFEC: E5 32              SBC   Earryh            ; subtract array mem end high byte
  Thu Sep 26 2019 15:30                                                                                                    Page 65


  4027                        
  4028                        ; save and convert integer AY to FAC1
  4029                        
  4030                        LAB_AYFC
  4031 00:BFEE: 46 11              LSR   Dtypef            ; clear data type flag, $FF=string, $00=numeric
  4032 00:BFF0: 85 5F              STA   FAC1_1            ; save FAC1 mantissa1
  4033 00:BFF2: 84 60              STY   FAC1_2            ; save FAC1 mantissa2
  4034 00:BFF4: A2 90              LDX   #$90              ; set exponent=2^16 (integer)
  4035 00:BFF6: 4C 7E C8           JMP   LAB_27E3          ; set exp=X, clear FAC1_3, normalise and return
  4036                        
  4037                        ; perform POS()
  4038                        
  4039                        LAB_POS
  4040 00:BFF9: A4 07              LDY   TPos              ; get terminal position
  4041                        
  4042                        ; convert Y to byte in FAC1
  4043                        
  4044                        LAB_1FD0
  4045 00:BFFB: A9 00              LDA   #$00              ; clear high byte
  4046 00:BFFD: 80 EF              BRA   LAB_AYFC          ; always save and convert integer AY to FAC1 and return
  4047                        
  4048                        ; check not Direct (used by DEF and INPUT)
  4049                        
  4050                        LAB_CKRN
  4051 00:BFFF: A6 3A              LDX   Clineh            ; get current line high byte
  4052 00:C001: E8                 INX                     ; increment it
  4053 00:C002: D0 A4              BNE   LAB_1F7B          ; return if can continue not direct mode
  4054                        
  4055                                                      ; else do illegal direct error
  4056                        LAB_1FD9
  4057 00:C004: A2 16              LDX   #$16              ; error code $16 ("Illegal direct" error)
  4058                        LAB_1FDB
  4059 00:C006: 4C 07 B1           JMP   LAB_XERR          ; go do error #X, then warm start
  4060                        
  4061                        ; perform DEF
  4062                        
  4063                        LAB_DEF
  4064 00:C009: 20 39 C0           JSR   LAB_200B          ; check FNx syntax
  4065 00:C00C: 85 4E              STA   func_l            ; save function pointer low byte
  4066 00:C00E: 84 4F              STY   func_h            ; save function pointer high byte
  4067 00:C010: 20 FF BF           JSR   LAB_CKRN          ; check not Direct (back here if ok)
  4068 00:C013: 20 98 BB           JSR   LAB_1BFE          ; scan for "(" , else do syntax error then warm start
  4069 00:C016: A9 80              LDA   #$80              ; set flag for FNx
  4070 00:C018: 85 13              STA   Sufnxf            ; save subscript/FNx flag
  4071 00:C01A: 20 42 BD           JSR   LAB_GVAR          ; get (var) address
  4072 00:C01D: 20 72 BA           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
  4073 00:C020: 20 8F BB           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
  4074 00:C023: A9 BD              LDA   #TK_EQUAL         ; get = token
  4075 00:C025: 20 91 BB           JSR   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
  4076 00:C028: A5 48              LDA   Cvarah            ; get current var address high byte
  4077 00:C02A: 48                 PHA                     ; push it
  4078 00:C02B: A5 47              LDA   Cvaral            ; get current var address low byte
  4079 00:C02D: 48                 PHA                     ; push it
  4080 00:C02E: A5 6F              LDA   Bpntrh            ; get BASIC execute pointer high byte
  4081 00:C030: 48                 PHA                     ; push it
  4082 00:C031: A5 6E              LDA   Bpntrl            ; get BASIC execute pointer low byte
  4083 00:C033: 48                 PHA                     ; push it
  4084 00:C034: 20 48 B6           JSR   LAB_DATA          ; go perform DATA
  4085 00:C037: 80 6E              BRA   LAB_207A          ; put execute pointer and variable pointer into function
  4086                                                      ; and return
  4087                        
  4088                        ; check FNx syntax
  4089                        
  Thu Sep 26 2019 15:30                                                                                                    Page 66


  4090                        LAB_200B
  4091 00:C039: A9 AB              LDA   #TK_FN            ; get FN" token
  4092 00:C03B: 20 91 BB           JSR   LAB_SCCA          ; scan for CHR$(A) , else do syntax error then warm start
  4093                                                      ; return character after A
  4094 00:C03E: 09 80              ORA   #$80              ; set FN flag bit
  4095 00:C040: 85 13              STA   Sufnxf            ; save FN flag so array variable test fails
  4096 00:C042: 20 49 BD           JSR   LAB_1D12          ; search for FN variable
  4097 00:C045: 4C 72 BA           JMP   LAB_CTNM          ; check if source is numeric and return, else do type
  4098                                                      ; mismatch
  4099                        
  4100                                                      ; Evaluate FNx
  4101                        LAB_201E
  4102 00:C048: 20 39 C0           JSR   LAB_200B          ; check FNx syntax
  4103 00:C04B: 48                 PHA                     ; push function pointer low byte
  4104 00:C04C: 5A                 PHY                     ; push function pointer high byte
  4105 00:C04D: 20 98 BB           JSR   LAB_1BFE          ; scan for "(", else do syntax error then warm start
  4106 00:C050: 20 84 BA           JSR   LAB_EVEX          ; evaluate expression
  4107 00:C053: 20 8F BB           JSR   LAB_1BFB          ; scan for ")", else do syntax error then warm start
  4108 00:C056: 20 72 BA           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
  4109 00:C059: 68                 PLA                     ; pop function pointer high byte
  4110 00:C05A: 85 4F              STA   func_h            ; restore it
  4111 00:C05C: 68                 PLA                     ; pop function pointer low byte
  4112 00:C05D: 85 4E              STA   func_l            ; restore it
  4113 00:C05F: A2 20              LDX   #$20              ; error code $20 ("Undefined function" error)
  4114 00:C061: A0 03              LDY   #$03              ; index to variable pointer high byte
  4115 00:C063: B1 4E              LDA   (func_l),Y        ; get variable pointer high byte
  4116 00:C065: F0 9F              BEQ   LAB_1FDB          ; if zero go do undefined function error
  4117                        
  4118 00:C067: 85 48              STA   Cvarah            ; save variable address high byte
  4119 00:C069: 88                 DEY                     ; index to variable address low byte
  4120 00:C06A: B1 4E              LDA   (func_l),Y        ; get variable address low byte
  4121 00:C06C: 85 47              STA   Cvaral            ; save variable address low byte
  4122 00:C06E: AA                 TAX                     ; copy address low byte
  4123                        
  4124                                                      ; now stack the function variable value before use
  4125 00:C06F: C8                 INY                     ; index to mantissa_3
  4126                        LAB_2043
  4127 00:C070: B1 47              LDA   (Cvaral),Y        ; get byte from variable
  4128 00:C072: 48                 PHA                     ; stack it
  4129 00:C073: 88                 DEY                     ; decrement index
  4130 00:C074: 10 FA              BPL   LAB_2043          ; loop until variable stacked
  4131                        
  4132 00:C076: A4 48              LDY   Cvarah            ; get variable address high byte
  4133 00:C078: 20 25 C8           JSR   LAB_2778          ; pack FAC1 (function expression value) into (XY)
  4134                                                      ; (function variable), return Y=0, always
  4135 00:C07B: A5 6F              LDA   Bpntrh            ; get BASIC execute pointer high byte
  4136 00:C07D: 48                 PHA                     ; push it
  4137 00:C07E: A5 6E              LDA   Bpntrl            ; get BASIC execute pointer low byte
  4138 00:C080: 48                 PHA                     ; push it
  4139 00:C081: B1 4E              LDA   (func_l),Y        ; get function execute pointer low byte
  4140 00:C083: 85 6E              STA   Bpntrl            ; save as BASIC execute pointer low byte
  4141 00:C085: C8                 INY                     ; index to high byte
  4142 00:C086: B1 4E              LDA   (func_l),Y        ; get function execute pointer high byte
  4143 00:C088: 85 6F              STA   Bpntrh            ; save as BASIC execute pointer high byte
  4144 00:C08A: A5 48              LDA   Cvarah            ; get variable address high byte
  4145 00:C08C: 48                 PHA                     ; push it
  4146 00:C08D: A5 47              LDA   Cvaral            ; get variable address low byte
  4147 00:C08F: 48                 PHA                     ; push it
  4148 00:C090: 20 6F BA           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
  4149                                                      ; else do type mismatch
  4150 00:C093: 68                 PLA                     ; pull variable address low byte
  4151 00:C094: 85 4E              STA   func_l            ; save variable address low byte
  4152 00:C096: 68                 PLA                     ; pull variable address high byte
  Thu Sep 26 2019 15:30                                                                                                    Page 67


  4153 00:C097: 85 4F              STA   func_h            ; save variable address high byte
  4154 00:C099: 20 B4 CF           JSR   LAB_GBYT          ; scan memory
  4155 00:C09C: F0 03              BEQ   LAB_2074          ; branch if null (should be [EOL] marker)
  4156 00:C09E: 4C A0 BB           JMP   LAB_SNER          ; else syntax error then warm start
  4157                        
  4158                        ; restore Bpntrl,Bpntrh and function variable from stack
  4159                        
  4160                        LAB_2074
  4161 00:C0A1: 68                 PLA                     ; pull BASIC execute pointer low byte
  4162 00:C0A2: 85 6E              STA   Bpntrl            ; restore BASIC execute pointer low byte
  4163 00:C0A4: 68                 PLA                     ; pull BASIC execute pointer high byte
  4164 00:C0A5: 85 6F              STA   Bpntrh            ; restore BASIC execute pointer high byte
  4165                        
  4166                        ; put execute pointer and variable pointer into function
  4167                        
  4168                        LAB_207A
  4169 00:C0A7: A0 00              LDY   #$00              ; clear index
  4170 00:C0A9: 68                 PLA                     ; pull BASIC execute pointer low byte
  4171 00:C0AA: 91 4E              STA   (func_l),Y        ; save to function
  4172 00:C0AC: C8                 INY                     ; increment index
  4173 00:C0AD: 68                 PLA                     ; pull BASIC execute pointer high byte
  4174 00:C0AE: 91 4E              STA   (func_l),Y        ; save to function
  4175 00:C0B0: C8                 INY                     ; increment index
  4176 00:C0B1: 68                 PLA                     ; pull current var address low byte
  4177 00:C0B2: 91 4E              STA   (func_l),Y        ; save to function
  4178 00:C0B4: C8                 INY                     ; increment index
  4179 00:C0B5: 68                 PLA                     ; pull current var address high byte
  4180 00:C0B6: 91 4E              STA   (func_l),Y        ; save to function
  4181 00:C0B8: 60                 RTS
  4182                        
  4183                        ; perform STR$()
  4184                        
  4185                        LAB_STRS
  4186 00:C0B9: 20 72 BA           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
  4187 00:C0BC: 20 07 CA           JSR   LAB_296E          ; convert FAC1 to string
  4188 00:C0BF: A9 75              LDA   #<Decssp1         ; set result string low pointer
  4189 00:C0C1: A0 00              LDY   #>Decssp1         ; set result string high pointer
  4190 00:C0C3: F0 12              BEQ   LAB_20AE          ; print null terminated string to Sutill/Sutilh
  4191                        
  4192                        ; Do string vector
  4193                        ; copy des_pl/h to des_2l/h and make string space A bytes long
  4194                        
  4195                        LAB_209C
  4196 00:C0C5: A6 60              LDX   des_pl            ; get descriptor pointer low byte
  4197 00:C0C7: A4 61              LDY   des_ph            ; get descriptor pointer high byte
  4198 00:C0C9: 86 50              STX   des_2l            ; save descriptor pointer low byte
  4199 00:C0CB: 84 51              STY   des_2h            ; save descriptor pointer high byte
  4200                        
  4201                        ; make string space A bytes long
  4202                        ; A=length, X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
  4203                        
  4204                        LAB_MSSP
  4205 00:C0CD: 20 41 C1           JSR   LAB_2115          ; make space in string memory for string A long
  4206                                                      ; return X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
  4207 00:C0D0: 86 5F              STX   str_pl            ; save string pointer low byte
  4208 00:C0D2: 84 60              STY   str_ph            ; save string pointer high byte
  4209 00:C0D4: 85 5E              STA   str_ln            ; save length
  4210 00:C0D6: 60                 RTS
  4211                        
  4212                        ; Scan, set up string
  4213                        ; print " terminated string to Sutill/Sutilh
  4214                        
  4215                        LAB_20AE
  Thu Sep 26 2019 15:30                                                                                                    Page 68


  4216 00:C0D7: A2 22              LDX   #$22              ; set terminator to "
  4217 00:C0D9: 86 0D              STX   Srchc             ; set search character (terminator 1)
  4218 00:C0DB: 86 0E              STX   Asrch             ; set terminator 2
  4219                        
  4220                        ; print [Srchc] or [Asrch] terminated string to Sutill/Sutilh
  4221                        ; source is AY
  4222                        
  4223                        LAB_20B4
  4224 00:C0DD: 85 6A              STA   ssptr_l           ; store string start low byte
  4225 00:C0DF: 84 6B              STY   ssptr_h           ; store string start high byte
  4226 00:C0E1: 85 5F              STA   str_pl            ; save string pointer low byte
  4227 00:C0E3: 84 60              STY   str_ph            ; save string pointer high byte
  4228 00:C0E5: A0 FF              LDY   #$FF              ; set length to -1
  4229                        LAB_20BE
  4230 00:C0E7: C8                 INY                     ; increment length
  4231 00:C0E8: B1 6A              LDA   (ssptr_l),Y       ; get byte from string
  4232 00:C0EA: F0 0C              BEQ   LAB_20CF          ; exit loop if null byte [EOS]
  4233                        
  4234 00:C0EC: C5 0D              CMP   Srchc             ; compare with search character (terminator 1)
  4235 00:C0EE: F0 04              BEQ   LAB_20CB          ; branch if terminator
  4236                        
  4237 00:C0F0: C5 0E              CMP   Asrch             ; compare with terminator 2
  4238 00:C0F2: D0 F3              BNE   LAB_20BE          ; loop if not terminator 2
  4239                        
  4240                        LAB_20CB
  4241 00:C0F4: C9 22              CMP   #$22              ; compare with "
  4242 00:C0F6: F0 01              BEQ   LAB_20D0          ; branch if " (carry set if = !)
  4243                        
  4244                        LAB_20CF
  4245 00:C0F8: 18                 CLC                     ; clear carry for add (only if [EOL] terminated string)
  4246                        LAB_20D0
  4247 00:C0F9: 84 5E              STY   str_ln            ; save length in FAC1 exponent
  4248 00:C0FB: 98                 TYA                     ; copy length to A
  4249 00:C0FC: 65 6A              ADC   ssptr_l           ; add string start low byte
  4250 00:C0FE: 85 6C              STA   Sendl             ; save string end low byte
  4251 00:C100: A6 6B              LDX   ssptr_h           ; get string start high byte
  4252 00:C102: 90 01              BCC   LAB_20DC          ; branch if no low byte overflow
  4253                        
  4254 00:C104: E8                 INX                     ; else increment high byte
  4255                        LAB_20DC
  4256 00:C105: 86 6D              STX   Sendh             ; save string end high byte
  4257 00:C107: A5 6B              LDA   ssptr_h           ; get string start high byte
  4258 00:C109: F0 04              BEQ   LAB_MVST          ; fix STR$() using page zero via LAB_296E
  4259 00:C10B: C9 04              CMP   #>Ibuffs          ; compare with location of input buffer page
  4260 00:C10D: D0 0B              BNE   LAB_RTST          ; branch if not in utility area
  4261                        
  4262                        LAB_MVST
  4263                                                      ; string in utility area, move to string memory
  4264 00:C10F: 98                 TYA                     ; copy length to A
  4265 00:C110: 20 C5 C0           JSR   LAB_209C          ; copy des_pl/h to des_2l/h and make string space A bytes
  4266                                                      ; long
  4267 00:C113: A6 6A              LDX   ssptr_l           ; get string start low byte
  4268 00:C115: A4 6B              LDY   ssptr_h           ; get string start high byte
  4269 00:C117: 20 AF C2           JSR   LAB_2298          ; store string A bytes long from XY to (Sutill)
  4270                        
  4271                        ; check for space on descriptor stack then ..
  4272                        ; put string address and length on descriptor stack and update stack pointers
  4273                        
  4274                        LAB_RTST
  4275 00:C11A: A6 17              LDX   next_s            ; get string stack pointer
  4276 00:C11C: E0 23              CPX   #des_sk+$09       ; compare with max+1
  4277 00:C11E: D0 05              BNE   LAB_20F8          ; branch if space on string stack
  4278                        
  Thu Sep 26 2019 15:30                                                                                                    Page 69


  4279                                                      ; else do string too complex error
  4280 00:C120: A2 1C              LDX   #$1C              ; error code $1C ("String too complex" error)
  4281                        LAB_20F5
  4282 00:C122: 4C 07 B1           JMP   LAB_XERR          ; do error #X, then warm start
  4283                        
  4284                        ; put string address and length on descriptor stack and update stack pointers
  4285                        
  4286                        LAB_20F8
  4287 00:C125: A5 5E              LDA   str_ln            ; get string length
  4288 00:C127: 95 00              STA   PLUS_0,X          ; put on string stack
  4289 00:C129: A5 5F              LDA   str_pl            ; get string pointer low byte
  4290 00:C12B: 95 01              STA   PLUS_1,X          ; put on string stack
  4291 00:C12D: A5 60              LDA   str_ph            ; get string pointer high byte
  4292 00:C12F: 95 02              STA   PLUS_2,X          ; put on string stack
  4293 00:C131: 86 60              STX   des_pl            ; save string descriptor pointer low byte
  4294 00:C133: 64 61              STZ   des_ph            ; save string descriptor pointer high byte (always $00)
  4295 00:C135: A0 FF              LDY   #$FF              ; Y = $FF
  4296 00:C137: 84 11              STY   Dtypef            ; save data type flag, $FF=string
  4297 00:C139: 86 18              STX   last_sl           ; save old stack pointer (current top item)
  4298 00:C13B: E8                 INX                     ; update stack pointer
  4299 00:C13C: E8                 INX                     ; update stack pointer
  4300 00:C13D: E8                 INX                     ; update stack pointer
  4301 00:C13E: 86 17              STX   next_s            ; save new top item value
  4302 00:C140: 60                 RTS
  4303                        
  4304                        ; Build descriptor
  4305                        ; make space in string memory for string A long
  4306                        ; return X=Sutill=ptr low byte, Y=Sutill=ptr high byte
  4307                        
  4308                        LAB_2115
  4309 00:C141: 46 12              LSR   Gclctd            ; clear garbage collected flag (b7)
  4310                        
  4311                                                      ; make space for string A long
  4312                        LAB_2117
  4313 00:C143: 48                 PHA                     ; save string length
  4314 00:C144: 49 FF              EOR   #$FF              ; complement it
  4315 00:C146: 38                 SEC                     ; set carry for subtract (twos comp add)
  4316 00:C147: 65 33              ADC   Sstorl            ; add bottom of string space low byte (subtract length)
  4317 00:C149: A4 34              LDY   Sstorh            ; get bottom of string space high byte
  4318 00:C14B: B0 01              BCS   LAB_2122          ; skip decrement if no underflow
  4319                        
  4320 00:C14D: 88                 DEY                     ; decrement bottom of string space high byte
  4321                        LAB_2122
  4322 00:C14E: C4 32              CPY   Earryh            ; compare with array mem end high byte
  4323 00:C150: 90 11              BCC   LAB_2137          ; do out of memory error if less
  4324                        
  4325 00:C152: D0 04              BNE   LAB_212C          ; if not = skip next test
  4326                        
  4327 00:C154: C5 31              CMP   Earryl            ; compare with array mem end low byte
  4328 00:C156: 90 0B              BCC   LAB_2137          ; do out of memory error if less
  4329                        
  4330                        LAB_212C
  4331 00:C158: 85 33              STA   Sstorl            ; save bottom of string space low byte
  4332 00:C15A: 84 34              STY   Sstorh            ; save bottom of string space high byte
  4333 00:C15C: 85 35              STA   Sutill            ; save string utility ptr low byte
  4334 00:C15E: 84 36              STY   Sutilh            ; save string utility ptr high byte
  4335 00:C160: AA                 TAX                     ; copy low byte to X
  4336 00:C161: 68                 PLA                     ; get string length back
  4337 00:C162: 60                 RTS
  4338                        
  4339                        LAB_2137
  4340 00:C163: A2 0C              LDX   #$0C              ; error code $0C ("Out of memory" error)
  4341 00:C165: A5 12              LDA   Gclctd            ; get garbage collected flag
  Thu Sep 26 2019 15:30                                                                                                    Page 70


  4342 00:C167: 30 B9              BMI   LAB_20F5          ; if set then do error code X
  4343                        
  4344 00:C169: 20 73 C1           JSR   LAB_GARB          ; else go do garbage collection
  4345 00:C16C: A9 80              LDA   #$80              ; flag for garbage collected
  4346 00:C16E: 85 12              STA   Gclctd            ; set garbage collected flag
  4347 00:C170: 68                 PLA                     ; pull length
  4348 00:C171: 80 D0              BRA   LAB_2117          ; go try again (loop always, length should never be = $00)
  4349                        
  4350                        ; garbage collection routine
  4351                        
  4352                        LAB_GARB
  4353 00:C173: A6 37              LDX   Ememl             ; get end of mem low byte
  4354 00:C175: A5 38              LDA   Ememh             ; get end of mem high byte
  4355                        
  4356                        ; re-run routine from last ending
  4357                        
  4358                        LAB_214B
  4359 00:C177: 86 33              STX   Sstorl            ; set string storage low byte
  4360 00:C179: 85 34              STA   Sstorh            ; set string storage high byte
  4361 00:C17B: 64 4F              STZ   garb_h            ; clear working pointer high byte (flag no strings to move)
  4362 00:C17D: A5 31              LDA   Earryl            ; get array mem end low byte
  4363 00:C17F: A6 32              LDX   Earryh            ; get array mem end high byte
  4364 00:C181: 85 5C              STA   Histrl            ; save as highest string low byte
  4365 00:C183: 86 5D              STX   Histrh            ; save as highest string high byte
  4366 00:C185: A9 1A              LDA   #des_sk           ; set descriptor stack pointer
  4367 00:C187: 85 23              STA   ut1_pl            ; save descriptor stack pointer low byte
  4368 00:C189: 64 24              STZ   ut1_ph            ; save descriptor stack pointer high byte ($00)
  4369                        LAB_2161
  4370 00:C18B: C5 17              CMP   next_s            ; compare with descriptor stack pointer
  4371 00:C18D: F0 05              BEQ   LAB_216A          ; branch if =
  4372                        
  4373 00:C18F: 20 F5 C1           JSR   LAB_21D7          ; go garbage collect descriptor stack
  4374 00:C192: 80 F7              BRA   LAB_2161          ; loop always
  4375                        
  4376                                                      ; done stacked strings, now do string vars
  4377                        LAB_216A
  4378 00:C194: 06 52              ASL   g_step            ; set step size = $06
  4379 00:C196: A5 2D              LDA   Svarl             ; get start of vars low byte
  4380 00:C198: A6 2E              LDX   Svarh             ; get start of vars high byte
  4381 00:C19A: 85 23              STA   ut1_pl            ; save as pointer low byte
  4382 00:C19C: 86 24              STX   ut1_ph            ; save as pointer high byte
  4383                        LAB_2176
  4384 00:C19E: E4 30              CPX   Sarryh            ; compare start of arrays high byte
  4385 00:C1A0: D0 04              BNE   LAB_217E          ; branch if no high byte match
  4386                        
  4387 00:C1A2: C5 2F              CMP   Sarryl            ; else compare start of arrays low byte
  4388 00:C1A4: F0 05              BEQ   LAB_2183          ; branch if = var mem end
  4389                        
  4390                        LAB_217E
  4391 00:C1A6: 20 EF C1           JSR   LAB_21D1          ; go garbage collect strings
  4392 00:C1A9: 80 F3              BRA   LAB_2176          ; loop always
  4393                        
  4394                                                      ; done string vars, now do string arrays
  4395                        LAB_2183
  4396 00:C1AB: 85 56              STA   Nbendl            ; save start of arrays low byte as working pointer
  4397 00:C1AD: 86 57              STX   Nbendh            ; save start of arrays high byte as working pointer
  4398 00:C1AF: A9 04              LDA   #$04              ; set step size
  4399 00:C1B1: 85 52              STA   g_step            ; save step size
  4400                        LAB_218B
  4401 00:C1B3: A5 56              LDA   Nbendl            ; get pointer low byte
  4402 00:C1B5: A6 57              LDX   Nbendh            ; get pointer high byte
  4403                        LAB_218F
  4404 00:C1B7: E4 32              CPX   Earryh            ; compare with array mem end high byte
  Thu Sep 26 2019 15:30                                                                                                    Page 71


  4405 00:C1B9: D0 04              BNE   LAB_219A          ; branch if not at end
  4406                        
  4407 00:C1BB: C5 31              CMP   Earryl            ; else compare with array mem end low byte
  4408 00:C1BD: F0 75              BEQ   LAB_2216          ; tidy up and exit if at end
  4409                        
  4410                        LAB_219A
  4411 00:C1BF: 85 23              STA   ut1_pl            ; save pointer low byte
  4412 00:C1C1: 86 24              STX   ut1_ph            ; save pointer high byte
  4413 00:C1C3: A0 02              LDY   #$02              ; set index
  4414 00:C1C5: B1 23              LDA   (ut1_pl),Y        ; get array size low byte
  4415 00:C1C7: 65 56              ADC   Nbendl            ; add start of this array low byte
  4416 00:C1C9: 85 56              STA   Nbendl            ; save start of next array low byte
  4417 00:C1CB: C8                 INY                     ; increment index
  4418 00:C1CC: B1 23              LDA   (ut1_pl),Y        ; get array size high byte
  4419 00:C1CE: 65 57              ADC   Nbendh            ; add start of this array high byte
  4420 00:C1D0: 85 57              STA   Nbendh            ; save start of next array high byte
  4421 00:C1D2: A0 01              LDY   #$01              ; set index
  4422 00:C1D4: B1 23              LDA   (ut1_pl),Y        ; get name second byte
  4423 00:C1D6: 10 DB              BPL   LAB_218B          ; skip if not string array
  4424                        
  4425                        ; was string array so ..
  4426                        
  4427 00:C1D8: A0 04              LDY   #$04              ; set index
  4428 00:C1DA: B1 23              LDA   (ut1_pl),Y        ; get # of dimensions
  4429 00:C1DC: 0A                 ASL                     ; *2
  4430 00:C1DD: 69 05              ADC   #$05              ; +5 (array header size)
  4431 00:C1DF: 20 27 C2           JSR   LAB_2208          ; go set up for first element
  4432                        LAB_21C4
  4433 00:C1E2: E4 57              CPX   Nbendh            ; compare with start of next array high byte
  4434 00:C1E4: D0 04              BNE   LAB_21CC          ; branch if <> (go do this array)
  4435                        
  4436 00:C1E6: C5 56              CMP   Nbendl            ; else compare element pointer low byte with next array
  4437                                                      ; low byte
  4438 00:C1E8: F0 CD              BEQ   LAB_218F          ; if equal then go do next array
  4439                        
  4440                        LAB_21CC
  4441 00:C1EA: 20 F5 C1           JSR   LAB_21D7          ; go defrag array strings
  4442 00:C1ED: 80 F3              BRA   LAB_21C4          ; go do next array string (loop always)
  4443                        
  4444                        ; defrag string variables
  4445                        ; enter with XA = variable pointer
  4446                        ; return with XA = next variable pointer
  4447                        
  4448                        LAB_21D1
  4449 00:C1EF: C8                 INY                     ; increment index (Y was $00)
  4450 00:C1F0: B1 23              LDA   (ut1_pl),Y        ; get var name byte 2
  4451 00:C1F2: 10 30              BPL   LAB_2206          ; if not string, step pointer to next var and return
  4452                        
  4453 00:C1F4: C8                 INY                     ; else increment index
  4454                        LAB_21D7
  4455 00:C1F5: B1 23              LDA   (ut1_pl),Y        ; get string length
  4456 00:C1F7: F0 2B              BEQ   LAB_2206          ; if null, step pointer to next string and return
  4457                        
  4458 00:C1F9: C8                 INY                     ; else increment index
  4459 00:C1FA: B1 23              LDA   (ut1_pl),Y        ; get string pointer low byte
  4460 00:C1FC: AA                 TAX                     ; copy to X
  4461 00:C1FD: C8                 INY                     ; increment index
  4462 00:C1FE: B1 23              LDA   (ut1_pl),Y        ; get string pointer high byte
  4463 00:C200: C5 34              CMP   Sstorh            ; compare bottom of string space high byte
  4464 00:C202: 90 06              BCC   LAB_21EC          ; branch if less
  4465 00:C204: D0 1E              BNE   LAB_2206          ; if greater, step pointer to next string and return
  4466                        
  4467                                                      ; high bytes were = so compare low bytes
  Thu Sep 26 2019 15:30                                                                                                    Page 72


  4468 00:C206: E4 33              CPX   Sstorl            ; compare bottom of string space low byte
  4469 00:C208: B0 1A              BCS   LAB_2206          ; if >=, step pointer to next string and return
  4470                        
  4471                                                      ; string pointer is < string storage pointer (pos in mem)
  4472                        LAB_21EC
  4473 00:C20A: C5 5D              CMP   Histrh            ; compare to highest string high byte
  4474 00:C20C: 90 17              BCC   LAB_2207          ; if <, step pointer to next string and return
  4475                        
  4476 00:C20E: D0 04              BNE   LAB_21F6          ; if > update pointers, step to next and return
  4477                        
  4478                                                      ; high bytes were = so compare low bytes
  4479 00:C210: E4 5C              CPX   Histrl            ; compare to highest string low byte
  4480 00:C212: 90 11              BCC   LAB_2207          ; if <, step pointer to next string and return
  4481                        
  4482                                                      ; string is in string memory space
  4483                        LAB_21F6
  4484 00:C214: 86 5C              STX   Histrl            ; save as new highest string low byte
  4485 00:C216: 85 5D              STA   Histrh            ; save as new highest string high byte
  4486 00:C218: A5 23              LDA   ut1_pl            ; get start of vars(descriptors) low byte
  4487 00:C21A: A6 24              LDX   ut1_ph            ; get start of vars(descriptors) high byte
  4488 00:C21C: 85 4E              STA   garb_l            ; save as working pointer low byte
  4489 00:C21E: 86 4F              STX   garb_h            ; save as working pointer high byte
  4490 00:C220: 88                 DEY                     ; decrement index DIFFERS
  4491 00:C221: 88                 DEY                     ; decrement index (should point to descriptor start)
  4492 00:C222: 84 54              STY   g_indx            ; save index pointer
  4493                        
  4494                                                      ; step pointer to next string
  4495                        LAB_2206
  4496 00:C224: 18                 CLC                     ; clear carry for add
  4497                        LAB_2207
  4498 00:C225: A5 52              LDA   g_step            ; get step size
  4499                        LAB_2208
  4500 00:C227: 65 23              ADC   ut1_pl            ; add pointer low byte
  4501 00:C229: 85 23              STA   ut1_pl            ; save pointer low byte
  4502 00:C22B: 90 02              BCC   LAB_2211          ; branch if no overflow
  4503                        
  4504 00:C22D: E6 24              INC   ut1_ph            ; else increment high byte
  4505                        LAB_2211
  4506 00:C22F: A6 24              LDX   ut1_ph            ; get pointer high byte
  4507 00:C231: A0 00              LDY   #$00              ; clear Y
  4508 00:C233: 60                 RTS
  4509                        
  4510                        ; search complete, now either exit or set-up and move string
  4511                        
  4512                        LAB_2216
  4513 00:C234: C6 52              DEC   g_step            ; decrement step size (now $03 for descriptor stack)
  4514 00:C236: A6 4F              LDX   garb_h            ; get string to move high byte
  4515 00:C238: F0 F5              BEQ   LAB_2211          ; exit if nothing to move
  4516                        
  4517 00:C23A: A4 54              LDY   g_indx            ; get index byte back (points to descriptor)
  4518 00:C23C: 18                 CLC                     ; clear carry for add
  4519 00:C23D: B1 4E              LDA   (garb_l),Y        ; get string length
  4520 00:C23F: 65 5C              ADC   Histrl            ; add highest string low byte
  4521 00:C241: 85 58              STA   Obendl            ; save old block end low pointer
  4522 00:C243: A5 5D              LDA   Histrh            ; get highest string high byte
  4523 00:C245: 69 00              ADC   #$00              ; add any carry
  4524 00:C247: 85 59              STA   Obendh            ; save old block end high byte
  4525 00:C249: A5 33              LDA   Sstorl            ; get bottom of string space low byte
  4526 00:C24B: A6 34              LDX   Sstorh            ; get bottom of string space high byte
  4527 00:C24D: 85 56              STA   Nbendl            ; save new block end low byte
  4528 00:C24F: 86 57              STX   Nbendh            ; save new block end high byte
  4529 00:C251: 20 91 B0           JSR   LAB_11D6          ; open up space in memory, don't set array end
  4530 00:C254: A4 54              LDY   g_indx            ; get index byte
  Thu Sep 26 2019 15:30                                                                                                    Page 73


  4531 00:C256: C8                 INY                     ; point to descriptor low byte
  4532 00:C257: A5 56              LDA   Nbendl            ; get string pointer low byte
  4533 00:C259: 91 4E              STA   (garb_l),Y        ; save new string pointer low byte
  4534 00:C25B: AA                 TAX                     ; copy string pointer low byte
  4535 00:C25C: E6 57              INC   Nbendh            ; correct high byte (move sets high byte -1)
  4536 00:C25E: A5 57              LDA   Nbendh            ; get new string pointer high byte
  4537 00:C260: C8                 INY                     ; point to descriptor high byte
  4538 00:C261: 91 4E              STA   (garb_l),Y        ; save new string pointer high byte
  4539 00:C263: 4C 77 C1           JMP   LAB_214B          ; re-run routine from last ending
  4540                                                      ; (but don't collect this string)
  4541                        
  4542                        ; concatenate
  4543                        ; add strings, string 1 is in descriptor des_pl, string 2 is in line
  4544                        
  4545                        LAB_224D
  4546 00:C266: A5 61              LDA   des_ph            ; get descriptor pointer high byte
  4547 00:C268: 48                 PHA                     ; put on stack
  4548 00:C269: A5 60              LDA   des_pl            ; get descriptor pointer low byte
  4549 00:C26B: 48                 PHA                     ; put on stack
  4550 00:C26C: 20 6D BB           JSR   LAB_GVAL          ; get value from line
  4551 00:C26F: 20 75 BA           JSR   LAB_CTST          ; check if source is string, else do type mismatch
  4552 00:C272: 68                 PLA                     ; get descriptor pointer low byte back
  4553 00:C273: 85 6A              STA   ssptr_l           ; set pointer low byte
  4554 00:C275: 68                 PLA                     ; get descriptor pointer high byte back
  4555 00:C276: 85 6B              STA   ssptr_h           ; set pointer high byte
  4556 00:C278: B2 6A              LDA   (ssptr_l)         ; get length_1 from descriptor
  4557 00:C27A: 18                 CLC                     ; clear carry for add
  4558 00:C27B: 72 60              ADC   (des_pl)          ; add length_2
  4559 00:C27D: 90 05              BCC   LAB_226D          ; branch if no overflow
  4560                        
  4561 00:C27F: A2 1A              LDX   #$1A              ; else set error code $1A ("String too long" error)
  4562 00:C281: 4C 07 B1           JMP   LAB_XERR          ; do error #X, then warm start
  4563                        
  4564                        LAB_226D
  4565 00:C284: 20 C5 C0           JSR   LAB_209C          ; copy des_pl/h to des_2l/h and make string space A bytes
  4566                                                      ; long
  4567 00:C287: 20 A1 C2           JSR   LAB_228A          ; copy string from descriptor (sdescr) to (Sutill)
  4568 00:C28A: A5 50              LDA   des_2l            ; get descriptor pointer low byte
  4569 00:C28C: A4 51              LDY   des_2h            ; get descriptor pointer high byte
  4570 00:C28E: 20 D2 C2           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
  4571                                                      ; returns with A = length, ut1_pl = pointer low byte,
  4572                                                      ; ut1_ph = pointer high byte
  4573 00:C291: 20 B3 C2           JSR   LAB_229C          ; store string A bytes long from (ut1_pl) to (Sutill)
  4574 00:C294: A5 6A              LDA   ssptr_l           ; set descriptor pointer low byte
  4575 00:C296: A4 6B              LDY   ssptr_h           ; set descriptor pointer high byte
  4576 00:C298: 20 D2 C2           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
  4577                                                      ; returns with A = length, X=ut1_pl=pointer low byte,
  4578                                                      ; Y=ut1_ph=pointer high byte
  4579 00:C29B: 20 1A C1           JSR   LAB_RTST          ; check for space on descriptor stack then put string
  4580                                                      ; address and length on descriptor stack and update stack
  4581                                                      ; pointers
  4582 00:C29E: 4C 99 BA           JMP   LAB_1ADB          ; continue evaluation
  4583                        
  4584                        ; copy string from descriptor (sdescr) to (Sutill)
  4585                        
  4586                        LAB_228A
  4587 00:C2A1: A0 00              LDY   #$00              ; clear index
  4588 00:C2A3: B1 6A              LDA   (sdescr),Y        ; get string length
  4589 00:C2A5: 48                 PHA                     ; save on stack
  4590 00:C2A6: C8                 INY                     ; increment index
  4591 00:C2A7: B1 6A              LDA   (sdescr),Y        ; get source string pointer low byte
  4592 00:C2A9: AA                 TAX                     ; copy to X
  4593 00:C2AA: C8                 INY                     ; increment index
  Thu Sep 26 2019 15:30                                                                                                    Page 74


  4594 00:C2AB: B1 6A              LDA   (sdescr),Y        ; get source string pointer high byte
  4595 00:C2AD: A8                 TAY                     ; copy to Y
  4596 00:C2AE: 68                 PLA                     ; get length back
  4597                        
  4598                        ; store string A bytes long from YX to (Sutill)
  4599                        
  4600                        LAB_2298
  4601 00:C2AF: 86 23              STX   ut1_pl            ; save source string pointer low byte
  4602 00:C2B1: 84 24              STY   ut1_ph            ; save source string pointer high byte
  4603                        
  4604                        ; store string A bytes long from (ut1_pl) to (Sutill)
  4605                        
  4606                        LAB_229C
  4607 00:C2B3: AA                 TAX                     ; copy length to index (don't count with Y)
  4608 00:C2B4: F0 14              BEQ   LAB_22B2          ; branch if = $0 (null string) no need to add zero length
  4609                        
  4610 00:C2B6: A0 00              LDY   #$00              ; zero pointer (copy forward)
  4611                        LAB_22A0
  4612 00:C2B8: B1 23              LDA   (ut1_pl),Y        ; get source byte
  4613 00:C2BA: 91 35              STA   (Sutill),Y        ; save destination byte
  4614                        
  4615 00:C2BC: C8                 INY                     ; increment index
  4616 00:C2BD: CA                 DEX                     ; decrement counter
  4617 00:C2BE: D0 F8              BNE   LAB_22A0          ; loop while <> 0
  4618                        
  4619 00:C2C0: 98                 TYA                     ; restore length from Y
  4620                        LAB_22A9
  4621 00:C2C1: 18                 CLC                     ; clear carry for add
  4622 00:C2C2: 65 35              ADC   Sutill            ; add string utility ptr low byte
  4623 00:C2C4: 85 35              STA   Sutill            ; save string utility ptr low byte
  4624 00:C2C6: 90 02              BCC   LAB_22B2          ; branch if no carry
  4625                        
  4626 00:C2C8: E6 36              INC   Sutilh            ; else increment string utility ptr high byte
  4627                        LAB_22B2
  4628 00:C2CA: 60                 RTS
  4629                        
  4630                        ; evaluate string
  4631                        
  4632                        LAB_EVST
  4633 00:C2CB: 20 75 BA           JSR   LAB_CTST          ; check if source is string, else do type mismatch
  4634                        
  4635                        ; pop string off descriptor stack, or from top of string space
  4636                        ; returns with A = length, X=pointer low byte, Y=pointer high byte
  4637                        
  4638                        LAB_22B6
  4639 00:C2CE: A5 60              LDA   des_pl            ; get descriptor pointer low byte
  4640 00:C2D0: A4 61              LDY   des_ph            ; get descriptor pointer high byte
  4641                        
  4642                        ; pop (YA) descriptor off stack or from top of string space
  4643                        ; returns with A = length, X=ut1_pl=pointer low byte, Y=ut1_ph=pointer high byte
  4644                        
  4645                        LAB_22BA
  4646 00:C2D2: 85 23              STA   ut1_pl            ; save descriptor pointer low byte
  4647 00:C2D4: 84 24              STY   ut1_ph            ; save descriptor pointer high byte
  4648 00:C2D6: 20 03 C3           JSR   LAB_22EB          ; clean descriptor stack, YA = pointer
  4649 00:C2D9: 08                 PHP                     ; save status flags
  4650 00:C2DA: A0 00              LDY   #$00              ; clear index
  4651 00:C2DC: B1 23              LDA   (ut1_pl),Y        ; get length from string descriptor
  4652 00:C2DE: 48                 PHA                     ; put on stack
  4653 00:C2DF: C8                 INY                     ; increment index
  4654 00:C2E0: B1 23              LDA   (ut1_pl),Y        ; get string pointer low byte from descriptor
  4655 00:C2E2: AA                 TAX                     ; copy to X
  4656 00:C2E3: C8                 INY                     ; increment index
  Thu Sep 26 2019 15:30                                                                                                    Page 75


  4657 00:C2E4: B1 23              LDA   (ut1_pl),Y        ; get string pointer high byte from descriptor
  4658 00:C2E6: A8                 TAY                     ; copy to Y
  4659 00:C2E7: 68                 PLA                     ; get string length back
  4660 00:C2E8: 28                 PLP                     ; restore status
  4661 00:C2E9: D0 13              BNE   LAB_22E6          ; branch if pointer <> last_sl,last_sh
  4662                        
  4663 00:C2EB: C4 34              CPY   Sstorh            ; compare bottom of string space high byte
  4664 00:C2ED: D0 0F              BNE   LAB_22E6          ; branch if <>
  4665                        
  4666 00:C2EF: E4 33              CPX   Sstorl            ; else compare bottom of string space low byte
  4667 00:C2F1: D0 0B              BNE   LAB_22E6          ; branch if <>
  4668                        
  4669 00:C2F3: 48                 PHA                     ; save string length
  4670 00:C2F4: 18                 CLC                     ; clear carry for add
  4671 00:C2F5: 65 33              ADC   Sstorl            ; add bottom of string space low byte
  4672 00:C2F7: 85 33              STA   Sstorl            ; save bottom of string space low byte
  4673 00:C2F9: 90 02              BCC   LAB_22E5          ; skip increment if no overflow
  4674                        
  4675 00:C2FB: E6 34              INC   Sstorh            ; increment bottom of string space high byte
  4676                        LAB_22E5
  4677 00:C2FD: 68                 PLA                     ; restore string length
  4678                        LAB_22E6
  4679 00:C2FE: 86 23              STX   ut1_pl            ; save string pointer low byte
  4680 00:C300: 84 24              STY   ut1_ph            ; save string pointer high byte
  4681 00:C302: 60                 RTS
  4682                        
  4683                        ; clean descriptor stack, YA = pointer
  4684                        ; checks if AY is on the descriptor stack, if so does a stack discard
  4685                        
  4686                        LAB_22EB
  4687 00:C303: C4 19              CPY   last_sh           ; compare pointer high byte
  4688 00:C305: D0 0C              BNE   LAB_22FB          ; exit if <>
  4689                        
  4690 00:C307: C5 18              CMP   last_sl           ; compare pointer low byte
  4691 00:C309: D0 08              BNE   LAB_22FB          ; exit if <>
  4692                        
  4693 00:C30B: 85 17              STA   next_s            ; save descriptor stack pointer
  4694 00:C30D: E9 03              SBC   #$03              ; -3
  4695 00:C30F: 85 18              STA   last_sl           ; save low byte -3
  4696 00:C311: A0 00              LDY   #$00              ; clear high byte
  4697                        LAB_22FB
  4698 00:C313: 60                 RTS
  4699                        
  4700                        ; perform CHR$()
  4701                        
  4702                        LAB_CHRS
  4703 00:C314: 20 18 C4           JSR   LAB_EVBY          ; evaluate byte expression, result in X
  4704 00:C317: DA                 PHX                     ; save character to stack
  4705 00:C318: A9 01              LDA   #$01              ; string is single byte
  4706 00:C31A: 20 CD C0           JSR   LAB_MSSP          ; make string space A bytes long A=$AC=length,
  4707                                                      ; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
  4708 00:C31D: 68                 PLA                     ; get character back
  4709 00:C31E: 92 5F              STA   (str_pl)          ; save byte in string (byte IS string!)
  4710 00:C320: 4C 1A C1           JMP   LAB_RTST          ; check for space on descriptor stack then put string
  4711                                                      ; address and length on descriptor stack and update stack
  4712                                                      ; pointers
  4713                        
  4714                        ; perform LEFT$()
  4715                        
  4716                        LAB_LEFT
  4717 00:C323: 48                 PHA                     ; push byte parameter
  4718 00:C324: 20 83 C3           JSR   LAB_236F          ; pull string data and byte parameter from stack
  4719                                                      ; return pointer in des_2l/h, byte in A (and X), Y=0
  Thu Sep 26 2019 15:30                                                                                                    Page 76


  4720 00:C327: D1 50              CMP   (des_2l),Y        ; compare byte parameter with string length
  4721 00:C329: 98                 TYA                     ; clear A
  4722 00:C32A: 80 09              BRA   LAB_2316          ; go do string copy (branch always)
  4723                        
  4724                        ; perform RIGHT$()
  4725                        
  4726                        LAB_RIGHT
  4727 00:C32C: 48                 PHA                     ; push byte parameter
  4728 00:C32D: 20 83 C3           JSR   LAB_236F          ; pull string data and byte parameter from stack
  4729                                                      ; return pointer in des_2l/h, byte in A (and X), Y=0
  4730 00:C330: 18                 CLC                     ; clear carry for add-1
  4731 00:C331: F1 50              SBC   (des_2l),Y        ; subtract string length
  4732 00:C333: 49 FF              EOR   #$FF              ; invert it (A=LEN(expression$)-l)
  4733                        
  4734                        LAB_2316
  4735 00:C335: 90 04              BCC   LAB_231C          ; branch if string length > byte parameter
  4736                        
  4737 00:C337: B1 50              LDA   (des_2l),Y        ; else make parameter = length
  4738 00:C339: AA                 TAX                     ; copy to byte parameter copy
  4739 00:C33A: 98                 TYA                     ; clear string start offset
  4740                        LAB_231C
  4741 00:C33B: 48                 PHA                     ; save string start offset
  4742                        LAB_231D
  4743 00:C33C: 8A                 TXA                     ; copy byte parameter (or string length if <)
  4744                        LAB_231E
  4745 00:C33D: 48                 PHA                     ; save string length
  4746 00:C33E: 20 CD C0           JSR   LAB_MSSP          ; make string space A bytes long A=$AC=length,
  4747                                                      ; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
  4748 00:C341: A5 50              LDA   des_2l            ; get descriptor pointer low byte
  4749 00:C343: A4 51              LDY   des_2h            ; get descriptor pointer high byte
  4750 00:C345: 20 D2 C2           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
  4751                                                      ; returns with A = length, X=ut1_pl=pointer low byte,
  4752                                                      ; Y=ut1_ph=pointer high byte
  4753 00:C348: 7A                 PLY                     ; get string length back
  4754 00:C349: 68                 PLA                     ; get string start offset back
  4755 00:C34A: 18                 CLC                     ; clear carry for add
  4756 00:C34B: 65 23              ADC   ut1_pl            ; add start offset to string start pointer low byte
  4757 00:C34D: 85 23              STA   ut1_pl            ; save string start pointer low byte
  4758 00:C34F: 90 02              BCC   LAB_2335          ; branch if no overflow
  4759                        
  4760 00:C351: E6 24              INC   ut1_ph            ; else increment string start pointer high byte
  4761                        LAB_2335
  4762 00:C353: 98                 TYA                     ; copy length to A
  4763 00:C354: 20 B3 C2           JSR   LAB_229C          ; store string A bytes long from (ut1_pl) to (Sutill)
  4764 00:C357: 4C 1A C1           JMP   LAB_RTST          ; check for space on descriptor stack then put string
  4765                                                      ; address and length on descriptor stack and update stack
  4766                                                      ; pointers
  4767                        
  4768                        ; perform MID$()
  4769                        
  4770                        LAB_MIDS
  4771 00:C35A: 48                 PHA                     ; push byte parameter
  4772 00:C35B: A9 FF              LDA   #$FF              ; set default length = 255
  4773 00:C35D: 85 61              STA   mids_l            ; save default length
  4774 00:C35F: 20 B4 CF           JSR   LAB_GBYT          ; scan memory
  4775 00:C362: C9 29              CMP   #')'              ; compare with ")"
  4776 00:C364: F0 06              BEQ   LAB_2358          ; branch if = ")" (skip second byte get)
  4777                        
  4778 00:C366: 20 9C BB           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
  4779 00:C369: 20 15 C4           JSR   LAB_GTBY          ; get byte parameter (use copy in mids_l)
  4780                        LAB_2358
  4781 00:C36C: 20 83 C3           JSR   LAB_236F          ; pull string data and byte parameter from stack
  4782                                                      ; return pointer in des_2l/h, byte in A (and X), Y=0
  Thu Sep 26 2019 15:30                                                                                                    Page 77


  4783 00:C36F: CA                 DEX                     ; decrement start index
  4784 00:C370: 8A                 TXA                     ; copy to A
  4785 00:C371: 48                 PHA                     ; save string start offset
  4786 00:C372: 18                 CLC                     ; clear carry for sub-1
  4787 00:C373: A2 00              LDX   #$00              ; clear output string length
  4788 00:C375: F1 50              SBC   (des_2l),Y        ; subtract string length
  4789 00:C377: B0 C3              BCS   LAB_231D          ; if start>string length go do null string
  4790                        
  4791 00:C379: 49 FF              EOR   #$FF              ; complement -length
  4792 00:C37B: C5 61              CMP   mids_l            ; compare byte parameter
  4793 00:C37D: 90 BE              BCC   LAB_231E          ; if length>remaining string go do RIGHT$
  4794                        
  4795 00:C37F: A5 61              LDA   mids_l            ; get length byte
  4796 00:C381: 80 BA              BRA   LAB_231E          ; go do string copy (branch always)
  4797                        
  4798                        ; pull string data and byte parameter from stack
  4799                        ; return pointer in des_2l/h, byte in A (and X), Y=0
  4800                        
  4801                        LAB_236F
  4802 00:C383: 20 8F BB           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
  4803 00:C386: 68                 PLA                     ; pull return address low byte (return address)
  4804 00:C387: 85 54              STA   Fnxjpl            ; save functions jump vector low byte
  4805 00:C389: 68                 PLA                     ; pull return address high byte (return address)
  4806 00:C38A: 85 55              STA   Fnxjph            ; save functions jump vector high byte
  4807 00:C38C: FA                 PLX                     ; get byte parameter
  4808 00:C38D: 68                 PLA                     ; pull string pointer low byte
  4809 00:C38E: 85 50              STA   des_2l            ; save it
  4810 00:C390: 68                 PLA                     ; pull string pointer high byte
  4811 00:C391: 85 51              STA   des_2h            ; save it
  4812 00:C393: A0 00              LDY   #$00              ; clear index
  4813 00:C395: 8A                 TXA                     ; copy byte parameter
  4814 00:C396: F0 77              BEQ   LAB_23A8          ; if null do function call error then warm start
  4815                        
  4816 00:C398: E6 54              INC   Fnxjpl            ; increment function jump vector low byte
  4817                                                      ; (JSR pushes return addr-1. this is all very nice
  4818                                                      ; but will go tits up if either call is on a page
  4819                                                      ; boundary!)
  4820 00:C39A: 6C 54 00           JMP   (Fnxjpl)          ; in effect, RTS
  4821                        
  4822                        ; perform LCASE$()
  4823                        
  4824                        LAB_LCASE
  4825 00:C39D: 20 CB C2           JSR   LAB_EVST          ; evaluate string
  4826 00:C3A0: 85 5E              STA   str_ln            ; set string length
  4827 00:C3A2: A8                 TAY                     ; copy length to Y
  4828 00:C3A3: F0 38              BEQ   NoString          ; branch if null string
  4829                        
  4830 00:C3A5: 20 CD C0           JSR   LAB_MSSP          ; make string space A bytes long A=length,
  4831                                                      ; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
  4832 00:C3A8: 86 5F              STX   str_pl            ; save string pointer low byte
  4833 00:C3AA: 84 60              STY   str_ph            ; save string pointer high byte
  4834 00:C3AC: A8                 TAY                     ; get string length back
  4835                        
  4836                        LC_loop
  4837 00:C3AD: 88                 DEY                     ; decrement index
  4838 00:C3AE: B1 23              LDA   (ut1_pl),Y        ; get byte from string
  4839 00:C3B0: 20 B8 BD           JSR   LAB_1D82          ; is character "A" to "Z"
  4840 00:C3B3: 90 02              BCC   NoUcase           ; branch if not upper case alpha
  4841                        
  4842 00:C3B5: 09 20              ORA   #$20              ; convert upper to lower case
  4843                        NoUcase
  4844 00:C3B7: 91 35              STA   (Sutill),Y        ; save byte back to string
  4845 00:C3B9: 98                 TYA                     ; test index
  Thu Sep 26 2019 15:30                                                                                                    Page 78


  4846 00:C3BA: D0 F1              BNE   LC_loop           ; loop if not all done
  4847 00:C3BC: 80 1F              BRA   NoString          ; tidy up and exit, branch always
  4848                        
  4849                        ; perform UCASE$()
  4850                        
  4851                        LAB_UCASE
  4852 00:C3BE: 20 CB C2           JSR   LAB_EVST          ; evaluate string
  4853 00:C3C1: 85 5E              STA   str_ln            ; set string length
  4854 00:C3C3: A8                 TAY                     ; copy length to Y
  4855 00:C3C4: F0 17              BEQ   NoString          ; branch if null string
  4856                        
  4857 00:C3C6: 20 CD C0           JSR   LAB_MSSP          ; make string space A bytes long A=length,
  4858                                                      ; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
  4859 00:C3C9: 86 5F              STX   str_pl            ; save string pointer low byte
  4860 00:C3CB: 84 60              STY   str_ph            ; save string pointer high byte
  4861 00:C3CD: A8                 TAY                     ; get string length back
  4862                        
  4863                        UC_loop
  4864 00:C3CE: 88                 DEY                     ; decrement index
  4865 00:C3CF: B1 23              LDA   (ut1_pl),Y        ; get byte from string
  4866 00:C3D1: 20 B4 BD           JSR   LAB_CASC          ; is character "a" to "z" (or "A" to "Z")
  4867 00:C3D4: 90 02              BCC   NoLcase           ; branch if not alpha
  4868                        
  4869 00:C3D6: 29 DF              AND   #$DF              ; convert lower to upper case
  4870                        NoLcase
  4871 00:C3D8: 91 35              STA   (Sutill),Y        ; save byte back to string
  4872 00:C3DA: 98                 TYA                     ; test index
  4873 00:C3DB: D0 F1              BNE   UC_loop           ; loop if not all done
  4874                        
  4875                        NoString
  4876 00:C3DD: 4C 1A C1           JMP   LAB_RTST          ; check for space on descriptor stack then put string
  4877                                                      ; address and length on descriptor stack and update stack
  4878                                                      ; pointers
  4879                        
  4880                        ; perform SADD()
  4881                        
  4882                        LAB_SADD
  4883 00:C3E0: 20 AE CF           JSR   LAB_IGBY          ; increment and scan memory
  4884 00:C3E3: 20 42 BD           JSR   LAB_GVAR          ; get var address
  4885                        
  4886 00:C3E6: 20 8F BB           JSR   LAB_1BFB          ; scan for ")", else do syntax error then warm start
  4887 00:C3E9: 20 75 BA           JSR   LAB_CTST          ; check if source is string, else do type mismatch
  4888                        
  4889 00:C3EC: A0 02              LDY   #$02              ; index to string pointer high byte
  4890 00:C3EE: B1 47              LDA   (Cvaral),Y        ; get string pointer high byte
  4891 00:C3F0: AA                 TAX                     ; copy string pointer high byte to X
  4892 00:C3F1: 88                 DEY                     ; index to string pointer low byte
  4893 00:C3F2: B1 47              LDA   (Cvaral),Y        ; get string pointer low byte
  4894 00:C3F4: A8                 TAY                     ; copy string pointer low byte to Y
  4895 00:C3F5: 8A                 TXA                     ; copy string pointer high byte to A
  4896 00:C3F6: 4C EE BF           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
  4897                        
  4898                        ; perform LEN()
  4899                        
  4900                        LAB_LENS
  4901 00:C3F9: 20 FF C3           JSR   LAB_ESGL          ; evaluate string, get length in A (and Y)
  4902 00:C3FC: 4C FB BF           JMP   LAB_1FD0          ; convert Y to byte in FAC1 and return
  4903                        
  4904                        ; evaluate string, get length in Y
  4905                        
  4906                        LAB_ESGL
  4907 00:C3FF: 20 CB C2           JSR   LAB_EVST          ; evaluate string
  4908 00:C402: A8                 TAY                     ; copy length to Y
  Thu Sep 26 2019 15:30                                                                                                    Page 79


  4909 00:C403: 60                 RTS
  4910                        
  4911                        ; perform ASC()
  4912                        
  4913                        LAB_ASC
  4914 00:C404: 20 FF C3           JSR   LAB_ESGL          ; evaluate string, get length in A (and Y)
  4915 00:C407: F0 06              BEQ   LAB_23A8          ; if null do function call error then warm start
  4916                        
  4917 00:C409: B2 23              LDA   (ut1_pl)          ; get byte
  4918 00:C40B: A8                 TAY                     ; copy to Y
  4919 00:C40C: 4C FB BF           JMP   LAB_1FD0          ; convert Y to byte in FAC1 and return
  4920                        
  4921                        ; do function call error then warm start
  4922                        
  4923                        LAB_23A8
  4924 00:C40F: 4C BE BE           JMP   LAB_FCER          ; do function call error then warm start
  4925                        
  4926                        ; scan and get byte parameter
  4927                        
  4928                        LAB_SGBY
  4929 00:C412: 20 AE CF           JSR   LAB_IGBY          ; increment and scan memory
  4930                        
  4931                        ; get byte parameter
  4932                        
  4933                        LAB_GTBY
  4934 00:C415: 20 6F BA           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
  4935                                                      ; else do type mismatch
  4936                        
  4937                        ; evaluate byte expression, result in X
  4938                        
  4939                        LAB_EVBY
  4940 00:C418: 20 38 BE           JSR   LAB_EVPI          ; evaluate integer expression (no check)
  4941                        
  4942 00:C41B: A4 60              LDY   FAC1_2            ; get FAC1 mantissa2
  4943 00:C41D: D0 F0              BNE   LAB_23A8          ; if top byte <> 0 do function call error then warm start
  4944                        
  4945 00:C41F: A6 61              LDX   FAC1_3            ; get FAC1 mantissa3
  4946 00:C421: 4C B4 CF           JMP   LAB_GBYT          ; scan memory and return
  4947                        
  4948                        ; perform VAL()
  4949                        
  4950                        LAB_VAL
  4951 00:C424: 20 FF C3           JSR   LAB_ESGL          ; evaluate string, get length in A (and Y)
  4952 00:C427: D0 03              BNE   LAB_23C5          ; branch if not null string
  4953                        
  4954                                                      ; string was null so set result = $00
  4955 00:C429: 4C D1 C5           JMP   LAB_24F1          ; clear FAC1 exponent and sign and return
  4956                        
  4957                        LAB_23C5
  4958 00:C42C: A6 6E              LDX   Bpntrl            ; get BASIC execute pointer low byte
  4959 00:C42E: A4 6F              LDY   Bpntrh            ; get BASIC execute pointer high byte
  4960 00:C430: 86 6C              STX   Btmpl             ; save BASIC execute pointer low byte
  4961 00:C432: 84 6D              STY   Btmph             ; save BASIC execute pointer high byte
  4962 00:C434: A6 23              LDX   ut1_pl            ; get string pointer low byte
  4963 00:C436: 86 6E              STX   Bpntrl            ; save as BASIC execute pointer low byte
  4964 00:C438: 18                 CLC                     ; clear carry
  4965 00:C439: 65 23              ADC   ut1_pl            ; add string length
  4966 00:C43B: 85 25              STA   ut2_pl            ; save string end low byte
  4967 00:C43D: A5 24              LDA   ut1_ph            ; get string pointer high byte
  4968 00:C43F: 85 6F              STA   Bpntrh            ; save as BASIC execute pointer high byte
  4969 00:C441: 69 00              ADC   #$00              ; add carry to high byte
  4970 00:C443: 85 26              STA   ut2_ph            ; save string end high byte
  4971 00:C445: B2 25              LDA   (ut2_pl)          ; get string end +1 byte
  Thu Sep 26 2019 15:30                                                                                                    Page 80


  4972 00:C447: 48                 PHA                     ; push it
  4973 00:C448: A9 00              LDA   #$00              ; clear A
  4974 00:C44A: 92 25              STA   (ut2_pl)          ; terminate string with $00
  4975 00:C44C: 20 B4 CF           JSR   LAB_GBYT          ; scan memory
  4976 00:C44F: 20 1F C9           JSR   LAB_2887          ; get FAC1 from string
  4977 00:C452: 68                 PLA                     ; restore string end +1 byte
  4978 00:C453: 92 25              STA   (ut2_pl)          ; put string end byte back
  4979                        
  4980                        ; restore BASIC execute pointer from temp (Btmpl/Btmph)
  4981                        
  4982                        LAB_23F3
  4983 00:C455: A6 6C              LDX   Btmpl             ; get BASIC execute pointer low byte back
  4984 00:C457: A4 6D              LDY   Btmph             ; get BASIC execute pointer high byte back
  4985 00:C459: 86 6E              STX   Bpntrl            ; save BASIC execute pointer low byte
  4986 00:C45B: 84 6F              STY   Bpntrh            ; save BASIC execute pointer high byte
  4987 00:C45D: 60                 RTS
  4988                        
  4989                        ; get two parameters for POKE or WAIT
  4990                        
  4991                        LAB_GADB
  4992 00:C45E: 20 6F BA           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
  4993                                                      ; else do type mismatch
  4994 00:C461: 20 77 C4           JSR   LAB_F2FX          ; save integer part of FAC1 in temporary integer
  4995                        
  4996                        ; scan for "," and get byte, else do Syntax error then warm start
  4997                        
  4998                        LAB_SCGB
  4999 00:C464: 20 9C BB           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
  5000 00:C467: A5 0B              LDA   Itemph            ; save temporary integer high byte
  5001 00:C469: 48                 PHA                     ; on stack
  5002 00:C46A: A5 0A              LDA   Itempl            ; save temporary integer low byte
  5003 00:C46C: 48                 PHA                     ; on stack
  5004 00:C46D: 20 15 C4           JSR   LAB_GTBY          ; get byte parameter
  5005 00:C470: 68                 PLA                     ; pull low byte
  5006 00:C471: 85 0A              STA   Itempl            ; restore temporary integer low byte
  5007 00:C473: 68                 PLA                     ; pull high byte
  5008 00:C474: 85 0B              STA   Itemph            ; restore temporary integer high byte
  5009 00:C476: 60                 RTS
  5010                        
  5011                        ; convert float to fixed routine. accepts any value that fits in 24 bits, +ve or
  5012                        ; -ve and converts it into a right truncated integer in Itempl and Itemph
  5013                        
  5014                        ; save unsigned 16 bit integer part of FAC1 in temporary integer
  5015                        
  5016                        LAB_F2FX
  5017 00:C477: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  5018 00:C479: C9 98              CMP   #$98              ; compare with exponent = 2^24
  5019 00:C47B: B0 92              BCS   LAB_23A8          ; if >= do function call error then warm start
  5020                        
  5021                        LAB_F2FU
  5022 00:C47D: 20 C9 C8           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
  5023 00:C480: A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
  5024 00:C482: A4 61              LDY   FAC1_3            ; get FAC1 mantissa3
  5025 00:C484: 84 0A              STY   Itempl            ; save temporary integer low byte
  5026 00:C486: 85 0B              STA   Itemph            ; save temporary integer high byte
  5027 00:C488: 60                 RTS
  5028                        
  5029                        ; perform PEEK()
  5030                        
  5031                        LAB_PEEK
  5032 00:C489: 20 77 C4           JSR   LAB_F2FX          ; save integer part of FAC1 in temporary integer
  5033 00:C48C: A2 00              LDX   #$00              ; clear index
  5034 00:C48E: A1 0A              LDA   (Itempl,X)        ; get byte via temporary integer (addr)
  Thu Sep 26 2019 15:30                                                                                                    Page 81


  5035 00:C490: A8                 TAY                     ; copy byte to Y
  5036 00:C491: 4C FB BF           JMP   LAB_1FD0          ; convert Y to byte in FAC1 and return
  5037                        
  5038                        ; perform POKE
  5039                        
  5040                        LAB_POKE
  5041 00:C494: 20 5E C4           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
  5042 00:C497: 8A                 TXA                     ; copy byte argument to A
  5043 00:C498: A2 00              LDX   #$00              ; clear index
  5044 00:C49A: 81 0A              STA   (Itempl,X)        ; save byte via temporary integer (addr)
  5045 00:C49C: 60                 RTS
  5046                        
  5047                        ; perform DEEK()
  5048                        
  5049                        LAB_DEEK
  5050 00:C49D: 20 77 C4           JSR   LAB_F2FX          ; save integer part of FAC1 in temporary integer
  5051 00:C4A0: A2 00              LDX   #$00              ; clear index
  5052 00:C4A2: A1 0A              LDA   (Itempl,X)        ; PEEK low byte
  5053 00:C4A4: A8                 TAY                     ; copy to Y
  5054 00:C4A5: E6 0A              INC   Itempl            ; increment pointer low byte
  5055 00:C4A7: D0 02              BNE   Deekh             ; skip high increment if no rollover
  5056                        
  5057 00:C4A9: E6 0B              INC   Itemph            ; increment pointer high byte
  5058                        Deekh
  5059 00:C4AB: A1 0A              LDA   (Itempl,X)        ; PEEK high byte
  5060 00:C4AD: 4C EE BF           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
  5061                        
  5062                        ; perform DOKE
  5063                        
  5064                        LAB_DOKE
  5065 00:C4B0: 20 6F BA           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
  5066                                                      ; else do type mismatch
  5067 00:C4B3: 20 77 C4           JSR   LAB_F2FX          ; convert floating-to-fixed
  5068                        
  5069 00:C4B6: 84 49              STY   Frnxtl            ; save pointer low byte (float to fixed returns word in AY)
  5070 00:C4B8: 85 4A              STA   Frnxth            ; save pointer high byte
  5071                        
  5072 00:C4BA: 20 9C BB           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
  5073 00:C4BD: 20 6F BA           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
  5074                                                      ; else do type mismatch
  5075 00:C4C0: 20 77 C4           JSR   LAB_F2FX          ; convert floating-to-fixed
  5076                        
  5077 00:C4C3: 98                 TYA                     ; copy value low byte (float to fixed returns word in AY)
  5078 00:C4C4: A2 00              LDX   #$00              ; clear index
  5079 00:C4C6: 81 49              STA   (Frnxtl,X)        ; POKE low byte
  5080 00:C4C8: E6 49              INC   Frnxtl            ; increment pointer low byte
  5081 00:C4CA: D0 02              BNE   Dokeh             ; skip high increment if no rollover
  5082                        
  5083 00:C4CC: E6 4A              INC   Frnxth            ; increment pointer high byte
  5084                        Dokeh
  5085 00:C4CE: A5 0B              LDA   Itemph            ; get value high byte
  5086 00:C4D0: 81 49              STA   (Frnxtl,X)        ; POKE high byte
  5087 00:C4D2: 4C B4 CF           JMP   LAB_GBYT          ; scan memory and return
  5088                        
  5089                        ; perform SWAP
  5090                        
  5091                        LAB_SWAP
  5092 00:C4D5: 20 42 BD           JSR   LAB_GVAR          ; get var1 address
  5093 00:C4D8: 85 49              STA   Lvarpl            ; save var1 address low byte
  5094 00:C4DA: 84 4A              STY   Lvarph            ; save var1 address high byte
  5095 00:C4DC: A5 11              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
  5096 00:C4DE: 48                 PHA                     ; save data type flag
  5097                        
  Thu Sep 26 2019 15:30                                                                                                    Page 82


  5098 00:C4DF: 20 9C BB           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
  5099 00:C4E2: 20 42 BD           JSR   LAB_GVAR          ; get var2 address (pointer in Cvaral/h)
  5100 00:C4E5: 68                 PLA                     ; pull var1 data type flag
  5101 00:C4E6: 45 11              EOR   Dtypef            ; compare with var2 data type
  5102 00:C4E8: 10 10              BPL   SwapErr           ; exit if not both the same type
  5103                        
  5104 00:C4EA: A0 03              LDY   #$03              ; four bytes to swap (either value or descriptor+1)
  5105                        SwapLp
  5106 00:C4EC: B1 49              LDA   (Lvarpl),Y        ; get byte from var1
  5107 00:C4EE: AA                 TAX                     ; save var1 byte
  5108 00:C4EF: B1 47              LDA   (Cvaral),Y        ; get byte from var2
  5109 00:C4F1: 91 49              STA   (Lvarpl),Y        ; save byte to var1
  5110 00:C4F3: 8A                 TXA                     ; restore var1 byte
  5111 00:C4F4: 91 47              STA   (Cvaral),Y        ; save byte to var2
  5112 00:C4F6: 88                 DEY                     ; decrement index
  5113 00:C4F7: 10 F3              BPL   SwapLp            ; loop until done
  5114 00:C4F9: 60                 RTS
  5115                        
  5116                        SwapErr
  5117 00:C4FA: 4C 7F BA           JMP   LAB_1ABC          ; do "Type mismatch" error then warm start
  5118                        
  5119                        ; perform CALL
  5120                        
  5121                        LAB_CALL
  5122 00:C4FD: 20 6F BA           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
  5123                                                      ; else do type mismatch
  5124 00:C500: 20 77 C4           JSR   LAB_F2FX          ; convert floating-to-fixed
  5125 00:C503: A9 C5              LDA   #>CallExit        ; set return address high byte
  5126 00:C505: 48                 PHA                     ; put on stack
  5127 00:C506: A9 0B              LDA   #<CallExit-1      ; set return address low byte
  5128 00:C508: 48                 PHA                     ; put on stack
  5129 00:C509: 6C 0A 00           JMP   (Itempl)          ; do indirect jump to user routine
  5130                        
  5131                        ; if the called routine exits correctly then it will return to here. this will then get
  5132                        ; the next byte for the interpreter and return
  5133                        
  5134                        CallExit
  5135 00:C50C: 4C B4 CF           JMP   LAB_GBYT          ; scan memory and return
  5136                        
  5137                        ; perform WAIT
  5138                        
  5139                        LAB_WAIT
  5140 00:C50F: 20 5E C4           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
  5141 00:C512: 86 49              STX   Frnxtl            ; save byte
  5142 00:C514: A2 00              LDX   #$00              ; clear mask
  5143 00:C516: 20 B4 CF           JSR   LAB_GBYT          ; scan memory
  5144 00:C519: F0 03              BEQ   LAB_2441          ; skip if no third argument
  5145                        
  5146 00:C51B: 20 64 C4           JSR   LAB_SCGB          ; scan for "," and get byte, else SN error then warm start
  5147                        LAB_2441
  5148 00:C51E: 86 4A              STX   Frnxth            ; save EOR argument
  5149                        LAB_2445
  5150 00:C520: B1 0A              LDA   (Itempl),Y        ; get byte via temporary integer (addr)
  5151 00:C522: 45 4A              EOR   Frnxth            ; EOR with second argument (mask)
  5152 00:C524: 25 49              AND   Frnxtl            ; AND with first argument (byte)
  5153 00:C526: F0 F8              BEQ   LAB_2445          ; loop if result is zero
  5154                        
  5155                        LAB_244D
  5156 00:C528: 60                 RTS
  5157                        
  5158                        ; perform subtraction, FAC1 from (AY)
  5159                        
  5160                        LAB_2455
  Thu Sep 26 2019 15:30                                                                                                    Page 83


  5161 00:C529: 20 0A C7           JSR   LAB_264D          ; unpack memory (AY) into FAC2
  5162                        
  5163                        ; perform subtraction, FAC1 from FAC2
  5164                        
  5165                        LAB_SUBTRACT
  5166 00:C52C: A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
  5167 00:C52E: 49 FF              EOR   #$FF              ; complement it
  5168 00:C530: 85 62              STA   FAC1_s            ; save FAC1 sign (b7)
  5169 00:C532: 45 69              EOR   FAC2_s            ; EOR with FAC2 sign (b7)
  5170 00:C534: 85 6A              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
  5171 00:C536: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  5172 00:C538: 80 0C              BRA   LAB_ADD           ; go add FAC2 to FAC1
  5173                        
  5174                        ; perform addition
  5175                        
  5176                        LAB_2467
  5177 00:C53A: 20 5B C6           JSR   LAB_257B          ; shift FACX A times right (>8 shifts)
  5178 00:C53D: 90 49              BCC   LAB_24A8          ; go subtract mantissas
  5179                        
  5180                        ; add 0.5 to FAC1
  5181                        
  5182                        LAB_244E
  5183 00:C53F: A9 FA              LDA   #<LAB_2A96        ; set 0.5 pointer low byte
  5184 00:C541: A0 D0              LDY   #>LAB_2A96        ; set 0.5 pointer high byte
  5185                        
  5186                        ; add (AY) to FAC1
  5187                        
  5188                        LAB_246C
  5189 00:C543: 20 0A C7           JSR   LAB_264D          ; unpack memory (AY) into FAC2
  5190                        
  5191                        ; add FAC2 to FAC1
  5192                        
  5193                        LAB_ADD
  5194 00:C546: D0 10              BNE   LAB_2474          ; branch if FAC1 was not zero
  5195                        
  5196                        ; copy FAC2 to FAC1
  5197                        
  5198                        LAB_279B
  5199 00:C548: A5 69              LDA   FAC2_s            ; get FAC2 sign (b7)
  5200                        
  5201                        ; save FAC1 sign and copy ABS(FAC2) to FAC1
  5202                        
  5203                        LAB_279D
  5204 00:C54A: 85 62              STA   FAC1_s            ; save FAC1 sign (b7)
  5205 00:C54C: A2 04              LDX   #$04              ; 4 bytes to copy
  5206                        LAB_27A1
  5207 00:C54E: B5 64              LDA   FAC1_o,X          ; get byte from FAC2,X
  5208 00:C550: 95 5D              STA   FAC1_e-1,X        ; save byte at FAC1,X
  5209 00:C552: CA                 DEX                     ; decrement count
  5210 00:C553: D0 F9              BNE   LAB_27A1          ; loop if not all done
  5211                        
  5212 00:C555: 86 6B              STX   FAC1_r            ; clear FAC1 rounding byte
  5213 00:C557: 60                 RTS
  5214                        
  5215                                                      ; FAC1 is non zero
  5216                        LAB_2474
  5217 00:C558: A6 6B              LDX   FAC1_r            ; get FAC1 rounding byte
  5218 00:C55A: 86 55              STX   FAC2_r            ; save as FAC2 rounding byte
  5219 00:C55C: A2 65              LDX   #FAC2_e           ; set index to FAC2 exponent addr
  5220 00:C55E: A5 65              LDA   FAC2_e            ; get FAC2 exponent
  5221                        LAB_247C
  5222 00:C560: A8                 TAY                     ; copy exponent
  5223 00:C561: F0 C5              BEQ   LAB_244D          ; exit if zero
  Thu Sep 26 2019 15:30                                                                                                    Page 84


  5224                        
  5225 00:C563: 38                 SEC                     ; set carry for subtract
  5226 00:C564: E5 5E              SBC   FAC1_e            ; subtract FAC1 exponent
  5227 00:C566: F0 20              BEQ   LAB_24A8          ; branch if = (go add mantissa)
  5228 00:C568: 90 10              BCC   LAB_2498          ; branch if <
  5229                        
  5230                                                      ; FAC2>FAC1
  5231 00:C56A: 84 5E              STY   FAC1_e            ; save FAC1 exponent
  5232 00:C56C: A4 69              LDY   FAC2_s            ; get FAC2 sign (b7)
  5233 00:C56E: 84 62              STY   FAC1_s            ; save FAC1 sign (b7)
  5234 00:C570: 49 FF              EOR   #$FF              ; complement A
  5235 00:C572: 69 00              ADC   #$00              ; +1 (twos complement, carry is set)
  5236 00:C574: 64 55              STZ   FAC2_r            ; clear FAC2 rounding byte
  5237 00:C576: A2 5E              LDX   #FAC1_e           ; set index to FAC1 exponent addr
  5238 00:C578: 80 02              BRA   LAB_249C          ; branch always
  5239                        
  5240                        LAB_2498
  5241 00:C57A: 64 6B              STZ   FAC1_r            ; clear FAC1 rounding byte
  5242                        LAB_249C
  5243 00:C57C: C9 F9              CMP   #$F9              ; compare exponent diff with $F9
  5244 00:C57E: 30 BA              BMI   LAB_2467          ; branch if range $79-$F8
  5245                        
  5246 00:C580: A8                 TAY                     ; copy exponent difference to Y
  5247 00:C581: A5 6B              LDA   FAC1_r            ; get FAC1 rounding byte
  5248 00:C583: 56 01              LSR   PLUS_1,X          ; shift FAC? mantissa1
  5249 00:C585: 20 72 C6           JSR   LAB_2592          ; shift FACX Y times right
  5250                        
  5251                                                      ; exponents are equal now do mantissa subtract
  5252                        LAB_24A8
  5253 00:C588: 24 6A              BIT   FAC_sc            ; test sign compare (FAC1 EOR FAC2)
  5254 00:C58A: 10 4C              BPL   LAB_24F8          ; if = add FAC2 mantissa to FAC1 mantissa and return
  5255                        
  5256 00:C58C: A0 5E              LDY   #FAC1_e           ; set index to FAC1 exponent addr
  5257 00:C58E: E0 65              CPX   #FAC2_e           ; compare X to FAC2 exponent addr
  5258 00:C590: F0 02              BEQ   LAB_24B4          ; branch if =
  5259                        
  5260 00:C592: A0 65              LDY   #FAC2_e           ; else set index to FAC2 exponent addr
  5261                        
  5262                                                      ; subtract smaller from bigger (take sign of bigger)
  5263                        LAB_24B4
  5264 00:C594: 38                 SEC                     ; set carry for subtract
  5265 00:C595: 49 FF              EOR   #$FF              ; ones complement A
  5266 00:C597: 65 55              ADC   FAC2_r            ; add FAC2 rounding byte
  5267 00:C599: 85 6B              STA   FAC1_r            ; save FAC1 rounding byte
  5268 00:C59B: B9 03 00           LDA   PLUS_3,Y          ; get FACY mantissa3
  5269 00:C59E: F5 03              SBC   PLUS_3,X          ; subtract FACX mantissa3
  5270 00:C5A0: 85 61              STA   FAC1_3            ; save FAC1 mantissa3
  5271 00:C5A2: B9 02 00           LDA   PLUS_2,Y          ; get FACY mantissa2
  5272 00:C5A5: F5 02              SBC   PLUS_2,X          ; subtract FACX mantissa2
  5273 00:C5A7: 85 60              STA   FAC1_2            ; save FAC1 mantissa2
  5274 00:C5A9: B9 01 00           LDA   PLUS_1,Y          ; get FACY mantissa1
  5275 00:C5AC: F5 01              SBC   PLUS_1,X          ; subtract FACX mantissa1
  5276 00:C5AE: 85 5F              STA   FAC1_1            ; save FAC1 mantissa1
  5277                        
  5278                        ; do ABS and normalise FAC1
  5279                        
  5280                        LAB_24D0
  5281 00:C5B0: B0 03              BCS   LAB_24D5          ; branch if number is +ve
  5282                        
  5283 00:C5B2: 20 17 C6           JSR   LAB_2537          ; negate FAC1
  5284                        
  5285                        ; normalise FAC1
  5286                        
  Thu Sep 26 2019 15:30                                                                                                    Page 85


  5287                        LAB_24D5
  5288 00:C5B5: A9 00              LDA   #$00              ; clear A
  5289 00:C5B7: A8                 TAY                     ; clear Y
  5290 00:C5B8: 18                 CLC                     ; clear carry for add
  5291                        LAB_24D9
  5292 00:C5B9: A6 5F              LDX   FAC1_1            ; get FAC1 mantissa1
  5293 00:C5BB: D0 3E              BNE   LAB_251B          ; if not zero normalise FAC1
  5294                        
  5295 00:C5BD: A6 60              LDX   FAC1_2            ; get FAC1 mantissa2
  5296 00:C5BF: 86 5F              STX   FAC1_1            ; save FAC1 mantissa1
  5297 00:C5C1: A6 61              LDX   FAC1_3            ; get FAC1 mantissa3
  5298 00:C5C3: 86 60              STX   FAC1_2            ; save FAC1 mantissa2
  5299 00:C5C5: A6 6B              LDX   FAC1_r            ; get FAC1 rounding byte
  5300 00:C5C7: 86 61              STX   FAC1_3            ; save FAC1 mantissa3
  5301 00:C5C9: 84 6B              STY   FAC1_r            ; clear FAC1 rounding byte
  5302 00:C5CB: 69 08              ADC   #$08              ; add x to exponent offset
  5303 00:C5CD: C9 18              CMP   #$18              ; compare with $18 (max offset, all bits would be =0)
  5304 00:C5CF: D0 E8              BNE   LAB_24D9          ; loop if not max
  5305                        
  5306                        ; clear FAC1 exponent and sign
  5307                        
  5308                        LAB_24F1
  5309 00:C5D1: A9 00              LDA   #$00              ; clear A
  5310                        LAB_24F3
  5311 00:C5D3: 85 5E              STA   FAC1_e            ; set FAC1 exponent
  5312                        
  5313                        ; save FAC1 sign
  5314                        
  5315                        LAB_24F5
  5316 00:C5D5: 85 62              STA   FAC1_s            ; save FAC1 sign (b7)
  5317 00:C5D7: 60                 RTS
  5318                        
  5319                        ; add FAC2 mantissa to FAC1 mantissa
  5320                        
  5321                        LAB_24F8
  5322 00:C5D8: 65 55              ADC   FAC2_r            ; add FAC2 rounding byte
  5323 00:C5DA: 85 6B              STA   FAC1_r            ; save FAC1 rounding byte
  5324 00:C5DC: A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
  5325 00:C5DE: 65 68              ADC   FAC2_3            ; add FAC2 mantissa3
  5326 00:C5E0: 85 61              STA   FAC1_3            ; save FAC1 mantissa3
  5327 00:C5E2: A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
  5328 00:C5E4: 65 67              ADC   FAC2_2            ; add FAC2 mantissa2
  5329 00:C5E6: 85 60              STA   FAC1_2            ; save FAC1 mantissa2
  5330 00:C5E8: A5 5F              LDA   FAC1_1            ; get FAC1 mantissa1
  5331 00:C5EA: 65 66              ADC   FAC2_1            ; add FAC2 mantissa1
  5332 00:C5EC: 85 5F              STA   FAC1_1            ; save FAC1 mantissa1
  5333 00:C5EE: B0 1A              BCS   LAB_252A          ; if carry then normalise FAC1 for C=1
  5334 00:C5F0: 60                 RTS                     ; else just exit
  5335                        
  5336                        LAB_2511
  5337 00:C5F1: 69 01              ADC   #$01              ; add 1 to exponent offset
  5338 00:C5F3: 06 6B              ASL   FAC1_r            ; shift FAC1 rounding byte
  5339 00:C5F5: 26 61              ROL   FAC1_3            ; shift FAC1 mantissa3
  5340 00:C5F7: 26 60              ROL   FAC1_2            ; shift FAC1 mantissa2
  5341 00:C5F9: 26 5F              ROL   FAC1_1            ; shift FAC1 mantissa1
  5342                        
  5343                        ; normalise FAC1
  5344                        
  5345                        LAB_251B
  5346 00:C5FB: 10 F4              BPL   LAB_2511          ; loop if not normalised
  5347                        
  5348 00:C5FD: 38                 SEC                     ; set carry for subtract
  5349 00:C5FE: E5 5E              SBC   FAC1_e            ; subtract FAC1 exponent
  Thu Sep 26 2019 15:30                                                                                                    Page 86


  5350 00:C600: B0 CF              BCS   LAB_24F1          ; branch if underflow (set result = $0)
  5351                        
  5352 00:C602: 49 FF              EOR   #$FF              ; complement exponent
  5353 00:C604: 69 01              ADC   #$01              ; +1 (twos complement)
  5354 00:C606: 85 5E              STA   FAC1_e            ; save FAC1 exponent
  5355                        
  5356                        ; test and normalise FAC1 for C=0/1
  5357                        
  5358                        LAB_2528
  5359 00:C608: 90 0C              BCC   LAB_2536          ; exit if no overflow
  5360                        
  5361                        ; normalise FAC1 for C=1
  5362                        
  5363                        LAB_252A
  5364 00:C60A: E6 5E              INC   FAC1_e            ; increment FAC1 exponent
  5365 00:C60C: F0 36              BEQ   LAB_2564          ; if zero do overflow error and warm start
  5366                        
  5367 00:C60E: 66 5F              ROR   FAC1_1            ; shift FAC1 mantissa1
  5368 00:C610: 66 60              ROR   FAC1_2            ; shift FAC1 mantissa2
  5369 00:C612: 66 61              ROR   FAC1_3            ; shift FAC1 mantissa3
  5370 00:C614: 66 6B              ROR   FAC1_r            ; shift FAC1 rounding byte
  5371                        LAB_2536
  5372 00:C616: 60                 RTS
  5373                        
  5374                        ; negate FAC1
  5375                        
  5376                        LAB_2537
  5377 00:C617: A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
  5378 00:C619: 49 FF              EOR   #$FF              ; complement it
  5379 00:C61B: 85 62              STA   FAC1_s            ; save FAC1 sign (b7)
  5380                        
  5381                        ; twos complement FAC1 mantissa
  5382                        
  5383                        LAB_253D
  5384 00:C61D: A5 5F              LDA   FAC1_1            ; get FAC1 mantissa1
  5385 00:C61F: 49 FF              EOR   #$FF              ; complement it
  5386 00:C621: 85 5F              STA   FAC1_1            ; save FAC1 mantissa1
  5387 00:C623: A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
  5388 00:C625: 49 FF              EOR   #$FF              ; complement it
  5389 00:C627: 85 60              STA   FAC1_2            ; save FAC1 mantissa2
  5390 00:C629: A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
  5391 00:C62B: 49 FF              EOR   #$FF              ; complement it
  5392 00:C62D: 85 61              STA   FAC1_3            ; save FAC1 mantissa3
  5393 00:C62F: A5 6B              LDA   FAC1_r            ; get FAC1 rounding byte
  5394 00:C631: 49 FF              EOR   #$FF              ; complement it
  5395 00:C633: 85 6B              STA   FAC1_r            ; save FAC1 rounding byte
  5396 00:C635: E6 6B              INC   FAC1_r            ; increment FAC1 rounding byte
  5397 00:C637: D0 0A              BNE   LAB_2563          ; exit if no overflow
  5398                        
  5399                        ; increment FAC1 mantissa
  5400                        
  5401                        LAB_2559
  5402 00:C639: E6 61              INC   FAC1_3            ; increment FAC1 mantissa3
  5403 00:C63B: D0 06              BNE   LAB_2563          ; finished if no rollover
  5404                        
  5405 00:C63D: E6 60              INC   FAC1_2            ; increment FAC1 mantissa2
  5406 00:C63F: D0 02              BNE   LAB_2563          ; finished if no rollover
  5407                        
  5408 00:C641: E6 5F              INC   FAC1_1            ; increment FAC1 mantissa1
  5409                        LAB_2563
  5410 00:C643: 60                 RTS
  5411                        
  5412                        ; do overflow error (overflow exit)
  Thu Sep 26 2019 15:30                                                                                                    Page 87


  5413                        
  5414                        LAB_2564
  5415 00:C644: A2 0A              LDX   #$0A              ; error code $0A ("Overflow" error)
  5416 00:C646: 4C 07 B1           JMP   LAB_XERR          ; do error #X, then warm start
  5417                        
  5418                        ; shift FCAtemp << A+8 times
  5419                        
  5420                        LAB_2569
  5421 00:C649: A2 26              LDX   #FACt_1-1         ; set offset to FACtemp
  5422                        LAB_256B
  5423 00:C64B: B4 03              LDY   PLUS_3,X          ; get FACX mantissa3
  5424 00:C64D: 84 6B              STY   FAC1_r            ; save as FAC1 rounding byte
  5425 00:C64F: B4 02              LDY   PLUS_2,X          ; get FACX mantissa2
  5426 00:C651: 94 03              STY   PLUS_3,X          ; save FACX mantissa3
  5427 00:C653: B4 01              LDY   PLUS_1,X          ; get FACX mantissa1
  5428 00:C655: 94 02              STY   PLUS_2,X          ; save FACX mantissa2
  5429 00:C657: A4 64              LDY   FAC1_o            ; get FAC1 overflow byte
  5430 00:C659: 94 01              STY   PLUS_1,X          ; save FACX mantissa1
  5431                        
  5432                        ; shift FACX -A times right (> 8 shifts)
  5433                        
  5434                        LAB_257B
  5435 00:C65B: 69 08              ADC   #$08              ; add 8 to shift count
  5436 00:C65D: 30 EC              BMI   LAB_256B          ; go do 8 shift if still -ve
  5437                        
  5438 00:C65F: F0 EA              BEQ   LAB_256B          ; go do 8 shift if zero
  5439                        
  5440 00:C661: E9 08              SBC   #$08              ; else subtract 8 again
  5441 00:C663: A8                 TAY                     ; save count to Y
  5442 00:C664: A5 6B              LDA   FAC1_r            ; get FAC1 rounding byte
  5443 00:C666: B0 12              BCS   LAB_259A          ;
  5444                        
  5445                        LAB_2588
  5446 00:C668: 16 01              ASL   PLUS_1,X          ; shift FACX mantissa1
  5447 00:C66A: 90 02              BCC   LAB_258E          ; branch if +ve
  5448                        
  5449 00:C66C: F6 01              INC   PLUS_1,X          ; this sets b7 eventually
  5450                        LAB_258E
  5451 00:C66E: 76 01              ROR   PLUS_1,X          ; shift FACX mantissa1 (correct for ASL)
  5452 00:C670: 76 01              ROR   PLUS_1,X          ; shift FACX mantissa1 (put carry in b7)
  5453                        
  5454                        ; shift FACX Y times right
  5455                        
  5456                        LAB_2592
  5457 00:C672: 76 02              ROR   PLUS_2,X          ; shift FACX mantissa2
  5458 00:C674: 76 03              ROR   PLUS_3,X          ; shift FACX mantissa3
  5459 00:C676: 6A                 ROR                     ; shift FACX rounding byte
  5460 00:C677: C8                 INY                     ; increment exponent diff
  5461 00:C678: D0 EE              BNE   LAB_2588          ; branch if range adjust not complete
  5462                        
  5463                        LAB_259A
  5464 00:C67A: 18                 CLC                     ; just clear it
  5465 00:C67B: 60                 RTS
  5466                        
  5467                        ; perform LOG()
  5468                        
  5469                        LAB_LOG
  5470 00:C67C: 20 67 C8           JSR   LAB_27CA          ; test sign and zero
  5471 00:C67F: F0 02              BEQ   LAB_25C4          ; if zero do function call error then warm start
  5472                        
  5473 00:C681: 10 03              BPL   LAB_25C7          ; skip error if +ve
  5474                        
  5475                        LAB_25C4
  Thu Sep 26 2019 15:30                                                                                                    Page 88


  5476 00:C683: 4C BE BE           JMP   LAB_FCER          ; do function call error then warm start (-ve)
  5477                        
  5478                        LAB_25C7
  5479 00:C686: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  5480 00:C688: E9 7F              SBC   #$7F              ; normalise it
  5481 00:C68A: 48                 PHA                     ; save it
  5482 00:C68B: A9 80              LDA   #$80              ; set exponent to zero
  5483 00:C68D: 85 5E              STA   FAC1_e            ; save FAC1 exponent
  5484 00:C68F: A9 7A              LDA   #<LAB_25AD        ; set 1/root2 pointer low byte
  5485 00:C691: A0 D0              LDY   #>LAB_25AD        ; set 1/root2 pointer high byte
  5486 00:C693: 20 43 C5           JSR   LAB_246C          ; add (AY) to FAC1 (1/root2)
  5487 00:C696: A9 7E              LDA   #<LAB_25B1        ; set root2 pointer low byte
  5488 00:C698: A0 D0              LDY   #>LAB_25B1        ; set root2 pointer high byte
  5489 00:C69A: 20 80 C7           JSR   LAB_26CA          ; convert AY and do (AY)/FAC1 (root2/(x+(1/root2)))
  5490 00:C69D: A9 F1              LDA   #<LAB_259C        ; set 1 pointer low byte
  5491 00:C69F: A0 D0              LDY   #>LAB_259C        ; set 1 pointer high byte
  5492 00:C6A1: 20 29 C5           JSR   LAB_2455          ; subtract (AY) from FAC1 ((root2/(x+(1/root2)))-1)
  5493 00:C6A4: A9 6D              LDA   #<LAB_25A0        ; set pointer low byte to counter
  5494 00:C6A6: A0 D0              LDY   #>LAB_25A0        ; set pointer high byte to counter
  5495 00:C6A8: 20 C1 CB           JSR   LAB_2B6E          ; ^2 then series evaluation
  5496 00:C6AB: A9 82              LDA   #<LAB_25B5        ; set -0.5 pointer low byte
  5497 00:C6AD: A0 D0              LDY   #>LAB_25B5        ; set -0.5 pointer high byte
  5498 00:C6AF: 20 43 C5           JSR   LAB_246C          ; add (AY) to FAC1
  5499 00:C6B2: 68                 PLA                     ; restore FAC1 exponent
  5500 00:C6B3: 20 BA C9           JSR   LAB_2912          ; evaluate new ASCII digit
  5501 00:C6B6: A9 86              LDA   #<LAB_25B9        ; set LOG(2) pointer low byte
  5502 00:C6B8: A0 D0              LDY   #>LAB_25B9        ; set LOG(2) pointer high byte
  5503                        
  5504                        ; do convert AY, FCA1*(AY)
  5505                        
  5506                        LAB_25FB
  5507 00:C6BA: 20 0A C7           JSR   LAB_264D          ; unpack memory (AY) into FAC2
  5508                        LAB_MULTIPLY
  5509 00:C6BD: F0 4A              BEQ   LAB_264C          ; exit if zero
  5510                        
  5511 00:C6BF: 20 30 C7           JSR   LAB_2673          ; test and adjust accumulators
  5512 00:C6C2: 64 27              STZ   FACt_1            ; clear temp mantissa1
  5513 00:C6C4: 64 28              STZ   FACt_2            ; clear temp mantissa2
  5514 00:C6C6: 64 29              STZ   FACt_3            ; clear temp mantissa3
  5515 00:C6C8: A5 6B              LDA   FAC1_r            ; get FAC1 rounding byte
  5516 00:C6CA: 20 DF C6           JSR   LAB_2622          ; go do shift/add FAC2
  5517 00:C6CD: A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
  5518 00:C6CF: 20 DF C6           JSR   LAB_2622          ; go do shift/add FAC2
  5519 00:C6D2: A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
  5520 00:C6D4: 20 DF C6           JSR   LAB_2622          ; go do shift/add FAC2
  5521 00:C6D7: A5 5F              LDA   FAC1_1            ; get FAC1 mantissa1
  5522 00:C6D9: 20 E4 C6           JSR   LAB_2627          ; go do shift/add FAC2
  5523 00:C6DC: 4C EC C7           JMP   LAB_273C          ; copy temp to FAC1, normalise and return
  5524                        
  5525                        LAB_2622
  5526 00:C6DF: D0 03              BNE   LAB_2627          ; branch if byte <> zero
  5527                        
  5528 00:C6E1: 4C 49 C6           JMP   LAB_2569          ; shift FCAtemp << A+8 times
  5529                        
  5530                                                      ; else do shift and add
  5531                        LAB_2627
  5532 00:C6E4: 4A                 LSR                     ; shift byte
  5533 00:C6E5: 09 80              ORA   #$80              ; set top bit (mark for 8 times)
  5534                        LAB_262A
  5535 00:C6E7: A8                 TAY                     ; copy result
  5536 00:C6E8: 90 13              BCC   LAB_2640          ; skip next if bit was zero
  5537                        
  5538 00:C6EA: 18                 CLC                     ; clear carry for add
  Thu Sep 26 2019 15:30                                                                                                    Page 89


  5539 00:C6EB: A5 29              LDA   FACt_3            ; get temp mantissa3
  5540 00:C6ED: 65 68              ADC   FAC2_3            ; add FAC2 mantissa3
  5541 00:C6EF: 85 29              STA   FACt_3            ; save temp mantissa3
  5542 00:C6F1: A5 28              LDA   FACt_2            ; get temp mantissa2
  5543 00:C6F3: 65 67              ADC   FAC2_2            ; add FAC2 mantissa2
  5544 00:C6F5: 85 28              STA   FACt_2            ; save temp mantissa2
  5545 00:C6F7: A5 27              LDA   FACt_1            ; get temp mantissa1
  5546 00:C6F9: 65 66              ADC   FAC2_1            ; add FAC2 mantissa1
  5547 00:C6FB: 85 27              STA   FACt_1            ; save temp mantissa1
  5548                        LAB_2640
  5549 00:C6FD: 66 27              ROR   FACt_1            ; shift temp mantissa1
  5550 00:C6FF: 66 28              ROR   FACt_2            ; shift temp mantissa2
  5551 00:C701: 66 29              ROR   FACt_3            ; shift temp mantissa3
  5552 00:C703: 66 6B              ROR   FAC1_r            ; shift temp rounding byte
  5553 00:C705: 98                 TYA                     ; get byte back
  5554 00:C706: 4A                 LSR                     ; shift byte
  5555 00:C707: D0 DE              BNE   LAB_262A          ; loop if all bits not done
  5556                        
  5557                        LAB_264C
  5558 00:C709: 60                 RTS
  5559                        
  5560                        ; unpack memory (AY) into FAC2
  5561                        
  5562                        LAB_264D
  5563 00:C70A: 85 23              STA   ut1_pl            ; save pointer low byte
  5564 00:C70C: 84 24              STY   ut1_ph            ; save pointer high byte
  5565 00:C70E: A0 03              LDY   #$03              ; 4 bytes to get (0-3)
  5566 00:C710: B1 23              LDA   (ut1_pl),Y        ; get mantissa3
  5567 00:C712: 85 68              STA   FAC2_3            ; save FAC2 mantissa3
  5568 00:C714: 88                 DEY                     ; decrement index
  5569 00:C715: B1 23              LDA   (ut1_pl),Y        ; get mantissa2
  5570 00:C717: 85 67              STA   FAC2_2            ; save FAC2 mantissa2
  5571 00:C719: 88                 DEY                     ; decrement index
  5572 00:C71A: B1 23              LDA   (ut1_pl),Y        ; get mantissa1+sign
  5573 00:C71C: 85 69              STA   FAC2_s            ; save FAC2 sign (b7)
  5574 00:C71E: 45 62              EOR   FAC1_s            ; EOR with FAC1 sign (b7)
  5575 00:C720: 85 6A              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
  5576 00:C722: A5 69              LDA   FAC2_s            ; recover FAC2 sign (b7)
  5577 00:C724: 09 80              ORA   #$80              ; set 1xxx xxx (set normal bit)
  5578 00:C726: 85 66              STA   FAC2_1            ; save FAC2 mantissa1
  5579 00:C728: 88                 DEY                     ; decrement index
  5580 00:C729: B1 23              LDA   (ut1_pl),Y        ; get exponent byte
  5581 00:C72B: 85 65              STA   FAC2_e            ; save FAC2 exponent
  5582 00:C72D: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  5583 00:C72F: 60                 RTS
  5584                        
  5585                        ; test and adjust accumulators
  5586                        
  5587                        LAB_2673
  5588 00:C730: A5 65              LDA   FAC2_e            ; get FAC2 exponent
  5589                        LAB_2675
  5590 00:C732: F0 1E              BEQ   LAB_2696          ; branch if FAC2 = $00 (handle underflow)
  5591                        
  5592 00:C734: 18                 CLC                     ; clear carry for add
  5593 00:C735: 65 5E              ADC   FAC1_e            ; add FAC1 exponent
  5594 00:C737: 90 05              BCC   LAB_2680          ; branch if sum of exponents <$0100
  5595                        
  5596 00:C739: 30 32              BMI   LAB_269B          ; do overflow error
  5597                        
  5598 00:C73B: 18                 CLC                     ; clear carry for the add
  5599 00:C73C: 80 02              BRA   LAB_2680b         ; branch around next instruction, saves one clock cycle
  5600                        LAB_2680
  5601 00:C73E: 10 12              BPL   LAB_2696          ; if +ve go handle underflow
  Thu Sep 26 2019 15:30                                                                                                    Page 90


  5602                        LAB_2680b
  5603 00:C740: 69 80              ADC   #$80              ; adjust exponent
  5604 00:C742: 85 5E              STA   FAC1_e            ; save FAC1 exponent
  5605 00:C744: D0 03              BNE   LAB_268B          ; branch if not zero
  5606                        
  5607 00:C746: 4C D5 C5           JMP   LAB_24F5          ; save FAC1 sign and return
  5608                        
  5609                        LAB_268B
  5610 00:C749: A5 6A              LDA   FAC_sc            ; get sign compare (FAC1 EOR FAC2)
  5611 00:C74B: 85 62              STA   FAC1_s            ; save FAC1 sign (b7)
  5612                        LAB_268F
  5613 00:C74D: 60                 RTS
  5614                        
  5615                        ; handle overflow and underflow
  5616                        
  5617                        LAB_2690
  5618 00:C74E: A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
  5619 00:C750: 10 1B              BPL   LAB_269B          ; do overflow error
  5620                        
  5621                                                      ; handle underflow
  5622                        LAB_2696
  5623 00:C752: 68                 PLA                     ; pop return address low byte
  5624 00:C753: 68                 PLA                     ; pop return address high byte
  5625 00:C754: 4C D1 C5           JMP   LAB_24F1          ; clear FAC1 exponent and sign and return
  5626                        
  5627                        ; multiply by 10
  5628                        
  5629                        LAB_269E
  5630 00:C757: 20 48 C8           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
  5631 00:C75A: AA                 TAX                     ; copy exponent (set the flags)
  5632 00:C75B: F0 F0              BEQ   LAB_268F          ; exit if zero
  5633                        
  5634 00:C75D: 18                 CLC                     ; clear carry for add
  5635 00:C75E: 69 02              ADC   #$02              ; add two to exponent (*4)
  5636 00:C760: B0 0B              BCS   LAB_269B          ; do overflow error if > $FF
  5637                        
  5638 00:C762: A2 00              LDX   #$00              ; clear byte
  5639 00:C764: 86 6A              STX   FAC_sc            ; clear sign compare (FAC1 EOR FAC2)
  5640 00:C766: 20 60 C5           JSR   LAB_247C          ; add FAC2 to FAC1 (*5)
  5641 00:C769: E6 5E              INC   FAC1_e            ; increment FAC1 exponent (*10)
  5642 00:C76B: D0 E0              BNE   LAB_268F          ; if non zero just do RTS
  5643                        
  5644                        LAB_269B
  5645 00:C76D: 4C 44 C6           JMP   LAB_2564          ; do overflow error and warm start
  5646                        
  5647                        ; divide by 10
  5648                        
  5649                        LAB_26B9
  5650 00:C770: 20 48 C8           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
  5651 00:C773: A9 02              LDA   #<LAB_26B5        ; set pointer to 10d low addr
  5652 00:C775: A0 D1              LDY   #>LAB_26B5        ; set pointer to 10d high addr
  5653 00:C777: A2 00              LDX   #$00              ; clear sign
  5654                        
  5655                        ; divide by (AY) (X=sign)
  5656                        
  5657                        LAB_26C2
  5658 00:C779: 86 6A              STX   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
  5659 00:C77B: 20 FB C7           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
  5660 00:C77E: 80 03              BRA   LAB_DIVIDE        ; do FAC2/FAC1
  5661                        
  5662                                                      ; Perform divide-by
  5663                        ; convert AY and do (AY)/FAC1
  5664                        
  Thu Sep 26 2019 15:30                                                                                                    Page 91


  5665                        LAB_26CA
  5666 00:C780: 20 0A C7           JSR   LAB_264D          ; unpack memory (AY) into FAC2
  5667                        
  5668                                                      ; Perform divide-into
  5669                        LAB_DIVIDE
  5670 00:C783: F0 62              BEQ   LAB_2737          ; if zero go do /0 error
  5671                        
  5672 00:C785: 20 57 C8           JSR   LAB_27BA          ; round FAC1
  5673 00:C788: A9 00              LDA   #$00              ; clear A
  5674 00:C78A: 38                 SEC                     ; set carry for subtract
  5675 00:C78B: E5 5E              SBC   FAC1_e            ; subtract FAC1 exponent (2s complement)
  5676 00:C78D: 85 5E              STA   FAC1_e            ; save FAC1 exponent
  5677 00:C78F: 20 30 C7           JSR   LAB_2673          ; test and adjust accumulators
  5678 00:C792: E6 5E              INC   FAC1_e            ; increment FAC1 exponent
  5679 00:C794: F0 D7              BEQ   LAB_269B          ; if zero do overflow error
  5680                        
  5681 00:C796: A2 FF              LDX   #$FF              ; set index for pre increment
  5682 00:C798: A9 01              LDA   #$01              ; set bit to flag byte save
  5683                        LAB_26E4
  5684 00:C79A: A4 66              LDY   FAC2_1            ; get FAC2 mantissa1
  5685 00:C79C: C4 5F              CPY   FAC1_1            ; compare FAC1 mantissa1
  5686 00:C79E: D0 0A              BNE   LAB_26F4          ; branch if <>
  5687                        
  5688 00:C7A0: A4 67              LDY   FAC2_2            ; get FAC2 mantissa2
  5689 00:C7A2: C4 60              CPY   FAC1_2            ; compare FAC1 mantissa2
  5690 00:C7A4: D0 04              BNE   LAB_26F4          ; branch if <>
  5691                        
  5692 00:C7A6: A4 68              LDY   FAC2_3            ; get FAC2 mantissa3
  5693 00:C7A8: C4 61              CPY   FAC1_3            ; compare FAC1 mantissa3
  5694                        LAB_26F4
  5695 00:C7AA: 08                 PHP                     ; save FAC2-FAC1 compare status
  5696 00:C7AB: 2A                 ROL                     ; shift the result byte
  5697 00:C7AC: 90 0E              BCC   LAB_2702          ; if no carry skip the byte save
  5698                        
  5699 00:C7AE: A0 01              LDY   #$01              ; set bit to flag byte save
  5700 00:C7B0: E8                 INX                     ; else increment the index to FACt
  5701 00:C7B1: E0 02              CPX   #$02              ; compare with the index to FACt_3
  5702 00:C7B3: 30 04              BMI   LAB_2701          ; if not last byte just go save it
  5703                        
  5704 00:C7B5: D0 28              BNE   LAB_272B          ; if all done go save FAC1 rounding byte, normalise and
  5705                                                      ; return
  5706                        
  5707 00:C7B7: A0 40              LDY   #$40              ; set bit to flag byte save for the rounding byte
  5708                        LAB_2701
  5709 00:C7B9: 95 27              STA   FACt_1,X          ; write result byte to FACt_1 + index
  5710 00:C7BB: 98                 TYA                     ; copy the next save byte flag
  5711                        LAB_2702
  5712 00:C7BC: 28                 PLP                     ; restore FAC2-FAC1 compare status
  5713 00:C7BD: 90 14              BCC   LAB_2704          ; if FAC2 < FAC1 then skip the subtract
  5714                        
  5715 00:C7BF: A8                 TAY                     ; save FAC2-FAC1 compare status
  5716 00:C7C0: A5 68              LDA   FAC2_3            ; get FAC2 mantissa3
  5717 00:C7C2: E5 61              SBC   FAC1_3            ; subtract FAC1 mantissa3
  5718 00:C7C4: 85 68              STA   FAC2_3            ; save FAC2 mantissa3
  5719 00:C7C6: A5 67              LDA   FAC2_2            ; get FAC2 mantissa2
  5720 00:C7C8: E5 60              SBC   FAC1_2            ; subtract FAC1 mantissa2
  5721 00:C7CA: 85 67              STA   FAC2_2            ; save FAC2 mantissa2
  5722 00:C7CC: A5 66              LDA   FAC2_1            ; get FAC2 mantissa1
  5723 00:C7CE: E5 5F              SBC   FAC1_1            ; subtract FAC1 mantissa1
  5724 00:C7D0: 85 66              STA   FAC2_1            ; save FAC2 mantissa1
  5725 00:C7D2: 98                 TYA                     ; restore FAC2-FAC1 compare status
  5726                        
  5727                                                      ; FAC2 = FAC2*2
  Thu Sep 26 2019 15:30                                                                                                    Page 92


  5728                        LAB_2704
  5729 00:C7D3: 06 68              ASL   FAC2_3            ; shift FAC2 mantissa3
  5730 00:C7D5: 26 67              ROL   FAC2_2            ; shift FAC2 mantissa2
  5731 00:C7D7: 26 66              ROL   FAC2_1            ; shift FAC2 mantissa1
  5732 00:C7D9: B0 CF              BCS   LAB_26F4          ; loop with no compare
  5733                        
  5734 00:C7DB: 30 BD              BMI   LAB_26E4          ; loop with compare
  5735 00:C7DD: 80 CB              BRA   LAB_26F4          ; loop always with no compare
  5736                        
  5737                        ; do A<<6, save as FAC1 rounding byte, normalise and return
  5738                        
  5739                        LAB_272B
  5740 00:C7DF: 4A                 LSR                     ; shift b1 - b0 ..
  5741 00:C7E0: 6A                 ROR                     ; ..
  5742 00:C7E1: 6A                 ROR                     ; .. to b7 - b6
  5743 00:C7E2: 85 6B              STA   FAC1_r            ; save FAC1 rounding byte
  5744 00:C7E4: 28                 PLP                     ; dump FAC2-FAC1 compare status
  5745 00:C7E5: 80 05              BRA   LAB_273C          ; copy temp to FAC1, normalise and return
  5746                        
  5747                        ; do "Divide by zero" error
  5748                        
  5749                        LAB_2737
  5750 00:C7E7: A2 14              LDX   #$14              ; error code $14 ("Divide by zero" error)
  5751 00:C7E9: 4C 07 B1           JMP   LAB_XERR          ; do error #X, then warm start
  5752                        
  5753                        ; copy temp to FAC1 and normalise
  5754                        
  5755                        LAB_273C
  5756 00:C7EC: A5 27              LDA   FACt_1            ; get temp mantissa1
  5757 00:C7EE: 85 5F              STA   FAC1_1            ; save FAC1 mantissa1
  5758 00:C7F0: A5 28              LDA   FACt_2            ; get temp mantissa2
  5759 00:C7F2: 85 60              STA   FAC1_2            ; save FAC1 mantissa2
  5760 00:C7F4: A5 29              LDA   FACt_3            ; get temp mantissa3
  5761 00:C7F6: 85 61              STA   FAC1_3            ; save FAC1 mantissa3
  5762 00:C7F8: 4C B5 C5           JMP   LAB_24D5          ; normalise FAC1 and return
  5763                        
  5764                        ; unpack memory (AY) into FAC1
  5765                        
  5766                        LAB_UFAC
  5767 00:C7FB: 85 23              STA   ut1_pl            ; save pointer low byte
  5768 00:C7FD: 84 24              STY   ut1_ph            ; save pointer high byte
  5769 00:C7FF: A0 03              LDY   #$03              ; 4 bytes to do
  5770 00:C801: B1 23              LDA   (ut1_pl),Y        ; get last byte
  5771 00:C803: 85 61              STA   FAC1_3            ; save FAC1 mantissa3
  5772 00:C805: 88                 DEY                     ; decrement index
  5773 00:C806: B1 23              LDA   (ut1_pl),Y        ; get last-1 byte
  5774 00:C808: 85 60              STA   FAC1_2            ; save FAC1 mantissa2
  5775 00:C80A: 88                 DEY                     ; decrement index
  5776 00:C80B: B1 23              LDA   (ut1_pl),Y        ; get second byte
  5777 00:C80D: 85 62              STA   FAC1_s            ; save FAC1 sign (b7)
  5778 00:C80F: 09 80              ORA   #$80              ; set 1xxx xxxx (add normal bit)
  5779 00:C811: 85 5F              STA   FAC1_1            ; save FAC1 mantissa1
  5780 00:C813: 88                 DEY                     ; decrement index
  5781 00:C814: B1 23              LDA   (ut1_pl),Y        ; get first byte (exponent)
  5782 00:C816: 85 5E              STA   FAC1_e            ; save FAC1 exponent
  5783 00:C818: 84 6B              STY   FAC1_r            ; clear FAC1 rounding byte
  5784 00:C81A: 60                 RTS
  5785                        
  5786                        ; pack FAC1 into Adatal
  5787                        
  5788                        LAB_276E
  5789 00:C81B: A2 56              LDX   #<Adatal          ; set pointer low byte
  5790                        LAB_2770
  Thu Sep 26 2019 15:30                                                                                                    Page 93


  5791 00:C81D: A0 00              LDY   #>Adatal          ; set pointer high byte
  5792 00:C81F: F0 04              BEQ   LAB_2778          ; pack FAC1 into (XY) and return
  5793                        
  5794                        ; pack FAC1 into (Lvarpl)
  5795                        
  5796                        LAB_PFAC
  5797 00:C821: A6 49              LDX   Lvarpl            ; get destination pointer low byte
  5798 00:C823: A4 4A              LDY   Lvarph            ; get destination pointer high byte
  5799                        
  5800                        ; pack FAC1 into (XY)
  5801                        
  5802                        LAB_2778
  5803 00:C825: 20 57 C8           JSR   LAB_27BA          ; round FAC1
  5804 00:C828: 86 23              STX   ut1_pl            ; save pointer low byte
  5805 00:C82A: 84 24              STY   ut1_ph            ; save pointer high byte
  5806 00:C82C: A0 03              LDY   #$03              ; set index
  5807 00:C82E: A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
  5808 00:C830: 91 23              STA   (ut1_pl),Y        ; store in destination
  5809 00:C832: 88                 DEY                     ; decrement index
  5810 00:C833: A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
  5811 00:C835: 91 23              STA   (ut1_pl),Y        ; store in destination
  5812 00:C837: 88                 DEY                     ; decrement index
  5813 00:C838: A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
  5814 00:C83A: 09 7F              ORA   #$7F              ; set bits x111 1111
  5815 00:C83C: 25 5F              AND   FAC1_1            ; AND in FAC1 mantissa1
  5816 00:C83E: 91 23              STA   (ut1_pl),Y        ; store in destination
  5817 00:C840: 88                 DEY                     ; decrement index
  5818 00:C841: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  5819 00:C843: 91 23              STA   (ut1_pl),Y        ; store in destination
  5820 00:C845: 84 6B              STY   FAC1_r            ; clear FAC1 rounding byte
  5821 00:C847: 60                 RTS
  5822                        
  5823                        ; round and copy FAC1 to FAC2
  5824                        
  5825                        LAB_27AB
  5826 00:C848: 20 57 C8           JSR   LAB_27BA          ; round FAC1
  5827                        
  5828                        ; copy FAC1 to FAC2
  5829                        
  5830                        LAB_27AE
  5831 00:C84B: A2 05              LDX   #$05              ; 5 bytes to copy
  5832                        LAB_27B0
  5833 00:C84D: B5 5D              LDA   FAC1_e-1,X        ; get byte from FAC1,X
  5834 00:C84F: 95 64              STA   FAC1_o,X          ; save byte at FAC2,X
  5835 00:C851: CA                 DEX                     ; decrement count
  5836 00:C852: D0 F9              BNE   LAB_27B0          ; loop if not all done
  5837                        
  5838 00:C854: 86 6B              STX   FAC1_r            ; clear FAC1 rounding byte
  5839                        LAB_27B9
  5840 00:C856: 60                 RTS
  5841                        
  5842                        ; round FAC1
  5843                        
  5844                        LAB_27BA
  5845 00:C857: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  5846 00:C859: F0 FB              BEQ   LAB_27B9          ; exit if zero
  5847                        
  5848 00:C85B: 06 6B              ASL   FAC1_r            ; shift FAC1 rounding byte
  5849 00:C85D: 90 F7              BCC   LAB_27B9          ; exit if no overflow
  5850                        
  5851                        ; round FAC1 (no check)
  5852                        
  5853                        LAB_27C2
  Thu Sep 26 2019 15:30                                                                                                    Page 94


  5854 00:C85F: 20 39 C6           JSR   LAB_2559          ; increment FAC1 mantissa
  5855 00:C862: D0 F2              BNE   LAB_27B9          ; branch if no overflow
  5856                        
  5857 00:C864: 4C 0A C6           JMP   LAB_252A          ; normalise FAC1 for C=1 and return
  5858                        
  5859                        ; get FAC1 sign
  5860                        ; return A=FF,C=1/-ve A=01,C=0/+ve
  5861                        
  5862                        LAB_27CA
  5863 00:C867: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  5864 00:C869: F0 09              BEQ   LAB_27D7          ; exit if zero (already correct SGN(0)=0)
  5865                        
  5866                        ; return A=FF,C=1/-ve A=01,C=0/+ve
  5867                        ; no = 0 check
  5868                        
  5869                        LAB_27CE
  5870 00:C86B: A5 62              LDA   FAC1_s            ; else get FAC1 sign (b7)
  5871                        
  5872                        ; return A=FF,C=1/-ve A=01,C=0/+ve
  5873                        ; no = 0 check, sign in A
  5874                        
  5875                        LAB_27D0
  5876 00:C86D: 2A                 ROL                     ; move sign bit to carry
  5877 00:C86E: A9 FF              LDA   #$FF              ; set byte for -ve result
  5878 00:C870: B0 02              BCS   LAB_27D7          ; return if sign was set (-ve)
  5879                        
  5880 00:C872: A9 01              LDA   #$01              ; else set byte for +ve result
  5881                        LAB_27D7
  5882 00:C874: 60                 RTS
  5883                        
  5884                        ; perform SGN()
  5885                        
  5886                        LAB_SGN
  5887 00:C875: 20 67 C8           JSR   LAB_27CA          ; get FAC1 sign
  5888                                                      ; return A=$FF/-ve A=$01/+ve
  5889                        ; save A as integer byte
  5890                        
  5891                        LAB_27DB
  5892 00:C878: 85 5F              STA   FAC1_1            ; save FAC1 mantissa1
  5893 00:C87A: 64 60              STZ   FAC1_2            ; clear FAC1 mantissa2
  5894 00:C87C: A2 88              LDX   #$88              ; set exponent
  5895                        
  5896                        ; set exp=X, clearFAC1 mantissa3 and normalise
  5897                        
  5898                        LAB_27E3
  5899 00:C87E: A5 5F              LDA   FAC1_1            ; get FAC1 mantissa1
  5900 00:C880: 49 FF              EOR   #$FF              ; complement it
  5901 00:C882: 2A                 ROL                     ; sign bit into carry
  5902                        
  5903                        ; set exp=X, clearFAC1 mantissa3 and normalise
  5904                        
  5905                        LAB_STFA
  5906 00:C883: 64 61              STZ   FAC1_3            ; clear FAC1 mantissa3
  5907 00:C885: 86 5E              STX   FAC1_e            ; set FAC1 exponent
  5908 00:C887: 64 6B              STZ   FAC1_r            ; clear FAC1 rounding byte
  5909 00:C889: 64 62              STZ   FAC1_s            ; clear FAC1 sign (b7)
  5910 00:C88B: 4C B0 C5           JMP   LAB_24D0          ; do ABS and normalise FAC1
  5911                        
  5912                        ; perform ABS()
  5913                        
  5914                        LAB_ABS
  5915 00:C88E: 46 62              LSR   FAC1_s            ; clear FAC1 sign (put zero in b7)
  5916 00:C890: 60                 RTS
  Thu Sep 26 2019 15:30                                                                                                    Page 95


  5917                        
  5918                        ; compare FAC1 with (AY)
  5919                        ; returns A=$00 if FAC1 = (AY)
  5920                        ; returns A=$01 if FAC1 > (AY)
  5921                        ; returns A=$FF if FAC1 < (AY)
  5922                        
  5923                        LAB_27F8
  5924 00:C891: 85 25              STA   ut2_pl            ; save pointer low byte
  5925                        LAB_27FA
  5926 00:C893: 84 26              STY   ut2_ph            ; save pointer high byte
  5927 00:C895: A0 00              LDY   #$00              ; clear index
  5928 00:C897: B1 25              LDA   (ut2_pl),Y        ; get exponent
  5929 00:C899: C8                 INY                     ; increment index
  5930 00:C89A: AA                 TAX                     ; copy (AY) exponent to X
  5931 00:C89B: F0 CA              BEQ   LAB_27CA          ; branch if (AY) exponent=0 and get FAC1 sign
  5932                                                      ; A=FF,C=1/-ve A=01,C=0/+ve
  5933                        
  5934 00:C89D: B1 25              LDA   (ut2_pl),Y        ; get (AY) mantissa1 (with sign)
  5935 00:C89F: 45 62              EOR   FAC1_s            ; EOR FAC1 sign (b7)
  5936 00:C8A1: 30 C8              BMI   LAB_27CE          ; if signs <> do return A=FF,C=1/-ve
  5937                                                      ; A=01,C=0/+ve and return
  5938                        
  5939 00:C8A3: E4 5E              CPX   FAC1_e            ; compare (AY) exponent with FAC1 exponent
  5940 00:C8A5: D0 1A              BNE   LAB_2828          ; branch if different
  5941                        
  5942 00:C8A7: B1 25              LDA   (ut2_pl),Y        ; get (AY) mantissa1 (with sign)
  5943 00:C8A9: 09 80              ORA   #$80              ; normalise top bit
  5944 00:C8AB: C5 5F              CMP   FAC1_1            ; compare with FAC1 mantissa1
  5945 00:C8AD: D0 12              BNE   LAB_2828          ; branch if different
  5946                        
  5947 00:C8AF: C8                 INY                     ; increment index
  5948 00:C8B0: B1 25              LDA   (ut2_pl),Y        ; get mantissa2
  5949 00:C8B2: C5 60              CMP   FAC1_2            ; compare with FAC1 mantissa2
  5950 00:C8B4: D0 0B              BNE   LAB_2828          ; branch if different
  5951                        
  5952 00:C8B6: C8                 INY                     ; increment index
  5953 00:C8B7: A9 7F              LDA   #$7F              ; set for 1/2 value rounding byte
  5954 00:C8B9: C5 6B              CMP   FAC1_r            ; compare with FAC1 rounding byte (set carry)
  5955 00:C8BB: B1 25              LDA   (ut2_pl),Y        ; get mantissa3
  5956 00:C8BD: E5 61              SBC   FAC1_3            ; subtract FAC1 mantissa3
  5957 00:C8BF: F0 27              BEQ   LAB_2850          ; exit if mantissa3 equal
  5958                        
  5959                        ; gets here if number <> FAC1
  5960                        
  5961                        LAB_2828
  5962 00:C8C1: A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
  5963 00:C8C3: 90 02              BCC   LAB_282E          ; branch if FAC1 > (AY)
  5964                        
  5965 00:C8C5: 49 FF              EOR   #$FF              ; else toggle FAC1 sign
  5966                        LAB_282E
  5967 00:C8C7: 80 A4              BRA   LAB_27D0          ; return A=FF,C=1/-ve A=01,C=0/+ve
  5968                        
  5969                        ; convert FAC1 floating-to-fixed
  5970                        
  5971                        LAB_2831
  5972 00:C8C9: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  5973 00:C8CB: F0 4A              BEQ   LAB_287F          ; if zero go clear FAC1 and return
  5974                        
  5975 00:C8CD: 38                 SEC                     ; set carry for subtract
  5976 00:C8CE: E9 98              SBC   #$98              ; subtract maximum integer range exponent
  5977 00:C8D0: 24 62              BIT   FAC1_s            ; test FAC1 sign (b7)
  5978 00:C8D2: 10 09              BPL   LAB_2845          ; branch if FAC1 +ve
  5979                        
  Thu Sep 26 2019 15:30                                                                                                    Page 96


  5980                                                      ; FAC1 was -ve
  5981 00:C8D4: AA                 TAX                     ; copy subtracted exponent
  5982 00:C8D5: A9 FF              LDA   #$FF              ; overflow for -ve number
  5983 00:C8D7: 85 64              STA   FAC1_o            ; set FAC1 overflow byte
  5984 00:C8D9: 20 1D C6           JSR   LAB_253D          ; twos complement FAC1 mantissa
  5985 00:C8DC: 8A                 TXA                     ; restore subtracted exponent
  5986                        LAB_2845
  5987 00:C8DD: A2 5E              LDX   #FAC1_e           ; set index to FAC1
  5988 00:C8DF: C9 F9              CMP   #$F9              ; compare exponent result
  5989 00:C8E1: 10 06              BPL   LAB_2851          ; if < 8 shifts shift FAC1 A times right and return
  5990                        
  5991 00:C8E3: 20 5B C6           JSR   LAB_257B          ; shift FAC1 A times right (> 8 shifts)
  5992 00:C8E6: 84 64              STY   FAC1_o            ; clear FAC1 overflow byte
  5993                        LAB_2850
  5994 00:C8E8: 60                 RTS
  5995                        
  5996                        ; shift FAC1 A times right
  5997                        
  5998                        LAB_2851
  5999 00:C8E9: A8                 TAY                     ; copy shift count
  6000 00:C8EA: A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
  6001 00:C8EC: 29 80              AND   #$80              ; mask sign bit only (x000 0000)
  6002 00:C8EE: 46 5F              LSR   FAC1_1            ; shift FAC1 mantissa1
  6003 00:C8F0: 05 5F              ORA   FAC1_1            ; OR sign in b7 FAC1 mantissa1
  6004 00:C8F2: 85 5F              STA   FAC1_1            ; save FAC1 mantissa1
  6005 00:C8F4: 20 72 C6           JSR   LAB_2592          ; shift FAC1 Y times right
  6006 00:C8F7: 84 64              STY   FAC1_o            ; clear FAC1 overflow byte
  6007 00:C8F9: 60                 RTS
  6008                        
  6009                        ; perform INT()
  6010                        
  6011                        LAB_INT
  6012 00:C8FA: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  6013 00:C8FC: C9 98              CMP   #$98              ; compare with max int
  6014 00:C8FE: B0 1E              BCS   LAB_2886          ; exit if >= (already int, too big for fractional part!)
  6015                        
  6016 00:C900: 20 C9 C8           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
  6017 00:C903: 84 6B              STY   FAC1_r            ; save FAC1 rounding byte
  6018 00:C905: A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
  6019 00:C907: 84 62              STY   FAC1_s            ; save FAC1 sign (b7)
  6020 00:C909: 49 80              EOR   #$80              ; toggle FAC1 sign
  6021 00:C90B: 2A                 ROL                     ; shift into carry
  6022 00:C90C: A9 98              LDA   #$98              ; set new exponent
  6023 00:C90E: 85 5E              STA   FAC1_e            ; save FAC1 exponent
  6024 00:C910: A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
  6025 00:C912: 85 0D              STA   Temp3             ; save for EXP() function
  6026 00:C914: 4C B0 C5           JMP   LAB_24D0          ; do ABS and normalise FAC1
  6027                        
  6028                        ; clear FAC1 and return
  6029                        
  6030                        LAB_287F
  6031 00:C917: 85 5F              STA   FAC1_1            ; clear FAC1 mantissa1
  6032 00:C919: 85 60              STA   FAC1_2            ; clear FAC1 mantissa2
  6033 00:C91B: 85 61              STA   FAC1_3            ; clear FAC1 mantissa3
  6034 00:C91D: A8                 TAY                     ; clear Y
  6035                        LAB_2886
  6036 00:C91E: 60                 RTS
  6037                        
  6038                        ; get FAC1 from string
  6039                        ; this routine now handles hex and binary values from strings
  6040                        ; starting with "$" and "%" respectively
  6041                        
  6042                        LAB_2887
  Thu Sep 26 2019 15:30                                                                                                    Page 97


  6043 00:C91F: 64 11              STZ   Dtypef            ; clear data type flag, $FF=string, $00=numeric
  6044 00:C921: A2 09              LDX   #$09              ; set index
  6045                        LAB_288B
  6046 00:C923: 74 5A              STZ   numexp,X          ; clear byte
  6047 00:C925: CA                 DEX                     ; decrement index
  6048 00:C926: 10 FB              BPL   LAB_288B          ; loop until numexp to negnum (and FAC1) = $00
  6049 00:C928: 90 7E              BCC   LAB_28FE          ; branch if 1st character numeric
  6050                        
  6051                        ; get FAC1 from string .. first character wasn't numeric
  6052                        
  6053 00:C92A: C9 2D              CMP   #'-'              ; else compare with "-"
  6054 00:C92C: D0 04              BNE   LAB_289A          ; branch if not "-"
  6055                        
  6056 00:C92E: 86 63              STX   negnum            ; set flag for -ve number (X = $FF)
  6057 00:C930: 80 04              BRA   LAB_289C          ; branch always (go scan and check for hex/bin)
  6058                        
  6059                        ; get FAC1 from string .. first character wasn't numeric or -
  6060                        
  6061                        LAB_289A
  6062 00:C932: C9 2B              CMP   #'+'              ; else compare with "+"
  6063 00:C934: D0 05              BNE   LAB_289D          ; branch if not "+" (go check for hex/bin)
  6064                        
  6065                        ; was "+" or "-" to start, so get next character
  6066                        
  6067                        LAB_289C
  6068 00:C936: 20 AE CF           JSR   LAB_IGBY          ; increment and scan memory
  6069 00:C939: 90 6D              BCC   LAB_28FE          ; branch if numeric character
  6070                        
  6071                        ; code here for hex and binary numbers
  6072                        
  6073                        LAB_289D
  6074 00:C93B: C9 24              CMP   #'$'              ; else compare with "$"
  6075 00:C93D: D0 03              BNE   LAB_NHEX          ; branch if not "$"
  6076                        
  6077 00:C93F: 4C D9 CD           JMP   LAB_CHEX          ; branch if "$"
  6078                        
  6079                        LAB_NHEX
  6080 00:C942: C9 25              CMP   #'%'              ; else compare with "%"
  6081 00:C944: D0 08              BNE   LAB_28A3          ; branch if not "%" (continue original code)
  6082                        
  6083 00:C946: 4C 07 CE           JMP   LAB_CBIN          ; branch if "%"
  6084                        
  6085                        LAB_289E
  6086 00:C949: 20 AE CF           JSR   LAB_IGBY          ; increment and scan memory (ignore + or get next number)
  6087                        LAB_28A1
  6088 00:C94C: 90 5A              BCC   LAB_28FE          ; branch if numeric character
  6089                        
  6090                        ; get FAC1 from string .. character wasn't numeric, -, +, hex or binary
  6091                        
  6092                        LAB_28A3
  6093 00:C94E: C9 2E              CMP   #'.'              ; else compare with "."
  6094 00:C950: F0 2D              BEQ   LAB_28D5          ; branch if "."
  6095                        
  6096                        ; get FAC1 from string .. character wasn't numeric, -, + or .
  6097                        
  6098 00:C952: C9 45              CMP   #'E'              ; else compare with "E"
  6099 00:C954: D0 2F              BNE   LAB_28DB          ; branch if not "E"
  6100                        
  6101                                                      ; was "E" so evaluate exponential part
  6102 00:C956: 20 AE CF           JSR   LAB_IGBY          ; increment and scan memory
  6103 00:C959: 90 17              BCC   LAB_28C7          ; branch if numeric character
  6104                        
  6105 00:C95B: C9 B3              CMP   #TK_MINUS         ; else compare with token for -
  Thu Sep 26 2019 15:30                                                                                                    Page 98


  6106 00:C95D: F0 0E              BEQ   LAB_28C2          ; branch if token for -
  6107                        
  6108 00:C95F: C9 2D              CMP   #'-'              ; else compare with "-"
  6109 00:C961: F0 0A              BEQ   LAB_28C2          ; branch if "-"
  6110                        
  6111 00:C963: C9 B2              CMP   #TK_PLUS          ; else compare with token for +
  6112 00:C965: F0 08              BEQ   LAB_28C4          ; branch if token for +
  6113                        
  6114 00:C967: C9 2B              CMP   #'+'              ; else compare with "+"
  6115 00:C969: F0 04              BEQ   LAB_28C4          ; branch if "+"
  6116 00:C96B: 80 07              BRA   LAB_28C9          ; branch always
  6117                        
  6118                        LAB_28C2
  6119 00:C96D: 66 5D              ROR   expneg            ; set exponent -ve flag (C, which=1, into b7)
  6120                        LAB_28C4
  6121 00:C96F: 20 AE CF           JSR   LAB_IGBY          ; increment and scan memory
  6122                        LAB_28C7
  6123 00:C972: 90 59              BCC   LAB_2925          ; branch if numeric character
  6124                        
  6125                        LAB_28C9
  6126 00:C974: 24 5D              BIT   expneg            ; test exponent -ve flag
  6127 00:C976: 10 0D              BPL   LAB_28DB          ; if +ve go evaluate exponent
  6128                        
  6129                                                      ; else do exponent = -exponent
  6130 00:C978: A9 00              LDA   #$00              ; clear result
  6131 00:C97A: 38                 SEC                     ; set carry for subtract
  6132 00:C97B: E5 5B              SBC   expcnt            ; subtract exponent byte
  6133 00:C97D: 80 08              BRA   LAB_28DD          ; go evaluate exponent
  6134                        
  6135                        LAB_28D5
  6136 00:C97F: 66 5C              ROR   numdpf            ; set decimal point flag
  6137 00:C981: 24 5C              BIT   numdpf            ; test decimal point flag
  6138 00:C983: 50 C4              BVC   LAB_289E          ; branch if only one decimal point so far
  6139                        
  6140                                                      ; evaluate exponent
  6141                        LAB_28DB
  6142 00:C985: A5 5B              LDA   expcnt            ; get exponent count byte
  6143                        LAB_28DD
  6144 00:C987: 38                 SEC                     ; set carry for subtract
  6145 00:C988: E5 5A              SBC   numexp            ; subtract numerator exponent
  6146 00:C98A: 85 5B              STA   expcnt            ; save exponent count byte
  6147 00:C98C: F0 12              BEQ   LAB_28F6          ; branch if no adjustment
  6148 00:C98E: 10 09              BPL   LAB_28EF          ; else if +ve go do FAC1*10^expcnt
  6149                        
  6150                                                      ; else go do FAC1/10^(0-expcnt)
  6151                        LAB_28E6
  6152 00:C990: 20 70 C7           JSR   LAB_26B9          ; divide by 10
  6153 00:C993: E6 5B              INC   expcnt            ; increment exponent count byte
  6154 00:C995: D0 F9              BNE   LAB_28E6          ; loop until all done
  6155 00:C997: 80 07              BRA   LAB_28F6          ; branch always
  6156                        
  6157                        LAB_28EF
  6158 00:C999: 20 57 C7           JSR   LAB_269E          ; multiply by 10
  6159 00:C99C: C6 5B              DEC   expcnt            ; decrement exponent count byte
  6160 00:C99E: D0 F9              BNE   LAB_28EF          ; loop until all done
  6161                        
  6162                        LAB_28F6
  6163 00:C9A0: A5 63              LDA   negnum            ; get -ve flag
  6164 00:C9A2: 30 01              BMI   LAB_28FB          ; if -ve do - FAC1 and return
  6165 00:C9A4: 60                 RTS
  6166                        
  6167                        ; do - FAC1 and return
  6168                        
  Thu Sep 26 2019 15:30                                                                                                    Page 99


  6169                        LAB_28FB
  6170 00:C9A5: 4C 66 CB           JMP   LAB_GTHAN         ; do - FAC1 and return
  6171                        
  6172                        ; do unsigned FAC1*10+number
  6173                        
  6174                        LAB_28FE
  6175 00:C9A8: 48                 PHA                     ; save character
  6176 00:C9A9: 24 5C              BIT   numdpf            ; test decimal point flag
  6177 00:C9AB: 10 02              BPL   LAB_2905          ; skip exponent increment if not set
  6178                        
  6179 00:C9AD: E6 5A              INC   numexp            ; else increment number exponent
  6180                        LAB_2905
  6181 00:C9AF: 20 57 C7           JSR   LAB_269E          ; multiply FAC1 by 10
  6182 00:C9B2: 68                 PLA                     ; restore character
  6183 00:C9B3: 29 0F              AND   #$0F              ; convert to binary
  6184 00:C9B5: 20 BA C9           JSR   LAB_2912          ; evaluate new ASCII digit
  6185 00:C9B8: 80 8F              BRA   LAB_289E          ; go do next character
  6186                        
  6187                        ; evaluate new ASCII digit
  6188                        
  6189                        LAB_2912
  6190 00:C9BA: 48                 PHA                     ; save digit
  6191 00:C9BB: 20 48 C8           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
  6192 00:C9BE: 68                 PLA                     ; restore digit
  6193 00:C9BF: 20 78 C8           JSR   LAB_27DB          ; save A as integer byte
  6194 00:C9C2: A5 69              LDA   FAC2_s            ; get FAC2 sign (b7)
  6195 00:C9C4: 45 62              EOR   FAC1_s            ; toggle with FAC1 sign (b7)
  6196 00:C9C6: 85 6A              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
  6197 00:C9C8: A6 5E              LDX   FAC1_e            ; get FAC1 exponent
  6198 00:C9CA: 4C 46 C5           JMP   LAB_ADD           ; add FAC2 to FAC1 and return
  6199                        
  6200                        ; evaluate next character of exponential part of number
  6201                        
  6202                        LAB_2925
  6203 00:C9CD: A5 5B              LDA   expcnt            ; get exponent count byte
  6204 00:C9CF: C9 0A              CMP   #$0A              ; compare with 10 decimal
  6205 00:C9D1: 90 09              BCC   LAB_2934          ; branch if less
  6206                        
  6207 00:C9D3: A9 64              LDA   #$64              ; make all -ve exponents = -100 decimal (causes underflow)
  6208 00:C9D5: 24 5D              BIT   expneg            ; test exponent -ve flag
  6209 00:C9D7: 30 0C              BMI   LAB_2942          ; branch if -ve
  6210                        
  6211 00:C9D9: 4C 44 C6           JMP   LAB_2564          ; else do overflow error
  6212                        
  6213                        LAB_2934
  6214 00:C9DC: 0A                 ASL                     ; * 2
  6215 00:C9DD: 0A                 ASL                     ; * 4
  6216 00:C9DE: 65 5B              ADC   expcnt            ; * 5
  6217 00:C9E0: 0A                 ASL                     ; * 10
  6218 00:C9E1: 72 6E              ADC   (Bpntrl)          ; add character (will be $30 too much!)
  6219 00:C9E3: E9 2F              SBC   #'0'-1            ; convert character to binary
  6220                        LAB_2942
  6221 00:C9E5: 85 5B              STA   expcnt            ; save exponent count byte
  6222 00:C9E7: 80 86              BRA   LAB_28C4          ; go get next character
  6223                        
  6224                        ; print " in line [LINE #]"
  6225                        
  6226                        LAB_2953
  6227 00:C9E9: A9 C8              LDA   #<LAB_LMSG        ; point to " in line " message low byte
  6228 00:C9EB: A0 D6              LDY   #>LAB_LMSG        ; point to " in line " message high byte
  6229 00:C9ED: 20 78 B8           JSR   LAB_18C3          ; print null terminated string from memory
  6230                        
  6231                                                      ; print Basic line #
  Thu Sep 26 2019 15:30                                                                                                    Page 100


  6232 00:C9F0: A5 3A              LDA   Clineh            ; get current line high byte
  6233 00:C9F2: A6 39              LDX   Clinel            ; get current line low byte
  6234                        
  6235                        ; print XA as unsigned integer
  6236                        
  6237                        LAB_295E
  6238 00:C9F4: 85 5F              STA   FAC1_1            ; save low byte as FAC1 mantissa1
  6239 00:C9F6: 86 60              STX   FAC1_2            ; save high byte as FAC1 mantissa2
  6240 00:C9F8: A2 90              LDX   #$90              ; set exponent to 16d bits
  6241 00:C9FA: 38                 SEC                     ; set integer is +ve flag
  6242 00:C9FB: 20 83 C8           JSR   LAB_STFA          ; set exp=X, clearFAC1 mantissa3 and normalise
  6243 00:C9FE: A0 00              LDY   #$00              ; clear index
  6244 00:CA00: 98                 TYA                     ; clear A
  6245 00:CA01: 20 14 CA           JSR   LAB_297B          ; convert FAC1 to string, skip sign character save
  6246 00:CA04: 4C 78 B8           JMP   LAB_18C3          ; print null terminated string from memory and return
  6247                        
  6248                        ; convert FAC1 to ASCII string result in (AY)
  6249                        ; not any more, moved scratchpad to page 0
  6250                        
  6251                        LAB_296E
  6252 00:CA07: A0 01              LDY   #$01              ; set index = 1
  6253 00:CA09: A9 20              LDA   #$20              ; character = " " (assume +ve)
  6254 00:CA0B: 24 62              BIT   FAC1_s            ; test FAC1 sign (b7)
  6255 00:CA0D: 10 02              BPL   LAB_2978          ; branch if +ve
  6256                        
  6257 00:CA0F: A9 2D              LDA   #$2D              ; else character = "-"
  6258                        LAB_2978
  6259 00:CA11: 99 74 00           STA   Decss,Y           ; save leading character (" " or "-")
  6260                        LAB_297B
  6261 00:CA14: 85 62              STA   FAC1_s            ; clear FAC1 sign (b7)
  6262 00:CA16: 84 6C              STY   Sendl             ; save index
  6263 00:CA18: C8                 INY                     ; increment index
  6264 00:CA19: A6 5E              LDX   FAC1_e            ; get FAC1 exponent
  6265 00:CA1B: D0 05              BNE   LAB_2989          ; branch if FAC1<>0
  6266                        
  6267                                                      ; exponent was $00 so FAC1 is 0
  6268 00:CA1D: A9 30              LDA   #'0'              ; set character = "0"
  6269 00:CA1F: 4C 20 CB           JMP   LAB_2A89          ; save last character, [EOT] and exit
  6270                        
  6271                                                      ; FAC1 is some non zero value
  6272                        LAB_2989
  6273 00:CA22: A9 00              LDA   #$00              ; clear (number exponent count)
  6274 00:CA24: E0 81              CPX   #$81              ; compare FAC1 exponent with $81 (>1.00000)
  6275                        
  6276 00:CA26: B0 09              BCS   LAB_299A          ; branch if FAC1=>1
  6277                        
  6278                                                      ; FAC1<1
  6279 00:CA28: A9 92              LDA   #<LAB_294F        ; set pointer low byte to 1,000,000
  6280 00:CA2A: A0 D0              LDY   #>LAB_294F        ; set pointer high byte to 1,000,000
  6281 00:CA2C: 20 BA C6           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
  6282 00:CA2F: A9 FA              LDA   #$FA              ; set number exponent count (-6)
  6283                        LAB_299A
  6284 00:CA31: 85 5A              STA   numexp            ; save number exponent count
  6285                        LAB_299C
  6286 00:CA33: A9 8E              LDA   #<LAB_294B        ; set pointer low byte to 999999.4375 (max before sci note)
  6287 00:CA35: A0 D0              LDY   #>LAB_294B        ; set pointer high byte to 999999.4375
  6288 00:CA37: 20 91 C8           JSR   LAB_27F8          ; compare FAC1 with (AY)
  6289 00:CA3A: F0 1E              BEQ   LAB_29C3          ; exit if FAC1 = (AY)
  6290                        
  6291 00:CA3C: 10 12              BPL   LAB_29B9          ; go do /10 if FAC1 > (AY)
  6292                        
  6293                                                      ; FAC1 < (AY)
  6294                        LAB_29A7
  Thu Sep 26 2019 15:30                                                                                                    Page 101


  6295 00:CA3E: A9 8A              LDA   #<LAB_2947        ; set pointer low byte to 99999.9375
  6296 00:CA40: A0 D0              LDY   #>LAB_2947        ; set pointer high byte to 99999.9375
  6297 00:CA42: 20 91 C8           JSR   LAB_27F8          ; compare FAC1 with (AY)
  6298 00:CA45: F0 02              BEQ   LAB_29B2          ; branch if FAC1 = (AY) (allow decimal places)
  6299 00:CA47: 10 0E              BPL   LAB_29C0          ; branch if FAC1 > (AY) (no decimal places)
  6300                        
  6301                                                      ; FAC1 <= (AY)
  6302                        LAB_29B2
  6303 00:CA49: 20 57 C7           JSR   LAB_269E          ; multiply by 10
  6304 00:CA4C: C6 5A              DEC   numexp            ; decrement number exponent count
  6305 00:CA4E: 80 EE              BRA   LAB_29A7          ; go test again (branch always)
  6306                        
  6307                        LAB_29B9
  6308 00:CA50: 20 70 C7           JSR   LAB_26B9          ; divide by 10
  6309 00:CA53: E6 5A              INC   numexp            ; increment number exponent count
  6310 00:CA55: 80 DC              BRA   LAB_299C          ; go test again (branch always)
  6311                        
  6312                        ; now we have just the digits to do
  6313                        
  6314                        LAB_29C0
  6315 00:CA57: 20 3F C5           JSR   LAB_244E          ; add 0.5 to FAC1 (round FAC1)
  6316                        LAB_29C3
  6317 00:CA5A: 20 C9 C8           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
  6318 00:CA5D: A2 01              LDX   #$01              ; set default digits before dp = 1
  6319 00:CA5F: A5 5A              LDA   numexp            ; get number exponent count
  6320 00:CA61: 18                 CLC                     ; clear carry for add
  6321 00:CA62: 69 07              ADC   #$07              ; up to 6 digits before point
  6322 00:CA64: 30 09              BMI   LAB_29D8          ; if -ve then 1 digit before dp
  6323                        
  6324 00:CA66: C9 08              CMP   #$08              ; A>=8 if n>=1E6
  6325 00:CA68: B0 06              BCS   LAB_29D9          ; branch if >= $08
  6326                        
  6327                                                      ; carry is clear
  6328 00:CA6A: 69 FF              ADC   #$FF              ; take 1 from digit count
  6329 00:CA6C: AA                 TAX                     ; copy to A
  6330 00:CA6D: A9 02              LDA   #$02              ;.set exponent adjust
  6331                        LAB_29D8
  6332 00:CA6F: 38                 SEC                     ; set carry for subtract
  6333                        LAB_29D9
  6334 00:CA70: E9 02              SBC   #$02              ; -2
  6335 00:CA72: 85 5B              STA   expcnt            ; save exponent adjust
  6336 00:CA74: 86 5A              STX   numexp            ; save digits before dp count
  6337 00:CA76: 8A                 TXA                     ; copy to A
  6338 00:CA77: F0 02              BEQ   LAB_29E4          ; branch if no digits before dp
  6339 00:CA79: 10 13              BPL   LAB_29F7          ; branch if digits before dp
  6340                        
  6341                        LAB_29E4
  6342 00:CA7B: A4 6C              LDY   Sendl             ; get output string index
  6343 00:CA7D: A9 2E              LDA   #$2E              ; character "."
  6344 00:CA7F: C8                 INY                     ; increment index
  6345 00:CA80: 99 74 00           STA   Decss,Y           ; save to output string
  6346 00:CA83: 8A                 TXA                     ;
  6347 00:CA84: F0 06              BEQ   LAB_29F5          ;
  6348                        
  6349 00:CA86: A9 30              LDA   #'0'              ; character "0"
  6350 00:CA88: C8                 INY                     ; increment index
  6351 00:CA89: 99 74 00           STA   Decss,Y           ; save to output string
  6352                        LAB_29F5
  6353 00:CA8C: 84 6C              STY   Sendl             ; save output string index
  6354                        LAB_29F7
  6355 00:CA8E: A0 00              LDY   #$00              ; clear index (point to 100,000)
  6356 00:CA90: A2 80              LDX   #$80              ;
  6357                        LAB_29FB
  Thu Sep 26 2019 15:30                                                                                                    Page 102


  6358 00:CA92: A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
  6359 00:CA94: 18                 CLC                     ; clear carry for add
  6360 00:CA95: 79 08 D1           ADC   LAB_2A9C,Y        ; add -ve LSB
  6361 00:CA98: 85 61              STA   FAC1_3            ; save FAC1 mantissa3
  6362 00:CA9A: A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
  6363 00:CA9C: 79 07 D1           ADC   LAB_2A9B,Y        ; add -ve NMSB
  6364 00:CA9F: 85 60              STA   FAC1_2            ; save FAC1 mantissa2
  6365 00:CAA1: A5 5F              LDA   FAC1_1            ; get FAC1 mantissa1
  6366 00:CAA3: 79 06 D1           ADC   LAB_2A9A,Y        ; add -ve MSB
  6367 00:CAA6: 85 5F              STA   FAC1_1            ; save FAC1 mantissa1
  6368 00:CAA8: E8                 INX                     ;
  6369 00:CAA9: B0 04              BCS   LAB_2A18          ;
  6370                        
  6371 00:CAAB: 10 E5              BPL   LAB_29FB          ; not -ve so try again
  6372                        
  6373 00:CAAD: 30 02              BMI   LAB_2A1A          ;
  6374                        
  6375                        LAB_2A18
  6376 00:CAAF: 30 E1              BMI   LAB_29FB          ;
  6377                        
  6378                        LAB_2A1A
  6379 00:CAB1: 8A                 TXA                     ;
  6380 00:CAB2: 90 04              BCC   LAB_2A21          ;
  6381                        
  6382 00:CAB4: 49 FF              EOR   #$FF              ;
  6383 00:CAB6: 69 0A              ADC   #$0A              ;
  6384                        LAB_2A21
  6385 00:CAB8: 69 2F              ADC   #'0'-1            ; add "0"-1 to result
  6386 00:CABA: C8                 INY                     ; increment index ..
  6387 00:CABB: C8                 INY                     ; .. to next less ..
  6388 00:CABC: C8                 INY                     ; .. power of ten
  6389 00:CABD: 84 47              STY   Cvaral            ; save as current var address low byte
  6390 00:CABF: A4 6C              LDY   Sendl             ; get output string index
  6391 00:CAC1: C8                 INY                     ; increment output string index
  6392 00:CAC2: AA                 TAX                     ; copy character to X
  6393 00:CAC3: 29 7F              AND   #$7F              ; mask out top bit
  6394 00:CAC5: 99 74 00           STA   Decss,Y           ; save to output string
  6395 00:CAC8: C6 5A              DEC   numexp            ; decrement # of characters before the dp
  6396 00:CACA: D0 06              BNE   LAB_2A3B          ; branch if still characters to do
  6397                        
  6398                                                      ; else output the point
  6399 00:CACC: A9 2E              LDA   #$2E              ; character "."
  6400 00:CACE: C8                 INY                     ; increment output string index
  6401 00:CACF: 99 74 00           STA   Decss,Y           ; save to output string
  6402                        LAB_2A3B
  6403 00:CAD2: 84 6C              STY   Sendl             ; save output string index
  6404 00:CAD4: A4 47              LDY   Cvaral            ; get current var address low byte
  6405 00:CAD6: 8A                 TXA                     ; get character back
  6406 00:CAD7: 49 FF              EOR   #$FF              ;
  6407 00:CAD9: 29 80              AND   #$80              ;
  6408 00:CADB: AA                 TAX                     ;
  6409 00:CADC: C0 12              CPY   #$12              ; compare index with max
  6410 00:CADE: D0 B2              BNE   LAB_29FB          ; loop if not max
  6411                        
  6412                                                      ; now remove trailing zeroes
  6413 00:CAE0: A4 6C              LDY   Sendl             ; get output string index
  6414                        LAB_2A4B
  6415 00:CAE2: B9 74 00           LDA   Decss,Y           ; get character from output string
  6416 00:CAE5: 88                 DEY                     ; decrement output string index
  6417 00:CAE6: C9 30              CMP   #'0'              ; compare with "0"
  6418 00:CAE8: F0 F8              BEQ   LAB_2A4B          ; loop until non "0" character found
  6419                        
  6420 00:CAEA: C9 2E              CMP   #'.'              ; compare with "."
  Thu Sep 26 2019 15:30                                                                                                    Page 103


  6421 00:CAEC: F0 01              BEQ   LAB_2A58          ; branch if was dp
  6422                        
  6423                                                      ; restore last character
  6424 00:CAEE: C8                 INY                     ; increment output string index
  6425                        LAB_2A58
  6426 00:CAEF: A9 2B              LDA   #$2B              ; character "+"
  6427 00:CAF1: A6 5B              LDX   expcnt            ; get exponent count
  6428 00:CAF3: F0 2E              BEQ   LAB_2A8C          ; if zero go set null terminator and exit
  6429                        
  6430                                                      ; exponent isn't zero so write exponent
  6431 00:CAF5: 10 08              BPL   LAB_2A68          ; branch if exponent count +ve
  6432                        
  6433 00:CAF7: A9 00              LDA   #$00              ; clear A
  6434 00:CAF9: 38                 SEC                     ; set carry for subtract
  6435 00:CAFA: E5 5B              SBC   expcnt            ; subtract exponent count adjust (convert -ve to +ve)
  6436 00:CAFC: AA                 TAX                     ; copy exponent count to X
  6437 00:CAFD: A9 2D              LDA   #'-'              ; character "-"
  6438                        LAB_2A68
  6439 00:CAFF: 99 76 00           STA   Decss+2,Y         ; save to output string
  6440 00:CB02: A9 45              LDA   #$45              ; character "E"
  6441 00:CB04: 99 75 00           STA   Decss+1,Y         ; save exponent sign to output string
  6442 00:CB07: 8A                 TXA                     ; get exponent count back
  6443 00:CB08: A2 2F              LDX   #'0'-1            ; one less than "0" character
  6444 00:CB0A: 38                 SEC                     ; set carry for subtract
  6445                        LAB_2A74
  6446 00:CB0B: E8                 INX                     ; increment 10's character
  6447 00:CB0C: E9 0A              SBC   #$0A              ; subtract 10 from exponent count
  6448 00:CB0E: B0 FB              BCS   LAB_2A74          ; loop while still >= 0
  6449                        
  6450 00:CB10: 69 3A              ADC   #':'              ; add character ":" ($30+$0A, result is 10 less that value)
  6451 00:CB12: 99 78 00           STA   Decss+4,Y         ; save to output string
  6452 00:CB15: 8A                 TXA                     ; copy 10's character
  6453 00:CB16: 99 77 00           STA   Decss+3,Y         ; save to output string
  6454 00:CB19: A9 00              LDA   #$00              ; set null terminator
  6455 00:CB1B: 99 79 00           STA   Decss+5,Y         ; save to output string
  6456 00:CB1E: 80 08              BRA   LAB_2A91          ; go set string pointer (AY) and exit (branch always)
  6457                        
  6458                                                      ; save last character, [EOT] and exit
  6459                        LAB_2A89
  6460 00:CB20: 99 74 00           STA   Decss,Y           ; save last character to output string
  6461                        
  6462                                                      ; set null terminator and exit
  6463                        LAB_2A8C
  6464 00:CB23: A9 00              LDA   #$00              ; set null terminator
  6465 00:CB25: 99 75 00           STA   Decss+1,Y         ; save after last character
  6466                        
  6467                                                      ; set string pointer (AY) and exit
  6468                        LAB_2A91
  6469 00:CB28: A9 75              LDA   #<Decssp1         ; set result string low pointer
  6470 00:CB2A: A0 00              LDY   #>Decssp1         ; set result string high pointer
  6471 00:CB2C: 60                 RTS
  6472                        
  6473                        ; perform power function
  6474                        
  6475                        LAB_POWER
  6476 00:CB2D: F0 42              BEQ   LAB_EXP           ; go do  EXP()
  6477                        
  6478 00:CB2F: A5 65              LDA   FAC2_e            ; get FAC2 exponent
  6479 00:CB31: D0 03              BNE   LAB_2ABF          ; branch if FAC2<>0
  6480                        
  6481 00:CB33: 4C D3 C5           JMP   LAB_24F3          ; clear FAC1 exponent and sign and return
  6482                        
  6483                        LAB_2ABF
  Thu Sep 26 2019 15:30                                                                                                    Page 104


  6484 00:CB36: A2 4E              LDX   #<func_l          ; set destination pointer low byte
  6485 00:CB38: A0 00              LDY   #>func_l          ; set destination pointer high byte
  6486 00:CB3A: 20 25 C8           JSR   LAB_2778          ; pack FAC1 into (XY)
  6487 00:CB3D: A5 69              LDA   FAC2_s            ; get FAC2 sign (b7)
  6488 00:CB3F: 10 0F              BPL   LAB_2AD9          ; branch if FAC2>0
  6489                        
  6490                                                      ; else FAC2 is -ve and can only be raised to an
  6491                                                      ; integer power which gives an x +j0 result
  6492 00:CB41: 20 FA C8           JSR   LAB_INT           ; perform INT
  6493 00:CB44: A9 4E              LDA   #<func_l          ; set source pointer low byte
  6494 00:CB46: A0 00              LDY   #>func_l          ; set source pointer high byte
  6495 00:CB48: 20 91 C8           JSR   LAB_27F8          ; compare FAC1 with (AY)
  6496 00:CB4B: D0 03              BNE   LAB_2AD9          ; branch if FAC1 <> (AY) to allow Function Call error
  6497                                                      ; this will leave FAC1 -ve and cause a Function Call
  6498                                                      ; error when LOG() is called
  6499                        
  6500 00:CB4D: 98                 TYA                     ; clear sign b7
  6501 00:CB4E: A4 0D              LDY   Temp3             ; save mantissa 3 from INT() function as sign in Y
  6502                                                      ; for possible later negation, b0
  6503                        LAB_2AD9
  6504 00:CB50: 20 4A C5           JSR   LAB_279D          ; save FAC1 sign and copy ABS(FAC2) to FAC1
  6505 00:CB53: 98                 TYA                     ; copy sign back ..
  6506 00:CB54: 48                 PHA                     ; .. and save it
  6507 00:CB55: 20 7C C6           JSR   LAB_LOG           ; do LOG(n)
  6508 00:CB58: A9 4E              LDA   #<garb_l          ; set pointer low byte
  6509 00:CB5A: A0 00              LDY   #>garb_l          ; set pointer high byte
  6510 00:CB5C: 20 BA C6           JSR   LAB_25FB          ; do convert AY, FCA1*(AY) (square the value)
  6511 00:CB5F: 20 71 CB           JSR   LAB_EXP           ; go do EXP(n)
  6512 00:CB62: 68                 PLA                     ; pull sign from stack
  6513 00:CB63: 4A                 LSR                     ; b0 is to be tested, shift to Cb
  6514 00:CB64: 90 0A              BCC   LAB_2AF9          ; if no bit then exit
  6515                        
  6516                                                      ; Perform negation
  6517                        ; do - FAC1
  6518                        
  6519                        LAB_GTHAN
  6520 00:CB66: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  6521 00:CB68: F0 06              BEQ   LAB_2AF9          ; exit if FAC1_e = $00
  6522                        
  6523 00:CB6A: A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
  6524 00:CB6C: 49 FF              EOR   #$FF              ; complement it
  6525 00:CB6E: 85 62              STA   FAC1_s            ; save FAC1 sign (b7)
  6526                        LAB_2AF9
  6527 00:CB70: 60                 RTS
  6528                        
  6529                        ; perform EXP()   (x^e)
  6530                        
  6531                        LAB_EXP
  6532 00:CB71: A9 96              LDA   #<LAB_2AFA        ; set 1.443 pointer low byte
  6533 00:CB73: A0 D0              LDY   #>LAB_2AFA        ; set 1.443 pointer high byte
  6534 00:CB75: 20 BA C6           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
  6535 00:CB78: A5 6B              LDA   FAC1_r            ; get FAC1 rounding byte
  6536 00:CB7A: 69 50              ADC   #$50              ; +$50/$100
  6537 00:CB7C: 90 03              BCC   LAB_2B2B          ; skip rounding if no carry
  6538                        
  6539 00:CB7E: 20 5F C8           JSR   LAB_27C2          ; round FAC1 (no check)
  6540                        LAB_2B2B
  6541 00:CB81: 85 55              STA   FAC2_r            ; save FAC2 rounding byte
  6542 00:CB83: 20 4B C8           JSR   LAB_27AE          ; copy FAC1 to FAC2
  6543 00:CB86: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  6544 00:CB88: C9 88              CMP   #$88              ; compare with EXP limit (256d)
  6545 00:CB8A: 90 03              BCC   LAB_2B39          ; branch if less
  6546                        
  Thu Sep 26 2019 15:30                                                                                                    Page 105


  6547                        LAB_2B36
  6548 00:CB8C: 20 4E C7           JSR   LAB_2690          ; handle overflow and underflow
  6549                        LAB_2B39
  6550 00:CB8F: 20 FA C8           JSR   LAB_INT           ; perform INT
  6551 00:CB92: A5 0D              LDA   Temp3             ; get mantissa 3 from INT() function
  6552 00:CB94: 18                 CLC                     ; clear carry for add
  6553 00:CB95: 69 81              ADC   #$81              ; normalise +1
  6554 00:CB97: F0 F3              BEQ   LAB_2B36          ; if $00 go handle overflow
  6555                        
  6556 00:CB99: 38                 SEC                     ; set carry for subtract
  6557 00:CB9A: E9 01              SBC   #$01              ; now correct for exponent
  6558 00:CB9C: 48                 PHA                     ; save FAC2 exponent
  6559                        
  6560                                                      ; swap FAC1 and FAC2
  6561 00:CB9D: A2 04              LDX   #$04              ; 4 bytes to do
  6562                        LAB_2B49
  6563 00:CB9F: B5 65              LDA   FAC2_e,X          ; get FAC2,X
  6564 00:CBA1: B4 5E              LDY   FAC1_e,X          ; get FAC1,X
  6565 00:CBA3: 95 5E              STA   FAC1_e,X          ; save FAC1,X
  6566 00:CBA5: 94 65              STY   FAC2_e,X          ; save FAC2,X
  6567 00:CBA7: CA                 DEX                     ; decrement count/index
  6568 00:CBA8: 10 F5              BPL   LAB_2B49          ; loop if not all done
  6569                        
  6570 00:CBAA: A5 55              LDA   FAC2_r            ; get FAC2 rounding byte
  6571 00:CBAC: 85 6B              STA   FAC1_r            ; save as FAC1 rounding byte
  6572 00:CBAE: 20 2C C5           JSR   LAB_SUBTRACT      ; perform subtraction, FAC2 from FAC1
  6573 00:CBB1: 20 66 CB           JSR   LAB_GTHAN         ; do - FAC1
  6574 00:CBB4: A9 9A              LDA   #<LAB_2AFE        ; set counter pointer low byte
  6575 00:CBB6: A0 D0              LDY   #>LAB_2AFE        ; set counter pointer high byte
  6576 00:CBB8: 20 D7 CB           JSR   LAB_2B84          ; go do series evaluation
  6577 00:CBBB: 64 6A              STZ   FAC_sc            ; clear sign compare (FAC1 EOR FAC2)
  6578 00:CBBD: 68                 PLA                     ;.get saved FAC2 exponent
  6579 00:CBBE: 4C 32 C7           JMP   LAB_2675          ; test and adjust accumulators and return
  6580                        
  6581                        ; ^2 then series evaluation
  6582                        
  6583                        LAB_2B6E
  6584 00:CBC1: 85 6C              STA   Cptrl             ; save count pointer low byte
  6585 00:CBC3: 84 6D              STY   Cptrh             ; save count pointer high byte
  6586 00:CBC5: 20 1B C8           JSR   LAB_276E          ; pack FAC1 into Adatal
  6587 00:CBC8: A9 56              LDA   #<Adatal          ; set pointer low byte (Y already $00)
  6588 00:CBCA: 20 BA C6           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
  6589 00:CBCD: 20 DB CB           JSR   LAB_2B88          ; go do series evaluation
  6590 00:CBD0: A9 56              LDA   #<Adatal          ; pointer to original # low byte
  6591 00:CBD2: A0 00              LDY   #>Adatal          ; pointer to original # high byte
  6592 00:CBD4: 4C BA C6           JMP   LAB_25FB          ; do convert AY, FCA1*(AY) and return
  6593                        
  6594                        ; series evaluation
  6595                        
  6596                        LAB_2B84
  6597 00:CBD7: 85 6C              STA   Cptrl             ; save count pointer low byte
  6598 00:CBD9: 84 6D              STY   Cptrh             ; save count pointer high byte
  6599                        LAB_2B88
  6600 00:CBDB: A2 5A              LDX   #<numexp          ; set pointer low byte
  6601 00:CBDD: 20 1D C8           JSR   LAB_2770          ; set pointer high byte and pack FAC1 into numexp
  6602 00:CBE0: B1 6C              LDA   (Cptrl),Y         ; get constants count
  6603 00:CBE2: 85 63              STA   numcon            ; save constants count
  6604 00:CBE4: A4 6C              LDY   Cptrl             ; get count pointer low byte
  6605 00:CBE6: C8                 INY                     ; increment it (now constants pointer)
  6606 00:CBE7: 98                 TYA                     ; copy it
  6607 00:CBE8: D0 02              BNE   LAB_2B97          ; skip next if no overflow
  6608                        
  6609 00:CBEA: E6 6D              INC   Cptrh             ; else increment high byte
  Thu Sep 26 2019 15:30                                                                                                    Page 106


  6610                        LAB_2B97
  6611 00:CBEC: 85 6C              STA   Cptrl             ; save low byte
  6612 00:CBEE: A4 6D              LDY   Cptrh             ; get high byte
  6613                        LAB_2B9B
  6614 00:CBF0: 20 BA C6           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
  6615 00:CBF3: A5 6C              LDA   Cptrl             ; get constants pointer low byte
  6616 00:CBF5: A4 6D              LDY   Cptrh             ; get constants pointer high byte
  6617 00:CBF7: 18                 CLC                     ; clear carry for add
  6618 00:CBF8: 69 04              ADC   #$04              ; +4 to  low pointer (4 bytes per constant)
  6619 00:CBFA: 90 01              BCC   LAB_2BA8          ; skip next if no overflow
  6620                        
  6621 00:CBFC: C8                 INY                     ; increment high byte
  6622                        LAB_2BA8
  6623 00:CBFD: 85 6C              STA   Cptrl             ; save pointer low byte
  6624 00:CBFF: 84 6D              STY   Cptrh             ; save pointer high byte
  6625 00:CC01: 20 43 C5           JSR   LAB_246C          ; add (AY) to FAC1
  6626 00:CC04: A9 5A              LDA   #<numexp          ; set pointer low byte to partial @ numexp
  6627 00:CC06: A0 00              LDY   #>numexp          ; set pointer high byte to partial @ numexp
  6628 00:CC08: C6 63              DEC   numcon            ; decrement constants count
  6629 00:CC0A: D0 E4              BNE   LAB_2B9B          ; loop until all done
  6630 00:CC0C: 60                 RTS
  6631                        
  6632                        ; RND(n), 32 bit Galoise version. make n=0 for 19th next number in sequence or n<>0
  6633                        ; to get 19th next number in sequence after seed n. This version of the PRNG uses
  6634                        ; the Galois method and a sample of 65536 bytes produced gives the following values.
  6635                        
  6636                        ; Entropy = 7.997442 bits per byte
  6637                        ; Optimum compression would reduce these 65536 bytes by 0 percent
  6638                        
  6639                        ; Chi square distribution for 65536 samples is 232.01, and
  6640                        ; randomly would exceed this value 75.00 percent of the time
  6641                        
  6642                        ; Arithmetic mean value of data bytes is 127.6724, 127.5 would be random
  6643                        ; Monte Carlo value for Pi is 3.122871269, error 0.60 percent
  6644                        ; Serial correlation coefficient is -0.000370, totally uncorrelated would be 0.0
  6645                        
  6646                        LAB_RND
  6647 00:CC0D: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  6648 00:CC0F: F0 07              BEQ   NextPRN           ; do next random # if zero
  6649                        
  6650                                                      ; else get seed into random number store
  6651 00:CC11: A2 70              LDX   #Rbyte4           ; set PRNG pointer low byte
  6652 00:CC13: A0 00              LDY   #$00              ; set PRNG pointer high byte
  6653 00:CC15: 20 25 C8           JSR   LAB_2778          ; pack FAC1 into (XY)
  6654                        NextPRN
  6655 00:CC18: A2 AF              LDX   #$AF              ; set EOR byte
  6656 00:CC1A: A0 13              LDY   #$13              ; do this nineteen times
  6657                        LoopPRN
  6658 00:CC1C: 06 71              ASL   Rbyte1            ; shift PRNG most significant byte
  6659 00:CC1E: 26 72              ROL   Rbyte2            ; shift PRNG middle byte
  6660 00:CC20: 26 73              ROL   Rbyte3            ; shift PRNG least significant byte
  6661 00:CC22: 26 70              ROL   Rbyte4            ; shift PRNG extra byte
  6662 00:CC24: 90 05              BCC   Ninc1             ; branch if bit 32 clear
  6663                        
  6664 00:CC26: 8A                 TXA                     ; set EOR byte
  6665 00:CC27: 45 71              EOR   Rbyte1            ; EOR PRNG extra byte
  6666 00:CC29: 85 71              STA   Rbyte1            ; save new PRNG extra byte
  6667                        Ninc1
  6668 00:CC2B: 88                 DEY                     ; decrement loop count
  6669 00:CC2C: D0 EE              BNE   LoopPRN           ; loop if not all done
  6670                        
  6671 00:CC2E: A2 02              LDX   #$02              ; three bytes to copy
  6672                        CopyPRNG
  Thu Sep 26 2019 15:30                                                                                                    Page 107


  6673 00:CC30: B5 71              LDA   Rbyte1,X          ; get PRNG byte
  6674 00:CC32: 95 5F              STA   FAC1_1,X          ; save FAC1 byte
  6675 00:CC34: CA                 DEX
  6676 00:CC35: 10 F9              BPL   CopyPRNG          ; loop if not complete
  6677                        
  6678 00:CC37: A9 80              LDA   #$80              ; set the exponent
  6679 00:CC39: 85 5E              STA   FAC1_e            ; save FAC1 exponent
  6680                        
  6681 00:CC3B: 0A                 ASL                     ; clear A
  6682 00:CC3C: 85 62              STA   FAC1_s            ; save FAC1 sign
  6683                        
  6684 00:CC3E: 4C B5 C5           JMP   LAB_24D5          ; normalise FAC1 and return
  6685                        
  6686                        ; perform COS()
  6687                        
  6688                        LAB_COS
  6689 00:CC41: A9 B7              LDA   #<LAB_2C78        ; set (pi/2) pointer low byte
  6690 00:CC43: A0 D0              LDY   #>LAB_2C78        ; set (pi/2) pointer high byte
  6691 00:CC45: 20 43 C5           JSR   LAB_246C          ; add (AY) to FAC1
  6692                        
  6693                        ; perform SIN()
  6694                        
  6695                        LAB_SIN
  6696 00:CC48: 20 48 C8           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
  6697 00:CC4B: A9 CC              LDA   #<LAB_2C7C        ; set (2*pi) pointer low byte
  6698 00:CC4D: A0 D0              LDY   #>LAB_2C7C        ; set (2*pi) pointer high byte
  6699 00:CC4F: A6 69              LDX   FAC2_s            ; get FAC2 sign (b7)
  6700 00:CC51: 20 79 C7           JSR   LAB_26C2          ; divide by (AY) (X=sign)
  6701 00:CC54: 20 48 C8           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
  6702 00:CC57: 20 FA C8           JSR   LAB_INT           ; perform INT
  6703 00:CC5A: 64 6A              STZ   FAC_sc            ; clear sign compare (FAC1 EOR FAC2)
  6704 00:CC5C: 20 2C C5           JSR   LAB_SUBTRACT      ; perform subtraction, FAC2 from FAC1
  6705 00:CC5F: A9 FE              LDA   #<LAB_2C80        ; set 0.25 pointer low byte
  6706 00:CC61: A0 D0              LDY   #>LAB_2C80        ; set 0.25 pointer high byte
  6707 00:CC63: 20 29 C5           JSR   LAB_2455          ; perform subtraction, (AY) from FAC1
  6708 00:CC66: A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
  6709 00:CC68: 48                 PHA                     ; save FAC1 sign
  6710 00:CC69: 10 0D              BPL   LAB_2C35          ; branch if +ve
  6711                        
  6712                                                      ; FAC1 sign was -ve
  6713 00:CC6B: 20 3F C5           JSR   LAB_244E          ; add 0.5 to FAC1
  6714 00:CC6E: A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
  6715 00:CC70: 30 09              BMI   LAB_2C38          ; branch if -ve
  6716                        
  6717 00:CC72: A5 15              LDA   Cflag             ; get comparison evaluation flag
  6718 00:CC74: 49 FF              EOR   #$FF              ; toggle flag
  6719 00:CC76: 85 15              STA   Cflag             ; save comparison evaluation flag
  6720                        LAB_2C35
  6721 00:CC78: 20 66 CB           JSR   LAB_GTHAN         ; do - FAC1
  6722                        LAB_2C38
  6723 00:CC7B: A9 FE              LDA   #<LAB_2C80        ; set 0.25 pointer low byte
  6724 00:CC7D: A0 D0              LDY   #>LAB_2C80        ; set 0.25 pointer high byte
  6725 00:CC7F: 20 43 C5           JSR   LAB_246C          ; add (AY) to FAC1
  6726 00:CC82: 68                 PLA                     ; restore FAC1 sign
  6727 00:CC83: 10 03              BPL   LAB_2C45          ; branch if was +ve
  6728                        
  6729                                                      ; else correct FAC1
  6730 00:CC85: 20 66 CB           JSR   LAB_GTHAN         ; do - FAC1
  6731                        LAB_2C45
  6732 00:CC88: A9 BB              LDA   #<LAB_2C84        ; set pointer low byte to counter
  6733 00:CC8A: A0 D0              LDY   #>LAB_2C84        ; set pointer high byte to counter
  6734 00:CC8C: 4C C1 CB           JMP   LAB_2B6E          ; ^2 then series evaluation and return
  6735                        
  Thu Sep 26 2019 15:30                                                                                                    Page 108


  6736                        ; perform TAN()
  6737                        
  6738                        LAB_TAN
  6739 00:CC8F: 20 1B C8           JSR   LAB_276E          ; pack FAC1 into Adatal
  6740 00:CC92: 64 15              STZ   Cflag             ; clear comparison evaluation flag
  6741 00:CC94: 20 48 CC           JSR   LAB_SIN           ; go do SIN(n)
  6742 00:CC97: A2 4E              LDX   #<func_l          ; set sin(n) pointer low byte
  6743 00:CC99: A0 00              LDY   #>func_l          ; set sin(n) pointer high byte
  6744 00:CC9B: 20 25 C8           JSR   LAB_2778          ; pack FAC1 into (XY)
  6745 00:CC9E: A9 56              LDA   #<Adatal          ; set n pointer low addr
  6746 00:CCA0: A0 00              LDY   #>Adatal          ; set n pointer high addr
  6747 00:CCA2: 20 FB C7           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
  6748 00:CCA5: 64 62              STZ   FAC1_s            ; clear FAC1 sign (b7)
  6749 00:CCA7: A5 15              LDA   Cflag             ; get comparison evaluation flag
  6750 00:CCA9: 20 B3 CC           JSR   LAB_2C74          ; save flag and go do series evaluation
  6751                        
  6752 00:CCAC: A9 4E              LDA   #<func_l          ; set sin(n) pointer low byte
  6753 00:CCAE: A0 00              LDY   #>func_l          ; set sin(n) pointer high byte
  6754 00:CCB0: 4C 80 C7           JMP   LAB_26CA          ; convert AY and do (AY)/FAC1
  6755                        
  6756                        LAB_2C74
  6757 00:CCB3: 48                 PHA                     ; save comparison evaluation flag
  6758 00:CCB4: 80 C2              BRA   LAB_2C35          ; go do series evaluation
  6759                        
  6760                        ; perform USR()
  6761                        
  6762                        LAB_USR
  6763 00:CCB6: 20 03 00           JSR   Usrjmp            ; call user code
  6764 00:CCB9: 4C 8F BB           JMP   LAB_1BFB          ; scan for ")", else do syntax error then warm start
  6765                        
  6766                        ; perform ATN()
  6767                        
  6768                        LAB_ATN
  6769 00:CCBC: A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
  6770 00:CCBE: 48                 PHA                     ; save sign
  6771 00:CCBF: 10 03              BPL   LAB_2CA1          ; branch if +ve
  6772                        
  6773 00:CCC1: 20 66 CB           JSR   LAB_GTHAN         ; else do - FAC1
  6774                        LAB_2CA1
  6775 00:CCC4: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  6776 00:CCC6: 48                 PHA                     ; push exponent
  6777 00:CCC7: C9 81              CMP   #$81              ; compare with 1
  6778 00:CCC9: 90 07              BCC   LAB_2CAF          ; branch if FAC1<1
  6779                        
  6780 00:CCCB: A9 F1              LDA   #<LAB_259C        ; set 1 pointer low byte
  6781 00:CCCD: A0 D0              LDY   #>LAB_259C        ; set 1 pointer high byte
  6782 00:CCCF: 20 80 C7           JSR   LAB_26CA          ; convert AY and do (AY)/FAC1
  6783                        LAB_2CAF
  6784 00:CCD2: A9 D0              LDA   #<LAB_2CC9        ; set pointer low byte to counter
  6785 00:CCD4: A0 D0              LDY   #>LAB_2CC9        ; set pointer high byte to counter
  6786 00:CCD6: 20 C1 CB           JSR   LAB_2B6E          ; ^2 then series evaluation
  6787 00:CCD9: 68                 PLA                     ; restore old FAC1 exponent
  6788 00:CCDA: C9 81              CMP   #$81              ; compare with 1
  6789 00:CCDC: 90 07              BCC   LAB_2CC2          ; branch if FAC1<1
  6790                        
  6791 00:CCDE: A9 B7              LDA   #<LAB_2C78        ; set (pi/2) pointer low byte
  6792 00:CCE0: A0 D0              LDY   #>LAB_2C78        ; set (pi/2) pointer high byte
  6793 00:CCE2: 20 29 C5           JSR   LAB_2455          ; perform subtraction, (AY) from FAC1
  6794                        LAB_2CC2
  6795 00:CCE5: 68                 PLA                     ; restore FAC1 sign
  6796 00:CCE6: 10 16              BPL   LAB_2D04          ; exit if was +ve
  6797                        
  6798 00:CCE8: 4C 66 CB           JMP   LAB_GTHAN         ; else do - FAC1 and return
  Thu Sep 26 2019 15:30                                                                                                    Page 109


  6799                        
  6800                        ; perform BITSET
  6801                        
  6802                        LAB_BITSET
  6803 00:CCEB: 20 5E C4           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
  6804 00:CCEE: E0 08              CPX   #$08              ; only 0 to 7 are allowed
  6805 00:CCF0: B0 20              BCS   FCError           ; branch if > 7
  6806                        
  6807 00:CCF2: A9 00              LDA   #$00              ; clear A
  6808 00:CCF4: 38                 SEC                     ; set the carry
  6809                        S_Bits
  6810 00:CCF5: 2A                 ROL                     ; shift bit
  6811 00:CCF6: CA                 DEX                     ; decrement bit number
  6812 00:CCF7: 10 FC              BPL   S_Bits            ; loop if still +ve
  6813                        
  6814 00:CCF9: E8                 INX                     ; make X = $00
  6815 00:CCFA: 01 0A              ORA   (Itempl,X)        ; or with byte via temporary integer (addr)
  6816 00:CCFC: 81 0A              STA   (Itempl,X)        ; save byte via temporary integer (addr)
  6817                        LAB_2D04
  6818 00:CCFE: 60                 RTS
  6819                        
  6820                        ; perform BITCLR
  6821                        
  6822                        LAB_BITCLR
  6823 00:CCFF: 20 5E C4           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
  6824 00:CD02: E0 08              CPX   #$08              ; only 0 to 7 are allowed
  6825 00:CD04: B0 0C              BCS   FCError           ; branch if > 7
  6826                        
  6827 00:CD06: A9 FF              LDA   #$FF              ; set A
  6828                        S_Bitc
  6829 00:CD08: 2A                 ROL                     ; shift bit
  6830 00:CD09: CA                 DEX                     ; decrement bit number
  6831 00:CD0A: 10 FC              BPL   S_Bitc            ; loop if still +ve
  6832                        
  6833 00:CD0C: E8                 INX                     ; make X = $00
  6834 00:CD0D: 21 0A              AND   (Itempl,X)        ; and with byte via temporary integer (addr)
  6835 00:CD0F: 81 0A              STA   (Itempl,X)        ; save byte via temporary integer (addr)
  6836 00:CD11: 60                 RTS
  6837                        
  6838                        FCError
  6839 00:CD12: 4C BE BE           JMP   LAB_FCER          ; do function call error then warm start
  6840                        
  6841                        ; perform BITTST()
  6842                        
  6843                        LAB_BTST
  6844 00:CD15: 20 AE CF           JSR   LAB_IGBY          ; increment BASIC pointer
  6845 00:CD18: 20 5E C4           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
  6846 00:CD1B: E0 08              CPX   #$08              ; only 0 to 7 are allowed
  6847 00:CD1D: B0 F3              BCS   FCError           ; branch if > 7
  6848                        
  6849 00:CD1F: 20 B4 CF           JSR   LAB_GBYT          ; get next BASIC byte
  6850 00:CD22: C9 29              CMP   #')'              ; is next character ")"
  6851 00:CD24: F0 03              BEQ   TST_OK            ; if ")" go do rest of function
  6852                        
  6853 00:CD26: 4C A0 BB           JMP   LAB_SNER          ; do syntax error then warm start
  6854                        
  6855                        TST_OK
  6856 00:CD29: 20 AE CF           JSR   LAB_IGBY          ; update BASIC execute pointer (to character past ")")
  6857 00:CD2C: A9 00              LDA   #$00              ; clear A
  6858 00:CD2E: 38                 SEC                     ; set the carry
  6859                        T_Bits
  6860 00:CD2F: 2A                 ROL                     ; shift bit
  6861 00:CD30: CA                 DEX                     ; decrement bit number
  Thu Sep 26 2019 15:30                                                                                                    Page 110


  6862 00:CD31: 10 FC              BPL   T_Bits            ; loop if still +ve
  6863                        
  6864 00:CD33: E8                 INX                     ; make X = $00
  6865 00:CD34: 21 0A              AND   (Itempl,X)        ; AND with byte via temporary integer (addr)
  6866 00:CD36: F0 02              BEQ   LAB_NOTT          ; branch if zero (already correct)
  6867                        
  6868 00:CD38: A9 FF              LDA   #$FF              ; set for -1 result
  6869                        LAB_NOTT
  6870 00:CD3A: 4C 78 C8           JMP   LAB_27DB          ; go do SGN tail
  6871                        
  6872                        ; perform BIN$()
  6873                        
  6874                        LAB_BINS
  6875 00:CD3D: E0 19              CPX   #$19              ; max + 1
  6876 00:CD3F: B0 48              BCS   BinFErr           ; exit if too big ( > or = )
  6877                        
  6878 00:CD41: 86 2A              STX   TempB             ; save # of characters ($00 = leading zero remove)
  6879 00:CD43: A9 18              LDA   #$18              ; need A byte long space
  6880 00:CD45: 20 CD C0           JSR   LAB_MSSP          ; make string space A bytes long
  6881 00:CD48: A0 17              LDY   #$17              ; set index
  6882 00:CD4A: A2 18              LDX   #$18              ; character count
  6883                        NextB1
  6884 00:CD4C: 46 0A              LSR   nums_1            ; shift highest byte
  6885 00:CD4E: 66 0B              ROR   nums_2            ; shift middle byte
  6886 00:CD50: 66 0C              ROR   nums_3            ; shift lowest byte bit 0 to carry
  6887 00:CD52: 8A                 TXA                     ; load with "0"/2
  6888 00:CD53: 2A                 ROL                     ; shift in carry
  6889 00:CD54: 91 5F              STA   (str_pl),Y        ; save to temp string + index
  6890 00:CD56: 88                 DEY                     ; decrement index
  6891 00:CD57: 10 F3              BPL   NextB1            ; loop if not done
  6892                        
  6893 00:CD59: A5 2A              LDA   TempB             ; get # of characters
  6894 00:CD5B: F0 0A              BEQ   EndBHS            ; branch if truncate
  6895                        
  6896 00:CD5D: AA                 TAX                     ; copy length to X
  6897 00:CD5E: 38                 SEC                     ; set carry for add !
  6898 00:CD5F: 49 FF              EOR   #$FF              ; 1's complement
  6899 00:CD61: 69 18              ADC   #$18              ; add 24d
  6900 00:CD63: F0 1C              BEQ   GoPr2             ; if zero print whole string
  6901 00:CD65: 80 0F              BRA   GoPr1             ; else go make output string
  6902                        
  6903                        ; this is the exit code and is also used by HEX$()
  6904                        ; truncate string to remove leading "0"s
  6905                        
  6906                        EndBHS
  6907 00:CD67: A8                 TAY                     ; clear index (A=0, X=length here)
  6908                        NextB2
  6909 00:CD68: B1 5F              LDA   (str_pl),Y        ; get character from string
  6910 00:CD6A: C9 30              CMP   #'0'              ; compare with "0"
  6911 00:CD6C: D0 07              BNE   GoPr              ; if not "0" then go print string from here
  6912                        
  6913 00:CD6E: CA                 DEX                     ; decrement character count
  6914 00:CD6F: F0 03              BEQ   GoPr3             ; if zero then end of string so go print it
  6915                        
  6916 00:CD71: C8                 INY                     ; else increment index
  6917 00:CD72: 80 F4              BRA   NextB2            ; loop always
  6918                        
  6919                        ; make fixed length output string - ignore overflows!
  6920                        
  6921                        GoPr3
  6922 00:CD74: E8                 INX                     ; need at least 1 character
  6923                        GoPr
  6924 00:CD75: 98                 TYA                     ; copy result
  Thu Sep 26 2019 15:30                                                                                                    Page 111


  6925                        GoPr1
  6926 00:CD76: 18                 CLC                     ; clear carry for add
  6927 00:CD77: 65 5F              ADC   str_pl            ; add low address
  6928 00:CD79: 85 5F              STA   str_pl            ; save low address
  6929 00:CD7B: A9 00              LDA   #$00              ; do high byte
  6930 00:CD7D: 65 60              ADC   str_ph            ; add high address
  6931 00:CD7F: 85 60              STA   str_ph            ; save high address
  6932                        GoPr2
  6933 00:CD81: 86 5E              STX   str_ln            ; X holds string length
  6934 00:CD83: 20 AE CF           JSR   LAB_IGBY          ; update BASIC execute pointer (to character past ")")
  6935 00:CD86: 4C 1A C1           JMP   LAB_RTST          ; check for space on descriptor stack then put address
  6936                                                      ; and length on descriptor stack and update stack pointers
  6937                        
  6938                        BinFErr
  6939 00:CD89: 4C BE BE           JMP   LAB_FCER          ; do function call error then warm start
  6940                        
  6941                        ; perform HEX$()
  6942                        
  6943                        LAB_HEXS
  6944 00:CD8C: E0 07              CPX   #$07              ; max + 1
  6945 00:CD8E: B0 F9              BCS   BinFErr           ; exit if too big ( > or = )
  6946                        
  6947 00:CD90: 86 2A              STX   TempB             ; save # of characters
  6948                        
  6949 00:CD92: A9 06              LDA   #$06              ; need 6 bytes for string
  6950 00:CD94: 20 CD C0           JSR   LAB_MSSP          ; make string space A bytes long
  6951 00:CD97: A0 05              LDY   #$05              ; set string index
  6952                        
  6953 00:CD99: A5 0C              LDA   nums_3            ; get lowest byte
  6954 00:CD9B: 20 B8 CD           JSR   LAB_A2HX          ; convert A to ASCII hex byte and output
  6955 00:CD9E: A5 0B              LDA   nums_2            ; get middle byte
  6956 00:CDA0: 20 B8 CD           JSR   LAB_A2HX          ; convert A to ASCII hex byte and output
  6957 00:CDA3: A5 0A              LDA   nums_1            ; get highest byte
  6958 00:CDA5: 20 B8 CD           JSR   LAB_A2HX          ; convert A to ASCII hex byte and output
  6959                        
  6960 00:CDA8: A2 06              LDX   #$06              ; character count
  6961 00:CDAA: A5 2A              LDA   TempB             ; get # of characters
  6962 00:CDAC: F0 B9              BEQ   EndBHS            ; branch if truncate
  6963                        
  6964 00:CDAE: AA                 TAX                     ; copy length to X
  6965 00:CDAF: 38                 SEC                     ; set carry for add !
  6966 00:CDB0: 49 FF              EOR   #$FF              ; 1's complement
  6967 00:CDB2: 69 06              ADC   #$06              ; add 6d
  6968 00:CDB4: F0 CB              BEQ   GoPr2             ; if zero print whole string
  6969 00:CDB6: 80 BE              BRA   GoPr1             ; else go make output string (branch always)
  6970                        
  6971                        ; convert A to ASCII hex byte and output .. note set decimal mode before calling
  6972                        
  6973                        LAB_A2HX
  6974 00:CDB8: AA                 TAX                     ; save byte
  6975 00:CDB9: 29 0F              AND   #$0F              ; mask off top bits
  6976 00:CDBB: 20 C3 CD           JSR   LAB_AL2X          ; convert low nibble to ASCII and output
  6977 00:CDBE: 8A                 TXA                     ; get byte back
  6978 00:CDBF: 4A                 LSR                     ; /2  shift high nibble to low nibble
  6979 00:CDC0: 4A                 LSR                     ; /4
  6980 00:CDC1: 4A                 LSR                     ; /8
  6981 00:CDC2: 4A                 LSR                     ; /16
  6982                        LAB_AL2X
  6983 00:CDC3: C9 0A              CMP   #$0A              ; set carry for +1 if >9
  6984 00:CDC5: 90 02              BCC   LAB_AL20          ; skip adjust if <= 9
  6985 00:CDC7: 69 06              ADC   #$06              ; adjust for A to F
  6986                        LAB_AL20
  6987 00:CDC9: 69 30              ADC   #'0'              ; add ASCII "0"
  Thu Sep 26 2019 15:30                                                                                                    Page 112


  6988 00:CDCB: 91 5F              STA   (str_pl),Y        ; save to temp string
  6989 00:CDCD: 88                 DEY                     ; decrement counter
  6990 00:CDCE: 60                 RTS
  6991                        
  6992                        LAB_NLTO
  6993 00:CDCF: 85 5E              STA   FAC1_e            ; save FAC1 exponent
  6994 00:CDD1: A9 00              LDA   #$00              ; clear sign compare
  6995                        LAB_MLTE
  6996 00:CDD3: 85 6A              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
  6997 00:CDD5: 8A                 TXA                     ; restore character
  6998 00:CDD6: 20 BA C9           JSR   LAB_2912          ; evaluate new ASCII digit
  6999                        
  7000                        ; gets here if the first character was "$" for hex
  7001                        ; get hex number
  7002                        
  7003                        LAB_CHEX
  7004 00:CDD9: 20 AE CF           JSR   LAB_IGBY          ; increment and scan memory
  7005 00:CDDC: 90 0A              BCC   LAB_ISHN          ; branch if numeric character
  7006                        
  7007 00:CDDE: 09 20              ORA   #$20              ; case convert, allow "A" to "F" and "a" to "f"
  7008 00:CDE0: E9 61              SBC   #'a'              ; subtract "a" (carry set here)
  7009 00:CDE2: C9 06              CMP   #$06              ; compare normalised with $06 (max+1)
  7010 00:CDE4: B0 2A              BCS   LAB_EXCH          ; exit if >"f" or <"0"
  7011                        
  7012 00:CDE6: 69 0A              ADC   #$0A              ; convert to nibble
  7013                        LAB_ISHN
  7014 00:CDE8: 29 0F              AND   #$0F              ; convert to binary
  7015 00:CDEA: AA                 TAX                     ; save nibble
  7016 00:CDEB: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  7017 00:CDED: F0 E4              BEQ   LAB_MLTE          ; skip multiply if zero
  7018                        
  7019 00:CDEF: 69 04              ADC   #$04              ; add four to exponent (*16 - carry clear here)
  7020 00:CDF1: 90 DC              BCC   LAB_NLTO          ; if no overflow do evaluate digit
  7021                        
  7022                        LAB_MLTO
  7023 00:CDF3: 4C 44 C6           JMP   LAB_2564          ; do overflow error and warm start
  7024                        
  7025                        LAB_NXCH
  7026 00:CDF6: AA                 TAX                     ; save bit
  7027 00:CDF7: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  7028 00:CDF9: F0 06              BEQ   LAB_MLBT          ; skip multiply if zero
  7029                        
  7030 00:CDFB: E6 5E              INC   FAC1_e            ; increment FAC1 exponent (*2)
  7031 00:CDFD: F0 F4              BEQ   LAB_MLTO          ; do overflow error if = $00
  7032                        
  7033 00:CDFF: A9 00              LDA   #$00              ; clear sign compare
  7034                        LAB_MLBT
  7035 00:CE01: 85 6A              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
  7036 00:CE03: 8A                 TXA                     ; restore bit
  7037 00:CE04: 20 BA C9           JSR   LAB_2912          ; evaluate new ASCII digit
  7038                        
  7039                        ; gets here if the first character was  "%" for binary
  7040                        ; get binary number
  7041                        
  7042                        LAB_CBIN
  7043 00:CE07: 20 AE CF           JSR   LAB_IGBY          ; increment and scan memory
  7044 00:CE0A: 49 30              EOR   #'0'              ; convert "0" to 0 etc.
  7045 00:CE0C: C9 02              CMP   #$02              ; compare with max+1
  7046 00:CE0E: 90 E6              BCC   LAB_NXCH          ; branch exit if < 2
  7047                        
  7048                        LAB_EXCH
  7049 00:CE10: 4C A0 C9           JMP   LAB_28F6          ; evaluate -ve flag and return
  7050                        
  Thu Sep 26 2019 15:30                                                                                                    Page 113


  7051                        ; ctrl-c check routine. includes limited "life" byte save for INGET routine
  7052                        
  7053                        CTRLC
  7054 00:CE13: AD 7F 04           LDA   ccflag            ; get [CTRL-C] check flag
  7055 00:CE16: D0 18              BNE   LAB_FBA2          ; exit if inhibited
  7056                        
  7057 00:CE18: 20 37 D0           JSR   V_INPT            ; scan input device
  7058 00:CE1B: 90 0B              BCC   LAB_FBA0          ; exit if buffer empty
  7059                        
  7060 00:CE1D: 8D 80 04           STA   ccbyte            ; save received byte
  7061 00:CE20: A2 20              LDX   #$20              ; "life" timer for bytes
  7062 00:CE22: 8E 81 04           STX   ccnull            ; set countdown
  7063 00:CE25: 4C E1 B4           JMP   LAB_1636          ; return to BASIC
  7064                        
  7065                        LAB_FBA0
  7066 00:CE28: AE 81 04           LDX   ccnull            ; get countdown byte
  7067 00:CE2B: F0 03              BEQ   LAB_FBA2          ; exit if finished
  7068                        
  7069 00:CE2D: CE 81 04           DEC   ccnull            ; else decrement countdown
  7070                        LAB_FBA2
  7071 00:CE30: 60                 RTS
  7072                        
  7073                        INGET
  7074 00:CE31: 20 37 D0           JSR   V_INPT            ; call scan input device
  7075 00:CE34: B0 09              BCS   LAB_FB95          ; if byte go reset timer
  7076                        
  7077 00:CE36: AD 81 04           LDA   ccnull            ; get countdown
  7078 00:CE39: F0 07              BEQ   LAB_FB96          ; exit if empty
  7079                        
  7080 00:CE3B: AD 80 04           LDA   ccbyte            ; get last received byte
  7081 00:CE3E: 38                 SEC                     ; flag we got a byte
  7082                        LAB_FB95
  7083 00:CE3F: 9C 81 04           STZ   ccnull            ; clear timer because we got a byte
  7084                        LAB_FB96
  7085 00:CE42: 60                 RTS
  7086                        
  7087                        ; MAX() MIN() pre process
  7088                        
  7089                        LAB_MMPP
  7090 00:CE43: 20 8C BA           JSR   LAB_EVEZ          ; process expression
  7091 00:CE46: 4C 72 BA           JMP   LAB_CTNM          ; check if source is numeric, else do type mismatch
  7092                        
  7093                        ; perform MAX()
  7094                        
  7095                        LAB_MAX
  7096 00:CE49: 20 77 CE           JSR   LAB_PHFA          ; push FAC1, evaluate expression,
  7097                                                      ; pull FAC2 and compare with FAC1
  7098 00:CE4C: 10 FB              BPL   LAB_MAX           ; branch if no swap to do
  7099                        
  7100 00:CE4E: A5 66              LDA   FAC2_1            ; get FAC2 mantissa1
  7101 00:CE50: 09 80              ORA   #$80              ; set top bit (clear sign from compare)
  7102 00:CE52: 85 66              STA   FAC2_1            ; save FAC2 mantissa1
  7103 00:CE54: 20 48 C5           JSR   LAB_279B          ; copy FAC2 to FAC1
  7104 00:CE57: 80 F0              BRA   LAB_MAX           ; go do next (branch always)
  7105                        
  7106                        ; perform MIN()
  7107                        
  7108                        LAB_MIN
  7109 00:CE59: 20 77 CE           JSR   LAB_PHFA          ; push FAC1, evaluate expression,
  7110                                                      ; pull FAC2 and compare with FAC1
  7111 00:CE5C: 30 FB              BMI   LAB_MIN           ; branch if no swap to do
  7112 00:CE5E: F0 F9              BEQ   LAB_MIN           ; branch if no swap to do
  7113                        
  Thu Sep 26 2019 15:30                                                                                                    Page 114


  7114 00:CE60: A5 66              LDA   FAC2_1            ; get FAC2 mantissa1
  7115 00:CE62: 09 80              ORA   #$80              ; set top bit (clear sign from compare)
  7116 00:CE64: 85 66              STA   FAC2_1            ; save FAC2 mantissa1
  7117 00:CE66: 20 48 C5           JSR   LAB_279B          ; copy FAC2 to FAC1
  7118 00:CE69: 80 EE              BRA   LAB_MIN           ; go do next (branch always)
  7119                        
  7120                        ; exit routine. don't bother returning to the loop code
  7121                        ; check for correct exit, else so syntax error
  7122                        
  7123                        LAB_MMEC
  7124 00:CE6B: C9 29              CMP   #')'              ; is it end of function?
  7125 00:CE6D: D0 05              BNE   LAB_MMSE          ; if not do MAX MIN syntax error
  7126                        
  7127 00:CE6F: 68                 PLA                     ; dump return address low byte
  7128 00:CE70: 68                 PLA                     ; dump return address high byte
  7129 00:CE71: 4C AE CF           JMP   LAB_IGBY          ; update BASIC execute pointer (to chr past ")")
  7130                        
  7131                        LAB_MMSE
  7132 00:CE74: 4C A0 BB           JMP   LAB_SNER          ; do syntax error then warm start
  7133                        
  7134                        ; check for next, evaluate and return or exit
  7135                        ; this is the routine that does most of the work
  7136                        
  7137                        LAB_PHFA
  7138 00:CE77: 20 B4 CF           JSR   LAB_GBYT          ; get next BASIC byte
  7139 00:CE7A: C9 2C              CMP   #','              ; is there more ?
  7140 00:CE7C: D0 ED              BNE   LAB_MMEC          ; if not go do end check
  7141                        
  7142                                                      ; push FAC1
  7143 00:CE7E: 20 57 C8           JSR   LAB_27BA          ; round FAC1
  7144 00:CE81: A5 62              LDA   FAC1_s            ; get FAC1 sign
  7145 00:CE83: 09 7F              ORA   #$7F              ; set all non sign bits
  7146 00:CE85: 25 5F              AND   FAC1_1            ; AND FAC1 mantissa1 (AND in sign bit)
  7147 00:CE87: 48                 PHA                     ; push on stack
  7148 00:CE88: A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
  7149 00:CE8A: 48                 PHA                     ; push on stack
  7150 00:CE8B: A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
  7151 00:CE8D: 48                 PHA                     ; push on stack
  7152 00:CE8E: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  7153 00:CE90: 48                 PHA                     ; push on stack
  7154                        
  7155 00:CE91: 20 AE CF           JSR   LAB_IGBY          ; scan and get next BASIC byte (after ",")
  7156 00:CE94: 20 6F BA           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
  7157                                                      ; else do type mismatch
  7158                        
  7159                                                      ; pop FAC2 (MAX/MIN expression so far)
  7160 00:CE97: 68                 PLA                     ; pop exponent
  7161 00:CE98: 85 65              STA   FAC2_e            ; save FAC2 exponent
  7162 00:CE9A: 68                 PLA                     ; pop mantissa3
  7163 00:CE9B: 85 68              STA   FAC2_3            ; save FAC2 mantissa3
  7164 00:CE9D: 68                 PLA                     ; pop mantissa1
  7165 00:CE9E: 85 67              STA   FAC2_2            ; save FAC2 mantissa2
  7166 00:CEA0: 68                 PLA                     ; pop sign/mantissa1
  7167 00:CEA1: 85 66              STA   FAC2_1            ; save FAC2 sign/mantissa1
  7168 00:CEA3: 85 69              STA   FAC2_s            ; save FAC2 sign
  7169                        
  7170                                                      ; compare FAC1 with (packed) FAC2
  7171 00:CEA5: A9 65              LDA   #<FAC2_e          ; set pointer low byte to FAC2
  7172 00:CEA7: A0 00              LDY   #>FAC2_e          ; set pointer high byte to FAC2
  7173 00:CEA9: 4C 91 C8           JMP   LAB_27F8          ; compare FAC1 with FAC2 (AY) and return
  7174                                                      ; returns A=$00 if FAC1 = (AY)
  7175                                                      ; returns A=$01 if FAC1 > (AY)
  7176                                                      ; returns A=$FF if FAC1 < (AY)
  Thu Sep 26 2019 15:30                                                                                                    Page 115


  7177                        
  7178                        ; perform WIDTH
  7179                        
  7180                        LAB_WDTH
  7181 00:CEAC: C9 2C              CMP   #','              ; is next byte ","
  7182 00:CEAE: F0 1B              BEQ   LAB_TBSZ          ; if so do tab size
  7183                        
  7184 00:CEB0: 20 15 C4           JSR   LAB_GTBY          ; get byte parameter
  7185 00:CEB3: 8A                 TXA                     ; copy width to A
  7186 00:CEB4: F0 0A              BEQ   LAB_NSTT          ; branch if set for infinite line
  7187                        
  7188 00:CEB6: E0 10              CPX   #$10              ; else make min width = 16d
  7189 00:CEB8: 90 45              BCC   TabErr            ; if less do function call error and exit
  7190                        
  7191                        ; this next compare ensures that we can't exit WIDTH via an error leaving the
  7192                        ; tab size greater than the line length.
  7193                        
  7194 00:CEBA: E4 16              CPX   TabSiz            ; compare with tab size
  7195 00:CEBC: B0 02              BCS   LAB_NSTT          ; branch if >= tab size
  7196                        
  7197 00:CEBE: 86 16              STX   TabSiz            ; else make tab size = terminal width
  7198                        LAB_NSTT
  7199 00:CEC0: 86 08              STX   TWidth            ; set the terminal width
  7200 00:CEC2: 20 B4 CF           JSR   LAB_GBYT          ; get BASIC byte back
  7201 00:CEC5: F0 1A              BEQ   WExit             ; exit if no following
  7202                        
  7203 00:CEC7: C9 2C              CMP   #','              ; else is it ","
  7204 00:CEC9: D0 A9              BNE   LAB_MMSE          ; if not do syntax error
  7205                        
  7206                        LAB_TBSZ
  7207 00:CECB: 20 12 C4           JSR   LAB_SGBY          ; scan and get byte parameter
  7208 00:CECE: 8A                 TXA                     ; copy TAB size
  7209 00:CECF: 30 2E              BMI   TabErr            ; if >127 do function call error and exit
  7210                        
  7211 00:CED1: E0 01              CPX   #$01              ; compare with min-1
  7212 00:CED3: 90 2A              BCC   TabErr            ; if <=1 do function call error and exit
  7213                        
  7214 00:CED5: A5 08              LDA   TWidth            ; set flags for width
  7215 00:CED7: F0 06              BEQ   LAB_SVTB          ; skip check if infinite line
  7216                        
  7217 00:CED9: E4 08              CPX   TWidth            ; compare TAB with width
  7218 00:CEDB: F0 02              BEQ   LAB_SVTB          ; ok if =
  7219 00:CEDD: B0 20              BCS   TabErr            ; branch if too big
  7220                        
  7221                        LAB_SVTB
  7222 00:CEDF: 86 16              STX   TabSiz            ; save TAB size
  7223                        
  7224                        ; calculate tab column limit from TAB size. The Iclim is set to the last tab
  7225                        ; position on a line that still has at least one whole tab width between it
  7226                        ; and the end of the line.
  7227                        
  7228                        WExit
  7229 00:CEE1: A5 08              LDA   TWidth            ; get width
  7230 00:CEE3: F0 06              BEQ   LAB_SULP          ; branch if infinite line
  7231                        
  7232 00:CEE5: C5 16              CMP   TabSiz            ; compare with tab size
  7233 00:CEE7: B0 03              BCS   LAB_WDLP          ; branch if >= tab size
  7234                        
  7235 00:CEE9: 85 16              STA   TabSiz            ; else make tab size = terminal width
  7236                        LAB_SULP
  7237 00:CEEB: 38                 SEC                     ; set carry for subtract
  7238                        LAB_WDLP
  7239 00:CEEC: E5 16              SBC   TabSiz            ; subtract tab size
  Thu Sep 26 2019 15:30                                                                                                    Page 116


  7240 00:CEEE: B0 FC              BCS   LAB_WDLP          ; loop while no borrow
  7241                        
  7242 00:CEF0: 65 16              ADC   TabSiz            ; add tab size back
  7243 00:CEF2: 18                 CLC                     ; clear carry for add
  7244 00:CEF3: 65 16              ADC   TabSiz            ; add tab size back again
  7245 00:CEF5: 85 09              STA   Iclim             ; save for now
  7246 00:CEF7: A5 08              LDA   TWidth            ; get width back
  7247 00:CEF9: 38                 SEC                     ; set carry for subtract
  7248 00:CEFA: E5 09              SBC   Iclim             ; subtract remainder
  7249 00:CEFC: 85 09              STA   Iclim             ; save tab column limit
  7250                        LAB_NOSQ
  7251 00:CEFE: 60                 RTS
  7252                        
  7253                        TabErr
  7254 00:CEFF: 4C BE BE           JMP   LAB_FCER          ; do function call error then warm start
  7255                        
  7256                        ; perform SQR()
  7257                        
  7258                        LAB_SQR
  7259 00:CF02: A5 62              LDA   FAC1_s            ; get FAC1 sign
  7260 00:CF04: 30 F9              BMI   TabErr            ; if -ve do function call error
  7261                        
  7262 00:CF06: A5 5E              LDA   FAC1_e            ; get exponent
  7263 00:CF08: F0 F4              BEQ   LAB_NOSQ          ; if zero just return
  7264                        
  7265                                                      ; else do root
  7266 00:CF0A: 20 48 C8           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
  7267                        
  7268 00:CF0D: 64 29              STZ   FACt_3            ; clear remainder
  7269 00:CF0F: 64 28              STZ   FACt_2            ; ..
  7270 00:CF11: 64 27              STZ   FACt_1            ; ..
  7271 00:CF13: 64 2A              STZ   TempB             ; ..
  7272                        
  7273 00:CF15: 64 61              STZ   FAC1_3            ; clear root
  7274 00:CF17: 64 60              STZ   FAC1_2            ; ..
  7275 00:CF19: 64 5F              STZ   FAC1_1            ; ..
  7276                        
  7277 00:CF1B: A2 18              LDX   #$18              ; 24 pairs of bits to do
  7278 00:CF1D: A5 65              LDA   FAC2_e            ; get exponent
  7279 00:CF1F: 4A                 LSR                     ; check odd/even
  7280 00:CF20: B0 0E              BCS   LAB_SQE2          ; if odd only 1 shift first time
  7281                        
  7282                        LAB_SQE1
  7283 00:CF22: 06 68              ASL   FAC2_3            ; shift highest bit of number ..
  7284 00:CF24: 26 67              ROL   FAC2_2            ; ..
  7285 00:CF26: 26 66              ROL   FAC2_1            ; ..
  7286 00:CF28: 26 29              ROL   FACt_3            ; .. into remainder
  7287 00:CF2A: 26 28              ROL   FACt_2            ; ..
  7288 00:CF2C: 26 27              ROL   FACt_1            ; ..
  7289 00:CF2E: 26 2A              ROL   TempB             ; .. never overflows
  7290                        LAB_SQE2
  7291 00:CF30: 06 68              ASL   FAC2_3            ; shift highest bit of number ..
  7292 00:CF32: 26 67              ROL   FAC2_2            ; ..
  7293 00:CF34: 26 66              ROL   FAC2_1            ; ..
  7294 00:CF36: 26 29              ROL   FACt_3            ; .. into remainder
  7295 00:CF38: 26 28              ROL   FACt_2            ; ..
  7296 00:CF3A: 26 27              ROL   FACt_1            ; ..
  7297 00:CF3C: 26 2A              ROL   TempB             ; .. never overflows
  7298                        
  7299 00:CF3E: 06 61              ASL   FAC1_3            ; root = root * 2
  7300 00:CF40: 26 60              ROL   FAC1_2            ; ..
  7301 00:CF42: 26 5F              ROL   FAC1_1            ; .. never overflows
  7302                        
  Thu Sep 26 2019 15:30                                                                                                    Page 117


  7303 00:CF44: A5 61              LDA   FAC1_3            ; get root low byte
  7304 00:CF46: 2A                 ROL                     ; *2
  7305 00:CF47: 85 0D              STA   Temp3             ; save partial low byte
  7306 00:CF49: A5 60              LDA   FAC1_2            ; get root low mid byte
  7307 00:CF4B: 2A                 ROL                     ; *2
  7308 00:CF4C: 85 0E              STA   Temp3+1           ; save partial low mid byte
  7309 00:CF4E: A5 5F              LDA   FAC1_1            ; get root high mid byte
  7310 00:CF50: 2A                 ROL                     ; *2
  7311 00:CF51: 85 0F              STA   Temp3+2           ; save partial high mid byte
  7312 00:CF53: A9 00              LDA   #$00              ; get root high byte (always $00)
  7313 00:CF55: 2A                 ROL                     ; *2
  7314 00:CF56: 85 10              STA   Temp3+3           ; save partial high byte
  7315                        
  7316                                                      ; carry clear for subtract +1
  7317 00:CF58: A5 29              LDA   FACt_3            ; get remainder low byte
  7318 00:CF5A: E5 0D              SBC   Temp3             ; subtract partial low byte
  7319 00:CF5C: 85 0D              STA   Temp3             ; save partial low byte
  7320                        
  7321 00:CF5E: A5 28              LDA   FACt_2            ; get remainder low mid byte
  7322 00:CF60: E5 0E              SBC   Temp3+1           ; subtract partial low mid byte
  7323 00:CF62: 85 0E              STA   Temp3+1           ; save partial low mid byte
  7324                        
  7325 00:CF64: A5 27              LDA   FACt_1            ; get remainder high mid byte
  7326 00:CF66: E5 0F              SBC   Temp3+2           ; subtract partial high mid byte
  7327 00:CF68: A8                 TAY                     ; copy partial high mid byte
  7328                        
  7329 00:CF69: A5 2A              LDA   TempB             ; get remainder high byte
  7330 00:CF6B: E5 10              SBC   Temp3+3           ; subtract partial high byte
  7331 00:CF6D: 90 0E              BCC   LAB_SQNS          ; skip sub if remainder smaller
  7332                        
  7333 00:CF6F: 85 2A              STA   TempB             ; save remainder high byte
  7334                        
  7335 00:CF71: 84 27              STY   FACt_1            ; save remainder high mid byte
  7336                        
  7337 00:CF73: A5 0E              LDA   Temp3+1           ; get remainder low mid byte
  7338 00:CF75: 85 28              STA   FACt_2            ; save remainder low mid byte
  7339                        
  7340 00:CF77: A5 0D              LDA   Temp3             ; get partial low byte
  7341 00:CF79: 85 29              STA   FACt_3            ; save remainder low byte
  7342                        
  7343 00:CF7B: E6 61              INC   FAC1_3            ; increment root low byte (never any rollover)
  7344                        LAB_SQNS
  7345 00:CF7D: CA                 DEX                     ; decrement bit pair count
  7346 00:CF7E: D0 A2              BNE   LAB_SQE1          ; loop if not all done
  7347                        
  7348 00:CF80: 38                 SEC                     ; set carry for subtract
  7349 00:CF81: A5 65              LDA   FAC2_e            ; get exponent
  7350 00:CF83: E9 80              SBC   #$80              ; normalise
  7351 00:CF85: 6A                 ROR                     ; /2 and re-bias to $80
  7352 00:CF86: 69 00              ADC   #$00              ; add bit zero back in (allow for half shift)
  7353 00:CF88: 85 5E              STA   FAC1_e            ; save it
  7354 00:CF8A: 4C B5 C5           JMP   LAB_24D5          ; normalise FAC1 and return
  7355                        
  7356                        ; perform VARPTR()
  7357                        
  7358                        LAB_VARPTR
  7359 00:CF8D: 20 AE CF           JSR   LAB_IGBY          ; increment and scan memory
  7360 00:CF90: 20 42 BD           JSR   LAB_GVAR          ; get var address
  7361 00:CF93: 20 8F BB           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
  7362 00:CF96: A4 47              LDY   Cvaral            ; get var address low byte
  7363 00:CF98: A5 48              LDA   Cvarah            ; get var address high byte
  7364 00:CF9A: 4C EE BF           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
  7365                        
  Thu Sep 26 2019 15:30                                                                                                    Page 118


  7366                        ; perform PI
  7367                        
  7368                        LAB_PI
  7369 00:CF9D: A9 CC              LDA   #<LAB_2C7C        ; set (2*pi) pointer low byte
  7370 00:CF9F: A0 D0              LDY   #>LAB_2C7C        ; set (2*pi) pointer high byte
  7371 00:CFA1: 20 FB C7           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
  7372 00:CFA4: C6 5E              DEC   FAC1_e            ; make result = PI
  7373 00:CFA6: 60                 RTS
  7374                        
  7375                        ; perform TWOPI
  7376                        
  7377                        LAB_TWOPI
  7378 00:CFA7: A9 CC              LDA   #<LAB_2C7C        ; set (2*pi) pointer low byte
  7379 00:CFA9: A0 D0              LDY   #>LAB_2C7C        ; set (2*pi) pointer high byte
  7380 00:CFAB: 4C FB C7           JMP   LAB_UFAC          ; unpack memory (AY) into FAC1 and return
  7381                        
  7382                        ; character get subroutine - ROM based
  7383                        
  7384                        ; the target address for the LDA at LAB_GBYT is the BASIC execute pointer.
  7385                        ; block is no longer copied to page zero and uses a CMOS instruction/address mode.
  7386                        ; 16-bit pointer is located in page zero.
  7387                        
  7388                        ; increment and scan memory
  7389                        LAB_IGBY
  7390 00:CFAE: E6 6E              INC   Bpntrl            ; increment BASIC execute pointer low byte
  7391 00:CFB0: D0 02              BNE   LAB_GBYT          ; branch if no carry, else
  7392 00:CFB2: E6 6F              INC   Bpntrh            ; increment BASIC execute pointer high byte
  7393                        
  7394                        ; scan memory
  7395                        LAB_GBYT
  7396 00:CFB4: B2 6E              LDA   (Bpntrl)          ; get byte to scan (addr set by call routine)
  7397 00:CFB6: C9 A9              CMP   #TK_ELSE          ; compare with the token for ELSE
  7398 00:CFB8: F0 0E              BEQ   LAB_2D05          ; exit if ELSE, not numeric, carry set
  7399                        
  7400 00:CFBA: C9 3A              CMP   #':'              ; compare with ":"
  7401 00:CFBC: B0 0A              BCS   LAB_2D05          ; exit if >= ":", not numeric, carry set
  7402                        
  7403 00:CFBE: C9 20              CMP   #' '              ; compare with " "
  7404 00:CFC0: F0 EC              BEQ   LAB_IGBY          ; if " " go do next
  7405                        
  7406                        ; changes per Mike Barry, saves a couple clock cycles
  7407 00:CFC2: 49 30              EOR #'0'                ; convert to binary
  7408 00:CFC4: C9 0A              CMP #10                 ; clear carry if decimal digit
  7409 00:CFC6: 49 30              EOR #'0'                ; convert back to ASCII
  7410                        
  7411                        LAB_2D05
  7412 00:CFC8: 60                 RTS
  7413                        
  7414                        LAB_LOAD
  7415                        ; To Load a program you need to start loading at Smeml/h
  7416                        ; then find the end of program (two $00), using Itemp/h,
  7417                        ; then clear other variables and call BASIC cleanup
  7418                        ;
  7419                        ; The variables used by the C02 Monitor are:
  7420                        ; PTRL/H plus set the Block count to 1 and clear the OPXMDM flag
  7421                        ;
  7422                        ; LOAD command
  7423                        
  7424 00:CFC9: A5 2B             LDA     Smeml            ; get start address
  7425 00:CFCB: 85 DA             STA     PTRL             ; put it in XMODEM pointer
  7426 00:CFCD: A5 2C             LDA     Smemh            ;
  7427 00:CFCF: 85 DB             STA     PTRH             ;
  7428                        
  Thu Sep 26 2019 15:30                                                                                                    Page 119


  7429 00:CFD1: A9 01             LDA    #$01              ; get count of one
  7430 00:CFD3: 85 DC             STA    BLKNO             ; set Xmodem block count
  7431 00:CFD5: 64 D6             STZ    OPXMDM            ; clear OPXMDM flag
  7432 00:CFD7: 20 3D D0          JSR    V_LOAD            ; call XMODEM receive vector
  7433                        
  7434                        ; Program loaded into memory, likely padded with $1A from Xmodem protocol
  7435                        ; use get_basmem routine to find the end program memory, then reset the pointers
  7436                        ; and call LAB_1319 to cleanup EhBasic.
  7437                        ; NOTE: Modified routine using OPXMDM Bit7 to indicate a LOAD was done and
  7438                        ; print the Ready message after cleanup.
  7439                        
  7440 00:CFDA: 20 12 D0          JSR     get_basmem       ; find end of program space
  7441 00:CFDD: A5 0A             LDA     Itempl           ; get start of free memory low byte address
  7442 00:CFDF: A4 0B             LDY     Itemph           ; get start of free memory high byte address
  7443 00:CFE1: 85 2D             STA     Svarl            ; and set variables and strings pointers
  7444 00:CFE3: 85 2F             STA     Sarryl           ; to the start of free memory
  7445 00:CFE5: 85 31             STA     Earryl           ;
  7446 00:CFE7: 84 2E             STY     Svarh            ;
  7447 00:CFE9: 84 30             STY     Sarryh           ;
  7448 00:CFEB: 84 32             STY     Earryh           ;
  7449 00:CFED: F7 D6             SMB7    OPXMDM           ; set upper bit in flag (print Ready msg)
  7450 00:CFEF: 4C D9 B1          JMP     LAB_1319         ; cleanup and Return to BASIC
  7451                        
  7452                        LAB_SAVE
  7453                        ; To Save a program you need to save start to end of program
  7454                        ; marked by two consecutive $00.
  7455                        ;
  7456                        ; The Xmodem Save routine in the C02 Monitor expects it's variables
  7457                        ; to be set before making the call via the JMP to V_SAVE.
  7458                        
  7459                        ; The variables used by the C02 Monitor are:
  7460                        ; - Source address (SCRL/H), Length (LENL/H), plus
  7461                        ; - the Block count set to one and the OPXMDM flag cleared.
  7462                        ;
  7463                        ; SAVE command
  7464                        
  7465 00:CFF2: 20 12 D0          JSR    get_basmem        ; find end of program space
  7466 00:CFF5: A6 2B             LDX    Smeml             ;
  7467 00:CFF7: A5 2C             LDA    Smemh             ; get start address of BASIC program
  7468 00:CFF9: 86 C8             STX    SRCL              ;
  7469 00:CFFB: 85 C9             STA    SRCH              ; save in xmodem pointer
  7470                        
  7471 00:CFFD: A5 0A             LDA    Itempl            ; get end of memory low byte
  7472 00:CFFF: 38                SEC                      ; set carry flag for subtract
  7473 00:D000: E5 2B             SBC    Smeml             ; subtract start of memory low byte
  7474 00:D002: 85 CC             STA    LENL              ; store to Monitor length low byte
  7475                        
  7476 00:D004: A5 0B             LDA    Itemph            ; get end of memory high byte
  7477 00:D006: E5 2C             SBC    Smemh             ; subtract start of memory high byte
  7478 00:D008: 85 CD             STA    LENH              ; save to Monitor length high byte
  7479                        
  7480 00:D00A: A9 01             LDA    #$01              ; get count of one
  7481 00:D00C: 85 DC             STA    BLKNO             ; set Xmodem block count
  7482 00:D00E: 64 D6             STZ    OPXMDM            ; clear OPXMDM flag
  7483                        
  7484 00:D010: 80 2E             BRA    V_SAVE            ; call Xmodem SAVE vector and return
  7485                        
  7486                        ; Basic program code links line numbers via the first two bytes of
  7487                        ; the program code starting at (Smeml) pointing to the next line of
  7488                        ; Basic code. The end is marked by two $00 bytes.
  7489                        ;
  7490                        ; This routine, finds the next line of Basic code updates (Itempl)
  7491                        ; and continues to the end of program code and increments (Itempl)
  Thu Sep 26 2019 15:30                                                                                                    Page 120


  7492                        ; by two, which then points to the start of free memory.
  7493                        
  7494                        get_basmem
  7495 00:D012: A5 2B             LDA     Smeml            ; get start address
  7496 00:D014: 85 0A             STA     Itempl           ; and save to
  7497 00:D016: A5 2C             LDA     Smemh            ; temp pointer
  7498 00:D018: 85 0B             STA     Itemph           ; high and low byte
  7499 00:D01A: A0 01             LDY     #$01             ; set Y reg for offset of 1
  7500                        
  7501                        scan_bas
  7502 00:D01C: B2 0A             LDA     (Itempl)         ; get BASIC low byte line address
  7503 00:D01E: AA                TAX                      ; save to X reg (could be next line low address)
  7504 00:D01F: F0 08             BEQ     chk_next         ; if zero, might be end, branch and check
  7505 00:D021: B1 0A             LDA     (Itempl),y       ; else, get high byte line address
  7506                        upd_bas
  7507 00:D023: 85 0B             STA     Itemph           ; update high byte line address
  7508 00:D025: 86 0A             STX     Itempl           ; update low byte line address
  7509 00:D027: 80 F3             BRA     scan_bas         ; loop back to find next line
  7510                        
  7511                        chk_next
  7512 00:D029: B1 0A             LDA     (Itempl),y       ; get next byte
  7513 00:D02B: D0 F6             BNE     upd_bas          ; if non-zero, branch to update line address
  7514                        
  7515 00:D02D: 20 30 D0          JSR     inc_line         ; else increment line address twice
  7516                        inc_line
  7517 00:D030: E6 0A             INC     Itempl           ; increment low byte count
  7518 00:D032: D0 02             BNE     skp_ith          ; if not zero, skip high byte increment
  7519 00:D034: E6 0B             INC     Itemph           ; increment low byte count
  7520                        skp_ith
  7521 00:D036: 60                RTS                      ; return to caller
  7522                        
  7523                        ; system dependant i/o vectors
  7524                        ; these are in RAM and are set by the monitor at start-up
  7525                        
  7526                        V_INPT
  7527 00:D037: 6C 84 04           JMP   (VEC_IN)          ; non halting scan input device
  7528                        V_OUTP
  7529 00:D03A: 6C 86 04           JMP   (VEC_OUT)         ; send byte to output device
  7530                        V_LOAD
  7531 00:D03D: 6C 88 04           JMP   (VEC_LD)          ; load BASIC program
  7532                        V_SAVE
  7533 00:D040: 6C 8A 04           JMP   (VEC_SV)          ; save BASIC program
  7534                        V_EXIT
  7535 00:D043: 6C 8C 04           JMP   (VEC_EXIT)        ; warm start C02 Monitor
  7536                        
  7537                        ; The rest are tables messages and code for RAM
  7538                        
  7539                        ; the rest of the code is tables and BASIC start-up code
  7540                        ; monitor routines required are added below for initialization
  7541                        
  7542                        PG4_TABS
  7543 00:D046: 00                 .byte $00               ; ctrl-c flag - $00 = enabled
  7544 00:D047: 00                 .byte $00               ; ctrl-c byte - GET needs this
  7545 00:D048: 00                 .byte $00               ; ctrl-c byte timeout - GET needs this
  7546 00:D049: 13 CE              .word CTRLC             ; ctrl c check vector
  7547                        ;
  7548 00:D04B: 36 FF              .word $FF36             ; byte in from C02BIOS (no waiting)
  7549 00:D04D: 3C FF              .word $FF3C             ; byte out from C02BIOS
  7550                        
  7551 00:D04F: 15 E0              .word $E015             ; Xmodem LOAD for C02 Monitor
  7552 00:D051: 12 E0              .word $E012             ; Xmodem SAVE for C02 Monitor
  7553 00:D053: 03 E0              .word $E003             ; Warm start for C02 Monitor
  7554                        
  Thu Sep 26 2019 15:30                                                                                                    Page 121


  7555                        PG4_TABE
  7556                        
  7557                        ; page zero initialisation table $00-$0B inclusive
  7558                        
  7559                        StrTab
  7560 00:D055: 4C                 .byte $4C               ; JMP opcode
  7561 00:D056: 00 B0              .word LAB_COLD          ; initial warm start vector (cold start)
  7562                        
  7563 00:D058: 4C                 .byte $4C               ; JMP opcode
  7564 00:D059: BE BE              .word LAB_FCER          ; initial user function vector ("Function call" error)
  7565                        
  7566 00:D05B: 00                 .byte $00               ; default NULL count
  7567 00:D05C: 00                 .byte $00               ; clear terminal position
  7568 00:D05D: 50                 .byte $50               ; default terminal width byte = 80
  7569 00:D05E: F2                 .byte $F2               ; default limit for TAB = 14
  7570 00:D05F: 00 08              .word Ram_base          ; start of user RAM
  7571                        EndTab
  7572                        
  7573                        LAB_SMSG
  7574 00:D061: 20 42 79 74        .byte " Bytes free",$00
       00:D065: 65 73 20 66 
       00:D069: 72 65 65 00 
  7575                        
  7576                        ; numeric constants and series
  7577                        ; cleaned up to removed commented lines which were replaced
  7578                        
  7579                                                      ; constants and series for LOG(n)
  7580                        LAB_25A0
  7581 00:D06D: 02                 .byte $02               ; counter
  7582 00:D06E: 80 19 56 62        .byte $80,$19,$56,$62   ; 0.59898
  7583 00:D072: 80 76 22 F3        .byte $80,$76,$22,$F3   ; 0.96147
  7584 00:D076: 82 38 AA 40        .byte $82,$38,$AA,$40   ; 2.88539
  7585                        
  7586                        LAB_25AD
  7587 00:D07A: 80 35 04 F3        .byte $80,$35,$04,$F3   ; 0.70711   1/root 2
  7588                        LAB_25B1
  7589 00:D07E: 81 35 04 F3        .byte $81,$35,$04,$F3   ; 1.41421   root 2
  7590                        LAB_25B5
  7591 00:D082: 80 80 00 00        .byte $80,$80,$00,$00   ; -0.5
  7592                        LAB_25B9
  7593 00:D086: 80 31 72 18        .byte $80,$31,$72,$18   ; 0.69315   LOG(2)
  7594                        
  7595                                                      ; numeric PRINT constants
  7596                        LAB_2947
  7597 00:D08A: 91 43 4F F8        .byte $91,$43,$4F,$F8   ; 99999.9375 (max value with at least one decimal)
  7598                        LAB_294B
  7599 00:D08E: 94 74 23 F7        .byte $94,$74,$23,$F7   ; 999999.4375 (max value before scientific notation)
  7600                        LAB_294F
  7601 00:D092: 94 74 24 00        .byte $94,$74,$24,$00   ; 1000000
  7602                        
  7603                                                      ; EXP(n) constants and series
  7604                        LAB_2AFA
  7605 00:D096: 81 38 AA 3B        .byte $81,$38,$AA,$3B   ; 1.4427 (1/LOG base 2 e)
  7606                        LAB_2AFE
  7607 00:D09A: 06                 .byte $06               ; counter
  7608 00:D09B: 74 63 90 8C        .byte $74,$63,$90,$8C   ; 2.17023e-4
  7609 00:D09F: 77 23 0C AB        .byte $77,$23,$0C,$AB   ; 0.00124
  7610 00:D0A3: 7A 1E 94 00        .byte $7A,$1E,$94,$00   ; 0.00968
  7611 00:D0A7: 7C 63 42 80        .byte $7C,$63,$42,$80   ; 0.05548
  7612 00:D0AB: 7E 75 FE D0        .byte $7E,$75,$FE,$D0   ; 0.24023
  7613 00:D0AF: 80 31 72 15        .byte $80,$31,$72,$15   ; 0.69315
  7614 00:D0B3: 81 00 00 00        .byte $81,$00,$00,$00   ; 1.00000
  7615                        
  Thu Sep 26 2019 15:30                                                                                                    Page 122


  7616                                                      ; trigonometric constants and series
  7617                        LAB_2C78
  7618 00:D0B7: 81 49 0F DB        .byte $81,$49,$0F,$DB   ; 1.570796371 (pi/2) as floating #
  7619                        LAB_2C84
  7620 00:D0BB: 04                 .byte $04               ; counter
  7621 00:D0BC: 86 1E D7 FB        .byte $86,$1E,$D7,$FB   ; 39.7109
  7622 00:D0C0: 87 99 26 65        .byte $87,$99,$26,$65   ;-76.575
  7623 00:D0C4: 87 23 34 58        .byte $87,$23,$34,$58   ; 81.6022
  7624 00:D0C8: 86 A5 5D E1        .byte $86,$A5,$5D,$E1   ;-41.3417
  7625                        LAB_2C7C
  7626 00:D0CC: 83 49 0F DB        .byte $83,$49,$0F,$DB   ; 6.28319 (2*pi) as floating #
  7627                        
  7628                        LAB_2CC9
  7629 00:D0D0: 08                 .byte $08               ; counter
  7630 00:D0D1: 78 3A C5 37        .byte $78,$3A,$C5,$37   ; 0.00285
  7631 00:D0D5: 7B 83 A2 5C        .byte $7B,$83,$A2,$5C   ;-0.0160686
  7632 00:D0D9: 7C 2E DD 4D        .byte $7C,$2E,$DD,$4D   ; 0.0426915
  7633 00:D0DD: 7D 99 B0 1E        .byte $7D,$99,$B0,$1E   ;-0.0750429
  7634 00:D0E1: 7D 59 ED 24        .byte $7D,$59,$ED,$24   ; 0.106409
  7635 00:D0E5: 7E 91 72 00        .byte $7E,$91,$72,$00   ;-0.142036
  7636 00:D0E9: 7E 4C B9 73        .byte $7E,$4C,$B9,$73   ; 0.199926
  7637 00:D0ED: 7F AA AA 53        .byte $7F,$AA,$AA,$53   ;-0.333331
  7638                        
  7639             0000D0F2   LAB_1D96    .EQU *+1          ; $00,$00 used for undefined variables
  7640                        LAB_259C
  7641 00:D0F1: 81 00 00 00        .byte $81,$00,$00,$00   ; 1.000000, used for INC
  7642                        LAB_2AFD
  7643 00:D0F5: 81 80 00 00        .byte $81,$80,$00,$00   ; -1.00000, used for DEC, must be on the same page as +1.00
  7644                        
  7645                                                      ; misc constants
  7646                        LAB_1DF7
  7647 00:D0F9: 90                 .byte $90               ;-32768 (uses first three bytes from 0.5)
  7648                        LAB_2A96
  7649 00:D0FA: 80 00 00 00        .byte $80,$00,$00,$00   ; 0.5
  7650                        LAB_2C80
  7651 00:D0FE: 7F 00 00 00        .byte $7F,$00,$00,$00   ; 0.25
  7652                        LAB_26B5
  7653 00:D102: 84 20 00 00        .byte $84,$20,$00,$00   ; 10.0000 divide by 10 constant
  7654                        
  7655                        ; This table is used in converting numbers to ASCII.
  7656                        
  7657                        LAB_2A9A
  7658             0000D107   LAB_2A9B .EQU LAB_2A9A+1
  7659             0000D108   LAB_2A9C .EQU LAB_2A9B+1
  7660 00:D106: FE 79 60           .byte $FE,$79,$60       ; -100000
  7661 00:D109: 00 27 10           .byte $00,$27,$10       ; 10000
  7662 00:D10C: FF FC 18           .byte $FF,$FC,$18       ; -1000
  7663 00:D10F: 00 00 64           .byte $00,$00,$64       ; 100
  7664 00:D112: FF FF F6           .byte $FF,$FF,$F6       ; -10
  7665 00:D115: 00 00 01           .byte $00,$00,$01       ; 1
  7666                        
  7667                        LAB_CTBL
  7668 00:D118: E4 B4              .word LAB_END-1         ; END
  7669 00:D11A: 26 B4              .word LAB_FOR-1         ; FOR
  7670 00:D11C: 06 BA              .word LAB_NEXT-1        ; NEXT
  7671 00:D11E: 47 B6              .word LAB_DATA-1        ; DATA
  7672 00:D120: EC B8              .word LAB_INPUT-1       ; INPUT
  7673 00:D122: F6 BC              .word LAB_DIM-1         ; DIM
  7674 00:D124: 0B B9              .word LAB_READ-1        ; READ
  7675 00:D126: 62 B7              .word LAB_LET-1         ; LET
  7676 00:D128: 34 B7              .word LAB_DEC-1         ; DEC new command
  7677 00:D12A: A6 B5              .word LAB_GOTO-1        ; GOTO
  7678 00:D12C: 65 B5              .word LAB_RUN-1         ; RUN
  Thu Sep 26 2019 15:30                                                                                                    Page 123


  7679 00:D12E: 76 B6              .word LAB_IF-1          ; IF
  7680 00:D130: 05 B5              .word LAB_RESTORE-1     ; RESTORE modified command
  7681 00:D132: 89 B5              .word LAB_GOSUB-1       ; GOSUB
  7682 00:D134: 32 B6              .word LAB_RETURN-1      ; RETURN
  7683 00:D136: DB B6              .word LAB_REM-1         ; REM
  7684 00:D138: E2 B4              .word LAB_STOP-1        ; STOP
  7685 00:D13A: E4 B6              .word LAB_ON-1          ; ON modified command
  7686 00:D13C: 43 B5              .word LAB_NULL-1        ; NULL modified command
  7687 00:D13E: 38 B7              .word LAB_INC-1         ; INC new command
  7688 00:D140: 0E C5              .word LAB_WAIT-1        ; WAIT
  7689 00:D142: C8 CF              .word LAB_LOAD-1        ; LOAD
  7690 00:D144: F1 CF              .word LAB_SAVE-1        ; SAVE
  7691 00:D146: 08 C0              .word LAB_DEF-1         ; DEF
  7692 00:D148: 93 C4              .word LAB_POKE-1        ; POKE
  7693 00:D14A: AF C4              .word LAB_DOKE-1        ; DOKE new command
  7694 00:D14C: FC C4              .word LAB_CALL-1        ; CALL new command
  7695 00:D14E: 6F B5              .word LAB_DO-1          ; DO new command
  7696 00:D150: D8 B5              .word LAB_LOOP-1        ; LOOP new command
  7697 00:D152: FD B7              .word LAB_PRINT-1       ; PRINT
  7698 00:D154: 49 B5              .word LAB_CONT-1        ; CONT
  7699 00:D156: 71 B3              .word LAB_LIST-1        ; LIST
  7700 00:D158: 6E B3              .word LAB_CLEAR-1       ; CLEAR
  7701 00:D15A: 21 B3              .word LAB_NEW-1         ; NEW
  7702 00:D15C: AB CE              .word LAB_WDTH-1        ; WIDTH new command
  7703 00:D15E: CF B7              .word LAB_GET-1         ; GET new command
  7704 00:D160: D4 C4              .word LAB_SWAP-1        ; SWAP new command
  7705 00:D162: EA CC              .word LAB_BITSET-1      ; BITSET new command
  7706 00:D164: FE CC              .word LAB_BITCLR-1      ; BITCLR new command
  7707 00:D166: 42 D0              .word V_EXIT-1          ; EXIT new command (exits to C02 Monitor)
  7708                        
  7709                        ; function pre process routine table
  7710                        
  7711                        LAB_FTPL
  7712             0000D169   LAB_FTPM    .EQU LAB_FTPL+$01
  7713 00:D168: 01 BC              .word LAB_PPFN-1        ; SGN(n)    process numeric expression in ()
  7714 00:D16A: 01 BC              .word LAB_PPFN-1        ; INT(n)          "
  7715 00:D16C: 01 BC              .word LAB_PPFN-1        ; ABS(n)          "
  7716 00:D16E: 8B BA              .word LAB_EVEZ-1        ; USR(x)    process any expression
  7717 00:D170: 8B BB              .word LAB_1BF7-1        ; FRE(x)          "
  7718 00:D172: 8B BB              .word LAB_1BF7-1        ; POS(x)          "
  7719 00:D174: 01 BC              .word LAB_PPFN-1        ; SQR(n)    process numeric expression in ()
  7720 00:D176: 01 BC              .word LAB_PPFN-1        ; RND(n)          "
  7721 00:D178: 01 BC              .word LAB_PPFN-1        ; LOG(n)          "
  7722 00:D17A: 01 BC              .word LAB_PPFN-1        ; EXP(n)          "
  7723 00:D17C: 01 BC              .word LAB_PPFN-1        ; COS(n)          "
  7724 00:D17E: 01 BC              .word LAB_PPFN-1        ; SIN(n)          "
  7725 00:D180: 01 BC              .word LAB_PPFN-1        ; TAN(n)          "
  7726 00:D182: 01 BC              .word LAB_PPFN-1        ; ATN(n)          "
  7727 00:D184: 01 BC              .word LAB_PPFN-1        ; PEEK(n)         "
  7728 00:D186: 01 BC              .word LAB_PPFN-1        ; DEEK(n)         "
  7729 00:D188: 00 00              .word $0000             ; SADD()    none
  7730 00:D18A: FB BB              .word LAB_PPFS-1        ; LEN($)    process string expression in ()
  7731 00:D18C: 01 BC              .word LAB_PPFN-1        ; STR$(n)   process numeric expression in ()
  7732 00:D18E: FB BB              .word LAB_PPFS-1        ; VAL($)    process string expression in ()
  7733 00:D190: FB BB              .word LAB_PPFS-1        ; ASC($)          "
  7734 00:D192: FB BB              .word LAB_PPFS-1        ; UCASE$($)       "
  7735 00:D194: FB BB              .word LAB_PPFS-1        ; LCASE$($)       "
  7736 00:D196: 01 BC              .word LAB_PPFN-1        ; CHR$(n)   process numeric expression in ()
  7737 00:D198: 24 BC              .word LAB_BHSS-1        ; HEX$(n)         "
  7738 00:D19A: 24 BC              .word LAB_BHSS-1        ; BIN$(n)         "
  7739 00:D19C: 00 00              .word $0000             ; BITTST()  none
  7740 00:D19E: 42 CE              .word LAB_MMPP-1        ; MAX()     process numeric expression
  7741 00:D1A0: 42 CE              .word LAB_MMPP-1        ; MIN()           "
  Thu Sep 26 2019 15:30                                                                                                    Page 124


  7742 00:D1A2: 07 BC              .word LAB_PPBI-1        ; PI        advance pointer
  7743 00:D1A4: 07 BC              .word LAB_PPBI-1        ; TWOPI           "
  7744 00:D1A6: 00 00              .word $0000             ; VARPTR()  none
  7745 00:D1A8: 0C BC              .word LAB_LRMS-1        ; LEFT$()   process string expression
  7746 00:D1AA: 0C BC              .word LAB_LRMS-1        ; RIGHT$()        "
  7747 00:D1AC: 0C BC              .word LAB_LRMS-1        ; MID$()          "
  7748                        
  7749                        ; action addresses for functions
  7750                        
  7751                        LAB_FTBL
  7752             0000D1AF   LAB_FTBM    .EQU LAB_FTBL+$01
  7753 00:D1AE: 74 C8              .word LAB_SGN-1         ; SGN()
  7754 00:D1B0: F9 C8              .word LAB_INT-1         ; INT()
  7755 00:D1B2: 8D C8              .word LAB_ABS-1         ; ABS()
  7756 00:D1B4: B5 CC              .word LAB_USR-1         ; USR()
  7757 00:D1B6: D9 BF              .word LAB_FRE-1         ; FRE()
  7758 00:D1B8: F8 BF              .word LAB_POS-1         ; POS()
  7759 00:D1BA: 01 CF              .word LAB_SQR-1         ; SQR()
  7760 00:D1BC: 0C CC              .word LAB_RND-1         ; RND() modified function
  7761 00:D1BE: 7B C6              .word LAB_LOG-1         ; LOG()
  7762 00:D1C0: 70 CB              .word LAB_EXP-1         ; EXP()
  7763 00:D1C2: 40 CC              .word LAB_COS-1         ; COS()
  7764 00:D1C4: 47 CC              .word LAB_SIN-1         ; SIN()
  7765 00:D1C6: 8E CC              .word LAB_TAN-1         ; TAN()
  7766 00:D1C8: BB CC              .word LAB_ATN-1         ; ATN()
  7767 00:D1CA: 88 C4              .word LAB_PEEK-1        ; PEEK()
  7768 00:D1CC: 9C C4              .word LAB_DEEK-1        ; DEEK() new function
  7769 00:D1CE: DF C3              .word LAB_SADD-1        ; SADD() new function
  7770 00:D1D0: F8 C3              .word LAB_LENS-1        ; LEN()
  7771 00:D1D2: B8 C0              .word LAB_STRS-1        ; STR$()
  7772 00:D1D4: 23 C4              .word LAB_VAL-1         ; VAL()
  7773 00:D1D6: 03 C4              .word LAB_ASC-1         ; ASC()
  7774 00:D1D8: BD C3              .word LAB_UCASE-1       ; UCASE$() new function
  7775 00:D1DA: 9C C3              .word LAB_LCASE-1       ; LCASE$()  new function
  7776 00:D1DC: 13 C3              .word LAB_CHRS-1        ; CHR$()
  7777 00:D1DE: 8B CD              .word LAB_HEXS-1        ; HEX$() new function
  7778 00:D1E0: 3C CD              .word LAB_BINS-1        ; BIN$() new function
  7779 00:D1E2: 14 CD              .word LAB_BTST-1        ; BITTST() new function
  7780 00:D1E4: 48 CE              .word LAB_MAX-1         ; MAX() new function
  7781 00:D1E6: 58 CE              .word LAB_MIN-1         ; MIN() new function
  7782 00:D1E8: 9C CF              .word LAB_PI-1          ; PI new function
  7783 00:D1EA: A6 CF              .word LAB_TWOPI-1       ; TWOPI new function
  7784 00:D1EC: 8C CF              .word LAB_VARPTR-1      ; VARPTR() new function
  7785 00:D1EE: 22 C3              .word LAB_LEFT-1        ; LEFT$()
  7786 00:D1F0: 2B C3              .word LAB_RIGHT-1       ; RIGHT$()
  7787 00:D1F2: 59 C3              .word LAB_MIDS-1        ; MID$()
  7788                        
  7789                        ; hierarchy and action addresses for operator
  7790                        
  7791                        LAB_OPPT
  7792 00:D1F4: 79                 .byte $79               ; +
  7793 00:D1F5: 45 C5              .word LAB_ADD-1
  7794 00:D1F7: 79                 .byte $79               ; -
  7795 00:D1F8: 2B C5              .word LAB_SUBTRACT-1
  7796 00:D1FA: 7B                 .byte $7B               ; *
  7797 00:D1FB: BC C6              .word LAB_MULTIPLY-1
  7798 00:D1FD: 7B                 .byte $7B               ; /
  7799 00:D1FE: 82 C7              .word LAB_DIVIDE-1
  7800 00:D200: 7F                 .byte $7F               ; ^
  7801 00:D201: 2C CB              .word LAB_POWER-1
  7802 00:D203: 50                 .byte $50               ; AND
  7803 00:D204: 6D BC              .word LAB_AND-1
  7804 00:D206: 46                 .byte $46               ; EOR new operator
  Thu Sep 26 2019 15:30                                                                                                    Page 125


  7805 00:D207: 53 BC              .word LAB_EOR-1
  7806 00:D209: 46                 .byte $46               ; OR
  7807 00:D20A: 60 BC              .word LAB_OR-1
  7808 00:D20C: 56                 .byte $56               ; >> new operator
  7809 00:D20D: 18 BD              .word LAB_RSHIFT-1
  7810 00:D20F: 56                 .byte $56               ; << new operator
  7811 00:D210: 00 BD              .word LAB_LSHIFT-1
  7812 00:D212: 7D                 .byte $7D               ; >
  7813 00:D213: 65 CB              .word LAB_GTHAN-1
  7814 00:D215: 5A                 .byte $5A               ; =
  7815 00:D216: B4 BB              .word LAB_EQUAL-1
  7816 00:D218: 64                 .byte $64               ; <
  7817 00:D219: 8E BC              .word LAB_LTHAN-1
  7818                        
  7819                        ; keywords start with ..
  7820                        ; this is the first character table and must be in alphabetic order
  7821                        
  7822                        TAB_1STC
  7823 00:D21B: 2A                 .byte "*"
  7824 00:D21C: 2B                 .byte "+"
  7825 00:D21D: 2D                 .byte "-"
  7826 00:D21E: 2F                 .byte "/"
  7827 00:D21F: 3C                 .byte "<"
  7828 00:D220: 3D                 .byte "="
  7829 00:D221: 3E                 .byte ">"
  7830 00:D222: 3F                 .byte "?"
  7831 00:D223: 41                 .byte "A"
  7832 00:D224: 42                 .byte "B"
  7833 00:D225: 43                 .byte "C"
  7834 00:D226: 44                 .byte "D"
  7835 00:D227: 45                 .byte "E"
  7836 00:D228: 46                 .byte "F"
  7837 00:D229: 47                 .byte "G"
  7838 00:D22A: 48                 .byte "H"
  7839 00:D22B: 49                 .byte "I"
  7840 00:D22C: 4C                 .byte "L"
  7841 00:D22D: 4D                 .byte "M"
  7842 00:D22E: 4E                 .byte "N"
  7843 00:D22F: 4F                 .byte "O"
  7844 00:D230: 50                 .byte "P"
  7845 00:D231: 52                 .byte "R"
  7846 00:D232: 53                 .byte "S"
  7847 00:D233: 54                 .byte "T"
  7848 00:D234: 55                 .byte "U"
  7849 00:D235: 56                 .byte "V"
  7850 00:D236: 57                 .byte "W"
  7851 00:D237: 5E                 .byte "^"
  7852 00:D238: 00                 .byte $00               ; table terminator
  7853                        
  7854                        ; pointers to keyword tables
  7855                        
  7856                        TAB_CHRT
  7857 00:D239: 73 D2              .word TAB_STAR          ; table for "*"
  7858 00:D23B: 75 D2              .word TAB_PLUS          ; table for "+"
  7859 00:D23D: 77 D2              .word TAB_MNUS          ; table for "-"
  7860 00:D23F: 79 D2              .word TAB_SLAS          ; table for "/"
  7861 00:D241: 7B D2              .word TAB_LESS          ; table for "<"
  7862 00:D243: 7F D2              .word TAB_EQUL          ; table for "="
  7863 00:D245: 81 D2              .word TAB_MORE          ; table for ">"
  7864 00:D247: 85 D2              .word TAB_QEST          ; table for "?"
  7865 00:D249: 87 D2              .word TAB_ASCA          ; table for "A"
  7866 00:D24B: 97 D2              .word TAB_ASCB          ; table for "B"
  7867 00:D24D: B0 D2              .word TAB_ASCC          ; table for "C"
  Thu Sep 26 2019 15:30                                                                                                    Page 126


  7868 00:D24F: C7 D2              .word TAB_ASCD          ; table for "D"
  7869 00:D251: E0 D2              .word TAB_ASCE          ; table for "E"
  7870 00:D253: F3 D2              .word TAB_ASCF          ; table for "F"
  7871 00:D255: FD D2              .word TAB_ASCG          ; table for "G"
  7872 00:D257: 0A D3              .word TAB_ASCH          ; table for "H"
  7873 00:D259: 10 D3              .word TAB_ASCI          ; table for "I"
  7874 00:D25B: 1F D3              .word TAB_ASCL          ; table for "L"
  7875 00:D25D: 44 D3              .word TAB_ASCM          ; table for "M"
  7876 00:D25F: 52 D3              .word TAB_ASCN          ; table for "N"
  7877 00:D261: 61 D3              .word TAB_ASCO          ; table for "O"
  7878 00:D263: 66 D3              .word TAB_ASCP          ; table for "P"
  7879 00:D265: 7B D3              .word TAB_ASCR          ; table for "R"
  7880 00:D267: 9E D3              .word TAB_ASCS          ; table for "S"
  7881 00:D269: C9 D3              .word TAB_ASCT          ; table for "T"
  7882 00:D26B: DD D3              .word TAB_ASCU          ; table for "U"
  7883 00:D26D: EE D3              .word TAB_ASCV          ; table for "V"
  7884 00:D26F: FA D3              .word TAB_ASCW          ; table for "W"
  7885 00:D271: 09 D4              .word TAB_POWR          ; table for "^"
  7886                        
  7887                        ; tables for each start character, note if a longer keyword with the same start
  7888                        ; letters as a shorter one exists then it must come first, else the list is in
  7889                        ; alphabetical order as follows ..
  7890                        
  7891                        ; [keyword,token
  7892                        ; [keyword,token]]
  7893                        ; end marker (#$00)
  7894                        
  7895                        TAB_STAR
  7896 00:D273: B4 00              .byte TK_MUL,$00        ; *
  7897                        TAB_PLUS
  7898 00:D275: B2 00              .byte TK_PLUS,$00       ; +
  7899                        TAB_MNUS
  7900 00:D277: B3 00              .byte TK_MINUS,$00      ; -
  7901                        TAB_SLAS
  7902 00:D279: B5 00              .byte TK_DIV,$00        ; /
  7903                        TAB_LESS
  7904                        LBB_LSHIFT
  7905 00:D27B: 3C BB              .byte "<",TK_LSHIFT     ; <<  note - "<<" must come before "<"
  7906 00:D27D: BE                 .byte TK_LT             ; <
  7907 00:D27E: 00                 .byte $00
  7908                        TAB_EQUL
  7909 00:D27F: BD 00              .byte TK_EQUAL,$00      ; =
  7910                        TAB_MORE
  7911                        LBB_RSHIFT
  7912 00:D281: 3E BA              .byte ">",TK_RSHIFT     ; >>  note - ">>" must come before ">"
  7913 00:D283: BC                 .byte TK_GT             ; >
  7914 00:D284: 00                 .byte $00
  7915                        TAB_QEST
  7916 00:D285: 9D 00              .byte TK_PRINT,$00      ; ?
  7917                        TAB_ASCA
  7918                        LBB_ABS
  7919 00:D287: 42 53 28 C1        .byte "BS(",TK_ABS      ; ABS(
  7920                        LBB_AND
  7921 00:D28B: 4E 44 B7           .byte "ND",TK_AND       ; AND
  7922                        LBB_ASC
  7923 00:D28E: 53 43 28 D3        .byte "SC(",TK_ASC      ; ASC(
  7924                        LBB_ATN
  7925 00:D292: 54 4E 28 CC        .byte "TN(",TK_ATN      ; ATN(
  7926 00:D296: 00                 .byte $00
  7927                        TAB_ASCB
  7928                        LBB_BINS
  7929 00:D297: 49 4E 24 28        .byte "IN$(",TK_BINS    ; BIN$(
       00:D29B: D8 
  Thu Sep 26 2019 15:30                                                                                                    Page 127


  7930                        LBB_BITCLR
  7931 00:D29C: 49 54 43 4C        .byte "ITCLR",TK_BITCLR ; BITCLR
       00:D2A0: 52 A6 
  7932                        LBB_BITSET
  7933 00:D2A2: 49 54 53 45        .byte "ITSET",TK_BITSET ; BITSET
       00:D2A6: 54 A5 
  7934                        LBB_BITTST
  7935 00:D2A8: 49 54 54 53        .byte "ITTST(",TK_BITTST
       00:D2AC: 54 28 D9 
  7936                                                      ; BITTST(
  7937 00:D2AF: 00                 .byte $00
  7938                        TAB_ASCC
  7939                        LBB_CALL
  7940 00:D2B0: 41 4C 4C 9A        .byte "ALL",TK_CALL     ; CALL
  7941                        LBB_CHRS
  7942 00:D2B4: 48 52 24 28        .byte "HR$(",TK_CHRS    ; CHR$(
       00:D2B8: D6 
  7943                        LBB_CLEAR
  7944 00:D2B9: 4C 45 41 52        .byte "LEAR",TK_CLEAR   ; CLEAR
       00:D2BD: A0 
  7945                        LBB_CONT
  7946 00:D2BE: 4F 4E 54 9E        .byte "ONT",TK_CONT     ; CONT
  7947                        LBB_COS
  7948 00:D2C2: 4F 53 28 C9        .byte "OS(",TK_COS      ; COS(
  7949 00:D2C6: 00                 .byte $00
  7950                        TAB_ASCD
  7951                        LBB_DATA
  7952 00:D2C7: 41 54 41 83        .byte "ATA",TK_DATA     ; DATA
  7953                        LBB_DEC
  7954 00:D2CB: 45 43 88           .byte "EC",TK_DEC       ; DEC
  7955                        LBB_DEEK
  7956 00:D2CE: 45 45 4B 28        .byte "EEK(",TK_DEEK    ; DEEK(
       00:D2D2: CE 
  7957                        LBB_DEF
  7958 00:D2D3: 45 46 97           .byte "EF",TK_DEF       ; DEF
  7959                        LBB_DIM
  7960 00:D2D6: 49 4D 85           .byte "IM",TK_DIM       ; DIM
  7961                        LBB_DOKE
  7962 00:D2D9: 4F 4B 45 99        .byte "OKE",TK_DOKE     ; DOKE note - "DOKE" must come before "DO"
  7963                        LBB_DO
  7964 00:D2DD: 4F 9B              .byte "O",TK_DO         ; DO
  7965 00:D2DF: 00                 .byte $00
  7966                        TAB_ASCE
  7967                        LBB_ELSE
  7968 00:D2E0: 4C 53 45 A9        .byte "LSE",TK_ELSE     ; ELSE
  7969                        LBB_END
  7970 00:D2E4: 4E 44 80           .byte "ND",TK_END       ; END
  7971                        LBB_EOR
  7972 00:D2E7: 4F 52 B8           .byte "OR",TK_EOR       ; EOR
  7973                        LBB_EXP
  7974 00:D2EA: 58 50 28 C8        .byte "XP(",TK_EXP      ; EXP(
  7975                        LBB_EXIT
  7976 00:D2EE: 58 49 54 A7        .byte "XIT",TK_EXIT     ; EXIT
  7977 00:D2F2: 00                 .byte $00
  7978                        TAB_ASCF
  7979                        LBB_FN
  7980 00:D2F3: 4E AB              .byte "N",TK_FN         ; FN
  7981                        LBB_FOR
  7982 00:D2F5: 4F 52 81           .byte "OR",TK_FOR       ; FOR
  7983                        LBB_FRE
  7984 00:D2F8: 52 45 28 C3        .byte "RE(",TK_FRE      ; FRE(
  7985 00:D2FC: 00                 .byte $00
  7986                        TAB_ASCG
  Thu Sep 26 2019 15:30                                                                                                    Page 128


  7987                        LBB_GET
  7988 00:D2FD: 45 54 A3           .byte "ET",TK_GET       ; GET
  7989                        LBB_GOSUB
  7990 00:D300: 4F 53 55 42        .byte "OSUB",TK_GOSUB   ; GOSUB
       00:D304: 8D 
  7991                        LBB_GOTO
  7992 00:D305: 4F 54 4F 89        .byte "OTO",TK_GOTO     ; GOTO
  7993 00:D309: 00                 .byte $00
  7994                        TAB_ASCH
  7995                        LBB_HEXS
  7996 00:D30A: 45 58 24 28        .byte "EX$(",TK_HEXS    ; HEX$(
       00:D30E: D7 
  7997 00:D30F: 00                 .byte $00
  7998                        TAB_ASCI
  7999                        LBB_IF
  8000 00:D310: 46 8B              .byte "F",TK_IF         ; IF
  8001                        LBB_INC
  8002 00:D312: 4E 43 93           .byte "NC",TK_INC       ; INC
  8003                        LBB_INPUT
  8004 00:D315: 4E 50 55 54        .byte "NPUT",TK_INPUT   ; INPUT
       00:D319: 84 
  8005                        LBB_INT
  8006 00:D31A: 4E 54 28 C0        .byte "NT(",TK_INT      ; INT(
  8007 00:D31E: 00                 .byte $00
  8008                        TAB_ASCL
  8009                        LBB_LCASES
  8010 00:D31F: 43 41 53 45        .byte "CASE$(",TK_LCASES
       00:D323: 24 28 D5 
  8011                                                      ; LCASE$(
  8012                        LBB_LEFTS
  8013 00:D326: 45 46 54 24        .byte "EFT$(",TK_LEFTS  ; LEFT$(
       00:D32A: 28 DF 
  8014                        LBB_LEN
  8015 00:D32C: 45 4E 28 D0        .byte "EN(",TK_LEN      ; LEN(
  8016                        LBB_LET
  8017 00:D330: 45 54 87           .byte "ET",TK_LET       ; LET
  8018                        LBB_LIST
  8019 00:D333: 49 53 54 9F        .byte "IST",TK_LIST     ; LIST
  8020                        LBB_LOAD
  8021 00:D337: 4F 41 44 95        .byte "OAD",TK_LOAD     ; LOAD
  8022                        LBB_LOG
  8023 00:D33B: 4F 47 28 C7        .byte "OG(",TK_LOG      ; LOG(
  8024                        LBB_LOOP
  8025 00:D33F: 4F 4F 50 9C        .byte "OOP",TK_LOOP     ; LOOP
  8026 00:D343: 00                 .byte $00
  8027                        TAB_ASCM
  8028                        LBB_MAX
  8029 00:D344: 41 58 28 DA        .byte "AX(",TK_MAX      ; MAX(
  8030                        LBB_MIDS
  8031 00:D348: 49 44 24 28        .byte "ID$(",TK_MIDS    ; MID$(
       00:D34C: E1 
  8032                        LBB_MIN
  8033 00:D34D: 49 4E 28 DB        .byte "IN(",TK_MIN      ; MIN(
  8034 00:D351: 00                 .byte $00
  8035                        TAB_ASCN
  8036                        LBB_NEW
  8037 00:D352: 45 57 A1           .byte "EW",TK_NEW       ; NEW
  8038                        LBB_NEXT
  8039 00:D355: 45 58 54 82        .byte "EXT",TK_NEXT     ; NEXT
  8040                        LBB_NOT
  8041 00:D359: 4F 54 AE           .byte "OT",TK_NOT       ; NOT
  8042                        LBB_NULL
  8043 00:D35C: 55 4C 4C 92        .byte "ULL",TK_NULL     ; NULL
  Thu Sep 26 2019 15:30                                                                                                    Page 129


  8044 00:D360: 00                 .byte $00
  8045                        TAB_ASCO
  8046                        LBB_ON
  8047 00:D361: 4E 91              .byte "N",TK_ON         ; ON
  8048                        LBB_OR
  8049 00:D363: 52 B9              .byte "R",TK_OR         ; OR
  8050 00:D365: 00                 .byte $00
  8051                        TAB_ASCP
  8052                        LBB_PEEK
  8053 00:D366: 45 45 4B 28        .byte "EEK(",TK_PEEK    ; PEEK(
       00:D36A: CD 
  8054                        LBB_PI
  8055 00:D36B: 49 DC              .byte "I",TK_PI         ; PI
  8056                        LBB_POKE
  8057 00:D36D: 4F 4B 45 98        .byte "OKE",TK_POKE     ; POKE
  8058                        LBB_POS
  8059 00:D371: 4F 53 28 C4        .byte "OS(",TK_POS      ; POS(
  8060                        LBB_PRINT
  8061 00:D375: 52 49 4E 54        .byte "RINT",TK_PRINT   ; PRINT
       00:D379: 9D 
  8062 00:D37A: 00                 .byte $00
  8063                        TAB_ASCR
  8064                        LBB_READ
  8065 00:D37B: 45 41 44 86        .byte "EAD",TK_READ     ; READ
  8066                        LBB_REM
  8067 00:D37F: 45 4D 8F           .byte "EM",TK_REM       ; REM
  8068                        LBB_RESTORE
  8069 00:D382: 45 53 54 4F        .byte "ESTORE",TK_RESTORE
       00:D386: 52 45 8C 
  8070                                                      ; RESTORE
  8071                        LBB_RETURN
  8072 00:D389: 45 54 55 52        .byte "ETURN",TK_RETURN ; RETURN
       00:D38D: 4E 8E 
  8073                        LBB_RIGHTS
  8074 00:D38F: 49 47 48 54        .byte "IGHT$(",TK_RIGHTS
       00:D393: 24 28 E0 
  8075                                                      ; RIGHT$(
  8076                        LBB_RND
  8077 00:D396: 4E 44 28 C6        .byte "ND(",TK_RND      ; RND(
  8078                        LBB_RUN
  8079 00:D39A: 55 4E 8A           .byte "UN",TK_RUN       ; RUN
  8080 00:D39D: 00                 .byte $00
  8081                        TAB_ASCS
  8082                        LBB_SADD
  8083 00:D39E: 41 44 44 28        .byte "ADD(",TK_SADD    ; SADD(
       00:D3A2: CF 
  8084                        LBB_SAVE
  8085 00:D3A3: 41 56 45 96        .byte "AVE",TK_SAVE     ; SAVE
  8086                        LBB_SGN
  8087 00:D3A7: 47 4E 28 BF        .byte "GN(",TK_SGN      ; SGN(
  8088                        LBB_SIN
  8089 00:D3AB: 49 4E 28 CA        .byte "IN(",TK_SIN      ; SIN(
  8090                        LBB_SPC
  8091 00:D3AF: 50 43 28 AC        .byte "PC(",TK_SPC      ; SPC(
  8092                        LBB_SQR
  8093 00:D3B3: 51 52 28 C5        .byte "QR(",TK_SQR      ; SQR(
  8094                        LBB_STEP
  8095 00:D3B7: 54 45 50 AF        .byte "TEP",TK_STEP     ; STEP
  8096                        LBB_STOP
  8097 00:D3BB: 54 4F 50 90        .byte "TOP",TK_STOP     ; STOP
  8098                        LBB_STRS
  8099 00:D3BF: 54 52 24 28        .byte "TR$(",TK_STRS    ; STR$(
       00:D3C3: D1 
  Thu Sep 26 2019 15:30                                                                                                    Page 130


  8100                        LBB_SWAP
  8101 00:D3C4: 57 41 50 A4        .byte "WAP",TK_SWAP     ; SWAP
  8102 00:D3C8: 00                 .byte $00
  8103                        TAB_ASCT
  8104                        LBB_TAB
  8105 00:D3C9: 41 42 28 A8        .byte "AB(",TK_TAB      ; TAB(
  8106                        LBB_TAN
  8107 00:D3CD: 41 4E 28 CB        .byte "AN(",TK_TAN      ; TAN(
  8108                        LBB_THEN
  8109 00:D3D1: 48 45 4E AD        .byte "HEN",TK_THEN     ; THEN
  8110                        LBB_TO
  8111 00:D3D5: 4F AA              .byte "O",TK_TO         ; TO
  8112                        LBB_TWOPI
  8113 00:D3D7: 57 4F 50 49        .byte "WOPI",TK_TWOPI   ; TWOPI
       00:D3DB: DD 
  8114 00:D3DC: 00                 .byte $00
  8115                        TAB_ASCU
  8116                        LBB_UCASES
  8117 00:D3DD: 43 41 53 45        .byte "CASE$(",TK_UCASES
       00:D3E1: 24 28 D4 
  8118                                                      ; UCASE$(
  8119                        LBB_UNTIL
  8120 00:D3E4: 4E 54 49 4C        .byte "NTIL",TK_UNTIL   ; UNTIL
       00:D3E8: B0 
  8121                        LBB_USR
  8122 00:D3E9: 53 52 28 C2        .byte "SR(",TK_USR      ; USR(
  8123 00:D3ED: 00                 .byte $00
  8124                        TAB_ASCV
  8125                        LBB_VAL
  8126 00:D3EE: 41 4C 28 D2        .byte "AL(",TK_VAL      ; VAL(
  8127                        LBB_VPTR
  8128 00:D3F2: 41 52 50 54        .byte "ARPTR(",TK_VPTR  ; VARPTR(
       00:D3F6: 52 28 DE 
  8129 00:D3F9: 00                 .byte $00
  8130                        TAB_ASCW
  8131                        LBB_WAIT
  8132 00:D3FA: 41 49 54 94        .byte "AIT",TK_WAIT     ; WAIT
  8133                        LBB_WHILE
  8134 00:D3FE: 48 49 4C 45        .byte "HILE",TK_WHILE   ; WHILE
       00:D402: B1 
  8135                        LBB_WIDTH
  8136 00:D403: 49 44 54 48        .byte "IDTH",TK_WIDTH   ; WIDTH
       00:D407: A2 
  8137 00:D408: 00                 .byte $00
  8138                        TAB_POWR
  8139 00:D409: B6 00              .byte TK_POWER,$00      ; ^
  8140                        
  8141                        ; new decode table for LIST
  8142                        ; Table is ..
  8143                        ; byte - keyword length, keyword first character
  8144                        ; word - pointer to rest of keyword from dictionary
  8145                        
  8146                        ; note if length is 1 then the pointer is ignored
  8147                        
  8148                        LAB_KEYT
  8149 00:D40B: 03 45              .byte 3,'E'
  8150 00:D40D: E4 D2              .word LBB_END           ; END
  8151 00:D40F: 03 46              .byte 3,'F'
  8152 00:D411: F5 D2              .word LBB_FOR           ; FOR
  8153 00:D413: 04 4E              .byte 4,'N'
  8154 00:D415: 55 D3              .word LBB_NEXT          ; NEXT
  8155 00:D417: 04 44              .byte 4,'D'
  8156 00:D419: C7 D2              .word LBB_DATA          ; DATA
  Thu Sep 26 2019 15:30                                                                                                    Page 131


  8157 00:D41B: 05 49              .byte 5,'I'
  8158 00:D41D: 15 D3              .word LBB_INPUT         ; INPUT
  8159 00:D41F: 03 44              .byte 3,'D'
  8160 00:D421: D6 D2              .word LBB_DIM           ; DIM
  8161 00:D423: 04 52              .byte 4,'R'
  8162 00:D425: 7B D3              .word LBB_READ          ; READ
  8163 00:D427: 03 4C              .byte 3,'L'
  8164 00:D429: 30 D3              .word LBB_LET           ; LET
  8165 00:D42B: 03 44              .byte 3,'D'
  8166 00:D42D: CB D2              .word LBB_DEC           ; DEC
  8167 00:D42F: 04 47              .byte 4,'G'
  8168 00:D431: 05 D3              .word LBB_GOTO          ; GOTO
  8169 00:D433: 03 52              .byte 3,'R'
  8170 00:D435: 9A D3              .word LBB_RUN           ; RUN
  8171 00:D437: 02 49              .byte 2,'I'
  8172 00:D439: 10 D3              .word LBB_IF            ; IF
  8173 00:D43B: 07 52              .byte 7,'R'
  8174 00:D43D: 82 D3              .word LBB_RESTORE       ; RESTORE
  8175 00:D43F: 05 47              .byte 5,'G'
  8176 00:D441: 00 D3              .word LBB_GOSUB         ; GOSUB
  8177 00:D443: 06 52              .byte 6,'R'
  8178 00:D445: 89 D3              .word LBB_RETURN        ; RETURN
  8179 00:D447: 03 52              .byte 3,'R'
  8180 00:D449: 7F D3              .word LBB_REM           ; REM
  8181 00:D44B: 04 53              .byte 4,'S'
  8182 00:D44D: BB D3              .word LBB_STOP          ; STOP
  8183 00:D44F: 02 4F              .byte 2,'O'
  8184 00:D451: 61 D3              .word LBB_ON            ; ON
  8185 00:D453: 04 4E              .byte 4,'N'
  8186 00:D455: 5C D3              .word LBB_NULL          ; NULL
  8187 00:D457: 03 49              .byte 3,'I'
  8188 00:D459: 12 D3              .word LBB_INC           ; INC
  8189 00:D45B: 04 57              .byte 4,'W'
  8190 00:D45D: FA D3              .word LBB_WAIT          ; WAIT
  8191 00:D45F: 04 4C              .byte 4,'L'
  8192 00:D461: 37 D3              .word LBB_LOAD          ; LOAD
  8193 00:D463: 04 53              .byte 4,'S'
  8194 00:D465: A3 D3              .word LBB_SAVE          ; SAVE
  8195 00:D467: 03 44              .byte 3,'D'
  8196 00:D469: D3 D2              .word LBB_DEF           ; DEF
  8197 00:D46B: 04 50              .byte 4,'P'
  8198 00:D46D: 6D D3              .word LBB_POKE          ; POKE
  8199 00:D46F: 04 44              .byte 4,'D'
  8200 00:D471: D9 D2              .word LBB_DOKE          ; DOKE
  8201 00:D473: 04 43              .byte 4,'C'
  8202 00:D475: B0 D2              .word LBB_CALL          ; CALL
  8203 00:D477: 02 44              .byte 2,'D'
  8204 00:D479: DD D2              .word LBB_DO            ; DO
  8205 00:D47B: 04 4C              .byte 4,'L'
  8206 00:D47D: 3F D3              .word LBB_LOOP          ; LOOP
  8207 00:D47F: 05 50              .byte 5,'P'
  8208 00:D481: 75 D3              .word LBB_PRINT         ; PRINT
  8209 00:D483: 04 43              .byte 4,'C'
  8210 00:D485: BE D2              .word LBB_CONT          ; CONT
  8211 00:D487: 04 4C              .byte 4,'L'
  8212 00:D489: 33 D3              .word LBB_LIST          ; LIST
  8213 00:D48B: 05 43              .byte 5,'C'
  8214 00:D48D: B9 D2              .word LBB_CLEAR         ; CLEAR
  8215 00:D48F: 03 4E              .byte 3,'N'
  8216 00:D491: 52 D3              .word LBB_NEW           ; NEW
  8217 00:D493: 05 57              .byte 5,'W'
  8218 00:D495: 03 D4              .word LBB_WIDTH         ; WIDTH
  8219 00:D497: 03 47              .byte 3,'G'
  Thu Sep 26 2019 15:30                                                                                                    Page 132


  8220 00:D499: FD D2              .word LBB_GET           ; GET
  8221 00:D49B: 04 53              .byte 4,'S'
  8222 00:D49D: C4 D3              .word LBB_SWAP          ; SWAP
  8223 00:D49F: 06 42              .byte 6,'B'
  8224 00:D4A1: A2 D2              .word LBB_BITSET        ; BITSET
  8225 00:D4A3: 06 42              .byte 6,'B'
  8226 00:D4A5: 9C D2              .word LBB_BITCLR        ; BITCLR
  8227 00:D4A7: 04 45              .byte 4,"E"
  8228 00:D4A9: EE D2              .word LBB_EXIT          ; EXIT
  8229                        
  8230                        ; secondary commands (can't start a statement)
  8231                        
  8232 00:D4AB: 04 54              .byte 4,'T'
  8233 00:D4AD: C9 D3              .word LBB_TAB           ; TAB
  8234 00:D4AF: 04 45              .byte 4,'E'
  8235 00:D4B1: E0 D2              .word LBB_ELSE          ; ELSE
  8236 00:D4B3: 02 54              .byte 2,'T'
  8237 00:D4B5: D5 D3              .word LBB_TO            ; TO
  8238 00:D4B7: 02 46              .byte 2,'F'
  8239 00:D4B9: F3 D2              .word LBB_FN            ; FN
  8240 00:D4BB: 04 53              .byte 4,'S'
  8241 00:D4BD: AF D3              .word LBB_SPC           ; SPC
  8242 00:D4BF: 04 54              .byte 4,'T'
  8243 00:D4C1: D1 D3              .word LBB_THEN          ; THEN
  8244 00:D4C3: 03 4E              .byte 3,'N'
  8245 00:D4C5: 59 D3              .word LBB_NOT           ; NOT
  8246 00:D4C7: 04 53              .byte 4,'S'
  8247 00:D4C9: B7 D3              .word LBB_STEP          ; STEP
  8248 00:D4CB: 05 55              .byte 5,'U'
  8249 00:D4CD: E4 D3              .word LBB_UNTIL         ; UNTIL
  8250 00:D4CF: 05 57              .byte 5,'W'
  8251 00:D4D1: FE D3              .word LBB_WHILE         ; WHILE
  8252                        
  8253                        ; opperators
  8254                        
  8255 00:D4D3: 01 2B              .byte 1,'+'
  8256 00:D4D5: 00 00              .word $0000             ; +
  8257 00:D4D7: 01 2D              .byte 1,'-'
  8258 00:D4D9: 00 00              .word $0000             ; -
  8259 00:D4DB: 01 2A              .byte 1,'*'
  8260 00:D4DD: 00 00              .word $0000             ; *
  8261 00:D4DF: 01 2F              .byte 1,'/'
  8262 00:D4E1: 00 00              .word $0000             ; /
  8263 00:D4E3: 01 5E              .byte 1,'^'
  8264 00:D4E5: 00 00              .word $0000             ; ^
  8265 00:D4E7: 03 41              .byte 3,'A'
  8266 00:D4E9: 8B D2              .word LBB_AND           ; AND
  8267 00:D4EB: 03 45              .byte 3,'E'
  8268 00:D4ED: E7 D2              .word LBB_EOR           ; EOR
  8269 00:D4EF: 02 4F              .byte 2,'O'
  8270 00:D4F1: 63 D3              .word LBB_OR            ; OR
  8271 00:D4F3: 02 3E              .byte 2,'>'
  8272 00:D4F5: 81 D2              .word LBB_RSHIFT        ; >>
  8273 00:D4F7: 02 3C              .byte 2,'<'
  8274 00:D4F9: 7B D2              .word LBB_LSHIFT        ; <<
  8275 00:D4FB: 01 3E              .byte 1,'>'
  8276 00:D4FD: 00 00              .word $0000             ; >
  8277 00:D4FF: 01 3D              .byte 1,'='
  8278 00:D501: 00 00              .word $0000             ; =
  8279 00:D503: 01 3C              .byte 1,'<'
  8280 00:D505: 00 00              .word $0000             ; <
  8281                        
  8282                        ; functions
  Thu Sep 26 2019 15:30                                                                                                    Page 133


  8283                        
  8284 00:D507: 04 53              .byte 4,'S'             ;
  8285 00:D509: A7 D3              .word LBB_SGN           ; SGN
  8286 00:D50B: 04 49              .byte 4,'I'             ;
  8287 00:D50D: 1A D3              .word LBB_INT           ; INT
  8288 00:D50F: 04 41              .byte 4,'A'             ;
  8289 00:D511: 87 D2              .word LBB_ABS           ; ABS
  8290 00:D513: 04 55              .byte 4,'U'             ;
  8291 00:D515: E9 D3              .word LBB_USR           ; USR
  8292 00:D517: 04 46              .byte 4,'F'             ;
  8293 00:D519: F8 D2              .word LBB_FRE           ; FRE
  8294 00:D51B: 04 50              .byte 4,'P'             ;
  8295 00:D51D: 71 D3              .word LBB_POS           ; POS
  8296 00:D51F: 04 53              .byte 4,'S'             ;
  8297 00:D521: B3 D3              .word LBB_SQR           ; SQR
  8298 00:D523: 04 52              .byte 4,'R'             ;
  8299 00:D525: 96 D3              .word LBB_RND           ; RND
  8300 00:D527: 04 4C              .byte 4,'L'             ;
  8301 00:D529: 3B D3              .word LBB_LOG           ; LOG
  8302 00:D52B: 04 45              .byte 4,'E'             ;
  8303 00:D52D: EA D2              .word LBB_EXP           ; EXP
  8304 00:D52F: 04 43              .byte 4,'C'             ;
  8305 00:D531: C2 D2              .word LBB_COS           ; COS
  8306 00:D533: 04 53              .byte 4,'S'             ;
  8307 00:D535: AB D3              .word LBB_SIN           ; SIN
  8308 00:D537: 04 54              .byte 4,'T'             ;
  8309 00:D539: CD D3              .word LBB_TAN           ; TAN
  8310 00:D53B: 04 41              .byte 4,'A'             ;
  8311 00:D53D: 92 D2              .word LBB_ATN           ; ATN
  8312 00:D53F: 05 50              .byte 5,'P'             ;
  8313 00:D541: 66 D3              .word LBB_PEEK          ; PEEK
  8314 00:D543: 05 44              .byte 5,'D'             ;
  8315 00:D545: CE D2              .word LBB_DEEK          ; DEEK
  8316 00:D547: 05 53              .byte 5,'S'             ;
  8317 00:D549: 9E D3              .word LBB_SADD          ; SADD
  8318 00:D54B: 04 4C              .byte 4,'L'             ;
  8319 00:D54D: 2C D3              .word LBB_LEN           ; LEN
  8320 00:D54F: 05 53              .byte 5,'S'             ;
  8321 00:D551: BF D3              .word LBB_STRS          ; STR$
  8322 00:D553: 04 56              .byte 4,'V'             ;
  8323 00:D555: EE D3              .word LBB_VAL           ; VAL
  8324 00:D557: 04 41              .byte 4,'A'             ;
  8325 00:D559: 8E D2              .word LBB_ASC           ; ASC
  8326 00:D55B: 07 55              .byte 7,'U'             ;
  8327 00:D55D: DD D3              .word LBB_UCASES        ; UCASE$
  8328 00:D55F: 07 4C              .byte 7,'L'             ;
  8329 00:D561: 1F D3              .word LBB_LCASES        ; LCASE$
  8330 00:D563: 05 43              .byte 5,'C'             ;
  8331 00:D565: B4 D2              .word LBB_CHRS          ; CHR$
  8332 00:D567: 05 48              .byte 5,'H'             ;
  8333 00:D569: 0A D3              .word LBB_HEXS          ; HEX$
  8334 00:D56B: 05 42              .byte 5,'B'             ;
  8335 00:D56D: 97 D2              .word LBB_BINS          ; BIN$
  8336 00:D56F: 07 42              .byte 7,'B'             ;
  8337 00:D571: A8 D2              .word LBB_BITTST        ; BITTST
  8338 00:D573: 04 4D              .byte 4,'M'             ;
  8339 00:D575: 44 D3              .word LBB_MAX           ; MAX
  8340 00:D577: 04 4D              .byte 4,'M'             ;
  8341 00:D579: 4D D3              .word LBB_MIN           ; MIN
  8342 00:D57B: 02 50              .byte 2,'P'             ;
  8343 00:D57D: 6B D3              .word LBB_PI            ; PI
  8344 00:D57F: 05 54              .byte 5,'T'             ;
  8345 00:D581: D7 D3              .word LBB_TWOPI         ; TWOPI
  Thu Sep 26 2019 15:30                                                                                                    Page 134


  8346 00:D583: 07 56              .byte 7,'V'             ;
  8347 00:D585: F2 D3              .word LBB_VPTR          ; VARPTR
  8348 00:D587: 06 4C              .byte 6,'L'             ;
  8349 00:D589: 26 D3              .word LBB_LEFTS         ; LEFT$
  8350 00:D58B: 07 52              .byte 7,'R'             ;
  8351 00:D58D: 8F D3              .word LBB_RIGHTS        ; RIGHT$
  8352 00:D58F: 05 4D              .byte 5,'M'             ;
  8353 00:D591: 48 D3              .word LBB_MIDS          ; MID$
  8354                        
  8355                        ; BASIC messages, mostly error messages
  8356                        
  8357                        LAB_BAER
  8358 00:D593: B7 D5              .word ERR_NF            ;$00 NEXT without FOR
  8359 00:D595: C4 D5              .word ERR_SN            ;$02 syntax
  8360 00:D597: CB D5              .word ERR_RG            ;$04 RETURN without GOSUB
  8361 00:D599: DC D5              .word ERR_OD            ;$06 out of data
  8362 00:D59B: E8 D5              .word ERR_FC            ;$08 function call
  8363 00:D59D: F6 D5              .word ERR_OV            ;$0A overflow
  8364 00:D59F: FF D5              .word ERR_OM            ;$0C out of memory
  8365 00:D5A1: 0A D6              .word ERR_US            ;$0E undefined statement
  8366 00:D5A3: 1E D6              .word ERR_BS            ;$10 array bounds
  8367 00:D5A5: 2B D6              .word ERR_DD            ;$12 double dimension array
  8368 00:D5A7: 3C D6              .word ERR_D0            ;$14 divide by 0
  8369 00:D5A9: 4B D6              .word ERR_ID            ;$16 illegal direct
  8370 00:D5AB: 5A D6              .word ERR_TM            ;$18 type mismatch
  8371 00:D5AD: 68 D6              .word ERR_LS            ;$1A long string
  8372 00:D5AF: 78 D6              .word ERR_ST            ;$1C string too complex
  8373 00:D5B1: 8B D6              .word ERR_CN            ;$1E continue error
  8374 00:D5B3: 9A D6              .word ERR_UF            ;$20 undefined function
  8375 00:D5B5: AD D6              .word ERR_LD            ;$22 LOOP without DO
  8376                        
  8377                        ; I may implement these two errors to force definition of variables and
  8378                        ; dimensioning of arrays before use.
  8379                        
  8380                        ;     .word ERR_UV            ;$24 undefined variable
  8381                        
  8382                        ; the above error has been tested and works (see code and comments below LAB_1D8B)
  8383                        
  8384                        ;     .word ERR_UA            ;$26 undimensioned array
  8385                        
  8386 00:D5B7: 4E 45 58 54  ERR_NF      .byte "NEXT w/o FOR",$00
       00:D5BB: 20 77 2F 6F 
       00:D5BF: 20 46 4F 52 
       00:D5C3: 00 
  8387 00:D5C4: 53 79 6E 74  ERR_SN      .byte "Syntax",$00
       00:D5C8: 61 78 00 
  8388 00:D5CB: 52 45 54 55  ERR_RG      .byte "RETURN w/o GOSUB",$00
       00:D5CF: 52 4E 20 77 
       00:D5D3: 2F 6F 20 47 
       00:D5D7: 4F 53 55 42 
       00:D5DB: 00 
  8389 00:D5DC: 4F 75 74 20  ERR_OD      .byte "Out of DATA",$00
       00:D5E0: 6F 66 20 44 
       00:D5E4: 41 54 41 00 
  8390 00:D5E8: 46 75 6E 63  ERR_FC      .byte "Function call",$00
       00:D5EC: 74 69 6F 6E 
       00:D5F0: 20 63 61 6C 
       00:D5F4: 6C 00 
  8391 00:D5F6: 4F 76 65 72  ERR_OV      .byte "Overflow",$00
       00:D5FA: 66 6C 6F 77 
       00:D5FE: 00 
  8392 00:D5FF: 4F 75 74 20  ERR_OM      .byte "Out of RAM",$00
       00:D603: 6F 66 20 52 
  Thu Sep 26 2019 15:30                                                                                                    Page 135


       00:D607: 41 4D 00 
  8393 00:D60A: 55 6E 64 65  ERR_US      .byte "Undefined statement",$00
       00:D60E: 66 69 6E 65 
       00:D612: 64 20 73 74 
       00:D616: 61 74 65 6D 
       00:D61A: 65 6E 74 00 
  8394 00:D61E: 41 72 72 61  ERR_BS      .byte "Array bounds",$00
       00:D622: 79 20 62 6F 
       00:D626: 75 6E 64 73 
       00:D62A: 00 
  8395 00:D62B: 44 6F 75 62  ERR_DD      .byte "Double dimension",$00
       00:D62F: 6C 65 20 64 
       00:D633: 69 6D 65 6E 
       00:D637: 73 69 6F 6E 
       00:D63B: 00 
  8396 00:D63C: 44 69 76 69  ERR_D0      .byte "Divide by zero",$00
       00:D640: 64 65 20 62 
       00:D644: 79 20 7A 65 
       00:D648: 72 6F 00 
  8397 00:D64B: 49 6C 6C 65  ERR_ID      .byte "Illegal direct",$00
       00:D64F: 67 61 6C 20 
       00:D653: 64 69 72 65 
       00:D657: 63 74 00 
  8398 00:D65A: 54 79 70 65  ERR_TM      .byte "Type mismatch",$00
       00:D65E: 20 6D 69 73 
       00:D662: 6D 61 74 63 
       00:D666: 68 00 
  8399 00:D668: 53 74 72 69  ERR_LS      .byte "String too long",$00
       00:D66C: 6E 67 20 74 
       00:D670: 6F 6F 20 6C 
       00:D674: 6F 6E 67 00 
  8400 00:D678: 53 74 72 69  ERR_ST      .byte "String too complex",$00
       00:D67C: 6E 67 20 74 
       00:D680: 6F 6F 20 63 
       00:D684: 6F 6D 70 6C 
       00:D688: 65 78 00 
  8401 00:D68B: 43 61 6E 27  ERR_CN      .byte "Can't continue",$00
       00:D68F: 74 20 63 6F 
       00:D693: 6E 74 69 6E 
       00:D697: 75 65 00 
  8402 00:D69A: 55 6E 64 65  ERR_UF      .byte "Undefined function",$00
       00:D69E: 66 69 6E 65 
       00:D6A2: 64 20 66 75 
       00:D6A6: 6E 63 74 69 
       00:D6AA: 6F 6E 00 
  8403 00:D6AD: 4C 4F 4F 50  ERR_LD      .byte "LOOP w/o DO",$00
       00:D6B1: 20 77 2F 6F 
       00:D6B5: 20 44 4F 00 
  8404                        
  8405                        ;ERR_UV     .byte "Undefined variable",$00
  8406                        
  8407                        ; the above error has been tested and works (see code and comments below LAB_1D8B)
  8408                        
  8409                        ;ERR_UA     .byte "Undimensioned array",$00
  8410                        
  8411 00:D6B9: 0D 0A 42 72  LAB_BMSG    .byte $0D,$0A,"Break",$00
       00:D6BD: 65 61 6B 00 
  8412 00:D6C1: 20 45 72 72  LAB_EMSG    .byte " Error",$00
       00:D6C5: 6F 72 00 
  8413 00:D6C8: 20 69 6E 20  LAB_LMSG    .byte " in line ",$00
       00:D6CC: 6C 69 6E 65 
       00:D6D0: 20 00 
  8414 00:D6D2: 0D 0A 52 65  LAB_RMSG    .byte $0D,$0A,"Ready",$0D,$0A,$00
  Thu Sep 26 2019 15:30                                                                                                    Page 136


       00:D6D6: 61 64 79 0D 
       00:D6DA: 0A 00 
  8415                        
  8416 00:D6DC: 20 45 78 74  LAB_IMSG    .byte " Extra ignored",$0D,$0A,$00
       00:D6E0: 72 61 20 69 
       00:D6E4: 67 6E 6F 72 
       00:D6E8: 65 64 0D 0A 
       00:D6EC: 00 
  8417 00:D6ED: 20 52 65 64  LAB_REDO    .byte " Redo from start",$0D,$0A,$00
       00:D6F1: 6F 20 66 72 
       00:D6F5: 6F 6D 20 73 
       00:D6F9: 74 61 72 74 
       00:D6FD: 0D 0A 00 
  8418                        
  8419                         .END


      Lines assembled: 8419
      Errors: 0
