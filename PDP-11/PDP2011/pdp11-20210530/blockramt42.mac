         .title test42 - terminal proof of concept code

;--
;-- Copyright (c) 2008-2021 Sytse van Slooten
;--
;-- Permission is hereby granted to any person obtaining a copy of these VHDL source files and
;-- other language source files and associated documentation files ("the materials") to use
;-- these materials solely for personal, non-commercial purposes.
;-- You are also granted permission to make changes to the materials, on the condition that this
;-- copyright notice is retained unchanged.
;--
;-- The materials are distributed in the hope that they will be useful, but WITHOUT ANY WARRANTY;
;-- without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
;--


         jmp t42
;         .word 0   ;                    0
;         .word 0   ;                    2
         .word 0   ;                    4
         .word 0   ;                    6
         .word 0   ;                   10
         .word 0   ;                   12
         .word 0   ;                   14
         .word 0   ;                   16
         .word 0   ;                   20
         .word 0   ;                   22
         .word 0   ;                   24
         .word 0   ;                   26
         .word 0   ;                   30
         .word 0   ;                   32
         .word 0   ;                   34
         .word 0   ;                   36
         .word 0   ;                   40
         .word 0   ;                   42
         .word 0   ;                   44
         .word 0   ;                   46
         .word 0   ;                   50
         .word 0   ;                   52
         .word 0   ;                   54
         .word 0   ;                   56
         .word 0   ;                   60
         .word 0   ;                   62
         .word 0   ;                   64
         .word 0   ;                   66
         .word 0   ;                   70
         .word 0   ;                   72
         .word 0   ;                   74
         .word 0   ;                   76
         .word 0   ;                  100
         .word 0   ;                  102
         .word 0   ;                  104
         .word 0   ;                  106
         .word 0   ;                  110
         .word 0   ;                  112
         .word 0   ;                  114
         .word 0   ;                  116
         .word 0   ;                  120
         .word 0   ;                  122
         .word 0   ;                  124
         .word 0   ;                  126
         .word 0   ;                  130
         .word 0   ;                  132
         .word 0   ;                  134
         .word 0   ;                  136
         .word 0   ;                  140
         .word 0   ;                  142
         .word 0   ;                  144
         .word 0   ;                  146
         .word 0   ;                  150
         .word 0   ;                  152
         .word 0   ;                  154
         .word 0   ;                  156
         .word 0   ;                  160
         .word 0   ;                  162
         .word 0   ;                  164
         .word 0   ;                  166
         .word 0   ;                  170
         .word 0   ;                  172
         .word 0   ;                  174
         .word 0   ;                  176
         .word 0   ;                  200
         .word 0   ;                  202
         .word 0   ;                  204
         .word 0   ;                  206
         .word 0   ;                  210
         .word 0   ;                  212
         .word 0   ;                  214
         .word 0   ;                  216
         .word 0   ;                  220
         .word 0   ;                  222
         .word 0   ;                  224
         .word 0   ;                  226
         .word 0   ;                  230
         .word 0   ;                  232
         .word 0   ;                  234
         .word 0   ;                  236
         .word 0   ;                  240
         .word 0   ;                  242
         .word 0   ;                  244
         .word 0   ;                  246
         .word 0   ;                  250
         .word 0   ;                  252
         .word 0   ;                  254
         .word 0   ;                  256
         .word 0   ;                  260
         .word 0   ;                  262
         .word 0   ;                  264
         .word 0   ;                  266
         .word 0   ;                  270
         .word 0   ;                  272
         .word 0   ;                  274
         .word 0   ;                  276
         .word 0   ;                  300
         .word 0   ;                  302
         .word 0   ;                  304
         .word 0   ;                  306
         .word 0   ;                  310
         .word 0   ;                  312
         .word 0   ;                  314
         .word 0   ;                  316
         .word 0   ;                  320
         .word 0   ;                  322
         .word 0   ;                  324
         .word 0   ;                  326
         .word 0   ;                  330
         .word 0   ;                  332
         .word 0   ;                  334
         .word 0   ;                  336
         .word 0   ;                  340
         .word 0   ;                  342
         .word 0   ;                  344
         .word 0   ;                  346
         .word 0   ;                  350
         .word 0   ;                  352
         .word 0   ;                  354
         .word 0   ;                  356
         .word 0   ;                  360
         .word 0   ;                  362
         .word 0   ;                  364
         .word 0   ;                  366
         .word 0   ;                  370
         .word 0   ;                  372
         .word 0   ;                  374
         .word 0   ;                  376
         .word 0   ;                  400
         .word 0   ;                  402
         .word 0   ;                  404
         .word 0   ;                  406
         .word 0   ;                  410
         .word 0   ;                  412
         .word 0   ;                  414
         .word 0   ;                  416
         .word 0   ;                  420
         .word 0   ;                  422
         .word 0   ;                  424
         .word 0   ;                  426
         .word 0   ;                  430
         .word 0   ;                  432
         .word 0   ;                  434
         .word 0   ;                  436
         .word 0   ;                  440
         .word 0   ;                  442
         .word 0   ;                  444
         .word 0   ;                  446
         .word 0   ;                  450
         .word 0   ;                  452
         .word 0   ;                  454
         .word 0   ;                  456
         .word 0   ;                  460
         .word 0   ;                  462
         .word 0   ;                  464
         .word 0   ;                  466
         .word 0   ;                  470
         .word 0   ;                  472
         .word 0   ;                  474
         .word 0   ;                  476
         .word 0   ;                  500
         .word 0   ;                  502
         .word 0   ;                  504
         .word 0   ;                  506
         .word 0   ;                  510
         .word 0   ;                  512
         .word 0   ;                  514
         .word 0   ;                  516
         .word 0   ;                  520
         .word 0   ;                  522
         .word 0   ;                  524
         .word 0   ;                  526
         .word 0   ;                  530
         .word 0   ;                  532
         .word 0   ;                  534
         .word 0   ;                  536
         .word 0   ;                  540
         .word 0   ;                  542
         .word 0   ;                  544
         .word 0   ;                  546
         .word 0   ;                  550
         .word 0   ;                  552
         .word 0   ;                  554
         .word 0   ;                  556
         .word 0   ;                  560
         .word 0   ;                  562
         .word 0   ;                  564
         .word 0   ;                  566
         .word 0   ;                  570
         .word 0   ;                  572
         .word 0   ;                  574
         .word 0   ;                  576
         .word 0   ;                  600
         .word 0   ;                  602
         .word 0   ;                  604
         .word 0   ;                  606
         .word 0   ;                  610
         .word 0   ;                  612
         .word 0   ;                  614
         .word 0   ;                  616
         .word 0   ;                  620
         .word 0   ;                  622
         .word 0   ;                  624
         .word 0   ;                  626
         .word 0   ;                  630
         .word 0   ;                  632
         .word 0   ;                  634
         .word 0   ;                  636
         .word 0   ;                  640
         .word 0   ;                  642
         .word 0   ;                  644
         .word 0   ;                  646
         .word 0   ;                  650
         .word 0   ;                  652
         .word 0   ;                  654
         .word 0   ;                  656
         .word 0   ;                  660
         .word 0   ;                  662
         .word 0   ;                  664
         .word 0   ;                  666
         .word 0   ;                  670
         .word 0   ;                  672
         .word 0   ;                  674
         .word 0   ;                  676
         .word 0   ;                  700
         .word 0   ;                  702
         .word 0   ;                  704
         .word 0   ;                  706
         .word 0   ;                  710
         .word 0   ;                  712
         .word 0   ;                  714
         .word 0   ;                  716
         .word 0   ;                  720
         .word 0   ;                  722
         .word 0   ;                  724
         .word 0   ;                  726
         .word 0   ;                  730
         .word 0   ;                  732
         .word 0   ;                  734
         .word 0   ;                  736
         .word 0   ;                  740
         .word 0   ;                  742
         .word 0   ;                  744
         .word 0   ;                  746
         .word 0   ;                  750
         .word 0   ;                  752
         .word 0   ;                  754
         .word 0   ;                  756
         .word 0   ;                  760
         .word 0   ;                  762
         .word 0   ;                  764
         .word 0   ;                  766
         .word 0   ;                  770
         .word 0   ;                  772
         .word 0   ;                  774
stbot:
stk:
         .word 0   ;                  776
;
; misc definitions
;
ht       = 11
lf       = 12
cr       = 15
ps       = 177776
stklmt   = 177774
pirq     = 177772
;
; general purpose register definitions
;
r0       = %0
r1       = %1
r2       = %2
r3       = %3
r4       = %4
r5       = %5
r6       = %6
r7       = %7
sp       = %6
pc       = %7
;
; start of code
;
t42:
         mov #340,@#177776             ; set psw prio to 7 - block interrupts
         mov #1000,sp
;
; setup buffers
;
         clr rcvcons                   ; consume equal produce means buffer empty
         clr rcvprod                   ; receive is what we receive on our slu port
         clr ps2cons                   ; first we consume, then we produce
         clr ps2prod                   ; xmit is what we received from the ps2 port
;
; setup interrupt vectors
;
         mov #ivecrcv,@#60
         mov #340,@#62
         mov #ivecxmt,@#64
         mov #340,@#66
         mov #ivecps2,@#70
         mov #340,@#72
         mov #100,@#177560             ; set interrupt enable in slu
         mov #100,@#150000
;
; mainline code
;
         mov #0,@#177776
;
; old sh*t
;
         mov #100000,r3
1$:
         movb #40,(r3)+              ; fill the buffer with spaces
         cmp r3,#106300              ; this value is 64. past the end of the visible area, and causes to show if the top line of the next row is off.
         bne 1$

         mov #hello,r2
         mov #100000,r3
2$:
         movb (r2)+,(r3)+
         bne 2$
         movb #40,-(r3)

         mov #100240,r3
4$:
         mov r3,@#140000

         jsr pc,ps2getc
         cmp r0,#0
         beq 44$
         jsr pc,ps2xlt
         cmp r0,#0
         beq 44$
         mov r1,r0
         movb r0,@#177566
         br 4$
;         br 444$    ; this does local echo
44$:
         jsr pc,rcvgetc

         cmp r0,#0                     ; did we get a character
         beq 4$                        ; zero means no

         movb r1,r0
         bicb #200,r0             ; vt is a 7-bit terminal... apparently

444$:
         cmpb r0,#15              ; cr
         bne 6$
         mov #100000,r1
5$:
         add #120,r1
         cmp r1,r3
         ble 5$
         sub #120,r1
         cmp r1,#100000
         bge 55$
         mov #100000,r1
55$:
         mov r1,r3
         br 4$
6$:
         jsr pc,spchar
         cmpb r0,#0
         beq 99$
         movb r0,(r3)+
99$:
         cmp r3,#106200
         blt 4$
         mov #100120,r1
         mov #100000,r2
         mov #106200,r4
100$:
         mov (r1)+,(r2)+
         cmp r1,r4
         bne 100$
101$:
         movb #40,(r2)+
         cmp r2,r4
         bne 101$
         mov #106060,r3
;         cmp r0,#12
;         beq 4$                        ; if we scrolled for lf, don't redo the last store
         br 4$                         ; done, next round
;
; spchar - deal with special characters; returns r0=0 if the char has been dealt with, the char itself otherwise. r3 has cursor address, rest must be left intact
;
spchar:
         cmpb r0,#0               ; null
         beq spcnex
;
         cmpb r0,#12              ; lf
         bne spcn12
         add #120,r3
         clr r0
         br spcnex
spcn12:
;
         cmpb r0,#177             ; del
         bne spcn177
         clr r0
spcn177:
;
         cmpb r0,#10              ; bs
         bne spcn10
         cmp r3,#100000           ; don't backspace out of buffer
         beq 10$
         sub #1,r3
10$:
         clr r0
         br spcnex
spcn10:
;
spcnex:
         rts pc
;
; rcvgetc - routine to consume a character from the slu rcv buf. Clobbers r0,r1; r0 is nonzero if a character is produced in r1
;
rcvgetc:
         mov #340,@#177776             ; disable interrupts
         mov rcvprod,r0                ; get produce pointer in r0
         mov rcvcons,r1                ; get consume pointer in r1
         cmp r0,r1                     ; equal?
         bne 10$                       ; no, continue
         clr r0                        ; equal, signal buffer was empty
         br 90$                        ; goto exit
10$:
         inc r0                        ; increment produce pointer - we're producing
         cmp r0,#80.                   ; need to wrap?
         blt 20$                       ; no, jump
         clr r0                        ; wrap in buffer
20$:
         mov r0,rcvprod                ; store updated produce pointer
         add #rcvbuf,r0                ; add address to offset
         movb (r0),r1                  ; load byte into r1; r0 - success flag - is certain to be nonzero after using it as the address
90$:
         mov #0,@#177776
         rts pc
;
; ps2getc - routine to consume a character from the ps2 rcv buf. Clobbers r0,r1; r0 is nonzero if a character is produced in r1
;
ps2getc:
         mov #340,@#177776             ; disable interrupts
         mov ps2prod,r0                ; get produce pointer in r0
         mov ps2cons,r1                ; get consume pointer in r1
         cmp r0,r1                     ; equal?
         bne 10$                       ; no, continue
         clr r0                        ; equal, signal buffer was empty
         br 90$                        ; goto exit
10$:
         inc r0                        ; increment produce pointer - we're producing
         cmp r0,#80.                   ; need to wrap?
         blt 20$                       ; no, jump
         clr r0                        ; wrap in buffer
20$:
         mov r0,ps2prod                ; store updated produce pointer
         add #ps2buf,r0                ; add address to offset
         movb (r0),r1                  ; load byte into r1; r0 - success flag - is certain to be nonzero after using it as the address
90$:
         mov #0,@#177776
         rts pc
;
; ps2xku - routine to maintain status flags for key up events
;
ps2xku:
         cmpb r0,#24                   ; left control
         bne 14$
         clr ps2lc
14$:
         cmpb r0,#22                   ; left shift
         bne 18$
         clr ps2ls
18$:
         cmpb r0,#131                  ; right shift
         bne 20$
         clr ps2rs
20$:
         rts pc
;
; ps2xkd - routine to maintain status flags for key down events
;
ps2xkd:
         cmpb r0,#24                   ; left control
         bne 14$
         mov #1,ps2lc
         clr r0
14$:
         cmpb r0,#22                   ; left shift
         bne 18$
         mov #1,ps2ls
         clr r0
18$:
         cmpb r0,#131                  ; right shift
         bne 20$
         mov #1,ps2rs
         clr r0
20$:
         rts pc
;
; ps2xlt - routine to translate ps2 scan code to ascii. Input scancode in r1; output ascii in r1, r0 nonzero if valid
;
ps2xlt:
         tst ps2up                     ; key up flag set?
         beq 10$                       ; no
         cmpb r1,#340                  ; check if the current code is e0
         bne 5$
         mov #1,ps2ex                  ; set marker
         br 99$
5$:
         clr ps2up                     ; clear key up flag
         movb r1,r0                    ; copy code
         jsr pc,ps2xku                 ; process key up events
         br 99$                        ; done - ignore the code
10$:
         tst ps2ex                     ; extended key code flag set?
         beq 12$                       ; no
         clr ps2ex                     ; clear extended key code flag
         br 99$                        ; ignore the code - for now
12$:
         movb r1,r0                    ; get input code into r0
         cmpb r0,#360                  ; key up - f0?
         bne 14$                       ; no
         mov #1,ps2up                  ; set flag
         br 99$
14$:
         cmpb r0,#340                  ; extended key - e0?
         bne 16$                       ; no
         mov #1,ps2ex                  ; set flag
         br 99$
16$:
         jsr pc,ps2xkd                 ; process key down status events
         cmpb r0,#0                    ; result?
         bne 18$                       ; no
         br 99$
18$:
         bitb #200,r0                  ; check if bit is set
         bne 99$                       ; yes, skip rest - don't know what to do with it
20$:
         bic #177600,r0                ; mask to low 7 bits
         tst ps2lc                     ; left control down?
         beq 60$                       ; no
         add #ps2tb1,r0                ; add base address of translate table
         movb (r0),r0                  ; load byte
         tstb r0                       ; was something nonzero there?
         beq 99$                       ; no - finished
         cmpb r0,#140                  ; lower case a minus one
         ble 99$                       ; below? then no go
         cmpb r0,#172                  ; lower case z
         bgt 99$                       ; over? then no go
         sub #140,r0                   ; controllify
         movb r0,r1                    ; set output
         br 98$

60$:
         tst ps2ls                     ; left shift down?
         bne 70$                       ; yes
         tst ps2rs                     ; right shift down?
         bne 70$                       ; yes

         add #ps2tb1,r0                ; add base address of translate table
         br 72$
70$:
         add #ps2tb2,r0                ; add base address of shifted translate table
72$:
         movb (r0),r0                  ; load byte
         tstb r0                       ; was something nonzero there?
         beq 99$                       ; no - finished
         movb r0,r1                    ; set output
         br 98$

98$:                                   ; exit path, code translated, make sure r0 is nonzero
         clr r0
         inc r0
         rts pc

99$:                                   ; exit path, no code - make sure r0 is zero
         clr r0
         rts pc

;
; interrupt service routine - receive from slu
;
ivecrcv:
         tstb @#177560                 ; check slu - did we really receive something?
         bpl 90$                       ; positive means ready bit is not set
         mov r0,-(sp)                  ; save r0
         mov r1,-(sp)                  ; save r1

         mov rcvcons,r0                ; get consume pointer in r0
         mov rcvprod,r1                ; get produce pointer in r1
         inc r0                        ; increment consume pointer - we're about to consume
         cmp r0,#80.                   ; check for max size of buffer
         blt 20$                       ; less?
         clr r0                        ; if yes, then start at zero
20$:
         cmp r0,r1                     ; after incrementing consume, produce and consume should not be the same - that would mean a buffer overrun
         beq 80$                       ; skip storing if buffer overrun

         mov r0,rcvcons                ; update consume pointer
         movb @#177562,r1              ; copy received character into r1
         add #rcvbuf,r0                ; add base to pointer
         movb r1,(r0)                  ; store into buffer

80$:
         mov (sp)+,r1                  ; restore r1
         mov (sp)+,r0                  ; restore r0
90$:
         mov #100,@#177560             ; make sure interrupt enable is set again
         rti

;
; interrupt service routine - slu xmit
;
ivecxmt:
         rti

;
; interrupt service routine - receive from ps2
;
ivecps2:
         tstb @#150000                 ; check ps2 - did we really receive something?
         bpl 90$                       ; positive means ready bit is not set
         mov r0,-(sp)                  ; save r0
         mov r1,-(sp)                  ; save r1

         mov ps2cons,r0                ; get consume pointer in r0
         mov ps2prod,r1                ; get produce pointer in r1
         inc r0                        ; increment consume pointer - we're about to consume
         cmp r0,#80.                   ; check for max size of buffer
         blt 20$                       ; less?
         clr r0                        ; if yes, then start at zero
20$:
         cmp r0,r1                     ; after incrementing consume, produce and consume should not be the same - that would mean a buffer overrun
         beq 80$                       ; skip storing if buffer overrun

         mov r0,ps2cons                ; update consume pointer
         movb @#150002,r1              ; copy received character into r1
         add #ps2buf,r0                ; add base to pointer
         movb r1,(r0)                  ; store into buffer

80$:
         mov (sp)+,r1                  ; restore r1
         mov (sp)+,r0                  ; restore r0
90$:
         mov #100,@#150000             ; make sure interrupt enable is set again
         rti

hello:   .asciz /Hello, world: vt-cpu t42                                                                        /

         .even
;
; pointers in circular buffers
;
rcvcons: .word 0
rcvprod: .word 0
ps2cons: .word 0
ps2prod: .word 0
;
; buffers - each 40 words, ie 80 bytes long
;
rcvbuf:  .word 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ps2buf:  .word 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
;
; data
;
ps2up:   .word 0                       ; nonzero if last scancode was a f0 - key up event
ps2ex:   .word 0                       ; nonzero if last scancode was a e0 - extended key
ps2lc:   .word 0                       ; nonzero if left control key is down
ps2ls:   .word 0                       ; nonzero if left shift key is down
ps2rs:   .word 0                       ; nonzero if right shift key is down
;
; ps2 scancode translate table - normal case
;
ps2tb1:
         .byte 0                       ; 00 - unused
         .byte 0                       ; 01 - f9
         .byte 0                       ; 02 -
         .byte 0                       ; 03 - f5
         .byte 0                       ; 04 - f3
         .byte 0                       ; 05 - f1
         .byte 0                       ; 06 - f2
         .byte 0                       ; 07 - f12
         .byte 0                       ; 08 -
         .byte 0                       ; 09 - f10
         .byte 0                       ; 0a - f8
         .byte 0                       ; 0b - f6
         .byte 0                       ; 0c - f4
         .ascii <11>                   ; 0d - tab
         .ascii /`/                    ; 0e - backtick/tilde
         .byte 0                       ; 0f -
         .byte 0                       ; 10 -
         .byte 0                       ; 11 -
         .byte 0                       ; 12 -
         .byte 0                       ; 13 -
         .byte 0                       ; 14 -
         .ascii /q/                    ; 15 - q
         .ascii /1/                    ; 16 - 1
         .byte 0                       ; 17 -
         .byte 0                       ; 18 -
         .byte 0                       ; 19 -
         .ascii /z/                    ; 1a - z
         .ascii /s/                    ; 1b - s
         .ascii /a/                    ; 1c - a
         .ascii /w/                    ; 1d - w
         .ascii /2/                    ; 1e - 2
         .byte 0                       ; 1f -
         .byte 0                       ; 20 -
         .ascii /c/                    ; 21 - c
         .ascii /x/                    ; 22 - x
         .ascii /d/                    ; 23 - d
         .ascii /e/                    ; 24 - e
         .ascii /4/                    ; 25 - 4
         .ascii /3/                    ; 26 - 3
         .byte 0                       ; 27 -
         .byte 0                       ; 28 -
         .ascii / /                    ; 29 - space
         .ascii /v/                    ; 2a - v
         .ascii /f/                    ; 2b - f
         .ascii /t/                    ; 2c - t
         .ascii /r/                    ; 2d - r
         .ascii /5/                    ; 2e - 5
         .byte 0                       ; 2f -
         .byte 0                       ; 30 -
         .ascii /n/                    ; 31 - n
         .ascii /b/                    ; 32 - b
         .ascii /h/                    ; 33 - h
         .ascii /g/                    ; 34 - g
         .ascii /y/                    ; 35 - y
         .ascii /6/                    ; 36 - 6
         .byte 0                       ; 37 -
         .byte 0                       ; 38 -
         .byte 0                       ; 39 -
         .ascii /m/                    ; 3a - m
         .ascii /j/                    ; 3b - j
         .ascii /u/                    ; 3c - u
         .ascii /7/                    ; 3d - 7
         .ascii /8/                    ; 3e - 8
         .byte 0                       ; 3f -
         .byte 0                       ; 40 -
         .ascii /,/                    ; 41 - comma, lt
         .ascii /k/                    ; 42 - k
         .ascii /i/                    ; 43 - i
         .ascii /o/                    ; 44 - o
         .ascii /0/                    ; 45 - 0
         .ascii /9/                    ; 46 - 9
         .byte 0                       ; 47 -
         .byte 0                       ; 48 -
         .ascii /./                    ; 49 - period, gt
         .ascii <57>                   ; 4a - slash, question mark
         .ascii /l/                    ; 4b - l
         .ascii /;/                    ; 4c - semicolon, colon
         .ascii /p/                    ; 4d - p
         .ascii /-/                    ; 4e - minus, underscore
         .byte 0                       ; 4f -
         .byte 0                       ; 50 -
         .byte 0                       ; 51 -
         .ascii /'/                    ; 52 - quote, double quote
         .byte 0                       ; 53 -
         .ascii /[/                    ; 54 - left square bracket, left curly bracket
         .ascii /=/                    ; 55 - equals, plus
         .byte 0                       ; 56 -
         .byte 0                       ; 57 -
         .byte 0                       ; 58 - caps lock
         .byte 0                       ; 59 - right shift
         .ascii <15>                   ; 5a - enter
         .ascii /]/                    ; 5b - right square bracket, right curly bracket
         .byte 0                       ; 5c -
         .ascii /\/                    ; 5d - backslash, vertical bar
         .byte 0                       ; 5e -
         .byte 0                       ; 5f -
         .byte 0                       ; 60 -
         .byte 0                       ; 61 -
         .byte 0                       ; 62 -
         .byte 0                       ; 63 -
         .byte 0                       ; 64 -
         .byte 0                       ; 65 -
         .ascii <177>                  ; 66 - backspace - sends del
         .byte 0                       ; 67 -
         .byte 0                       ; 68 -
         .byte 0                       ; 69 -
         .byte 0                       ; 6a -
         .byte 0                       ; 6b -
         .byte 0                       ; 6c -
         .byte 0                       ; 6d -
         .byte 0                       ; 6e -
         .byte 0                       ; 6f -
         .byte 0                       ; 70 -
         .byte 0                       ; 71 -
         .byte 0                       ; 72 -
         .byte 0                       ; 73 -
         .byte 0                       ; 74 -
         .byte 0                       ; 75 -
         .ascii <33>                   ; 76 - escape
         .byte 0                       ; 77 -
         .byte 0                       ; 78 - f11
         .byte 0                       ; 79 -
         .byte 0                       ; 7a -
         .byte 0                       ; 7b -
         .byte 0                       ; 7c -
         .byte 0                       ; 7d -
         .byte 0                       ; 7e -
         .byte 0                       ; 7f -
;
; ps2 scancode translate table - shifted case
;
ps2tb2:
         .byte 0                       ; 00 - unused
         .byte 0                       ; 01 - f9
         .byte 0                       ; 02 -
         .byte 0                       ; 03 - f5
         .byte 0                       ; 04 - f3
         .byte 0                       ; 05 - f1
         .byte 0                       ; 06 - f2
         .byte 0                       ; 07 - f12
         .byte 0                       ; 08 -
         .byte 0                       ; 09 - f10
         .byte 0                       ; 0a - f8
         .byte 0                       ; 0b - f6
         .byte 0                       ; 0c - f4
         .ascii <11>                   ; 0d - tab
         .ascii /~/                    ; 0e - backtick/tilde
         .byte 0                       ; 0f -
         .byte 0                       ; 10 -
         .byte 0                       ; 11 -
         .byte 0                       ; 12 -
         .byte 0                       ; 13 -
         .byte 0                       ; 14 -
         .ascii /Q/                    ; 15 - q
         .ascii /!/                    ; 16 - 1
         .byte 0                       ; 17 -
         .byte 0                       ; 18 -
         .byte 0                       ; 19 -
         .ascii /Z/                    ; 1a - z
         .ascii /S/                    ; 1b - s
         .ascii /A/                    ; 1c - a
         .ascii /W/                    ; 1d - w
         .ascii /@/                    ; 1e - 2
         .byte 0                       ; 1f -
         .byte 0                       ; 20 -
         .ascii /C/                    ; 21 - c
         .ascii /X/                    ; 22 - x
         .ascii /D/                    ; 23 - d
         .ascii /E/                    ; 24 - e
         .ascii /$/                    ; 25 - 4
         .ascii /#/                    ; 26 - 3
         .byte 0                       ; 27 -
         .byte 0                       ; 28 -
         .ascii / /                    ; 29 - space
         .ascii /V/                    ; 2a - v
         .ascii /F/                    ; 2b - f
         .ascii /T/                    ; 2c - t
         .ascii /R/                    ; 2d - r
         .ascii /%/                    ; 2e - 5
         .byte 0                       ; 2f -
         .byte 0                       ; 30 -
         .ascii /N/                    ; 31 - n
         .ascii /B/                    ; 32 - b
         .ascii /H/                    ; 33 - h
         .ascii /G/                    ; 34 - g
         .ascii /Y/                    ; 35 - y
         .ascii /^/                    ; 36 - 6
         .byte 0                       ; 37 -
         .byte 0                       ; 38 -
         .byte 0                       ; 39 -
         .ascii /M/                    ; 3a - m
         .ascii /J/                    ; 3b - j
         .ascii /U/                    ; 3c - u
         .ascii /&/                    ; 3d - 7
         .ascii /*/                    ; 3e - 8
         .byte 0                       ; 3f -
         .byte 0                       ; 40 -
         .ascii /</                    ; 41 - comma, lt
         .ascii /K/                    ; 42 - k
         .ascii /I/                    ; 43 - i
         .ascii /O/                    ; 44 - o
         .ascii /)/                    ; 45 - 0
         .ascii /(/                    ; 46 - 9
         .byte 0                       ; 47 -
         .byte 0                       ; 48 -
         .ascii />/                    ; 49 - period, gt
         .ascii /?/                    ; 4a - slash, question mark
         .ascii /L/                    ; 4b - l
         .ascii /:/                    ; 4c - semicolon, colon
         .ascii /P/                    ; 4d - p
         .ascii /_/                    ; 4e - minus, underscore
         .byte 0                       ; 4f -
         .byte 0                       ; 50 -
         .byte 0                       ; 51 -
         .ascii /"/                    ; 52 - quote, double quote
         .byte 0                       ; 53 -
         .ascii /{/                    ; 54 - left square bracket, left curly bracket
         .ascii /+/                    ; 55 - equals, plus
         .byte 0                       ; 56 -
         .byte 0                       ; 57 -
         .byte 0                       ; 58 - caps lock
         .byte 0                       ; 59 -
         .ascii <15>                   ; 5a - enter
         .ascii /}/                    ; 5b - right square bracket, right curly bracket
         .byte 0                       ; 5c -
         .ascii /|/                    ; 5d - backslash, vertical bar
         .byte 0                       ; 5e -
         .byte 0                       ; 5f -
         .byte 0                       ; 60 -
         .byte 0                       ; 61 -
         .byte 0                       ; 62 -
         .byte 0                       ; 63 -
         .byte 0                       ; 64 -
         .byte 0                       ; 65 -
         .ascii <10>                   ; 66 - backspace
         .byte 0                       ; 67 -
         .byte 0                       ; 68 -
         .byte 0                       ; 69 -
         .byte 0                       ; 6a -
         .byte 0                       ; 6b -
         .byte 0                       ; 6c -
         .byte 0                       ; 6d -
         .byte 0                       ; 6e -
         .byte 0                       ; 6f -
         .byte 0                       ; 70 -
         .byte 0                       ; 71 -
         .byte 0                       ; 72 -
         .byte 0                       ; 73 -
         .byte 0                       ; 74 -
         .byte 0                       ; 75 -
         .ascii <33>                   ; 76 - escape
         .byte 0                       ; 77 -
         .byte 0                       ; 78 - f11
         .byte 0                       ; 79 -
         .byte 0                       ; 7a -
         .byte 0                       ; 7b -
         .byte 0                       ; 7c -
         .byte 0                       ; 7d -
         .byte 0                       ; 7e -
         .byte 0                       ; 7f -
