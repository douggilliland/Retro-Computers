0001                         *************************************
0002                         * COPYRIGHT (C) MOTOROLA, INC. 1979 *
0003                         *************************************
0004                         
0005                         *************************************
0006                         * THIS IS THE BASE ASSIST09 ROM.
0007                         * IT MAY RUN WITH OR WITHOUT THE
0008                         * EXTENSION ROM WHICH
0009                         * WHEN PRESENT WILL BE AUTOMATICALLY
0010                         * INCORPORATED BY THE BLDVTR
0011                         * SUBROUTINE.
0012                         *************************************
0013                         
0014                         *********************************************
0015                         * GLOBAL MODULE EQUATES
0016                         ********************************************
0017 f800                    ROMBEG  EQU     $F800           ; ROM START ASSEMBLY ADDRESS
0018 ffffe700                    RAMOFS  EQU     -$1900          ; ROM OFFSET TO RAM WORK PAGE
0019 0800                    ROMSIZ  EQU     2048            ; ROM SIZE
0020 f000                    ROM2OF  EQU     ROMBEG-ROMSIZ   ; START OF EXTENSION ROM
0021 e008                    ACIA    EQU     $E008           ; DEFAULT ACIA ADDRESS
0022 e000                    PTM     EQU     $E000           ; DEFAULT PTM ADDRESS
0023 0000                    DFTCHP  EQU     0               ; DEFAULT CHARACTER PAD COUNT
0024 0005                    DFTNLP  EQU     5               ; DEFAULT NEW LINE PAD COUNT
0025 003e                    PROMPT  EQU     '>              ; PROMPT CHARACTER
0026 0008                    NUMBKP  EQU     8               ; NUMBER OF BREAKPOINTS
0027                         *********************************************
0028                         
0029                         *********************************************
0030                         * MISCELANEOUS EQUATES
0031                         *********************************************
0032 0004                    EOT     EQU     $04             ; END OF TRANSMISSION
0033 0007                    BELL    EQU     $07             ; BELL CHARACTER
0034 000a                    LF      EQU     $0A             ; LINE FEED
0035 000d                    CR      EQU     $0D             ; CARRIAGE RETURN
0036 0010                    DLE     EQU     $10             ; DATA LINK ESCAPE
0037 0018                    CAN     EQU     $18             ; CANCEL (CTL-X)
0038                         
0039                         * PTM ACCESS DEFINITIONS
0040 e001                    PTMSTA  EQU     PTM+1           ; READ STATUS REGISTER
0041 e000                    PTMC13  EQU     PTM             ; CONTROL REGISTERS 1 AND 3
0042 e001                    PTMC2   EQU     PTM+1           ; CONTROL REGISTER 2
0043 e002                    PTMTM1  EQU     PTM+2           ; LATCH 1
0044 e004                    PTMTM2  EQU     PTM+4           ; LATCH 2
0045 e006                    PTMTM3  EQU     PTM+6           ; LATCH 3
0046 008c                    SKIP2   EQU     $8C             ; "CMPX #" OPCODE - SKIPS TWO BYTES
0047                         
0048                         *******************************************
0049                         * ASSIST09 MONITOR SWI FUNCTIONS
0050                         * THE FOLLOWING EQUATES DEFINE FUNCTIONS PROVIDED
0051                         * BY THE ASSIST09 MONITOR VIA THE SWI INSTRUCTION.
0052                         ******************************************
0053 0000                    INCHNP  EQU     0               ; INPUT CHAR IN A REG - NO PARITY
0054 0001                    OUTCH   EQU     1               ; OUTPUT CHAR FROM A REG
0055 0002                    PDATA1  EQU     2               ; OUTPUT STRING
0056 0003                    PDATA   EQU     3               ; OUTPUT CR/LF THEN STRING
0057 0004                    OUT2HS  EQU     4               ; OUTPUT TWO HEX AND SPACE
0058 0005                    OUT4HS  EQU     5               ; OUTPUT FOUR HEX AND SPACE
0059 0006                    PCRLF   EQU     6               ; OUTPUT CR/LF
0060 0007                    SPACE   EQU     7               ; OUTPUT A SPACE
0061 0008                    MONITR  EQU     8               ; ENTER ASSIST09 MONITOR
0062 0009                    VCTRSW  EQU     9               ; VECTOR EXAMINE/SWITCH
0063 000a                    BRKPT   EQU     10              ; USER PROGRAM BREAKPOINT
0064 000b                    PAUSE   EQU     11              ; TASK PAUSE FUNCTION
0065 000b                    NUMFUN  EQU     11              ; NUMBER OF AVAILABLE FUNCTIONS
0066                         
0067                         * NEXT SUB-CODES FOR ACCESSING THE VECTOR TABLE.
0068                         * THEY ARE EQUIVALENT TO OFFSETS IN THE TABLE.
0069                         * RELATIVE POSITIONING MUST BE MAINTAINED
0070                         
0071 0000                    .AVTBL  EQU     0               ; ADDRESS OF VECTOR TABLE
0072 0002                    .CMDL1  EQU     2               ; FIRST COMMAND LIST
0073 0004                    .RSVD   EQU     4               ; RESERVED HARDWARE VECTOR
0074 0006                    .SWI3   EQU     6               ; SWI3 ROUTINE
0075 0008                    .SWI2   EQU     8               ; SWI2 ROUTINE
0076 000a                    .FIRQ   EQU     10              ; FIRQ ROUTINE
0077 000c                    .IRQ    EQU     12              ; IRQ ROUTINE
0078 000e                    .SWI    EQU     14              ; SWI ROUTINE
0079 0010                    .NMI    EQU     16              ; NMI ROUTINE
0080 0012                    .RESET  EQU     18              ; RESET ROUTINE
0081 0014                    .CION   EQU     20              ; CONSOLE ON
0082 0016                    .CIDTA  EQU     22              ; CONSOLE INPUT DATA
0083 0018                    .CIOFF  EQU     24              ; CONSOLE INPUT OFF
0084 001a                    .COON   EQU     26              ; CONSOLE OUTPUT ON
0085 001c                    .CODTA  EQU     28              ; CONSOLE OUTPUT DATA
0086 001e                    .COOFF  EQU     30              ; CONSOLE OUTPUT OFF
0087 0020                    .HSDTA  EQU     32              ; HIGH SPEED PRINTDATA
0088 0022                    .BSON   EQU     34              ; PUNCH/LOAD ON
0089 0024                    .BSDTA  EQU     36              ; PUNCH/LOAD DATA
0090 0026                    .BSOFF  EQU     38              ; PUNCH/LOAD OFF
0091 0028                    .PAUSE  EQU     40              ; TASK PAUSE ROUTINE
0092 002a                    .EXPAN  EQU     42              ; EXPRESSION ANALYZER
0093 002c                    .CMDL2  EQU     44              ; SECOND COMMAND LIST
0094 002e                    .ACIA   EQU     46              ; ACIA ADDRESS
0095 0030                    .PAD    EQU     48              ; CHARACTER PAD AND NEW LINE PAD
0096 0032                    .ECHO   EQU     50              ; ECHO/LOAD AND NULL BKPT FLAG
0097 0034                    .PTM    EQU     52              ; PTM ADDRESS
0098 001b                    NUMVTR  EQU     52/2+1          ; NUMBER OF VECTORS
0099 0034                    HIVTR   EQU     52              ; HIGHEST VECTOR OFFSET
0100                         
0101                         ******************************************
0102                         *           WORK AREA
0103                         * THIS WORK AREA IS ASSIGNED TO THE PAGE ADDRESSED BY
0104                         * -$1800,PCR FROM THE BASE ADDRESS OF THE ASSIST09
0105                         * ROM. THE DIRECT PAGE REGISTER DURING MOST ROUTINE
0106                         * OPERATIONS WILL POINT TO THIS WORK AREA. THE STACK
0107                         * INITIALLY STARTS UNDER THE RESERVED WORK AREAS AS
0108                         * DEFINED HEREIN.
0109                         ******************************************
0110 df00                    WORKPG  EQU     ROMBEG+RAMOFS   ; SETUP DIRECT PAGE ADDRESS
0111                         *       SETDP   =WORKPG         ; NOTIFY ASSEMBLER
0112 e000                            ORG     WORKPG+256      ; READY PAGE DEFINITIONS
0113                         
0114                         * THE FOLLOWING THRU BKPTOP MUST RESIDE IN THIS ORDER
0115                         * FOR PROPER INITIALIZATION
0116 dffc                            ORG     *-4
0117 dffc                    PAUSER  EQU     *               ; PAUSE ROUTINE
0118 dffb                            ORG     *-1
0119 dffb                    SWIBFL  EQU     *               ; BYPASS SWI AS BREAKPOINT FLAG
0120 dffa                            ORG     *-1
0121 dffa                    BKPTCT  EQU     *               ; BREAKPOINT COUNT
0122 dff8                            ORG     *-2             ; SLEVEL EQU
0123 dff8                    SLEVEL  EQU     *               ; STACK TRACE LEVEL
0124 dfc2                            ORG     -NUMVTR*2+*
0125 dfc2                    VECTAB  EQU     *               ; VECTOR TABLE
0126 dfb2                            ORG     -2*NUMBKP+*
0127 dfb2                    BKPTBL  EQU     *               ; BREAKPOINT TABLE
0128 dfa2                            ORG     -2*NUMBKP+*
0129 dfa2                    BKPTOP  EQU     *               ; BREAKPOINT OPCODE TABLE
0130 dfa0                            ORG     *-2
0131 dfa0                    WINDOW  EQU     *               ; WINDOW
0132 df9e                            ORG     *-2
0133 df9e                    ADDR    EQU     *               ; ADDRESS POINTER VALUE
0134 df9d                            ORG     *-1
0135 df9d                    BASEPG  EQU     *               ; BASE PAGE VALUE
0136 df9b                            ORG     *-2
0137 df9b                    NUMBER  EQU     *               ; BINARY BUILD AREA
0138 df99                            ORG     *-2
0139 df99                    LASTOP  EQU     *               ; LAST OPCODE TRACED
0140 df97                            ORG     *-2
0141 df97                    RSTACK  EQU     *               ; RESET STACK POINTER
0142 df95                            ORG     *-2
0143 df95                    PSTACK  EQU     *               ; COMMAND RECOVERY STACK
0144 df93                            ORG     *-2
0145 df93                    PCNTER  EQU     *               ; LAST PROGRAM COUNTER
0146 df91                            ORG     *-2
0147 df91                    TRACEC  EQU     *               ; TRACE COUNT
0148 df90                            ORG     *-1
0149 df90                    SWICNT  EQU     *               ; TRACE "SWI" NEST LEVEL COUNT
0150 df8f                            ORG     *-1             ; (MISFLG MUST FOLLOW SWICNT)
0151 df8f                    MISFLG  EQU     *               ; LOAD CMD/THRU BREAKPOINT FLAG
0152 df8e                            ORG     *-1
0153 df8e                    DELIM   EQU     *               ; EXPRESSION DELIMITER/WORK BYTE
0154 df66                            ORG     *-40
0155 df66                    ROM2WK  EQU     *               ; EXTENSION ROM RESERVED AREA
0156 df51                            ORG     *-21
0157 df51                    TSTACK  EQU     *               ; TEMPORARY STACK HOLD
0158 df51                    STACK   EQU     *               ; START OF INITIAL STACK
0159                         
0160                         ******************************************
0161                         * DEFAULT THE ROM BEGINNING ADDRESS TO 'ROMBEG'
0162                         * ASSIST09 IS POSITION ADDRESS INDEPENDENT, HOWEVER
0163                         * WE ASSEMBLE ASSUMING CONTROL OF THE HARDWARE VECTORS.
0164                         * NOTE THAT THE WORK RAM PAGE MUST BE 'RAMOFS'
0165                         * FROM THE ROM BEGINNING ADDRESS.
0166                         ********************************************
0167 f800                            ORG     ROMBEG          ; ROM ASSEMBLY/DEFAULT ADDRESS
0168                         
0169                         *****************************************************
0170                         * BLDVTR - BUILD ASSIST09 VECTOR TABLE
0171                         * HARDWARE RESET CALLS THIS SUBROUTINE TO BUILD THE
0172                         * ASSIST09 VECTOR TABLE. THIS SUBROUTINE RESIDES AT
0173                         * THE FIRST BYTE OF THE ASSIST09 ROM, AND CAN BE
0174                         * CALLED VIA EXTERNAL CONTROL CODE FOR REMOTE
0175                         * ASSIST09 EXECUTION.
0176                         * INPUT: S->VALID STACK RAM
0177                         * OUTPUT: U->VECTOR TABLE ADDRESS
0178                         * DPR->ASSIST09 WORK AREA PAGE
0179                         * THE VECTOR TABLE AND DEFAULTS ARE INITIALIZED
0180                         * ALL REGISTERS VOLATILE
0181                         *************************************************
0182 f800 30 8d e7 be        BLDVTR  LEAX    VECTAB,PCR      ; ADDRESS VECTOR TABLE
0183 f804 1f 10                      TFR     X,D             ; OBTAIN BASE PAGE ADDRESS
0184 f806 1f 8b                      TFR     A,DP            ; SETUP DPR
0185 f808 97 9d                      STA     <BASEPG         ; STORE FOR QUICK REFERENCE
0186 f80a 33 84                      LEAU    ,X              ; RETURN TABLE TO CALLER
0187 f80c 31 8c 35                   LEAY    <INITVT,PCR     ; LOAD FROM ADDR
0188 f80f ef 81                      STU     ,X++            ; INIT VECTOR TABLE ADDRESS
0189 f811 c6 16                      LDB     #NUMVTR-5       ; NUMBER RELOCATABLE VECTORS
0190 f813 34 04                      PSHS    B               ; STORE INDEX ON STACK
0191 f815 1f 20              BLD2    TFR     Y,D             ; PREPARE ADDRESS RESOLVE
0192 f817 e3 a1                      ADDD    ,Y++            ; TO ABSOLUTE ADDRESS
0193 f819 ed 81                      STD     ,X++            ; INTO VECTOR TABLE
0194 f81b 6a e4                      DEC     ,S              ; COUNT DOWN
0195 f81d 26 f6                      BNE     BLD2            ; BRANCH IF MORE TO INSERT
0196 f81f c6 0d                      LDB     #INTVE-INTVS    ; STATIC VALUE INIT LENGTH
0197 f821 a6 a0              BLD3    LDA     ,Y+             ; LOAD NEXT BYTE
0198 f823 a7 80                      STA     ,X+             ; STORE INTO POSITION
0199 f825 5a                         DECB                    ; COUNT DOWN
0200 f826 26 f9                      BNE     BLD3            ; LOOP UNTIL DONE
0201 f828 31 8d f7 d4                LEAY    ROM2OF,PCR      ; TEST POSSIBLE EXTENSION ROM
0202 f82c 8e 20 fe                   LDX     #$20FE          ; LOAD "BRA *" FLAG PATTERN
0203 f82f ac a1                      CMPX    ,Y++            ; ? EXTENDED ROM HERE
0204 f831 26 02                      BNE     BLDRTN          ; BRANCH NOT OUR ROM TO RETURN
0205 f833 ad a4                      JSR     ,Y              ; CALL EXTENDED ROM INITIALIZE
0206 f835 35 84              BLDRTN  PULS    PC,B            ; RETURN TO INITIALIZER
0207                         
0208                         *****************************************************
0209                         *                RESET ENTRY POINT
0210                         * HARDWARE RESET ENTERS HERE IF ASSIST09 IS ENABLED
0211                         * TO RECEIVE THE MC6809 HARDWARE VECTORS. WE CALL
0212                         * THE BLDVTR SUBROUTINE TO INITIALIZE THE VECTOR
0213                         * TABLE, STACK, AND THEN FIREUP THE MONITOR VIA SWI
0214                         * CALL.
0215                         *******************************************************
0216 f837 32 8d e7 16        RESET   LEAS    STACK,PCR       ; SETUP INITIAL STACK
0217 f83b 8d c3                      BSR     BLDVTR          ; BUILD VECTOR TABLE
0218 f83d 4f                 RESET2  CLRA                    ; ISSUE STARTUP MESSAGE
0219 f83e 1f 8b                      TFR     A,DP            ; DEFAULT TO PAGE ZERO
0220 f840 3f                         SWI                     ; PERFORM MONITOR FIREUP
0221 f841 08                         FCB     MONITR          ; TO ENTER COMMAND PROCESSING
0222 f842 20 f9                      BRA     RESET2          ; REENTER MONITOR IF 'CONTINUE'
0223                         
0224                         ******************************************************
0225                         *        INITVT - INITIAL VECTOR TABLE
0226                         * THIS TABLE IS RELOCATED TO RAM AND REPRESENTS THE
0227                         * INITIAL STATE OF THE VECTOR TABLE. ALL ADDRESSES
0228                         * ARE CONVERTED TO ABSOLUTE FORM. THIS TABLE STARTS
0229                         * WITH THE SECOND ENTRY, ENDS WITH STATIC CONSTANT
0230                         * INITIALIZATION DATA WHICH CARRIES BEYOND THE TABLE.
0231                         ************************************************
0232 f844 01 58              INITVT  FDB     CMDTBL-*        ; DEFAULT FIRST COMMAND TABLE
0233 f846 02 92                      FDB     RSRVDR-*        ; DEFAULT UNDEFINED HARDWARE VECTOR
0234 f848 02 90                      FDB     SWI3R-*         ; DEFAULT SWI3
0235 f84a 02 8e                      FDB     SWI2R-*         ; DEFAULT SWI2
0236 f84c 02 70                      FDB     FIRQR-*         ; DEFAULT FIRQ
0237 f84e 02 8a                      FDB     IRQR-*          ; DEFAULT IRQ ROUTINE
0238 f850 00 45                      FDB     SWIR-*          ; DEFAULT SWI ROUTINE
0239 f852 02 2b                      FDB     NMIR-*          ; DEFAULT NMI ROUTINE
0240 f854 ff e3                      FDB     RESET-*         ; RESTART VECTOR
0241 f856 02 90                      FDB     CION-*          ; DEFAULT CION
0242 f858 02 84                      FDB     CIDTA-*         ; DEFAULT CIDTA
0243 f85a 02 96                      FDB     CIOFF-*         ; DEFAULT CIOFF
0244 f85c 02 8a                      FDB     COON-*          ; DEFAULT COON
0245 f85e 02 93                      FDB     CODTA-*         ; DEFAULT CODTA
0246 f860 02 90                      FDB     COOFF-*         ; DEFAULT COOFF
0247 f862 03 9a                      FDB     HSDTA-*         ; DEFAULT HSDTA
0248 f864 02 b7                      FDB     BSON-*          ; DEFAULT BSON
0249 f866 02 d2                      FDB     BSDTA-*         ; DEFAULT BSDTA
0250 f868 02 bf                      FDB     BSOFF-*         ; DEFAULT BSOFF
0251 f86a e7 92                      FDB     PAUSER-*        ; DEFAULT PAUSE ROUTINE
0252 f86c 04 7d                      FDB     EXP1-*          ; DEFAULT EXPRESSION ANALYZER
0253 f86e 01 2d                      FDB     CMDTB2-*        ; DEFAULT SECOND COMMAND TABLE
0254                         * CONSTANTS
0255 f870 e0 08              INTVS   FDB     ACIA            ; DEFAULT ACIA
0256 f872 00 05                      FCB     DFTCHP,DFTNLP   ; DEFAULT NULL PADDS
0257 f874 00 00                      FDB     0               ; DEFAULT ECHO
0258 f876 e0 00                      FDB     PTM             ; DEFAULT PTM
0259 f878 00 00                      FDB     0               ; INITIAL STACK TRACE LEVEL
0260 f87a 00                         FCB     0               ; INITIAL BREAKPOINT COUNT
0261 f87b 00                         FCB     0               ; SWI BREAKPOINT LEVEL
0262 f87c 39                         FCB     $39             ; DEFAULT PAUSE ROUTINE (RTS)
0263 f87d                    INTVE   EQU     *
0264                         *B
0265                         ***********************************************
0266                         *            ASSIST09 SWI HANDLER
0267                         * THE SWI HANDLER PROVIDES ALL INTERFACING NECESSARY
0268                         * FOR A USER PROGRAM. A FUNCTION BYTE IS ASSUMED TO
0269                         * FOLLOW THE SWI INSTRUCTION. IT IS BOUND CHECKED
0270                         * AND THE PROPER ROUTINE IS GIVEN CONTROL. THIS
0271                         * INVOCATION MAY ALSO BE A BREAKPOINT INTERRUPT.
0272                         * IF SO, THE BREAKPOINT HANDLER IS ENTERED.
0273                         * INPUT: MACHINE STATE DEFINED FOR SWI
0274                         * OUTPUT: VARIES ACCORDING TO FUNCTION CALLED. PC ON
0275                         * CALLERS STACK INCREMENTED BY ONE IF VALID CALL.
0276                         * VOLATILE REGISTERS: SEE FUNCTIONS CALLED
0277                         * STATE: RUNS DISABLED UNLESS FUNCTION CLEARS I FLAG.
0278                         ************************************************
0279                         * SWI FUNCTION VECTOR TABLE
0280 f87d 01 94              SWIVTB  FDB     ZINCH-SWIVTB    ; INCHNP
0281 f87f 01 b1                      FDB     ZOTCH1-SWIVTB   ; OUTCH
0282 f881 01 cb                      FDB     ZPDTA1-SWIVTB   ; PDATA1
0283 f883 01 c3                      FDB     ZPDATA-SWIVTB   ; PDATA
0284 f885 01 75                      FDB     ZOT2HS-SWIVTB   ; OUT2HS
0285 f887 01 73                      FDB     ZOT4HS-SWIVTB   ; OUT4HS
0286 f889 01 c0                      FDB     ZPCRLF-SWIVTB   ; PCRLF
0287 f88b 01 79                      FDB     ZSPACE-SWIVTB   ; SPACE
0288 f88d 00 55                      FDB     ZMONTR-SWIVTB   ; MONITR
0289 f88f 01 7d                      FDB     ZVSWTH-SWIVTB   ; VCTRSW
0290 f891 02 56                      FDB     ZBKPNT-SWIVTB   ; BREAKPOINT
0291 f893 01 d1                      FDB     ZPAUSE-SWIVTB   ; TASK PAUSE
0292                         
0293 f895 6a 8d e6 f7        SWIR    DEC     SWICNT,PCR      ; UP "SWI" LEVEL FOR TRACE
0294 f899 17 02 25                   LBSR    LDDP            ; SETUP PAGE AND VERIFY STACK
0295                         * CHECK FOR BREAKPOINT TRAP
0296 f89c ee 6a                      LDU     10,S            ; LOAD PROGRAM COUNTER
0297 f89e 33 5f                      LEAU    -1,U            ; BACK TO SWI ADDRESS
0298 f8a0 0d fb                      TST     <SWIBFL         ; ? THIS "SWI" BREAKPOINT
0299 f8a2 26 11                      BNE     SWIDNE          ; BRANCH IF SO TO LET THROUGH
0300 f8a4 17 06 9b                   LBSR    CBKLDR          ; OBTAIN BREAKPOINT POINTERS
0301 f8a7 50                         NEGB                    ; OBTAIN POSITIVE COUNT
0302 f8a8 5a                 SWILP   DECB                    ; COUNT DOWN
0303 f8a9 2b 0a                      BMI     SWIDNE          ; BRANCH WHEN DONE
0304 f8ab 11 a3 a1                   CMPU    ,Y++            ; ? WAS THIS A BREAKPOINT
0305 f8ae 26 f8                      BNE     SWILP           ; BRANCH IF NOT
0306 f8b0 ef 6a                      STU     10,S            ; SET PROGRAM COUNTER BACK
0307 f8b2 16 02 1e                   LBRA    ZBKPNT          ; GO DO BREAKPOINT
0308 f8b5 0f fb              SWIDNE  CLR     <SWIBFL         ; CLEAR IN CASE SET
0309 f8b7 37 06                      PULU    D               ; OBTAIN FUNCTION BYTE, UP PC
0310 f8b9 c1 0b                      CMPB    #NUMFUN         ; ? TOO HIGH
0311 f8bb 10 22 02 0f                LBHI    ERROR           ; YES, DO BREAKPOINT
0312 f8bf ef 6a                      STU     10,S            ; BUMP PROGRAM COUNTER PAST SWI
0313 f8c1 58                         ASLB                    ; FUNCTION CODE TIMES TWO
0314 f8c2 33 8c b8                   LEAU    SWIVTB,PCR      ; OBTAIN VECTOR BRANCH ADDRESS
0315 f8c5 ec c5                      LDD     B,U             ; LOAD OFFSET
0316 f8c7 6e cb                      JMP     D,U             ; JUMP TO ROUTINE
0317                         
0318                         **********************************************
0319                         * REGISTERS TO FUNCTION ROUTINES:
0320                         *  DP-> WORK AREA PAGE
0321                         *  D,Y,U=UNRELIABLE           X=AS CALLED FROM USER
0322                         *  S=AS FROM SWI INTERRUPT
0323                         *********************************************
0324                         
0325                         **************************************************
0326                         *            [SWI FUNCTION 8]
0327                         *              MONITOR ENTRY
0328                         *  FIREUP THE ASSIST09 MONITOR.
0329                         *  THE STACK WITH ITS VALUES FOR THE DIRECT PAGE
0330                         *  REGISTER AND CONDITION CODE FLAGS ARE USED AS IS.
0331                         *   1) INITIALIZE CONSOLE I/O
0332                         *   2) OPTIONALLY PRINT SIGNON
0333                         *   3) INITIALIZE PTM FOR SINGLE STEPPING
0334                         *   4) ENTER COMMAND PROCESSOR
0335                         * INPUT: A=0 INIT CONSOLE AND PRINT STARTUP MESSAGE
0336                         *        A#0 OMIT CONSOLE INIT AND STARTUP MESSAGE
0337                         *************************************************
0338                         
0339 f8c9 41 53 53 49 53 54  SIGNON  FCC     /ASSIST09/      ; SIGNON EYE-CATCHER
     30 39
0340 f8d1 04                         FCB     EOT
0341 f8d2 10 df 97           ZMONTR  STS     <RSTACK         ; SAVE FOR BAD STACK RECOVERY
0342 f8d5 6d 61                      TST     1,S             ; ? INIT CONSOLE AND SEND MSG
0343 f8d7 26 0d                      BNE     ZMONT2          ; BRANCH IF NOT
0344 f8d9 ad 9d e6 f9                JSR     [VECTAB+.CION,PCR] ; READY CONSOLE INPUT
0345 f8dd ad 9d e6 fb                JSR     [VECTAB+.COON,PCR] ; READY CONSOLE OUTPUT
0346 f8e1 30 8c e5                   LEAX    SIGNON,PCR         ; READY SIGNON EYE-CATCHER
0347 f8e4 3f                         SWI                     ; PERFORM
0348 f8e5 03                         FCB     PDATA           ; PRINT STRING
0349 f8e6 9e f6              ZMONT2  LDX     <VECTAB+.PTM    ; LOAD PTM ADDRESS
0350 f8e8 27 0d                      BEQ     CMD             ; BRANCH IF NOT TO USE A PTM
0351 f8ea 6f 02                      CLR     PTMTM1-PTM,X    ; SET LATCH TO CLEAR RESET
0352 f8ec 6f 03                      CLR     PTMTM1+1-PTM,X  ; AND SET GATE HIGH
0353 f8ee cc 01 a6                   LDD     #$01A6          ; SETUP TIMER 1 MODE
0354 f8f1 a7 01                      STA     PTMC2-PTM,X     ; SETUP FOR CONTROL REGISTER1
0355 f8f3 e7 84                      STB     PTMC13-PTM,X    ; SET OUTPUT ENABLED/
0356                         * SINGLE SHOT/ DUAL 8 BIT/INTERNAL MODE/OPERATE
0357 f8f5 6f 01                      CLR     PTMC2-PTM,X     ; SET CR2 BACK TO RESET FORM
0358                         * FALL INTO COMMAND PROCESSOR
0359                         
0360                         ***************************************************
0361                         *          COMMAND HANDLER
0362                         *  BREAKPOINTS ARE REMOVED AT THIS TIME.
0363                         *  PROMPT FOR A COMMAND, AND STORE ALL CHARACTERS
0364                         *  UNTIL A SEPARATOR ON THE STACK.
0365                         *  SEARCH FOR FIRST MATCHING COMMAND SUBSET,
0366                         *  CALL IT OR GIVE '?' RESPONSE.
0367                         *  DURING COMMAND SEARCH:
0368                         *      B=OFFSET TO NEXT ENTRY ON X
0369                         *      U=SAVED S
0370                         *      U-1=ENTRY SIZE+2
0371                         *      U-2=VALID NUMBER FLAG (>=0 VALID)/COMPARE CNT
0372                         *      U-3=CARRIAGE RETURN FLAG (0=CR HAS BEEN DONE)
0373                         *      U-4=START OF COMMAND STORE
0374                         *      S+0=END OF COMMAND STORE
0375                         ***********************************************
0376                         
0377 f8f7 3f                 CMD     SWI                     ; TO NEW LINE
0378 f8f8 06                         FCB     PCRLF           ; FUNCTION
0379                         * DISARM THE BREAKPOINTS
0380 f8f9 17 06 46           CMDNEP  LBSR    CBKLDR          ; OBTAIN BREAKPOINT POINTERS
0381 f8fc 2a 0c                      BPL     CMDNOL          ; BRANCH IF NOT ARMED OR NONE
0382 f8fe 50                         NEGB                    ; MAKE POSITIVE
0383 f8ff d7 fa                      STB     <BKPTCT         ; FLAG AS DISARMED
0384 f901 5a                 CMDDDL  DECB                    ; ? FINISHED
0385 f902 2b 06                      BMI     CMDNOL          ; BRANCH IF SO
0386 f904 a6 30                      LDA     -NUMBKP*2,Y     ; LOAD OPCODE STORED
0387 f906 a7 b1                      STA     [,Y++]          ; STORE BACK OVER "SWI"
0388 f908 20 f7                      BRA     CMDDDL          ; LOOP UNTIL DONE
0389 f90a ae 6a              CMDNOL  LDX     10,S            ; LOAD USERS PROGRAM COUNTER
0390 f90c 9f 93                      STX     <PCNTER         ; SAVE FOR EXPRESSION ANALYZER
0391 f90e 86 3e                      LDA     #PROMPT         ; LOAD PROMPT CHARACTER
0392 f910 3f                         SWI                     ; SEND TO OUTPUT HANDLER
0393 f911 01                         FCB     OUTCH           ; FUNCTION
0394 f912 33 e4                      LEAU    ,S              ; REMEMBER STACK RESTORE ADDRESS
0395 f914 df 95                      STU     <PSTACK         ; REMEMBER STACK FOR ERROR USE
0396 f916 4f                         CLRA                    ; PREPARE ZERO
0397 f917 5f                         CLRB                    ; PREPARE ZERO
0398 f918 dd 9b                      STD     <NUMBER         ; CLEAR NUMBER BUILD AREA
0399 f91a dd 8f                      STD     <MISFLG         ; CLEAR MISCEL. AND SWICNT FLAGS
0400 f91c dd 91                      STD     <TRACEC         ; CLEAR TRACE COUNT
0401 f91e c6 02                      LDB     #2              ; SET D TO TWO
0402 f920 34 07                      PSHS    D,CC            ; PLACE DEFAULTS ONTO STACK
0403                         * CHECK FOR "QUICK" COMMANDS.
0404 f922 17 04 54                   LBSR    READ            ; OBTAIN FIRST CHARACTER
0405 f925 30 8d 05 81                LEAX    CDOT+2,PCR      ; PRESET FOR SINGLE TRACE
0406 f929 81 2e                      CMPA    #'.             ; ? QUICK TRACE
0407 f92b 27 5a                      BEQ     CMDXQT          ; BRANCH EQUAL FOR TRACE ONE
0408 f92d 30 8d 04 e9                LEAX    CMPADP+2,PCR    ; READY MEMORY ENTRY POINT
0409 f931 81 2f                      CMPA    #'/             ; ? OPEN LAST USED MEMORY
0410 f933 27 52                      BEQ     CMDXQT          ; BRANCH TO DO IT IF SO
0411                         * PROCESS NEXT CHARACTER
0412 f935 81 20              CMD2    CMPA    #'              ; ? BLANK OR DELIMITER
0413 f937 23 14                      BLS    CMDGOT           ; BRANCH YES, WE HAVE IT
0414 f939 34 02                      PSHS   A                ; BUILD ONTO STACK
0415 f93b 6c 5f                      INC    -1,U             ; COUNT THIS CHARACTER
0416 f93d 81 2f                      CMPA   #'/              ; ? MEMORY COMMAND
0417 f93f 27 4f                      BEQ    CMDMEM           ; BRANCH IF SO
0418 f941 17 04 0b                   LBSR   BLDHXC           ; TREAT AS HEX VALUE
0419 f944 27 02                      BEQ    CMD3             ; BRANCH IF STILL VALID NUMBER
0420 f946 6a 5e                      DEC    -2,U             ; FLAG AS INVALID NUMBER
0421 f948 17 04 2e           CMD3    LBSR   READ             ; OBTAIN NEXT CHARACTER
0422 f94b 20 e8                      BRA    CMD2             ; TEST NEXT CHARACTER
0423                         * GOT COMMAND, NOW SEARCH TABLES
0424 f94d 80 0d              CMDGOT  SUBA   #CR              ; SET ZERO IF CARRIAGE RETURN
0425 f94f a7 5d                      STA    -3,U             ; SETUP FLAG
0426 f951 9e c4                      LDX    <VECTAB+.CMDL1   ; START WITH FIRST CMD LIST
0427 f953 e6 80              CMDSCH  LDB    ,X+              ; LOAD ENTRY LENGTH
0428 f955 2a 10                      BPL    CMDSME           ; BRANCH IF NOT LIST END
0429 f957 9e ee                      LDX    <VECTAB+.CMDL2   ; NOW TO SECOND CMD LITS
0430 f959 5c                         INCB                    ; ? TO CONTINUE TO DEFAULT LIST
0431 f95a 27 f7                      BEQ     CMDSCH          ; BRANCH IF SO
0432 f95c 10 de 95           CMDBAD  LDS     <PSTACK         ; RESTORE STACK
0433 f95f 30 8d 01 5a                LEAX    ERRMSG,PCR      ; POINT TO ERROR STRING
0434 f963 3f                         SWI                     ; SEND OUT
0435 f964 02                         FCB     PDATA1          ; TO CONSOLE
0436 f965 20 90                      BRA     CMD             ; AND TRY AGAIN
0437                         * SEARCH NEXT ENTRY
0438 f967 5a                 CMDSME  DECB                    ; TAKE ACCOUNT OF LENGTH BYTE
0439 f968 e1 5f                      CMPB    -1,U            ; ? ENTERED LONGER THAN ENTRY
0440 f96a 24 03                      BHS     CMDSIZ          ; BRANCH IF NOT TOO LONG
0441 f96c 3a                 CMDFLS  ABX                     ; SKIP TO NEXT ENTRY
0442 f96d 20 e4                      BRA     CMDSCH          ; AND TRY NEXT
0443 f96f 31 5d              CMDSIZ  LEAY    -3,U            ; PREPARE TO COMPARE
0444 f971 a6 5f                      LDA     -1,U            ; LOAD SIZE+2
0445 f973 80 02                      SUBA    #2              ; TO ACTUAL SIZE ENTERED
0446 f975 a7 5e                      STA     -2,U            ; SAVE SIZE FOR COUNTDOWN
0447 f977 5a                 CMDCMP  DECB                    ; DOWN ONE BYTE
0448 f978 a6 80                      LDA     ,X+             ; NEXT COMMAND CHARACTER
0449 f97a a1 a2                      CMPA    ,-Y             ; ? SAME AS THAT ENTERED
0450 f97c 26 ee                      BNE     CMDFLS          ; BRANCH TO FLUSH IF NOT
0451 f97e 6a 5e                      DEC     -2,U            ; COUNT DOWN LENGTH OF ENTRY
0452 f980 26 f5                      BNE     CMDCMP          ; BRANCH IF MORE TO TEST
0453 f982 3a                         ABX                     ; TO NEXT ENTRY
0454 f983 ec 1e                      LDD     -2,X            ; LOAD OFFSET
0455 f985 30 8b                      LEAX    D,X             ; COMPUTE ROUTINE ADDRESS+2
0456 f987 6d 5d              CMDXQT  TST     -3,U            ; SET CC FOR CARRIAGE RETURN TEST
0457 f989 32 c4                      LEAS    ,U              ; DELETE STACK WORK AREA
0458 f98b ad 1e                      JSR     -2,X            ; CALL COMMAND
0459 f98d 16 ff 7a                   LBRA    CMDNOL          ; GO GET NEXT COMMAND
0460 f990 6d 5e              CMDMEM  TST     -2,U            ; ? VALID HEX NUMBER ENTERED
0461 f992 2b c8                      BMI     CMDBAD          ; BRANCH ERROR IF NOT
0462 f994 30 88 ae                   LEAX    <CMEMN-CMPADP,X ; TO DIFFERENT ENTRY
0463 f997 dc 9b                      LDD     <NUMBER         ; LOAD NUMBER ENTERED
0464 f999 20 ec                      BRA     CMDXQT          ; AND ENTER MEMORY COMMAND
0465                         
0466                         ** COMMANDS ARE ENTERED AS A SUBROUTINE WITH:
0467                         **    DPR->ASSIST09 DIRECT PAGE WORK AREA
0468                         **    Z=1 CARRIAGE RETURN ENTERED
0469                         **    Z=0 NON CARRIAGE RETURN DELIMITER
0470                         **    S=NORMAL RETURN ADDRESS
0471                         ** THE LABEL "CMDBAD" MAY BE ENTERED TO ISSUE AN
0472                         ** AN ERROR FLAG (*).
0473                         **************************************************
0474                         *       ASSIST09 COMMAND TABLES
0475                         * THESE ARE THE DEFAULT COMMAND TABLES. EXTERNAL
0476                         * TABLES OF THE SAME FORMAT MAY EXTEND/REPLACE
0477                         * THESE BY USING THE VECTOR SWAP FUNCTION.
0478                         *
0479                         * ENTRY FORMAT:
0480                         *    +0...TOTAL SIZE OF ENTRY (INCLUDING THIS BYTE)
0481                         *    +1...COMMAND STRING
0482                         *    +N...TWO BYTE OFFSET TO COMMAND (ENTRYADDR-*)
0483                         *
0484                         * THE TABLES TERMINATE WITH A ONE BYTE -1 OR -2.
0485                         * THE -1 CONTINUES THE COMMAND SEARCH WITH THE
0486                         *        SECOND COMMAND TABLE.
0487                         * THE -2 TERMINATES COMMAND SEARCHES.
0488                         *****************************************************
0489                         
0490                         * THIS IS THE DEFAULT LIST FOR THE SECOND COMMAND
0491                         * LIST ENTRY.
0492                         
0493 f99b fe                 CMDTB2  FCB     -2              ; STOP COMMAND SEARCHES
0494                         
0495                         * THIS IS THE DEFAULT LIST FOR THE FIRST COMMAND
0496                         * LIST ENTRY.
0497                         
0498 f99c                    CMDTBL  EQU     *               ; MONITOR COMMAND TABLE
0499 f99c 04                         FCB     4
0500 f99d 42                         FCC     /B/             ; 'BREAKPOINT' COMMAND
0501 f99e 05 4d                      FDB     CBKPT-*
0502 f9a0 04                         FCB     4
0503 f9a1 43                         FCC     /C/             ; 'CALL' COMMAND
0504 f9a2 04 17                      FDB     CCALL-*
0505 f9a4 04                         FCB     4
0506 f9a5 44                         FCC     /D/             ; 'DISPLAY' COMMAND
0507 f9a6 04 9d                      FDB     CDISP-*
0508 f9a8 04                         FCB     4
0509 f9a9 45                         FCC     /E/             ; 'ENCODE' COMMAND
0510 f9aa 05 9f                      FDB     CENCDE-*
0511 f9ac 04                         FCB     4
0512 f9ad 47                         FCC     /G/             ; 'GO' COMMAND
0513 f9ae 03 d2                      FDB     CGO-*
0514 f9b0 04                         FCB     4
0515 f9b1 4c                         FCC     /L/             ; 'LOAD' COMMAND
0516 f9b2 04 dd                      FDB     CLOAD-*
0517 f9b4 04                         FCB     4
0518 f9b5 4d                         FCC     /M/             ; 'MEMORY' COMMAND
0519 f9b6 04 0d                      FDB     CMEM-*
0520 f9b8 04                         FCB     4
0521 f9b9 4e                         FCC     /N/             ; 'NULLS' COMMAND
0522 f9ba 04 fd                      FDB     CNULLS-*
0523 f9bc 04                         FCB     4
0524 f9bd 4f                         FCC     /O/             ; 'OFFSET' COMMAND
0525 f9be 05 0a                      FDB     COFFS-*
0526 f9c0 04                         FCB     4
0527 f9c1 50                         FCC     /P/             ; 'PUNCH' COMMAND
0528 f9c2 04 af                      FDB     CPUNCH-*
0529 f9c4 04                         FCB     4
0530 f9c5 52                         FCC     /R/             ; 'REGISTERS' COMMAND
0531 f9c6 02 84                      FDB     CREG-*
0532 f9c8 04                         FCB     4
0533 f9c9 53                         FCC     /S/             ; 'STLEVEL' COMMAND
0534 f9ca 04 f2                      FDB     CSTLEV-*
0535 f9cc 04                         FCB     4
0536 f9cd 54                         FCC     /T/             ; 'TRACE' COMMAND
0537 f9ce 04 d6                      FDB     CTRACE-*
0538 f9d0 04                         FCB     4
0539 f9d1 56                         FCC     /V/             ; 'VERIFY' COMMAND
0540 f9d2 04 cf                      FDB     CVER-*
0541 f9d4 04                         FCB     4
0542 f9d5 57                         FCC     /W/             ; 'WINDOW' COMMAND
0543 f9d6 04 68                      FDB     CWINDO-*
0544 f9d8 ff                         FCB     -1              ; END, CONTINUE WITH THE SECOND
0545                         
0546                         *************************************************
0547                         *             [SWI FUNCTIONS 4 AND 5]
0548                         *      4 - OUT2HS - DECODE BYTE TO HEX AND ADD SPACE
0549                         *      5 - OUT4HS - DECODE WORD TO HEX AND ADD SPACE
0550                         * INPUT: X->BYTE OR WORD TO DECODE
0551                         * OUTPUT: CHARACTERS SENT TO OUTPUT HANDLER
0552                         *         X->NEXT BYTE OR WORD
0553                         *************************************************
0554 f9d9 a6 80              ZOUT2H  LDA     ,X+             ; LOAD NEXT BYTE
0555 f9db 34 06                      PSHS    D               ; SAVE - DO NOT REREAD
0556 f9dd c6 10                      LDB     #16             ; SHIFT BY 4 BITS
0557 f9df 3d                         MUL                     ; WITH MULTIPLY
0558 f9e0 8d 04                      BSR     ZOUTHX          ; SEND OUT AS HEX
0559 f9e2 35 06                      PULS    D               ; RESTORE BYTES
0560 f9e4 84 0f                      ANDA    #$0F            ; ISOLATE RIGHT HEX
0561 f9e6 8b 90              ZOUTHX  ADDA    #$90            ; PREPARE A-F ADJUST
0562 f9e8 19                         DAA                     ; ADJUST
0563 f9e9 89 40                      ADCA    #$40            ; PREPARE CHARACTER BITS
0564 f9eb 19                         DAA                     ; ADJUST
0565 f9ec 6e 9d e5 ee        SEND    JMP     [VECTAB+.CODTA,PCR] ; SEND TO OUT HANDLER
0566                         
0567 f9f0 8d e7              ZOT4HS  BSR     ZOUT2H          ; CONVERT FIRST BYTE
0568 f9f2 8d e5              ZOT2HS  BSR     ZOUT2H          ; CONVERT BYTE TO HEX
0569 f9f4 af 64                      STX     4,S             ; UPDATE USERS X REGISTER
0570                         * FALL INTO SPACE ROUTINE
0571                         
0572                         *************************************************
0573                         *            [SWI FUNCTION 7]
0574                         *         SPACE - SEND BLANK TO OUTPUT HANDLER
0575                         * INPUT: NONE
0576                         * OUTPUT: BLANK SEND TO CONSOLE HANDLER
0577                         *************************************************
0578 f9f6 86 20              ZSPACE  LDA     #'              ; LOAD BLANK
0579 f9f8 20 3d                      BRA     ZOTCH2          ; SEND AND RETURN
0580                         
0581                         ***********************************************
0582                         *             [SWI FUNCTION 9]
0583                         *          SWAP VECTOR TABLE ENTRY
0584                         * INPUT: A=VECTOR TABLE CODE (OFFSET)
0585                         * X=0 OR REPLACEMENT VALUE
0586                         * OUTPUT: X=PREVIOUS VALUE
0587                         ***********************************************
0588 f9fa a6 61              ZVSWTH  LDA     1,S             ; LOAD REQUESTERS A
0589 f9fc 81 34                      CMPA    #HIVTR          ; ? SUB-CODE TOO HIGH
0590 f9fe 22 39                      BHI     ZOTCH3          ; IGNORE CALL IF SO
0591 fa00 10 9e c2                   LDY     <VECTAB+.AVTBL  ; LOAD VECTOR TABLE ADDRESS
0592 fa03 ee a6                      LDU     A,Y             ; U=OLD ENTRY
0593 fa05 ef 64                      STU     4,S             ; RETURN OLD VALUE TO CALLERS X
0594 fa07 af 7e                      STX     -2,S            ; ? X=0
0595 fa09 27 2e                      BEQ     ZOTCH3          ; YES, DO NOT CHANGE ENTRY
0596 fa0b af a6                      STX     A,Y             ; REPLACE ENTRY
0597 fa0d 20 2a                      BRA     ZOTCH3          ; RETURN FROM SWI
0598                         *D
0599                         
0600                         ************************************************
0601                         *               [SWI FUNCTION 0]
0602                         *  INCHNP - OBTAIN INPUT CHAR IN A (NO PARITY)
0603                         * NULLS AND RUBOUTS ARE IGNORED.
0604                         * AUTOMATIC LINE FEED IS SENT UPON RECEIVING A
0605                         * CARRIAGE RETURN.
0606                         * UNLESS WE ARE LOADING FROM TAPE.
0607                         ************************************************
0608 fa0f 8d 5d              ZINCHP  BSR     XQPAUS          ; RELEASE PROCESSOR
0609 fa11 8d 5f              ZINCH   BSR     XQCIDT          ; CALL INPUT DATA APPENDAGE
0610 fa13 24 fa                      BCC     ZINCHP          ; LOOP IF NONE AVAILABLE
0611 fa15 4d                         TSTA                    ; ? TEST FOR NULL
0612 fa16 27 f9                      BEQ     ZINCH           ; IGNORE NULL
0613 fa18 81 7f                      CMPA    #$7F            ; ? RUBOUT
0614 fa1a 27 f5                      BEQ     ZINCH           ; BRANCH YES TO IGNORE
0615 fa1c a7 61                      STA     1,S             ; STORE INTO CALLERS A
0616 fa1e 0d 8f                      TST     <MISFLG         ; ? LOAD IN PROGRESS
0617 fa20 26 17                      BNE     ZOTCH3          ; BRANCH IF SO TO NOT ECHO
0618 fa22 81 0d                      CMPA    #CR             ; ? CARRIAGE RETURN
0619 fa24 26 04                      BNE     ZIN2            ; NO, TEST ECHO BYTE
0620 fa26 86 0a                      LDA     #LF             ; LOAD LINE FEED
0621 fa28 8d c2                      BSR     SEND            ; ALWAYS ECHO LINE FEED
0622 fa2a 0d f4              ZIN2    TST     <VECTAB+.ECHO   ; ? ECHO DESIRED
0623 fa2c 26 0b                      BNE     ZOTCH3          ; NO, RETURN
0624                         * FALL THROUGH TO OUTCH
0625                         ************************************************
0626                         *            [SWI FUNCTION 1]
0627                         *        OUTCH - OUTPUT CHARACTER FROM A
0628                         * INPUT: NONE
0629                         * OUTPUT: IF LINEFEED IS THE OUTPUT CHARACTER THEN
0630                         * C=0 NO CTL-X RECEIVED, C=1 CTL-X RECEIVED
0631                         ************************************************
0632 fa2e a6 61              ZOTCH1  LDA     1,S             ; LOAD CHARACTER TO SEND
0633 fa30 30 8c 09                   LEAX    <ZPCRLS,PCR     ; DEFAULT FOR LINE FEED
0634 fa33 81 0a                      CMPA    #LF             ; ? LINE FEED
0635 fa35 27 0f                      BEQ     ZPDTLP          ; BRANCH TO CHECK PAUSE IF SO
0636 fa37 8d b3              ZOTCH2  BSR     SEND            ; SEND TO OUTPUT ROUTINE
0637 fa39 0c 90              ZOTCH3  INC     <SWICNT         ; BUMP UP "SWI" TRACE NEST LEVEL
0638 fa3b 3b                         RTI                     ; RETURN FROM "SWI" FUNCTION
0639                         
0640                         **************************************************
0641                         * [SWI FUNCTION 6]
0642                         * PCRLF - SEND CR/LF TO CONSOLE HANDLER
0643                         * INPUT: NONE
0644                         * OUTPUT: CR AND LF SENT TO HANDLER
0645                         * C=0 NO CTL-X, C=1 CTL-X RECEIVED
0646                         **************************************************
0647 fa3c 04                 ZPCRLS  FCB     EOT             ; NULL STRING
0648 fa3d 30 8c fc           ZPCRLF LEAX     ZPCRLS,PCR      ; READY CR,LF STRING
0649                         * FALL INTO CR/LF CODE
0650                         
0651                         **************************************************
0652                         * [SWI FUNCTION 3]
0653                         * PDATA - OUTPUT CR/LF AND STRING
0654                         * INPUT: X->STRING
0655                         * OUTPUT: CR/LF AND STRING SENT TO OUTPUT CONSOLE
0656                         * HANDLER.
0657                         * C=0 NO CTL-X, C=1 CTL-X RECEIVED
0658                         * NOTE: LINE FEED MUST FOLLOW CARRIAGE RETURN FOR
0659                         * PROPER PUNCH DATA.
0660                         **************************************************
0661                         
0662 fa40 86 0d              ZPDATA  LDA     #CR             ; LOAD CARRIAGE RETURN
0663 fa42 8d a8                      BSR     SEND            ; SEND IT
0664 fa44 86 0a                      LDA     #LF             ; LOAD LINE FEED
0665                         * FALL INTO PDATA1
0666                         
0667                         *************************************************
0668                         * [SWI FUNCTION 2]
0669                         * PDATA1 - OUTPUT STRING TILL EOT ($04)
0670                         * THIS ROUTINE PAUSES IF AN INPUT BYTE BECOMES
0671                         * AVAILABLE DURING OUTPUT TRANSMISSION UNTIL A
0672                         * SECOND IS RECEIVED.
0673                         * INPUT: X->STRING
0674                         * OUTPUT: STRING SENT TO OUTPUT CONSOLE DRIVER
0675                         * C=0 NO CTL-X, C=1 CTL-X RECEIVED
0676                         *************************************************
0677                         
0678 fa46 8d a4              ZPDTLP  BSR     SEND            ; SEND CHARACTER TO DRIVER
0679 fa48 a6 80              ZPDTA1  LDA     ,X+             ; LOAD NEXT CHARACTER
0680 fa4a 81 04                      CMPA    #EOT            ; ? EOT
0681 fa4c 26 f8                      BNE     ZPDTLP          ; LOOP IF NOT
0682                         * FALL INTO PAUSE CHECK FUNCTION
0683                         
0684                         ********************************************
0685                         * [SWI FUNCTION 12]
0686                         * PAUSE - RETURN TO TASK DISPATCHING AND CHECK
0687                         * FOR FREEZE CONDITION OR CTL-X BREAK
0688                         * THIS FUNCTION ENTERS THE TASK PAUSE HANDLER SO
0689                         * OPTIONALLY OTHER 6809 PROCESSES MAY GAIN CONTROL.
0690                         * UPON RETURN, CHECK FOR A 'FREEZE' CONDITION
0691                         * WITH A RESULTING WAIT LOOP, OR CONDITION CODE
0692                         * RETURN IF A CONTROL-X IS ENTERED FROM THE INPUT
0693                         * HANDLER.
0694                         * OUTPUT: C=1 IF CTL-X HAS ENTERED, C=0 OTHERWISE
0695                         ******************************************
0696                         
0697 fa4e 8d 1e              ZPAUSE  BSR     XQPAUS          ; RELEASE CONTROL AT EVERY LINE
0698 fa50 8d 06                      BSR     CHKABT          ; CHECK FOR FREEZE OR ABORT
0699 fa52 1f a9                      TFR     CC,B            ; PREPARE TO REPLACE CC
0700 fa54 e7 e4                      STB     ,S              ; OVERLAY OLD ONE ON STACK
0701 fa56 20 e1                      BRA     ZOTCH3          ; RETURN FROM "SWI"
0702                         
0703                         * CHKABT - SCAN FOR INPUT PAUSE/ABORT DURING OUTPUT
0704                         * OUTPUT: C=0 OK, C=1 ABORT (CTL-X ISSUED)
0705                         * VOLATILE: U,X,D
0706 fa58 8d 18              CHKABT  BSR     XQCIDT          ; ATTEMPT INPUT
0707 fa5a 24 05                      BCC     CHKRTN          ; BRANCH NO TO RETURN
0708 fa5c 81 18                      CMPA    #CAN            ; ? CTL-X FOR ABORT
0709 fa5e 26 02                      BNE     CHKWT           ; BRANCH NO TO PAUSE
0710 fa60 53                 CHKSEC  COMB                    ; SET CARRY
0711 fa61 39                 CHKRTN  RTS                     ; RETURN TO CALLER WITH CC SET
0712 fa62 8d 0a              CHKWT   BSR     XQPAUS          ; PAUSE FOR A MOMENT
0713 fa64 8d 0c                      BSR     XQCIDT          ; ? KEY FOR START
0714 fa66 24 fa                      BCC     CHKWT           ; LOOP UNTIL RECEIVED
0715 fa68 81 18                      CMPA    #CAN            ; ? ABORT SIGNALED FROM WAIT
0716 fa6a 27 f4                      BEQ     CHKSEC          ; BRANCH YES
0717 fa6c 4f                         CLRA                    ; SET C=0 FOR NO ABORT
0718 fa6d 39                         RTS                     ; AND RETURN
0719                         
0720                         * SAVE MEMORY WITH JUMPS
0721 fa6e 6e 9d e5 78        XQPAUS  JMP   [VECTAB+.PAUSE,PCR] ; TO PAUSE ROUTINE
0722 fa72 ad 9d e5 62        XQCIDT  JSR   [VECTAB+.CIDTA,PCR] ; TO INPUT ROUTINE
0723 fa76 84 7f                      ANDA  #$7F              ; STRIP PARITY
0724 fa78 39                         RTS                     ; RETURN TO CALLER
0725                         
0726                         ********************************************
0727                         * NMI DEFAULT INTERRUPT HANDLER
0728                         * THE NMI HANDLER IS USED FOR TRACING INSTRUCTIONS.
0729                         * TRACE PRINTOUTS OCCUR ONLY AS LONG AS THE STACK
0730                         * TRACE LEVEL IS NOT BREACHED BY FALLING BELOW IT.
0731                         * TRACING CONTINUES UNTIL THE COUNT TURNS ZERO OR
0732                         * A CTL-X IS ENTERED FROM THE INPUT CONSOLE DEVICE.
0733                         *********************************************
0734                         
0735 fa79 4f 50 2d 04        MSHOWP  FCB     'O,'P,'-,EOT    ; OPCODE PREP
0736                         
0737 fa7d 8d 42              NMIR    BSR     LDDP            ; LOAD PAGE AND VERIFY STACK
0738 fa7f 0d 8f                      TST     <MISFLG         ; ? THRU A BREAKPOINT
0739 fa81 26 34                      BNE     NMICON          ; BRANCH IF SO TO CONTINUE
0740 fa83 0d 90                      TST     <SWICNT         ; ? INHIBIT "SWI" DURING TRACE
0741 fa85 2b 29                      BMI     NMITRC          ; BRANCH YES
0742 fa87 30 6c                      LEAX    12,S            ; OBTAIN USERS STACK POINTER
0743 fa89 9c f8                      CMPX    <SLEVEL         ; ? TO TRACE HERE
0744 fa8b 25 23                      BLO     NMITRC          ; BRANCH IF TOO LOW TO DISPLAY
0745 fa8d 30 8c e9                   LEAX    MSHOWP,PCR      ; LOAD OP PREP
0746 fa90 3f                         SWI                     ; SEND TO CONSOLE
0747 fa91 02                         FCB     PDATA1          ; FUNCTION
0748 fa92 09 8e                      ROL     <DELIM          ; SAVE CARRY BIT
0749 fa94 30 8d e5 01                LEAX    LASTOP,PCR      ; POINT TO LAST OP
0750 fa98 3f                         SWI                     ; SEND OUT AS HEX
0751 fa99 05                         FCB     OUT4HS          ; FUNCTION
0752 fa9a 8d 17                      BSR     REGPRS          ; FOLLOW MEMORY WITH REGISTERS
0753 fa9c 25 37                      BCS     ZBKCMD          ; BRANCH IF "CANCEL"
0754 fa9e 06 8e                      ROR     <DELIM          ; RESTORE CARRY BIT
0755 faa0 25 33                      BCS     ZBKCMD          ; BRANCH IF "CANCEL"
0756 faa2 9e 91                      LDX     <TRACEC         ; LOAD TRACE COUNT
0757 faa4 27 2f                      BEQ     ZBKCMD          ; IF ZERO TO COMMAND HANDLER
0758 faa6 30 1f                      LEAX    -1,X            ; MINUS ONE
0759 faa8 9f 91                      STX     <TRACEC         ; REFRESH
0760 faaa 27 29                      BEQ     ZBKCMD          ; STOP TRACE WHEN ZERO
0761 faac 8d aa                      BSR     CHKABT          ; ? ABORT THE TRACE
0762 faae 25 25                      BCS     ZBKCMD          ; BRANCH YES TO COMMAND HANDLER
0763 fab0 16 03 f7           NMITRC  LBRA    CTRCE3          ; NO, TRACE ANOTHER INSTRUCTION
0764                         
0765 fab3 17 01 b9           REGPRS  LBSR    REGPRT          ; PRINT REGISTERS AS FROM COMMAND
0766 fab6 39                         RTS                     ; RETURN TO CALLER
0767                         
0768                         * JUST EXECUTED THRU A BRKPNT. NOW CONTINUE NORMALLY
0769                         
0770 fab7 0f 8f              NMICON  CLR     <MISFLG        ; CLEAR THRU FLAG
0771 fab9 17 02 eb                   LBSR    ARMBK2         ; ARM BREAKPOINTS
0772 fabc 3b                 RTI     RTI                    ; AND CONTINUE USERS PROGRAM
0773                         
0774                         * LDDP - SETUP DIRECT PAGE REGISTER, VERIFY STACK.
0775                         * AN INVALID STACK CAUSES A RETURN TO THE COMMAND
0776                         * HANDLER.
0777                         * INPUT: FULLY STACKED REGISTERS FROM AN INTERRUPT
0778                         * OUTPUT: DPR LOADED TO WORK PAGE
0779                         
0780 fabd 3f 07 20 04        ERRMSG  FCB     '?,BELL,$20,EOT ; ERROR RESPONSE
0781                         
0782 fac1 e6 8d e4 d8        LDDP    LDB     BASEPG,PCR      ; LOAD DIRECT PAGE HIGH BYTE
0783 fac5 1f 9b                      TFR     B,DP            ; SETUP DIRECT PAGE REGISTER
0784 fac7 a1 63                      CMPA    3,S             ; ? IS STACK VALID
0785 fac9 27 25                      BEQ     RTS             ; YES, RETURN
0786 facb 10 de 97                   LDS     <RSTACK         ; RESET TO INITIAL STACK POINTER
0787 face 30 8c ec           ERROR   LEAX    ERRMSG,PCR      ; LOAD ERROR REPORT
0788 fad1 3f                         SWI                     ; SEND OUT BEFORE REGISTERS
0789 fad2 03                         FCB     PDATA           ; ON NEXT LINE
0790                         * FALL INTO BREAKPOINT HANDLER
0791                         
0792                         **********************************************
0793                         * [SWI FUNCTION 10]
0794                         * BREAKPOINT PROGRAM FUNCTION
0795                         * PRINT REGISTERS AND GO TO COMMAND HANLER
0796                         ***********************************************
0797                         
0798 fad3 8d de              ZBKPNT  BSR     REGPRS          ; PRINT OUT REGISTERS
0799 fad5 16 fe 21           ZBKCMD  LBRA    CMDNEP          ; NOW ENTER COMMAND HANDLER
0800                         
0801                         ********************************************
0802                         * IRQ, RESERVED, SWI2 AND SWI3 INTERRUPT HANDLERS
0803                         * THE DEFAULT HANDLING IS TO CAUSE A BREAKPOINT.
0804                         ********************************************
0805 fad8                    SWI2R   EQU     *               ; SWI2 ENTRY
0806 fad8                    SWI3R   EQU     *               ; SWI3 ENTRY
0807 fad8                    IRQR    EQU     *               ; IRQ ENTRY
0808 fad8 8d e7              RSRVDR  BSR     LDDP            ; SET BASE PAGE, VALIDATE STACK
0809 fada 20 f7                      BRA     ZBKPNT          ; FORCE A BREAKPOINT
0810                         
0811                         ******************************************
0812                         * FIRQ HANDLER
0813                         * JUST RETURN FOR THE FIRQ INTERRUPT
0814                         ******************************************
0815 fabc                    FIRQR   EQU     RTI             ; IMMEDIATE RETURN
0816                         
0817                         **************************************************
0818                         * DEFAULT I/O DRIVERS
0819                         **************************************************
0820                         * CIDTA - RETURN CONSOLE INPUT CHARACTER
0821                         * OUTPUT: C=0 IF NO DATA READY, C=1 A=CHARACTER
0822                         * U VOLATILE
0823                         
0824 fadc de f0              CIDTA   LDU     <VECTAB+.ACIA   ; LOAD ACIA ADDRESS
0825 fade a6 c4                      LDA     ,U              ; LOAD STATUS REGISTER
0826 fae0 44                         LSRA                    ; TEST RECEIVER REGISTER FLAG
0827 fae1 24 02                      BCC     CIRTN           ; RETURN IF NOTHING
0828 fae3 a6 41                      LDA     1,U             ; LOAD DATA BYTE
0829 fae5 39                 CIRTN   RTS                     ; RETURN TO CALLER
0830                         
0831                         * CION - INPUT CONSOLE INITIALIZATION
0832                         * COON - OUTPUT CONSOLE INITIALIZATION
0833                         * A,X VOLATILE
0834 fae6                    CION   EQU      *
0835 fae6 86 03              COON   LDA      #3              ; RESET ACIA CODE
0836 fae8 9e f0                     LDX      <VECTAB+.ACIA   ; LOAD ACIA ADDRESS
0837 faea a7 84                     STA      ,X              ; STORE INTO STATUS REGISTER
0838 faec 86 51                     LDA      #$51            ; SET CONTROL
0839 faee a7 84                     STA      ,X              ; REGISTER UP
0840 faf0 39                 RTS    RTS                      ; RETURN TO CALLER
0841                         
0842                         * THE FOLLOWING HAVE NO DUTIES TO PERFORM
0843 faf0                    CIOFF EQU       RTS             ; CONSOLE INPUT OFF
0844 faf0                    COOFF EQU       RTS             ; CONSOLE OUTPUT OFF
0845                         
0846                         * CODTA - OUTPUT CHARACTER TO CONSOLE DEVICE
0847                         * INPUT: A=CHARACTER TO SEND
0848                         * OUTPUT: CHAR SENT TO TERMINAL WITH PROPER PADDING
0849                         * ALL REGISTERS TRANSPARENT
0850                         
0851 faf1 34 47              CODTA   PSHS    U,D,CC          ; SAVE REGISTERS,WORK BYTE
0852 faf3 de f0                      LDU     <VECTAB+.ACIA   ; ADDRESS ACIA
0853 faf5 8d 1b                      BSR     CODTAO          ; CALL OUTPUT CHAR SUBROUTINE
0854 faf7 81 10                      CMPA    #DLE            ; ? DATA LINE ESCAPE
0855 faf9 27 12                      BEQ     CODTRT          ; YES, RETURN
0856 fafb d6 f2                      LDB     <VECTAB+.PAD    ; DEFAULT TO CHAR PAD COUNT
0857 fafd 81 0d                      CMPA    #CR             ; ? CR
0858 faff 26 02                      BNE     CODTPD          ; BRANCH NO
0859 fb01 d6 f3                      LDB     <VECTAB+.PAD+1  ; LOAD NEW LINE PAD COUNT
0860 fb03 4f                 CODTPD  CLRA                    ; CREATE NULL
0861 fb04 e7 e4                      STB     ,S              ; SAVE COUNT
0862 fb06 8c                         FCB     SKIP2           ; ENTER LOOP
0863 fb07 8d 09              CODTLP  BSR     CODTAO          ; SEND NULL
0864 fb09 6a e4                      DEC     ,S              ; ? FINISHED
0865 fb0b 2a fa                      BPL     CODTLP          ; NO, CONTINUE WITH MORE
0866 fb0d 35 c7              CODTRT  PULS    PC,U,D,CC       ; RESTORE REGISTERS AND RETURN
0867                         
0868 fb0f 17 ff 5c           CODTAD  LBSR    XQPAUS          ; TEMPORARY GIVE UP CONTROL
0869 fb12 e6 41              CODTAO  LDB     1,U             ; LOAD ACIA CONTROL REGISTER
0870 fb14 c5 02                      BITB    #$02            ; ? TX REGISTER CLEAR >LSAB FIXME
0871 fb16 26 f7                      BNE     CODTAD          ; RELEASE CONTROL IF NOT
0872 fb18 a7 c4                      STA     ,U              ; STORE INTO DATA REGISTER
0873 fb1a 39                         RTS                     ; RETURN TO CALLER
0874                         *E
0875                         
0876                         * BSON - TURN ON READ/VERIFY/PUNCH MECHANISM
0877                         * A IS VOLATILE
0878                         
0879 fb1b 86 11              BSON    LDA     #$11            ; SET READ CODE
0880 fb1d 6d 66                      TST     6,S             ; ? READ OR VERIFY
0881 fb1f 26 01                      BNE     BSON2           ; BRANCH YES
0882 fb21 4c                         INCA                    ; SET TO WRITE
0883 fb22 3f                 BSON2   SWI                     ; PERFORM OUTPUT
0884 fb23 01                         FCB     OUTCH           ; FUNCTION
0885 fb24 0c 8f                      INC     <MISFLG         ; SET LOAD IN PROGRESS FLAG
0886 fb26 39                         RTS                     ; RETURN TO CALLER
0887                         
0888                         * BSOFF - TURN OFF READ/VERIFY/PUNCH MECHANISM
0889                         * A,X VOLATILE
0890                         
0891 fb27 86 14              BSOFF   LDA     #$14            ; TO DC4 - STOP
0892 fb29 3f                         SWI                     ; SEND OUT
0893 fb2a 01                         FCB     OUTCH           ; FUNCTION
0894 fb2b 4a                         DECA                    ; CHANGE TO DC3 (X-OFF)
0895 fb2c 3f                         SWI                     ; SEND OUT
0896 fb2d 01                         FCB     OUTCH           ; FUNCTION
0897 fb2e 0a 8f                      DEC     <MISFLG         ; CLEAR LOAD IN PROGRESS FLAG
0898 fb30 8e 61 a8                   LDX     #25000          ; DELAY 1 SECOND (2MHZ CLOCK)
0899 fb33 30 1f              BSOFLP  LEAX    -1,X            ; COUNT DOWN
0900 fb35 26 fc                      BNE     BSOFLP          ; LOOP TILL DONE
0901 fb37 39                         RTS                     ; RETURN TO CALLER
0902                         
0903                         * BSDTA - READ/VERIFY/PUNCH HANDLER
0904                         * INPUT: S+6=CODE BYTE, VERIFY(-1),PUNCH(0),LOAD(1)
0905                         * S+4=START ADDRESS
0906                         * S+2=STOP ADDRESS
0907                         * S+0=RETURN ADDRESS
0908                         * OUTPUT: Z=1 NORMAL COMPLETION, Z=0 INVALID LOAD/VER
0909                         * REGISTERS ARE VOLATILE
0910 fb38 ee 62              BSDTA   LDU     2,S             ; U=TO ADDRESS OR OFFSET
0911 fb3a 6d 66                      TST     6,S             ; ? PUNCH
0912 fb3c 27 54                      BEQ     BSDPUN          ; BRANCH YES
0913                         
0914                         * DURING READ/VERIFY: S+2=MSB ADDRESS SAVE BYTE
0915                         * S+1=BYTE COUNTER
0916                         * S+0=CHECKSUM
0917                         * U HOLDS OFFSET
0918 fb3e 32 7d                      LEAS    -3,S            ; ROOM FOR WORK/COUNTER/CHECKSUM
0919 fb40 3f                 BSDLD1  SWI                     ; GET NEXT CHARACTER
0920 fb41 00                         FCB     INCHNP          ; FUNCTION
0921 fb42 81 53              BSDLD2  CMPA    #'S             ; ? START OF S1/S9
0922 fb44 26 fa                      BNE     BSDLD1          ; BRANCH NOT
0923 fb46 3f                         SWI                     ; GET NEXT CHARACTER
0924 fb47 00                         FCB     INCHNP          ; FUNCTION
0925 fb48 81 39                      CMPA    #'9             ; ? HAVE S9
0926 fb4a 27 22                      BEQ     BSDSRT          ; YES, RETURN GOOD CODE
0927 fb4c 81 31                      CMPA    #'1             ; ? HAVE NEW RECORD
0928 fb4e 26 f2                      BNE     BSDLD2          ; BRANCH IF NOT
0929 fb50 6f e4                      CLR     ,S              ; CLEAR CHECKSUM
0930 fb52 8d 21                      BSR     BYTE            ; OBTAIN BYTE COUNT
0931 fb54 e7 61                      STB     1,S             ; SAVE FOR DECREMENT
0932                         
0933                         * READ ADDRESS
0934 fb56 8d 1d                      BSR     BYTE            ; OBTAIN HIGH VALUE
0935 fb58 e7 62                      STB     2,S             ; SAVE IT
0936 fb5a 8d 19                      BSR     BYTE            ; OBTAIN LOW VALUE
0937 fb5c a6 62                      LDA     2,S             ; MAKE D=VALUE
0938 fb5e 31 cb                      LEAY    D,U             ; Y=ADDRESS+OFFSET
0939                         * STORE TEXT
0940 fb60 8d 13              BSDNXT  BSR     BYTE            ; NEXT BYTE
0941 fb62 27 0c                      BEQ     BSDEOL          ; BRANCH IF CHECKSUM
0942 fb64 6d 69                      TST     9,S             ; ? VERIFY ONLY
0943 fb66 2b 02                      BMI     BSDCMP          ; YES, ONLY COMPARE
0944 fb68 e7 a4                      STB     ,Y              ; STORE INTO MEMORY
0945 fb6a e1 a0              BSDCMP  CMPB    ,Y+             ; ? VALID RAM
0946 fb6c 27 f2                      BEQ     BSDNXT          ; YES, CONTINUE READING
0947 fb6e 35 92              BSDSRT  PULS    PC,X,A          ; RETURN WITH Z SET PROPER
0948 fb70 4c                 BSDEOL  INCA                    ; ? VALID CHECKSUM
0949 fb71 27 cd                      BEQ     BSDLD1          ; BRANCH YES
0950 fb73 20 f9                      BRA     BSDSRT          ; RETURN Z=0 INVALID
0951                         
0952                         * BYTE BUILDS 8 BIT VALUE FROM TWO HEX DIGITS IN
0953 fb75 8d 12              BYTE    BSR     BYTHEX         ; OBTAIN FIRST HEX
0954 fb77 c6 10                      LDB     #16            ; PREPARE SHIFT
0955 fb79 3d                         MUL                    ; OVER TO A
0956 fb7a 8d 0d                      BSR     BYTHEX         ; OBTAIN SECOND HEX
0957 fb7c 34 04                      PSHS    B              ; SAVE HIGH HEX
0958 fb7e ab e0                      ADDA    ,S+            ; COMBINE BOTH SIDES
0959 fb80 1f 89                      TFR     A,B            ; SEND BACK IN B
0960 fb82 ab 62                      ADDA    2,S            ; COMPUTE NEW CHECKSUM
0961 fb84 a7 62                      STA     2,S            ; STORE BACK
0962 fb86 6a 63                      DEC     3,S            ; DECREMENT BYTE COUNT
0963 fb88 39                 BYTRTS  RTS                    ; RETURN TO CALLER
0964                         
0965 fb89 3f                 BYTHEX  SWI                    ; GET NEXT HEX
0966 fb8a 00                         FCB     INCHNP         ; CHARACTER
0967 fb8b 17 01 d4                   LBSR    CNVHEX         ; CONVERT TO HEX
0968 fb8e 27 f8                      BEQ     BYTRTS         ; RETURN IF VALID HEX
0969 fb90 35 f2                      PULS    PC,U,Y,X,A     ; RETURN TO CALLER WITH Z=0
0970                         
0971                         * PUNCH STACK USE: S+8=TO ADDRESS
0972                         *                  S+6=RETURN ADDRESS
0973                         *                  S+4=SAVED PADDING VALUES
0974                         *                  S+2 FROM ADDRESS
0975                         *                  S+1=FRAME COUNT/CHECKSUM
0976                         *                  S+0=BYTE COUNT
0977                         
0978 fb92 de f2              BSDPUN  LDU     <VECTAB+.PAD    ; LOAD PADDING VALUES
0979 fb94 ae 64                      LDX     4,S             ; X=FROM ADDRESS
0980 fb96 34 56                      PSHS    U,X,D           ; CREATE STACK WORK AREA
0981 fb98 cc 00 18                   LDD     #24             ; SET A=0, B=24
0982 fb9b d7 f2                      STB     <VECTAB+.PAD    ; SETUP 24 CHARACTER PADS
0983 fb9d 3f                         SWI                     ; SEND NULLS OUT
0984 fb9e 01                         FCB     OUTCH           ; FUNCTION
0985 fb9f c6 04                      LDB     #4              ; SETUP NEW LINE PAD TO 4
0986 fba1 dd f2                      STD     <VECTAB+.PAD    ; SETUP PUNCH PADDING
0987                         * CALCULATE SIZE
0988 fba3 ec 68              BSPGO   LDD     8,S             ; LOAD TO
0989 fba5 a3 62                      SUBD    2,S             ; MINUS FROM=LENGTH
0990 fba7 10 83 00 18                CMPD    #24             ; ? MORE THAN 23
0991 fbab 25 02                      BLO     BSPOK           ; NO, OK
0992 fbad c6 17                      LDB     #23             ; FORCE TO 23 MAX
0993 fbaf 5c                 BSPOK   INCB                    ; PREPARE COUNTER
0994 fbb0 e7 e4                      STB     ,S              ; STORE BYTE COUNT
0995 fbb2 cb 03                      ADDB    #3              ; ADJUST TO FRAME COUNT
0996 fbb4 e7 61                      STB     1,S             ; SAVE
0997                         
0998                         *PUNCH CR,LF,NULS,S,1
0999 fbb6 30 8c 33                  LEAX     <BSPSTR,PCR     ; LOAD START RECORD HEADER
1000 fbb9 3f                        SWI                      ; SEND OUT
1001 fbba 03                        FCB      PDATA           ; FUNCTION
1002                         * SEND FRAME COUNT
1003 fbbb 5f                        CLRB                     ; INITIALIZE CHECKSUM
1004 fbbc 30 61                     LEAX     1,S             ; POINT TO FRAME COUNT AND ADDR
1005 fbbe 8d 27                     BSR      BSPUN2          ; SEND FRAME COUNT
1006                         *DATA ADDRESS
1007 fbc0 8d 25                    BSR       BSPUN2          ; SEND ADDRESS HI
1008 fbc2 8d 23                    BSR       BSPUN2          ; SEND ADDRESS LOW
1009                         *PUNCH DATA
1010 fbc4 ae 62                     LDX      2,S             ; LOAD START DATA ADDRESS
1011 fbc6 8d 1f              BSPMRE BSR      BSPUN2          ; SEND OUT NEXT BYTE
1012 fbc8 6a e4                     DEC      ,S              ; ? FINAL BYTE
1013 fbca 26 fa                     BNE      BSPMRE          ; LOOP IF NOT DONE
1014 fbcc af 62                     STX      2,S             ; UPDATE FROM ADDRESS VALUE
1015                         *PUNCH CHECKSUM
1016 fbce 53                        COMB                     ; COMPLEMENT
1017 fbcf e7 61                     STB      1,S             ; STORE FOR SENDOUT
1018 fbd1 30 61                     LEAX     1,S             ; POINT TO IT
1019 fbd3 8d 14                     BSR      BSPUNC          ; SEND OUT AS HEX
1020 fbd5 ae 68                     LDX      8,S             ; LOAD TOP ADDRESS
1021 fbd7 ac 62                     CMPX     2,S             ; ? DONE
1022 fbd9 24 c8                     BHS      BSPGO           ; BRANCH NOT
1023 fbdb 30 8c 11                  LEAX     <BSPEOF,PCR     ; PREPARE END OF FILE
1024 fbde 3f                        SWI                      ; SEND OUT STRING
1025 fbdf 03                        FCB      PDATA           ; FUNCTION
1026 fbe0 ec 64                     LDD      4,S             ; RECOVER PAD COUNTS
1027 fbe2 dd f2                     STD      <VECTAB+.PAD    ; RESTORE
1028 fbe4 4f                        CLRA                     ; SET Z=1 FOR OK RETURN
1029 fbe5 35 d6                     PULS     PC,U,X,D        ; RETURN WITH OK CODE
1030 fbe7 eb 84              BSPUN2 ADDB     ,X              ; ADD TO CHECKSUM
1031 fbe9 16 fd ed           BSPUNC LBRA     ZOUT2H          ; SEND OUT AS HEX AND RETURN
1032                         
1033 fbec 53 01 04           BSPSTR FCB      'S,1,EOT        ; CR,LF,NULLS,S,1
1034 fbef 53 39 30 33 30 30  BSPEOF FCC      /S9030000FC/         ; EOF STRING
     30 30 46 43
1035 fbf9 0d 0a 04                  FCB      CR,LF,EOT
1036                         
1037                         * HSDTA - HIGH SPEED PRINT MEMORY
1038                         * INPUT: S+4=START ADDRESS
1039                         * S+2=STOP ADDRESS
1040                         * S+0=RETURN ADDRESS
1041                         * X,D VOLATILE
1042                         
1043                         * SEND TITLE
1044                         
1045 fbfc 3f                 HSDTA   SWI                     ; SEND NEW LINE
1046 fbfd 06                         FCB     PCRLF           ; FUNCTION
1047 fbfe c6 06                      LDB     #6              ; PREPARE 6 SPACES
1048 fc00 3f                 HSBLNK  SWI                     ; SEND BLANK
1049 fc01 07                         FCB     SPACE           ; FUNCTION
1050 fc02 5a                         DECB                    ; COUNT DOWN
1051 fc03 26 fb                      BNE     HSBLNK          ; LOOP IF MORE
1052 fc05 5f                         CLRB                    ; SETUP BYTE COUNT
1053 fc06 1f 98              HSHTTL  TFR     B,A             ; PREPARE FOR CONVERT
1054 fc08 17 fd db                   LBSR    ZOUTHX          ; CONVERT TO A HEX DIGIT
1055 fc0b 3f                         SWI                     ; SEND BLANK
1056 fc0c 07                         FCB     SPACE           ; FUNCTION
1057 fc0d 3f                         SWI                     ; SEND ANOTHER
1058 fc0e 07                         FCB     SPACE           ; BLANK
1059 fc0f 5c                         INCB                    ; UP ANOTHER
1060 fc10 c1 10                      CMPB    #$10            ; ? PAST 'F'
1061 fc12 25 f2                      BLO     HSHTTL          ; LOOP UNTIL SO
1062 fc14 3f                 HSHLNE  SWI                     ; TO NEXT LINE
1063 fc15 06                         FCB     PCRLF           ; FUNCTION
1064 fc16 25 2f                      BCS     HSDRTN          ; RETURN IF USER ENTERED CTL-X
1065 fc18 30 64                      LEAX    4,S             ; POINT AT ADDRESS TO CONVERT
1066 fc1a 3f                         SWI                     ; PRINT OUT ADDRESS
1067 fc1b 05                         FCB     OUT4HS          ; FUNCTION
1068 fc1c ae 64                      LDX     4,S             ; LOAD ADDRESS PROPER
1069 fc1e c6 10                      LDB     #16             ; NEXT SIXTEEN
1070 fc20 3f                 HSHNXT  SWI                     ; CONVERT BYTE TO HEX AND SEND
1071 fc21 04                         FCB     OUT2HS          ; FUNCTION
1072 fc22 5a                         DECB                    ; COUNT DOWN
1073 fc23 26 fb                      BNE     HSHNXT          ; LOOP IF NOT SIXTEENTH
1074 fc25 3f                         SWI                     ; SEND BLANK
1075 fc26 07                         FCB     SPACE           ; FUNCTION
1076 fc27 ae 64                      LDX     4,S             ; RELOAD FROM ADDRESS
1077 fc29 c6 10                      LDB     #16             ; COUNT
1078 fc2b a6 80              HSHCHR  LDA     ,X+             ; NEXT BYTE
1079 fc2d 2b 04                      BMI     HSHDOT          ; TOO LARGE, TO A DOT
1080 fc2f 81 20                      CMPA    #'              ; ? LOWER THAN A BLANK
1081 fc31 24 02                      BHS     HSHCOK          ; NO, BRANCH OK
1082 fc33 86 2e              HSHDOT  LDA     #'.             ; CONVERT INVALID TO A BLANK
1083 fc35 3f                 HSHCOK  SWI                     ; SEND CHARACTER
1084 fc36 01                         FCB     OUTCH           ; FUNCTION
1085 fc37 5a                         DECB                    ; ? DONE
1086 fc38 26 f1                      BNE     HSHCHR          ; BRANCH NO
1087 fc3a ac 62                      CPX     2,S             ; ? PAST LAST ADDRESS
1088 fc3c 24 09                      BHS     HSDRTN          ; QUIT IF SO
1089 fc3e af 64                      STX     4,S             ; UPDATE FROM ADDRESS
1090 fc40 a6 65                      LDA     5,S             ; LOAD LOW BYTE ADDRESS
1091 fc42 48                         ASLA                    ; ? TO SECTION BOUNDARY
1092 fc43 26 cf                      BNE     HSHLNE          ; BRANCH IF NOT
1093 fc45 20 b5                      BRA     HSDTA           ; BRANCH IF SO
1094 fc47 3f                 HSDRTN  SWI                     ; SEND NEW LINE
1095 fc48 06                         FCB     PCRLF           ; FUNCTION
1096 fc49 39                         RTS                     ; RETURN TO CALLER
1097                         *F
1098                         
1099                         ***********************************************
1100                         *     A S S I S T 0 9    C O M M A N D S
1101                         ***********************************************
1102                         
1103                         *************REGISTERS - DISPLAY AND CHANGE REGISTERS
1104 fc4a 8d 23              CREG    BSR     REGPRT          ; PRINT REGISTERS
1105 fc4c 4c                         INCA                    ; SET FOR CHANGE FUNCTION
1106 fc4d 8d 21                      BSR     REGCHG          ; GO CHANGE, DISPLAY REGISTERS
1107 fc4f 39                         RTS                     ; RETURN TO COMMAND PROCESSOR
1108                         
1109                         ********************************************
1110                         * REGPRT - PRINT/CHANGE REGISTERS SUBROUTINE
1111                         * WILL ABORT TO 'CMDBAD' IF OVERFLOW DETECTED DURING
1112                         * A CHANGE OPERATION. CHANGE DISPLAYS REGISTERS WHEN
1113                         * DONE.
1114                         
1115                         * REGISTER MASK LIST CONSISTS OF:
1116                         * A) CHARACTERS DENOTING REGISTER
1117                         * B) ZERO FOR ONE BYTE, -1 FOR TWO
1118                         * C) OFFSET ON STACK TO REGISTER POSITION
1119                         * INPUT: SP+4=STACKED REGISTERS
1120                         * A=0 PRINT, A#0 PRINT AND CHANGE
1121                         * OUTPUT: (ONLY FOR REGISTER DISPLAY)
1122                         * C=1 CONTROL-X ENTERED, C=0 OTHERWISE
1123                         * VOLATILE: D,X (CHANGE)
1124                         * B,X (DISPLAY)
1125                         *******************************************
1126                         
1127 fc50 50 43 ff 13        REGMSK  FCB     'P,'C,-1,19     ; PC REG
1128 fc54 41 00 0a                   FCB     'A,0,10         ; A REG
1129 fc57 42 00 0b                   FCB     'B,0,11         ; B REG
1130 fc5a 58 ff 0d                   FCB     'X,-1,13        ; X REG
1131 fc5d 59 ff 0f                   FCB     'Y,-1,15        ; Y REG
1132 fc60 55 ff 11                   FCB     'U,-1,17        ; U REG
1133 fc63 53 ff 01                   FCB     'S,-1,1         ; S REG
1134 fc66 43 43 00 09                FCB     'C,'C,0,9       ; CC REG
1135 fc6a 44 50 00 0c                FCB     'D,'P,0,12      ; DP REG
1136 fc6e 00                         FCB     0               ; END OF LIST
1137                         
1138 fc6f 4f                 REGPRT  CLRA                    ; SETUP PRINT ONLY FLAG
1139 fc70 30 e8 10           REGCHG  LEAX    4+12,S          ; READY STACK VALUE
1140 fc73 34 32                      PSHS    Y,X,A           ; SAVE ON STACK WITH OPTION
1141 fc75 31 8c d8                   LEAY    REGMSK,PCR      ; LOAD REGISTER MASK
1142 fc78 ec a0              REGP1   LDD     ,Y+             ; LOAD NEXT CHAR OR <=0
1143 fc7a 4d                         TSTA                    ; ? END OF CHARACTERS
1144 fc7b 2f 04                      BLE     REGP2           ; BRANCH NOT CHARACTER
1145 fc7d 3f                         SWI                     ; SEND TO CONSOLE
1146 fc7e 01                         FCB     OUTCH           ; FUNCTION BYTE
1147 fc7f 20 f7                      BRA     REGP1           ; CHECK NEXT
1148 fc81 86 2d              REGP2   LDA     #'-             ; READY '-'
1149 fc83 3f                         SWI                     ; SEND OUT
1150 fc84 01                         FCB     OUTCH           ; WITH OUTCH
1151 fc85 30 e5                      LEAX    B,S             ; X->REGISTER TO PRINT
1152 fc87 6d e4                      TST     ,S              ; ? CHANGE OPTION
1153 fc89 26 12                      BNE     REGCNG          ; BRANCH YES
1154 fc8b 6d 3f                      TST     -1,Y            ; ? ONE OR TWO BYTES
1155 fc8d 27 03                      BEQ     REGP3           ; BRANCH ZERO MEANS ONE
1156 fc8f 3f                         SWI                     ; PERFORM WORD HEX
1157 fc90 05                         FCB     OUT4HS          ; FUNCTION
1158 fc91 8c                         FCB     SKIP2           ; SKIP BYTE PRINT
1159 fc92 3f                 REGP3   SWI                     ; PERFORM BYTE HEX
1160 fc93 04                         FCB     OUT2HS          ; FUNCTION
1161 fc94 ec a0              REG4    LDD     ,Y+             ; TO FRONT OF NEXT ENTRY
1162 fc96 5d                         TSTB                    ; ? END OF ENTRIES
1163 fc97 26 df                      BNE     REGP1           ; LOOP IF MORE
1164 fc99 3f                         SWI                     ; FORCE NEW LINE
1165 fc9a 06                         FCB     PCRLF           ; FUNCTION
1166 fc9b 35 b2              REGRTN  PULS    PC,Y,X,A        ; RESTORE STACK AND RETURN
1167                         
1168 fc9d 8d 40              REGCNG  BSR     BLDNNB          ; INPUT BINARY NUMBER
1169 fc9f 27 10                      BEQ     REGNXC          ; IF CHANGE THEN JUMP
1170 fca1 81 0d                      CMPA    #CR             ; ? NO MORE DESIRED
1171 fca3 27 1e                      BEQ     REGAGN          ; BRANCH NOPE
1172 fca5 e6 3f                      LDB     -1,Y            ; LOAD SIZE FLAG
1173 fca7 5a                         DECB                    ; MINUS ONE
1174 fca8 50                         NEGB                    ; MAKE POSITIVE
1175 fca9 58                         ASLB                    ; TIMES TWO (=2 OR =4)
1176 fcaa 3f                 REGSKP  SWI                     ; PERFORM SPACES
1177 fcab 07                         FCB     SPACE           ; FUNCTION
1178 fcac 5a                         DECB
1179 fcad 26 fb                      BNE     REGSKP          ; LOOP IF MORE
1180 fcaf 20 e3                      BRA     REG4            ; CONTINUE WITH NEXT REGISTER
1181 fcb1 a7 e4              REGNXC  STA     ,S              ; SAVE DELIMITER IN OPTION
1182                         *                               ; (ALWAYS > 0)
1183 fcb3 dc 9b                      LDD     <NUMBER         ; OBTAIN BINARY RESULT
1184 fcb5 6d 3f                      TST     -1,Y            ; ? TWO BYTES WORTH
1185 fcb7 26 02                      BNE     REGTWO          ; BRANCH YES
1186 fcb9 a6 82                      LDA     ,-X             ; SETUP FOR TWO
1187 fcbb ed 84              REGTWO  STD     ,X              ; STORE IN NEW VALUE
1188 fcbd a6 e4                      LDA     ,S              ; RECOVER DELIMITER
1189 fcbf 81 0d                      CMPA    #CR             ; ? END OF CHANGES
1190 fcc1 26 d1                      BNE     REG4            ; NO, KEEP ON TRUCK'N
1191                         * MOVE STACKED DATA TO NEW STACK IN CASE STACK
1192                         * POINTER HAS CHANGED
1193 fcc3 30 8d e2 8a        REGAGN  LEAX    TSTACK,PCR      ; LOAD TEMP AREA
1194 fcc7 c6 15                      LDB     #21             ; LOAD COUNT
1195 fcc9 35 02              REGTF1  PULS    A               ; NEXT BYTE
1196 fccb a7 80                      STA     ,X+             ; STORE INTO TEMP
1197 fccd 5a                         DECB                    ; COUNT DOWN
1198 fcce 26 f9                      BNE     REGTF1          ; LOOP IF MORE
1199 fcd0 10 ee 88 ec                LDS     -20,X           ; LOAD NEW STACK POINTER
1200 fcd4 c6 15                      LDB     #21             ; LOAD COUNT AGAIN
1201 fcd6 a6 82              REGTF2 LDA      ,-X             ; NEXT TO STORE
1202 fcd8 34 02                     PSHS     A               ; BACK ONTO NEW STACK
1203 fcda 5a                        DECB                     ; COUNT DOWN
1204 fcdb 26 f9                     BNE      REGTF2          ; LOOP IF MORE
1205 fcdd 20 bc                     BRA      REGRTN          ; GO RESTART COMMAND
1206                         
1207                         *********************************************
1208                         * BLDNUM - BUILDS BINARY VALUE FROM INPUT HEX
1209                         * THE ACTIVE EXPRESSION HANDLER IS USED.
1210                         * INPUT: S=RETURN ADDRESS
1211                         * OUTPUT: A=DELIMITER WHICH TERMINATED VALUE
1212                         * (IF DELM NOT ZERO)
1213                         * "NUMBER"=WORD BINARY RESULT
1214                         * Z=1 IF INPUT RECEIVED, Z=0 IF NO HEX RECEIVED
1215                         * REGISTERS ARE TRANSPARENT
1216                         **********************************************
1217                         * EXECUTE SINGLE OR EXTENDED ROM EXPRESSION HANDLER
1218                         *
1219                         * THE FLAG "DELIM" IS USED AS FOLLOWS:
1220                         * DELIM=0 NO LEADING BLANKS, NO FORCED TERMINATOR
1221                         * DELIM=CHR ACCEPT LEADING 'CHR'S, FORCED TERMINATOR
1222 fcdf 4f                 BLDNNB  CLRA                    ; NO DYNAMIC DELIMITER
1223 fce0 8c                         FCB     SKIP2           ; SKIP NEXT INSTRUCTION
1224                         * BUILD WITH LEADING BLANKS
1225 fce1 86 20              BLDNUM  LDA     #'              ; ALLOW LEADING BLANKS
1226 fce3 97 8e                      STA     <DELIM          ; STORE AS DELIMITER
1227 fce5 6e 9d e3 03                JMP     [VECTAB+.EXPAN,PCR]   ; TO EXP ANALYZER
1228                         * THIS IS THE DEFAULT SINGLE ROM ANALYZER. WE ACCEPT:
1229                         * 1) HEX INPUT
1230                         * 2) 'M' FOR LAST MEMORY EXAMINE ADDRESS
1231                         * 3) 'P' FOR PROGRAM COUNTER ADDRESS
1232                         * 4) 'W' FOR WINDOW VALUE
1233                         * 5) '@' FOR INDIRECT VALUE
1234                         
1235 fce9 34 14              EXP1    PSHS    X,B             ; SAVE REGISTERS
1236 fceb 8d 5c              EXPDLM  BSR     BLDHXI          ; CLEAR NUMBER, CHECK FIRST CHAR
1237 fced 27 18                      BEQ     EXP2            ; IF HEX DIGIT CONTINUE BUILDING
1238                         * SKIP BLANKS IF DESIRED
1239 fcef 91 8e                      CMPA    <DELIM          ; ? CORRECT DELIMITER
1240 fcf1 27 f8                      BEQ     EXPDLM          ; YES, IGNORE IT
1241                         * TEST FOR M OR P
1242 fcf3 9e 9e                      LDX     <ADDR           ; DEFAULT FOR 'M'
1243 fcf5 81 4d                      CMPA    #'M             ; ? MEMORY EXAMINE ADDR WANTED
1244 fcf7 27 16                      BEQ     EXPTDL          ; BRANCH IF SO
1245 fcf9 9e 93                      LDX     <PCNTER         ; DEFAULT FOR 'P'
1246 fcfb 81 50                      CMPA    #'P             ; ? LAST PROGRAM COUNTER WANTED
1247 fcfd 27 10                      BEQ     EXPTDL          ; BRANCH IF SO
1248 fcff 9e a0                      LDX     <WINDOW         ; DEFAULT TO WINDOW
1249 fd01 81 57                      CMPA    #'W             ; ? WINDOW WANTED
1250 fd03 27 0a                      BEQ     EXPTDL
1251                         
1252 fd05 35 94              EXPRTN  PULS    PC,X,B          ; RETURN AND RESTORE REGISTERS
1253                         * GOT HEX, NOW CONTINUE BUILDING
1254 fd07 8d 44              EXP2    BSR     BLDHEX          ; COMPUTE NEXT DIGIT
1255 fd09 27 fc                      BEQ     EXP2            ; CONTINUE IF MORE
1256 fd0b 20 0a                      BRA     EXPCDL          ; SEARCH FOR +/-
1257                         * STORE VALUE AND CHECK IF NEED DELIMITER
1258 fd0d ae 84              EXPTDI  LDX     ,X              ; INDIRECTION DESIRED
1259 fd0f 9f 9b              EXPTDL  STX     <NUMBER         ; STORE RESULT
1260 fd11 0d 8e                      TST     <DELIM          ; ? TO FORCE A DELIMITER
1261 fd13 27 f0                      BEQ     EXPRTN          ; RETURN IF NOT WITH VALUE
1262 fd15 8d 62                      BSR     READ            ; OBTAIN NEXT CHARACTER
1263                         * TEST FOR + OR -
1264 fd17 9e 9b              EXPCDL  LDX     <NUMBER         ; LOAD LAST VALUE
1265 fd19 81 2b                      CMPA    #'+             ; ? ADD OPERATOR
1266 fd1b 26 0e                      BNE     EXPCHM          ; BRANCH NOT
1267 fd1d 8d 23                      BSR     EXPTRM          ; COMPUTE NEXT TERM
1268 fd1f 34 02                      PSHS    A               ; SAVE DELIMITER
1269 fd21 dc 9b                      LDD     <NUMBER         ; LOAD NEW TERM
1270 fd23 30 8b              EXPADD  LEAX    D,X             ; ADD TO X
1271 fd25 9f 9b                      STX     <NUMBER         ; STORE AS NEW RESULT
1272 fd27 35 02                      PULS    A               ; RESTORE DELIMITER
1273 fd29 20 ec                      BRA     EXPCDL          ; NOW TEST IT
1274 fd2b 81 2d              EXPCHM  CMPA    #'-             ; ? SUBTRACT OPERATOR
1275 fd2d 27 07                      BEQ     EXPSUB          ; BRANCH IF SO
1276 fd2f 81 40                      CMPA    #'@             ; ? INDIRECTION DESIRED
1277 fd31 27 da                      BEQ     EXPTDI          ; BRANCH IF SO
1278 fd33 5f                         CLRB                    ; SET DELIMITER RETURN
1279 fd34 20 cf                      BRA     EXPRTN          ; AND RETURN TO CALLER
1280 fd36 8d 0a              EXPSUB  BSR     EXPTRM          ; OBTAIN NEXT TERM
1281 fd38 34 02                      PSHS    A               ; SAVE DELIMITER
1282 fd3a dc 9b                      LDD     <NUMBER         ; LOAD UP NEXT TERM
1283 fd3c 40                         NEGA                    ; NEGATE A
1284 fd3d 50                         NEGB                    ; NEGATE B
1285 fd3e 82 00                      SBCA    #0              ; CORRECT FOR A
1286 fd40 20 e1                      BRA     EXPADD          ; GO ADD TO EXPRESSION
1287                         * COMPUTE NEXT EXPRESSION TERM
1288                         * OUTPUT: X=OLD VALUE
1289                         * 'NUMBER'=NEXT TERM
1290 fd42 8d 9d              EXPTRM  BSR     BLDNUM          ; OBTAIN NEXT VALUE
1291 fd44 27 32                      BEQ     CNVRTS          ; RETURN IF VALID NUMBER
1292 fd46 16 fc 13           BLDBAD  LBRA    CMDBAD          ; ABORT COMMAND IF INVALID
1293                         
1294                         *********************************************
1295                         * BUILD BINARY VALUE USING INPUT CHARACTERS.
1296                         * INPUT: A=ASCII HEX VALUE OR DELIMITER
1297                         * SP+0=RETURN ADDRESS
1298                         * SP+2=16 BIT RESULT AREA
1299                         * OUTPUT: Z=1 A=BINARY VALUE
1300                         * Z=0 IF INVALID HEX CHARACTER (A UNCHANGED)
1301                         * VOLATILE: D
1302                         ****************************************
1303 fd49 0f 9b              BLDHXI  CLR     <NUMBER         ; CLEAR NUMBER
1304 fd4b 0f 9c                      CLR     <NUMBER+1       ; CLEAR NUMBER
1305 fd4d 8d 2a              BLDHEX  BSR     READ            ; GET INPUT CHARACTER
1306 fd4f 8d 11              BLDHXC  BSR     CNVHEX          ; CONVERT AND TEST CHARACTER
1307 fd51 26 25                      BNE     CNVRTS          ; RETURN IF NOT A NUMBER
1308 fd53 c6 10                      LDB     #16             ; PREPARE SHIFT
1309 fd55 3d                         MUL                     ; BY FOUR PLACES
1310 fd56 86 04                      LDA     #4              ; ROTATE BINARY INTO VALUE
1311 fd58 58                 BLDSHF  ASLB                    ; OBTAIN NEXT BIT
1312 fd59 09 9c                      ROL     <NUMBER+1       ; INTO LOW BYTE
1313 fd5b 09 9b                      ROL     <NUMBER         ; INTO HI BYTE
1314 fd5d 4a                         DECA                    ; COUNT DOWN
1315 fd5e 26 f8                      BNE     BLDSHF          ; BRANCH IF MORE TO DO
1316 fd60 20 14                      BRA     CNVOK           ; SET GOOD RETURN CODE
1317                         
1318                         ****************************************
1319                         * CONVERT ASCII CHARACTER TO BINARY BYTE
1320                         * INPUT: A=ASCII
1321                         * OUTPUT: Z=1 A=BINARY VALUE
1322                         * Z=0 IF INVALID
1323                         * ALL REGISTERS TRANSPARENT
1324                         * (A UNALTERED IF INVALID HEX)
1325                         **************************************
1326 fd62 81 30              CNVHEX  CMPA    #'0             ; ? LOWER THAN A ZERO
1327 fd64 25 12                      BLO     CNVRTS          ; BRANCH NOT VALUE
1328 fd66 81 39                      CMPA    #'9             ; ? POSSIBLE A-F
1329 fd68 2f 0a                      BLE     CNVGOT          ; BRANCH NO TO ACCEPT
1330 fd6a 81 41                      CMPA    #'A             ; ? LESS THEN TEN
1331 fd6c 25 0a                      BLO     CNVRTS          ; RETURN IF MINUS (INVALID)
1332 fd6e 81 46                      CMPA    #'F             ; ? NOT TOO LARGE
1333 fd70 22 06                      BHI     CNVRTS          ; NO, RETURN TOO LARGE
1334 fd72 80 07                      SUBA    #7              ; DOWN TO BINARY
1335 fd74 84 0f              CNVGOT  ANDA    #$0F            ; CLEAR HIGH HEX
1336 fd76 1a 04              CNVOK   ORCC    #4              ; FORCE ZERO ON FOR VALID HEX
1337 fd78 39                 CNVRTS  RTS                     ; RETURN TO CALLER
1338                         
1339                         * GET INPUT CHAR, ABORT COMMAND IF CONTROL-X (CANCEL)
1340 fd79 3f                 READ     SWI                    ; GET NEXT CHARACTER
1341 fd7a 00                          FCB    INCHNP          ; FUNCTION
1342 fd7b 81 18                       CMPA   #CAN            ; ? ABORT COMMAND
1343 fd7d 27 c7                       BEQ    BLDBAD          ; BRANCH TO ABORT IF SO
1344 fd7f 39                          RTS                    ; RETURN TO CALLER
1345                         *G
1346                         
1347                         ***************GO - START PROGRAM EXECUTION
1348 fd80 8d 01              CGO      BSR    GOADDR          ; BUILD ADDRESS IF NEEDED
1349 fd82 3b                          RTI                    ; START EXECUTING
1350                         
1351                         * FIND OPTIONAL NEW PROGRAM COUNTER. ALSO ARM THE
1352                         * BREAKPOINTS.
1353 fd83 35 30              GOADDR   PULS   Y,X             ; RECOVER RETURN ADDRESS
1354 fd85 34 10                       PSHS   X               ; STORE RETURN BACK
1355 fd87 26 19                       BNE    GONDFT          ; IF NO CARRIAGE RETURN THEN NEW PC
1356                         
1357                         * DEFAULT PROGRAM COUNTER, SO FALL THROUGH IF
1358                         * IMMEDIATE BREAKPOINT.
1359 fd89 17 01 b6                    LBSR   CBKLDR          ; SEARCH BREAKPOINTS
1360 fd8c ae 6c                       LDX    12,S            ; LOAD PROGRAM COUNTER
1361 fd8e 5a                 ARMBLP  DECB                    ; COUNT DOWN
1362 fd8f 2b 16                      BMI     ARMBK2          ; DONE, NONE TO SINGLE TRACE
1363 fd91 a6 30                      LDA     -NUMBKP*2,Y     ; PRE-FETCH OPCODE
1364 fd93 ac a1                      CMPX    ,Y++            ; ? IS THIS A BREAKPOINT
1365 fd95 26 f7                      BNE     ARMBLP          ; LOOP IF NOT
1366 fd97 81 3f                      CMPA    #$3F            ; ? SWI BREAKPOINTED
1367 fd99 26 02                      BNE     ARMNSW          ; NO, SKIP SETTING OF PASS FLAG
1368 fd9b 97 fb                      STA     <SWIBFL         ; SHOW UPCOMING SWI NOT BRKPNT
1369 fd9d 0c 8f              ARMNSW  INC     <MISFLG         ; FLAG THRU A BREAKPOINT
1370 fd9f 16 01 06                   LBRA    CDOT            ; DO SINGLE TRACE W/O BREAKPOINTS
1371                         
1372                         * OBTAIN NEW PROGRAM COUNTER
1373 fda2 17 00 bb           GONDFT  LBSR    CDNUM           ; OBTAIN NEW PROGRAM COUNTER
1374 fda5 ed 6c                      STD     12,S            ; STORE INTO STACK
1375 fda7 17 01 98           ARMBK2  LBSR    CBKLDR          ; OBTAIN TABLE
1376 fdaa 00 fa                      NEG     <BKPTCT         ; COMPLEMENT TO SHOW ARMED
1377 fdac 5a                 ARMLOP  DECB                    ; ? DONE
1378 fdad 2b c9                      BMI     CNVRTS          ; RETURN WHEN DONE
1379 fdaf a6 b4                      LDA     [,Y]            ; LOAD OPCODE
1380 fdb1 a7 30                      STA     -NUMBKP*2,Y     ; STORE INTO OPCODE TABLE
1381 fdb3 86 3f                      LDA     #$3F            ; READY "SWI" OPCODE
1382 fdb5 a7 b1                      STA     [,Y++]          ; STORE AND MOVE UP TABLE
1383 fdb7 20 f3                      BRA     ARMLOP          ; AND CONTINUE
1384                         
1385                         *******************CALL - CALL ADDRESS AS SUBROUTINE
1386 fdb9 8d c8              CCALL   BSR     GOADDR          ; FETCH ADDRESS IF NEEDED
1387 fdbb 35 7f                      PULS    U,Y,X,DP,D,CC   ; RESTORE USERS REGISTERS
1388 fdbd ad f1                      JSR     [,S++]          ; CALL USER SUBROUTINE
1389 fdbf 3f                 CGOBRK  SWI                     ; PERFORM BREAKPOINT
1390 fdc0 0a                         FCB     BRKPT           ; FUNCTION
1391 fdc1 20 fc                      BRA     CGOBRK          ; LOOP UNTIL USER CHANGES PC
1392                         
1393                         ****************MEMORY - DISPLAY/CHANGE MEMORY
1394                         * CMEMN AND CMPADP ARE DIRECT ENTRY POINTS FROM
1395                         * THE COMMAND HANDLER FOR QUICK COMMANDS
1396 fdc3 17 00 9a           CMEM    LBSR    CDNUM           ; OBTAIN ADDRESS
1397 fdc6 dd 9e              CMEMN   STD     <ADDR           ; STORE DEFAULT
1398 fdc8 9e 9e              CMEM2   LDX     <ADDR           ; LOAD POINTER
1399 fdca 17 fc 0c                   LBSR    ZOUT2H          ; SEND OUT HEX VALUE OF BYTE
1400 fdcd 86 2d                      LDA     #'-             ; LOAD DELIMITER
1401 fdcf 3f                         SWI                     ; SEND OUT
1402 fdd0 01                         FCB     OUTCH           ; FUNCTION
1403 fdd1 17 ff 0b           CMEM4   LBSR    BLDNNB          ; OBTAIN NEW BYTE VALUE
1404 fdd4 27 0a                      BEQ     CMENUM          ; BRANCH IF NUMBER
1405                         * COMA - SKIP BYTE
1406 fdd6 81 2c                      CMPA    #',             ; ? COMMA
1407 fdd8 26 0e                      BNE     CMNOTC          ; BRANCH NOT
1408 fdda 9f 9e                      STX     <ADDR           ; UPDATE POINTER
1409 fddc 30 01                      LEAX    1,X             ; TO NEXT BYTE
1410 fdde 20 f1                      BRA     CMEM4           ; AND INPUT IT
1411 fde0 d6 9c              CMENUM  LDB     <NUMBER+1       ; LOAD LOW BYTE VALUE
1412 fde2 8d 47                      BSR     MUPDAT          ; GO OVERLAY MEMORY BYTE
1413 fde4 81 2c                      CMPA    #',             ; ? CONTINUE WITH NO DISPLAY
1414 fde6 27 e9                      BEQ     CMEM4           ; BRANCH YES
1415                         * QUOTED STRING
1416 fde8 81 27              CMNOTC  CMPA    #$27            ; ? QUOTED STRING
1417 fdea 26 0c                      BNE     CMNOTQ          ; BRANCH NO
1418 fdec 8d 8b              CMESTR  BSR     READ            ; OBTAIN NEXT CHARACTER
1419 fdee 81 27                      CMPA    #$27            ; ? END OF QUOTED STRING
1420 fdf0 27 0c                      BEQ     CMSPCE          ; YES, QUIT STRING MODE
1421 fdf2 1f 89                      TFR     A,B             ; TO B FOR SUBROUTINE
1422 fdf4 8d 35                      BSR     MUPDAT          ; GO UPDATE BYTE
1423 fdf6 20 f4                      BRA     CMESTR          ; GET NEXT CHARACTER
1424                         * BLANK - NEXT BYTE
1425 fdf8 81 20              CMNOTQ  CMPA    #$20            ; ? BLANK FOR NEXT BYTE
1426 fdfa 26 06                      BNE     CMNOTB          ; BRANCH NOT
1427 fdfc 9f 9e                      STX     <ADDR           ; UPDATE POINTER
1428 fdfe 3f                 CMSPCE  SWI                     ; GIVE SPACE
1429 fdff 07                         FCB     SPACE           ; FUNCTION
1430 fe00 20 c6                      BRA     CMEM2           ; NOW PROMPT FOR NEXT
1431                         
1432                         * LINE FEED - NEXT BYTE WITH ADDRESS
1433 fe02 81 0a              CMNOTB  CMPA    #LF             ; ? LINE FEED FOR NEXT BYTE
1434 fe04 26 08                      BNE     CMNOTL          ; BRANCH NO
1435 fe06 86 0d                      LDA     #CR             ; GIVE CARRIAGE RETURN
1436 fe08 3f                         SWI                     ; TO CONSOLE
1437 fe09 01                         FCB     OUTCH           ; HANDLER
1438 fe0a 9f 9e                      STX     <ADDR           ; STORE NEXT ADDRESS
1439 fe0c 20 0a                      BRA     CMPADP          ; BRANCH TO SHOW
1440                         
1441                         * UP ARROW - PREVIOUS BYTE AND ADDRESS
1442 fe0e 81 5e              CMNOTL  CMPA    #'^             ; ? UP ARROW FOR PREVIOUS BYTE
1443 fe10 26 0a                      BNE     CMNOTU          ; BRANCH NOT
1444 fe12 30 1e                      LEAX    -2,X            ; DOWN TO PREVIOUS BYTE
1445 fe14 9f 9e                      STX     <ADDR           ; STORE NEW POINTER
1446 fe16 3f                 CMPADS  SWI                     ; FORCE NEW LINE
1447 fe17 06                         FCB     PCRLF           ; FUNCTION
1448 fe18 8d 07              CMPADP  BSR     PRTADR          ; GO PRINT ITS VALUE
1449 fe1a 20 ac                      BRA     CMEM2           ; THEN PROMPT FOR INPUT
1450                         
1451                         * SLASH - NEXT BYTE WITH ADDRESS
1452 fe1c 81 2f              CMNOTU  CMPA    #'/             ; ? SLASH FOR CURRENT DISPLAY
1453 fe1e 27 f6                      BEQ     CMPADS          ; YES, SEND ADDRESS
1454 fe20 39                         RTS                     ; RETURN FROM COMMAND
1455                         
1456                         * PRINT CURRENT ADDRESS
1457 fe21 9e 9e              PRTADR  LDX     <ADDR           ; LOAD POINTER VALUE
1458 fe23 34 10                      PSHS    X               ; SAVE X ON STACK
1459 fe25 30 e4                      LEAX    ,S              ; POINT TO IT FOR DISPLAY
1460 fe27 3f                         SWI                     ; DISPLAY POINTER IN HEX
1461 fe28 05                         FCB     OUT4HS          ; FUNCTION
1462 fe29 35 90                      PULS    PC,X            ; RECOVER POINTER AND RETURN
1463                         
1464                         * UPDATE BYTE
1465 fe2b 9e 9e              MUPDAT  LDX     <ADDR           ; LOAD NEXT BYTE POINTER
1466 fe2d e7 80                      STB     ,X+             ; STORE AND INCREMENT X
1467 fe2f e1 1f                      CMPB    -1,X            ; ? SUCCESFULL STORE
1468 fe31 26 03                      BNE     MUPBAD          ; BRANCH FOR '?' IF NOT
1469 fe33 9f 9e                      STX     <ADDR           ; STORE NEW POINTER VALUE
1470 fe35 39                         RTS                     ; BACK TO CALLER
1471 fe36 34 02              MUPBAD  PSHS    A               ; SAVE A REGISTER
1472 fe38 86 3f                      LDA     #'?             ; SHOW INVALID
1473 fe3a 3f                         SWI                     ; SEND OUT
1474 fe3b 01                         FCB     OUTCH           ; FUNCTION
1475 fe3c 35 82                      PULS    PC,A            ; RETURN TO CALLER
1476                         
1477                         ********************WINDOW - SET WINDOW VALUE
1478 fe3e 8d 20              CWINDO  BSR     CDNUM           ; OBTAIN WINDOW VALUE
1479 fe40 dd a0                      STD     <WINDOW         ; STORE IT IN
1480 fe42 39                         RTS                     ; END COMMAND
1481                         
1482                         ******************DISPLAY - HIGH SPEED DISPLAY MEMORY
1483 fe43 8d 1b              CDISP   BSR     CDNUM           ; FETCH ADDRESS
1484 fe45 c4 f0                      ANDB    #$F0            ; FORCE TO 16 BOUNDARY
1485 fe47 1f 02                      TFR     D,Y             ; SAVE IN Y
1486 fe49 30 2f                      LEAX    15,Y            ; DEFAULT LENGTH
1487 fe4b 25 04                      BCS     CDISPS          ; BRANCH IF END OF INPUT
1488 fe4d 8d 11                      BSR     CDNUM           ; OBTAIN COUNT
1489 fe4f 30 ab                      LEAX    D,Y             ; ASSUME COUNT, COMPUTE END ADDR
1490 fe51 34 30              CDISPS  PSHS    Y,X             ; SETUP PARAMETERS FOR HSDATA
1491 fe53 10 a3 62                   CMPD    2,S             ; ? WAS IT COUNT
1492 fe56 23 02                      BLS     CDCNT           ; BRANCH YES
1493 fe58 ed e4                      STD     ,S              ; STORE HIGH ADDRESS
1494 fe5a ad 9d e1 84        CDCNT   JSR     [VECTAB+.HSDTA,PCR] ; CALL PRINT ROUTINE
1495 fe5e 35 e0                      PULS    PC,U,Y          ; CLEAN STACK AND END COMMAND
1496                         
1497                         * OBTAIN NUMBER - ABORT IF NONE
1498                         * ONLY DELIMITERS OF CR, BLANK, OR '/' ARE ACCEPTED
1499                         * OUTPUT: D=VALUE, C=1 IF CARRIAGE RETURN DELMITER,
1500                         * ELSE C=0
1501 fe60 17 fe 7e           CDNUM   LBSR    BLDNUM          ; OBTAIN NUMBER
1502 fe63 26 09                      BNE     CDBADN          ; BRANCH IF INVALID
1503 fe65 81 2f                      CMPA    #'/             ; ? VALID DELIMITER
1504 fe67 22 05                      BHI     CDBADN          ; BRANCH IF NOT FOR ERROR
1505 fe69 81 0e                      CMPA    #CR+1           ; LEAVE COMPARE FOR CARRIAGE RET
1506 fe6b dc 9b                      LDD     <NUMBER         ; LOAD NUMBER
1507 fe6d 39                         RTS                     ; RETURN WITH COMPARE
1508 fe6e 16 fa eb           CDBADN  LBRA    CMDBAD          ; RETURN TO ERROR MECHANISM
1509                         
1510                         *****************PUNCH - PUNCH MEMORY IN S1-S9 FORMAT
1511 fe71 8d ed              CPUNCH  BSR     CDNUM           ; OBTAIN START ADDRESS
1512 fe73 1f 02                      TFR     D,Y             ; SAVE IN Y
1513 fe75 8d e9                      BSR     CDNUM           ; OBTAIN END ADDRESS
1514 fe77 6f e2                      CLR     ,-S             ; SETUP PUNCH FUNCTION CODE
1515 fe79 34 26                      PSHS    Y,D             ; STORE VALUES ON STACK
1516 fe7b ad 9d e1 65        CCALBS  JSR     [VECTAB+.BSON,PCR] ; INITIALIZE HANDLER
1517 fe7f ad 9d e1 63                JSR     [VECTAB+.BSDTA,PCR] ; PERFORM FUNCTION
1518 fe83 34 01                      PSHS    CC              ; SAVE RETURN CODE
1519 fe85 ad 9d e1 5f                JSR     [VECTAB+.BSOFF,PCR] ; TURN OFF HANDLER
1520 fe89 35 01                      PULS    CC              ; OBTAIN CONDITION CODE SAVED
1521 fe8b 26 e1                      BNE     CDBADN          ; BRANCH IF ERROR
1522 fe8d 35 b2                      PULS    PC,Y,X,A        ; RETURN FROM COMMAND
1523                         
1524                         *****************LOAD - LOAD MEMORY FROM S1-S9 FORMAT
1525 fe8f 8d 01              CLOAD   BSR     CLVOFS          ; CALL SETUP AND PASS CODE
1526 fe91 01                         FCB     1               ; LOAD FUNCTION CODE FOR PACKET
1527                         
1528 fe92 33 f1              CLVOFS  LEAU    [,S++]          ; LOAD CODE IN HIGH BYTE OF U
1529 fe94 33 d4                      LEAU    [,U]            ; NOT CHANGING CC AND RESTORE S
1530 fe96 27 03                      BEQ     CLVDFT          ; BRANCH IF CARRIAGE RETURN NEXT
1531 fe98 8d c6                      BSR     CDNUM           ; OBTAIN OFFSET
1532 fe9a 8c                         FCB     SKIP2           ; SKIP DEFAULT OFFSET
1533 fe9b 4f                 CLVDFT  CLRA                    ; CREATE ZERO OFFSET
1534 fe9c 5f                         CLRB                    ; AS DEFAULT
1535 fe9d 34 4e                      PSHS    U,DP,D          ; SETUP CODE, NULL WORD, OFFSET
1536 fe9f 20 da                      BRA     CCALBS          ; ENTER CALL TO BS ROUTINES
1537                         
1538                         ******************VERIFY - COMPARE MEMORY WITH FILES
1539 fea1 8d ef              CVER    BSR     CLVOFS          ; COMPUTE OFFSET IF ANY
1540 fea3 ff                         FCB     -1              ; VERIFY FNCTN CODE FOR PACKET
1541                         
1542                         *******************TRACE - TRACE INSTRUCTIONS
1543                         ******************* . - SINGLE STEP TRACE
1544 fea4 8d ba              CTRACE  BSR     CDNUM           ; OBTAIN TRACE COUNT
1545 fea6 dd 91                      STD     <TRACEC         ; STORE COUNT
1546 fea8 32 62              CDOT    LEAS    2,S             ; RID COMMAND RETURN FROM STACK
1547 feaa ee f8 0a           CTRCE3  LDU     [10,S]          ; LOAD OPCODE TO EXECUTE
1548 fead df 99                      STU     <LASTOP         ; STORE FOR TRACE INTERRUPT
1549 feaf de f6                      LDU     <VECTAB+.PTM    ; LOAD PTM ADDRESS
1550 feb1 cc 07 01                   LDD     #$0701          ; 7,1 CYCLES DOWN+CYCLES UP
1551 feb4 ed 42                      STD     PTMTM1-PTM,U    ; START NMI TIMEOUT
1552 feb6 3b                         RTI                     ; RETURN FOR ONE INSTRUCTION
1553                         
1554                         *************NULLS  -  SET NEW LINE AND CHAR PADDING
1555 feb7 8d a7              CNULLS  BSR     CDNUM           ; OBTAIN NEW LINE PAD
1556 feb9 dd f2                      STD     <VECTAB+.PAD    ; RESET VALUES
1557 febb 39                         RTS                     ; END COMMAND
1558                         
1559                         ******************STLEVEL - SET STACK TRACE LEVEL
1560 febc 27 05              CSTLEV  BEQ     STLDFT          ; TAKE DEFAULT
1561 febe 8d a0                      BSR     CDNUM           ; OBTAIN NEW STACK LEVEL
1562 fec0 dd f8                      STD     <SLEVEL         ; STORE NEW ENTRY
1563 fec2 39                         RTS                     ; TO COMMAND HANDLER
1564 fec3 30 6e              STLDFT  LEAX    14,S            ; COMPUTE NMI COMPARE
1565 fec5 9f f8                      STX     <SLEVEL         ; AND STORE IT
1566 fec7 39                         RTS                     ; END COMMAND
1567                         
1568                         ******************OFFSET - COMPUTE SHORT AND LONG
1569                         ******************                  BRANCH OFFSETS
1570 fec8 8d 96              COFFS   BSR     CDNUM           ; OBTAIN INSTRUCTION ADDRESS
1571 feca 1f 01                      TFR     D,X             ; USE AS FROM ADDRESS
1572 fecc 8d 92                      BSR     CDNUM           ; OBTAIN TO ADDRESS
1573                         * D=TO INSTRUCTION, X=FROM INSTRUCTION OFFSET BYTE(S)
1574 fece 30 01                      LEAX    1,X             ; ADJUST FOR *+2 SHORT BRANCH
1575 fed0 34 30                      PSHS    Y,X             ; STORE WORK WORD AND VALUE ON S
1576 fed2 a3 e4                      SUBD    ,S              ; FIND OFFSET
1577 fed4 ed e4                      STD     ,S              ; SAVE OVER STACK
1578 fed6 30 61                      LEAX    1,S             ; POINT FOR ONE BYTE DISPLAY
1579 fed8 1d                         SEX                     ; SIGN EXTEND LOW BYTE
1580 fed9 a1 e4                      CMPA    ,S              ; ? VALID ONE BYTE OFFSET
1581 fedb 26 02                      BNE     COFNO1          ; BRANCH IF NOT
1582 fedd 3f                         SWI                     ; SHOW ONE BYTE OFFSET
1583 fede 04                         FCB     OUT2HS          ; FUNCTION
1584 fedf ee e4              COFNO1  LDU     ,S              ; RELOAD OFFSET
1585 fee1 33 5f                      LEAU    -1,U            ; CONVERT TO LONG BRANCH OFFSET
1586 fee3 ef 84                      STU     ,X              ; STORE BACK WHERE X POINTS NOW
1587 fee5 3f                         SWI                     ; SHOW TWO BYTE OFFSET
1588 fee6 05                         FCB     OUT4HS          ; FUNCTION
1589 fee7 3f                         SWI                     ; FORCE NEW LINE
1590 fee8 06                         FCB     PCRLF           ; FUNCTION
1591 fee9 35 96                      PULS    PC,X,D          ; RESTORE STACK AND END COMMAND
1592                         *H
1593                         
1594                         *************BREAKPOINT - DISPLAY/ENTER/DELETE/CLEAR
1595                         *************             BREAKPOINTS
1596 feeb 27 23              CBKPT   BEQ     CBKDSP          ; BRANCH DISPLAY OF JUST 'B'
1597 feed 17 fd f1                   LBSR    BLDNUM          ; ATTEMPT VALUE ENTRY
1598 fef0 27 2c                      BEQ     CBKADD          ; BRANCH TO ADD IF SO
1599 fef2 81 2d                      CMPA    #'-             ; ? CORRECT DELIMITER
1600 fef4 26 3f                      BNE     CBKERR          ; NO, BRANCH FOR ERROR
1601 fef6 17 fd e8                   LBSR    BLDNUM          ; ATTEMPT DELETE VALUE
1602 fef9 27 03                      BEQ     CBKDLE          ; GOT ONE, GO DELETE IT
1603 fefb 0f fa                      CLR     <BKPTCT         ; WAS 'B -', SO ZERO COUNT
1604 fefd 39                 CBKRTS  RTS                     ; END COMMAND
1605                         * DELETE THE ENTRY
1606 fefe 8d 40              CBKDLE  BSR     CBKSET          ; SETUP REGISTERS AND VALUE
1607 ff00 5a                 CBKDLP  DECB                    ; ? ANY ENTRIES IN TABLE
1608 ff01 2b 32                      BMI     CBKERR          ; BRANCH NO, ERROR
1609 ff03 ac a1                      CMPX    ,Y++            ; ? IS THIS THE ENTRY
1610 ff05 26 f9                      BNE     CBKDLP          ; NO, TRY NEXT
1611                         * FOUND, NOW MOVE OTHERS UP IN ITS PLACE
1612 ff07 ae a1              CBKDLM  LDX     ,Y++            ; LOAD NEXT ONE UP
1613 ff09 af 3c                      STX     -4,Y            ; MOVE DOWN BY ONE
1614 ff0b 5a                         DECB                    ; ? DONE
1615 ff0c 2a f9                      BPL     CBKDLM          ; NO, CONTINUE MOVE
1616 ff0e 0a fa                      DEC     <BKPTCT         ; DECREMENT BREAKPOINT COUNT
1617 ff10 8d 2e              CBKDSP  BSR     CBKSET          ; SETUP REGISTERS AND LOAD VALUE
1618 ff12 27 e9                      BEQ     CBKRTS          ; RETURN IF NONE TO DISPLY
1619 ff14 30 a1              CBKDSL  LEAX    ,Y++            ; POINT TO NEXT ENTRY
1620 ff16 3f                         SWI                     ; DISPLAY IN HEX
1621 ff17 05                         FCB     OUT4HS          ; FUNCTION
1622 ff18 5a                         DECB                    ; COUNT DOWN
1623 ff19 26 f9                      BNE     CBKDSL          ; LOOP IF NGABLE RAM
1624 ff1b 3f                         SWI                     ; SKIP TO NEW LINK
1625 ff1c 06                         FCB     PCRLF           ; FUNCTIONRTS
1626 ff1d 39                         RTS
1627                         
1628                         * ADD NEW ENTRY
1629 ff1e 8d 20              CBKADD  BSR     CBKSET          ; SETUP REGISTERS
1630 ff20 c1 08                      CMPB    #NUMBKP         ; ? ALREADY FULL
1631 ff22 27 11                      BEQ     CBKERR          ; BRANCH ERROR IF SO
1632 ff24 a6 84                      LDA     ,X              ; LOAD BYTE TO TRAP
1633 ff26 e7 84                      STB     ,X              ; TRY TO CHANGE
1634 ff28 e1 84                      CMPB    ,X              ; ? CHANGEABLE RAM
1635 ff2a 26 09                      BNE     CBKERR          ; BRANCH ERROR IF NOT
1636 ff2c a7 84                      STA ,X                  ; RESTORE BYTE
1637 ff2e 5a                 CBKADL  DECB                    ; COUNT DOWN
1638 ff2f 2b 07                      BMI     CBKADT          ; BRANCH IF DONE TO ADD IT
1639 ff31 ac a1                      CMPX    ,Y++            ; ? ENTRY ALREADY HERE
1640 ff33 26 f9                      BNE     CBKADL          ; LOOP IF NOT
1641 ff35 16 fa 24           CBKERR  LBRA    CMDBAD          ; RETURN TO ERROR PRODUCE
1642 ff38 af a4              CBKADT  STX ,Y                  ; ADD THIS ENTRY
1643 ff3a 6f 31                      CLR     -NUMBKP*2+1,Y   ; CLEAR OPTIONAL BYTE
1644 ff3c 0c fa                      INC     <BKPTCT         ; ADD ONE TO COUNT
1645 ff3e 20 d0                      BRA     CBKDSP          ; AND NOW DISPLAY ALL OF 'EM
1646                         * SETUP REGISTERS FOR SCAN
1647 ff40 9e 9b              CBKSET  LDX     <NUMBER         ; LOAD VALUE DESIRED
1648 ff42 31 8d e0 6c        CBKLDR  LEAY    BKPTBL,PCR      ; LOAD START OF TABLE
1649 ff46 d6 fa                      LDB     <BKPTCT         ; LOAD ENTRY COUNT
1650 ff48 39                         RTS                     ; RETURN
1651                         
1652                         *****************ENCODE  -  ENCODE A POSTBYTE
1653 ff49 6f e2              CENCDE  CLR     ,-S             ; DEFAULT TO NOT INDIRECT
1654 ff4b 5f                         CLRB                    ; ZERO POSTBYTE VALUE
1655 ff4c 30 8c 3f                   LEAX    <CONV1,PCR      ; START TABLE SEARCH
1656 ff4f 3f                         SWI                     ; OBTAIN FIRST CHARACTER
1657 ff50 00                         FCB     INCHNP          ; FUNCTION
1658 ff51 81 5b                      CMPA    #'[             ; ? INDIRECT HERE
1659 ff53 26 06                      BNE     CEN2            ; BRANCH IF NOT
1660 ff55 86 10                      LDA     #$10            ; SET INDIRECT BIT ON
1661 ff57 a7 e4                      STA     ,S              ; SAVE FOR LATER
1662 ff59 3f                 CENGET  SWI                     ; OBTAIN NEXT CHARACTER
1663 ff5a 00                         FCB     INCHNP          ; FUNCTION
1664 ff5b 81 0d              CEN2    CMPA    #CR             ; ? END OF ENTRY
1665 ff5d 27 0c                      BEQ     CEND1           ; BRANCH YES
1666 ff5f 6d 84              CENLP1  TST     ,X              ; ? END OF TABLE
1667 ff61 2b d2                      BMI     CBKERR          ; BRANCH ERROR IF SO
1668 ff63 a1 81                      CMPA    ,X++            ; ? THIS THE CHARACTER
1669 ff65 26 f8                      BNE     CENLP1          ; BRANCH IF NOT
1670 ff67 eb 1f                      ADDB    -1,X            ; ADD THIS VALUE
1671 ff69 20 ee                      BRA     CENGET          ; GET NEXT INPUT
1672 ff6b 30 8c 49           CEND1   LEAX    <CONV2,PCR      ; POINT AT TABLE 2
1673 ff6e 1f 98                      TFR     B,A             ; SAVE COPY IN A
1674 ff70 84 60                      ANDA    #$60            ; ISOLATE REGISTER MASK
1675 ff72 aa e4                      ORA     ,S              ; ADD IN INDIRECTION BIT
1676 ff74 a7 e4                      STA     ,S              ; SAVE BACK AS POSTBYTE SKELETON
1677 ff76 c4 9f                      ANDB    #$9F            ; CLEAR REGISTER BITS
1678 ff78 6d 84              CENLP2  TST     ,X              ; ? END OF TABLE
1679 ff7a 27 b9                      BEQ     CBKERR          ; BRANCH ERROR IF SO
1680 ff7c e1 81                      CMPB    ,X++            ; ? SAME VALUE
1681 ff7e 26 f8                      BNE     CENLP2          ; LOOP IF NOT
1682 ff80 e6 1f                      LDB     -1,X            ; LOAD RESULT VALUE
1683 ff82 ea e4                      ORB     ,S              ; ADD TO BASE SKELETON
1684 ff84 e7 e4                      STB     ,S              ; SAVE POSTBYTE ON STACK
1685 ff86 30 e4                      LEAX    ,S              ; POINT TO IT
1686 ff88 3f                         SWI                     ; SEND OUT AS HEX
1687 ff89 04                         FCB     OUT2HS          ; FUNCTION
1688 ff8a 3f                         SWI                     ; TO NEXT LINE
1689 ff8b 06                         FCB     PCRLF           ; FUNCTION
1690 ff8c 35 84                      PULS    PC,B            ; END OF COMMAND
1691                         
1692                         * TABLE ONE DEFINES VALID INPUT IN SEQUENCE
1693                         CONV1
1694 ff8e 41 04 42 05 44 06          FCB     'A,$04,'B,$05,'D,$06,'H,$01
     48 01
1695 ff96 48 01 48 01 48 00          FCB     'H,$01,'H,$01,'H,$00,',,$00
     2c 00
1696 ff9e 2d 09 2d 01 53 70          FCB     '-,$09,'-,$01,'S,$70,'Y,$30
     59 30
1697 ffa6 55 50 58 10 2b 07          FCB     'U,$50,'X,$10,'+,$07,'+,$01
     2b 01
1698 ffae 50 80 43 00 52 00          FCB     'P,$80,'C,$00,'R,$00,'],$00
     5d 00
1699 ffb6 ff                         FCB     $FF             ; END OF TABLE
1700                         
1701                         * CONV2 USES ABOVE CONVERSION TO SET POSTBYTE
1702                         * BIT SKELETON.
1703                         CONV2
1704 ffb7 10 84 11 00                FDB     $1084,$1100     ; R,      H,R
1705 ffbb 12 88 13 89                FDB     $1288,$1389     ; HH,R    HHHH,R
1706 ffbf 14 86 15 85                FDB     $1486,$1585     ; A,R     B,R
1707 ffc3 16 8b 17 80                FDB     $168B,$1780     ; D,R     ,R+
1708 ffc7 18 81 19 82                FDB     $1881,$1982     ; ,R++    ,-R
1709 ffcb 1a 83 82 8c                FDB     $1A83,$828C     ; ,--R    HH,PCR
1710 ffcf 83 8d 03 9f                FDB     $838D,$039F     ; HHHH,PCR [HHHH]
1711 ffd3 00                         FCB     0               ; END OF TABLE
1712                         
1713                         ****************************************************
1714                         *            DEFAULT INTERRUPT TRANSFERS           *
1715                         ****************************************************
1716 ffd4 6e 9d df ee        RSRVD   JMP     [VECTAB+.RSVD,PCR]      ; RESERVED VECTOR
1717 ffd8 6e 9d df ec        SWI3    JMP     [VECTAB+.SWI3,PCR]      ; SWI3 VECTOR
1718 ffdc 6e 9d df ea        SWI2    JMP     [VECTAB+.SWI2,PCR]      ; SWI2 VECTOR
1719 ffe0 6e 9d df e8        FIRQ    JMP     [VECTAB+.FIRQ,PCR]      ; FIRQ VECTOR
1720 ffe4 6e 9d df e6        IRQ     JMP     [VECTAB+.IRQ,PCR]       ; IRQ VECTOR
1721 ffe8 6e 9d df e4        SWI     JMP     [VECTAB+.SWI,PCR]       ; SWI VECTOR
1722 ffec 6e 9d df e2        NMI     JMP     [VECTAB+.NMI,PCR]       ; NMI VECTOR
1723                         
1724                         ******************************************************
1725                         *            ASSIST09 HARDWARE VECTOR TABLE
1726                         * THIS TABLE IS USED IF THE ASSIST09 ROM ADDRESSES
1727                         * THE MC6809 HARDWARE VECTORS.
1728                         ******************************************************
1729 fff0                            ORG     ROMBEG+ROMSIZ-16 ; SETUP HARDWARE VECTORS
1730 fff0 ff d4                      FDB     RSRVD           ; RESERVED SLOT
1731 fff2 ff d8                      FDB     SWI3            ; SOFTWARE INTERRUPT 3
1732 fff4 ff dc                      FDB     SWI2            ; SOFTWARE INTERRUPT 2
1733 fff6 ff e0                      FDB     FIRQ            ; FAST INTERRUPT REQUEST
1734 fff8 ff e4                      FDB     IRQ             ; INTERRUPT REQUEST
1735 fffa ff e8                      FDB     SWI             ; SOFTWARE INTERRUPT
1736 fffc ff ec                      FDB     NMI             ; NON-MASKABLE INTERRUPT
1737 fffe f8 37                      FDB     RESET           ; RESTART
