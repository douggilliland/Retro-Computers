                      *************************************
                      * COPYRIGHT (C) MOTOROLA, INC. 1979 *
                      *************************************
                      
                      *************************************
                      * THIS IS THE BASE ASSIST09 ROM.
                      * IT MAY RUN WITH OR WITHOUT THE
                      * EXTENSION ROM WHICH
                      * WHEN PRESENT WILL BE AUTOMATICALLY
                      * INCORPORATED BY THE BLDVTR
                      * SUBROUTINE.
                      *************************************
                      
                      *********************************************
                      * GLOBAL MODULE EQUATES
                      ********************************************
F800                  ROMBEG  EQU     $F800           ; ROM START ASSEMBLY ADDRESS
6800                  RAMOFS  EQU     -$9800          ; ROM OFFSET TO RAM WORK PAGE
0800                  ROMSIZ  EQU     2048            ; ROM SIZE
F000                  ROM2OF  EQU     ROMBEG-ROMSIZ   ; START OF EXTENSION ROM
A000                  ACIA    EQU     $A000           ; DEFAULT ACIA ADDRESS
0000                  PTM     EQU     $0000           ; DEFAULT PTM ADDRESS
0000                  DFTCHP  EQU     0               ; DEFAULT CHARACTER PAD COUNT
0005                  DFTNLP  EQU     5               ; DEFAULT NEW LINE PAD COUNT
003E                  PROMPT  EQU     '>              ; PROMPT CHARACTER
0008                  NUMBKP  EQU     8               ; NUMBER OF BREAKPOINTS
                      *********************************************
                      
                      *********************************************
                      * MISCELANEOUS EQUATES
                      *********************************************
0004                  EOT     EQU     $04             ; END OF TRANSMISSION
0007                  BELL    EQU     $07             ; BELL CHARACTER
000A                  LF      EQU     $0A             ; LINE FEED
000D                  CR      EQU     $0D             ; CARRIAGE RETURN
0010                  DLE     EQU     $10             ; DATA LINK ESCAPE
0018                  CAN     EQU     $18             ; CANCEL (CTL-X)
                      
                      * PTM ACCESS DEFINITIONS
0001                  PTMSTA  EQU     PTM+1           ; READ STATUS REGISTER
0000                  PTMC13  EQU     PTM             ; CONTROL REGISTERS 1 AND 3
0001                  PTMC2   EQU     PTM+1           ; CONTROL REGISTER 2
0002                  PTMTM1  EQU     PTM+2           ; LATCH 1
0004                  PTMTM2  EQU     PTM+4           ; LATCH 2
0006                  PTMTM3  EQU     PTM+6           ; LATCH 3
008C                  SKIP2   EQU     $8C             ; "CMPX #" OPCODE - SKIPS TWO BYTES
                      
                      *******************************************
                      * ASSIST09 MONITOR SWI FUNCTIONS
                      * THE FOLLOWING EQUATES DEFINE FUNCTIONS PROVIDED
                      * BY THE ASSIST09 MONITOR VIA THE SWI INSTRUCTION.
                      ******************************************
0000                  INCHNP  EQU     0               ; INPUT CHAR IN A REG - NO PARITY
0001                  OUTCH   EQU     1               ; OUTPUT CHAR FROM A REG
0002                  PDATA1  EQU     2               ; OUTPUT STRING
0003                  PDATA   EQU     3               ; OUTPUT CR/LF THEN STRING
0004                  OUT2HS  EQU     4               ; OUTPUT TWO HEX AND SPACE
0005                  OUT4HS  EQU     5               ; OUTPUT FOUR HEX AND SPACE
0006                  PCRLF   EQU     6               ; OUTPUT CR/LF
0007                  SPACE   EQU     7               ; OUTPUT A SPACE
0008                  MONITR  EQU     8               ; ENTER ASSIST09 MONITOR
0009                  VCTRSW  EQU     9               ; VECTOR EXAMINE/SWITCH
000A                  BRKPT   EQU     10              ; USER PROGRAM BREAKPOINT
000B                  PAUSE   EQU     11              ; TASK PAUSE FUNCTION
000B                  NUMFUN  EQU     11              ; NUMBER OF AVAILABLE FUNCTIONS
                      
                      ; NEXT SUB-CODES FOR ACCESSING THE VECTOR TABLE.
                      ; THEY ARE EQUIVALENT TO OFFSETS IN THE TABLE.
                      ; RELATIVE POSITIONING MUST BE MAINTAINED
                      
0000                  XAVTBL  EQU             0                               ; ADDRESS OF VECTOR TABLE
0002                  XCMDL1  EQU     2               ; FIRST COMMAND LIST
0004                  XRSVD   EQU     4               ; RESERVED HARDWARE VECTOR
0006                  XSWI3   EQU     6               ; SWI3 ROUTINE
0008                  XSWI2   EQU     8               ; SWI2 ROUTINE
000A                  XFIRQ   EQU     10              ; FIRQ ROUTINE
000C                  XIRQ    EQU     12              ; IRQ ROUTINE
000E                  XSWI    EQU     14              ; SWI ROUTINE
0010                  XNMI    EQU     16              ; NMI ROUTINE
0012                  XRESET  EQU     18              ; RESET ROUTINE
0014                  XCION   EQU     20              ; CONSOLE ON
0016                  XCIDTA  EQU     22              ; CONSOLE INPUT DATA
0018                  XCIOFF  EQU     24              ; CONSOLE INPUT OFF
001A                  XCOON   EQU     26              ; CONSOLE OUTPUT ON
001C                  XCODTA  EQU     28              ; CONSOLE OUTPUT DATA
001E                  XCOOFF  EQU     30              ; CONSOLE OUTPUT OFF
0020                  XHSDTA  EQU     32              ; HIGH SPEED PRINTDATA
0022                  XBSON   EQU     34              ; PUNCH/LOAD ON
0024                  XBSDTA EQU      36              ; PUNCH/LOAD DATA
0026                  XBSOFF  EQU     38              ; PUNCH/LOAD OFF
0028                  XPAUSE  EQU     40              ; TASK PAUSE ROUTINE
002A                  XEXPAN  EQU     42              ; EXPRESSION ANALYZER
002C                  XCMDL2  EQU     44              ; SECOND COMMAND LIST
002E                  XACIA   EQU     46              ; ACIA ADDRESS
0030                  XPAD    EQU     48              ; CHARACTER PAD AND NEW LINE PAD
0032                  XECHO   EQU     50              ; ECHO/LOAD AND NULL BKPT FLAG
0034                  XPTM    EQU     52              ; PTM ADDRESS
001B                  NUMVTR  EQU     52/2+1          ; NUMBER OF VECTORS
0034                  HIVTR   EQU     52              ; HIGHEST VECTOR OFFSET
                      
                      ******************************************
                      *           WORK AREA
                      * THIS WORK AREA IS ASSIGNED TO THE PAGE ADDRESSED BY
                      * -$1800,PCR FROM THE BASE ADDRESS OF THE ASSIST09
                      * ROM. THE DIRECT PAGE REGISTER DURING MOST ROUTINE
                      * OPERATIONS WILL POINT TO THIS WORK AREA. THE STACK
                      * INITIALLY STARTS UNDER THE RESERVED WORK AREAS AS
                      * DEFINED HEREIN.
                      ******************************************
6000                  WORKPG  EQU     ROMBEG+RAMOFS   ; SETUP DIRECT PAGE ADDRESS
                      *       SETDP   =WORKPG         ; NOTIFY ASSEMBLER
6100                          ORG     WORKPG+256      ; READY PAGE DEFINITIONS
                      
                      * THE FOLLOWING THRU BKPTOP MUST RESIDE IN THIS ORDER
                      * FOR PROPER INITIALIZATION
60FC                          ORG     *-4
60FC                  PAUSER  EQU     *               ; PAUSE ROUTINE
60FB                          ORG     *-1
60FB                  SWIBFL  EQU     *               ; BYPASS SWI AS BREAKPOINT FLAG
60FA                          ORG     *-1
60FA                  BKPTCT  EQU     *               ; BREAKPOINT COUNT
60F8                          ORG     *-2             ; SLEVEL EQU
60F8                  SLEVEL  EQU     *               ; STACK TRACE LEVEL
60C2                          ORG     -NUMVTR*2+*
60C2                  VECTAB  EQU     *               ; VECTOR TABLE
60B2                          ORG     -2*NUMBKP+*
60B2                  BKPTBL  EQU     *               ; BREAKPOINT TABLE
60A2                          ORG     -2*NUMBKP+*
60A2                  BKPTOP  EQU     *               ; BREAKPOINT OPCODE TABLE
60A0                          ORG     *-2
60A0                  WINDOW  EQU     *               ; WINDOW
609E                          ORG     *-2
609E                  ADDR    EQU     *               ; ADDRESS POINTER VALUE
609D                          ORG     *-1
609D                  BASEPG  EQU     *               ; BASE PAGE VALUE
609B                          ORG     *-2
609B                  NUMBER  EQU     *               ; BINARY BUILD AREA
6099                          ORG     *-2
6099                  LASTOP  EQU     *               ; LAST OPCODE TRACED
6097                          ORG     *-2
6097                  RSTACK  EQU     *               ; RESET STACK POINTER
6095                          ORG     *-2
6095                  PSTACK  EQU     *               ; COMMAND RECOVERY STACK
6093                          ORG     *-2
6093                  PCNTER  EQU     *               ; LAST PROGRAM COUNTER
6091                          ORG     *-2
6091                  TRACEC  EQU     *               ; TRACE COUNT
6090                          ORG     *-1
6090                  SWICNT  EQU     *               ; TRACE "SWI" NEST LEVEL COUNT
608F                          ORG     *-1             ; (MISFLG MUST FOLLOW SWICNT)
608F                  MISFLG  EQU     *               ; LOAD CMD/THRU BREAKPOINT FLAG
608E                          ORG     *-1
608E                  DELIM   EQU     *               ; EXPRESSION DELIMITER/WORK BYTE
6066                          ORG     *-40
6066                  ROM2WK  EQU     *               ; EXTENSION ROM RESERVED AREA
6051                          ORG     *-21
6051                  TSTACK  EQU     *               ; TEMPORARY STACK HOLD
6051                  STACK   EQU     *               ; START OF INITIAL STACK
                      
                      * Fill from start of ROM ($C000) to starting location of ROM code
                      *  ($F800) with all ones.
                      
C000                          ORG     $C000
C000  FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF         FILL    $FF, ROMBEG-*   ; Fill ROM with FFs until $DB00
                      
                      ******************************************
                      * DEFAULT THE ROM BEGINNING ADDRESS TO 'ROMBEG'
                      * ASSIST09 IS POSITION ADDRESS INDEPENDENT, HOWEVER
                      * WE ASSEMBLE ASSUMING CONTROL OF THE HARDWARE VECTORS.
                      * NOTE THAT THE WORK RAM PAGE MUST BE 'RAMOFS'
                      * FROM THE ROM BEGINNING ADDRESS.
                      ********************************************
F800                          ORG     ROMBEG          ; ROM ASSEMBLY/DEFAULT ADDRESS
                      
                      *****************************************************
                      * BLDVTR - BUILD ASSIST09 VECTOR TABLE
                      * HARDWARE RESET CALLS THIS SUBROUTINE TO BUILD THE
                      * ASSIST09 VECTOR TABLE. THIS SUBROUTINE RESIDES AT
                      * THE FIRST BYTE OF THE ASSIST09 ROM, AND CAN BE
                      * CALLED VIA EXTERNAL CONTROL CODE FOR REMOTE
                      * ASSIST09 EXECUTION.
                      * INPUT: S->VALID STACK RAM
                      * OUTPUT: U->VECTOR TABLE ADDRESS
                      * DPR->ASSIST09 WORK AREA PAGE
                      * THE VECTOR TABLE AND DEFAULTS ARE INITIALIZED
                      * ALL REGISTERS VOLATILE
                      *************************************************
F800  308D68BE        BLDVTR  LEAX    VECTAB,PCR      ; ADDRESS VECTOR TABLE
F804  1F10                    TFR     X,D             ; OBTAIN BASE PAGE ADDRESS
F806  1F8B                    TFR     A,DP            ; SETUP DPR
F808  979D                    STA     <BASEPG         ; STORE FOR QUICK REFERENCE
F80A  3384                    LEAU    ,X              ; RETURN TABLE TO CALLER
F80C  318C35                  LEAY    <INITVT,PCR     ; LOAD FROM ADDR
F80F  EF81                    STU     ,X++            ; INIT VECTOR TABLE ADDRESS
F811  C616                    LDB     #NUMVTR-5       ; NUMBER RELOCATABLE VECTORS
F813  3404                    PSHS    B               ; STORE INDEX ON STACK
F815  1F20            BLD2    TFR     Y,D             ; PREPARE ADDRESS RESOLVE
F817  E3A1                    ADDD    ,Y++            ; TO ABSOLUTE ADDRESS
F819  ED81                    STD     ,X++            ; INTO VECTOR TABLE
F81B  6AE4                    DEC     ,S              ; COUNT DOWN
F81D  26F6                    BNE     BLD2            ; BRANCH IF MORE TO INSERT
F81F  C60D                    LDB     #INTVE-INTVS    ; STATIC VALUE INIT LENGTH
F821  A6A0            BLD3    LDA     ,Y+             ; LOAD NEXT BYTE
F823  A780                    STA     ,X+             ; STORE INTO POSITION
F825  5A                      DECB                    ; COUNT DOWN
F826  26F9                    BNE     BLD3            ; LOOP UNTIL DONE
F828  318DF7D4                LEAY    ROM2OF,PCR      ; TEST POSSIBLE EXTENSION ROM
F82C  8E20FE                  LDX     #$20FE          ; LOAD "BRA *" FLAG PATTERN
F82F  ACA1                    CMPX    ,Y++            ; ? EXTENDED ROM HERE
F831  2602                    BNE     BLDRTN          ; BRANCH NOT OUR ROM TO RETURN
F833  ADA4                    JSR     ,Y              ; CALL EXTENDED ROM INITIALIZE
F835  3584            BLDRTN  PULS    PC,B            ; RETURN TO INITIALIZER
                      
                      *****************************************************
                      *                RESET ENTRY POINT
                      * HARDWARE RESET ENTERS HERE IF ASSIST09 IS ENABLED
                      * TO RECEIVE THE MC6809 HARDWARE VECTORS. WE CALL
                      * THE BLDVTR SUBROUTINE TO INITIALIZE THE VECTOR
                      * TABLE, STACK, AND THEN FIREUP THE MONITOR VIA SWI
                      * CALL.
                      *******************************************************
F837  328D6816        RESET   LEAS    STACK,PCR       ; SETUP INITIAL STACK
F83B  8DC3                    BSR     BLDVTR          ; BUILD VECTOR TABLE
F83D  4F              RESET2  CLRA                    ; ISSUE STARTUP MESSAGE
F83E  1F8B                    TFR     A,DP            ; DEFAULT TO PAGE ZERO
F840  3F                      SWI                     ; PERFORM MONITOR FIREUP
F841  08                      FCB     MONITR          ; TO ENTER COMMAND PROCESSING
F842  20F9                    BRA     RESET2          ; REENTER MONITOR IF 'CONTINUE'
                      
                      ******************************************************
                      *        INITVT - INITIAL VECTOR TABLE
                      * THIS TABLE IS RELOCATED TO RAM AND REPRESENTS THE
                      * INITIAL STATE OF THE VECTOR TABLE. ALL ADDRESSES
                      * ARE CONVERTED TO ABSOLUTE FORM. THIS TABLE STARTS
                      * WITH THE SECOND ENTRY, ENDS WITH STATIC CONSTANT
                      * INITIALIZATION DATA WHICH CARRIES BEYOND THE TABLE.
                      ************************************************
F844  0158            INITVT  FDB     CMDTBL-*        ; DEFAULT FIRST COMMAND TABLE
F846  0292                    FDB     RSRVDR-*        ; DEFAULT UNDEFINED HARDWARE VECTOR
F848  0290                    FDB     SWI3R-*         ; DEFAULT SWI3
F84A  028E                    FDB     SWI2R-*         ; DEFAULT SWI2
F84C  0270                    FDB     FIRQR-*         ; DEFAULT FIRQ
F84E  028A                    FDB     IRQR-*          ; DEFAULT IRQ ROUTINE
F850  0045                    FDB     SWIR-*          ; DEFAULT SWI ROUTINE
F852  022B                    FDB     NMIR-*          ; DEFAULT NMI ROUTINE
F854  FFE3                    FDB     RESET-*         ; RESTART VECTOR
F856  0290                    FDB     CION-*          ; DEFAULT CION
F858  0284                    FDB     CIDTA-*         ; DEFAULT CIDTA
F85A  0296                    FDB     CIOFF-*         ; DEFAULT CIOFF
F85C  028A                    FDB     COON-*          ; DEFAULT COON
F85E  0293                    FDB     CODTA-*         ; DEFAULT CODTA
F860  0290                    FDB     COOFF-*         ; DEFAULT COOFF
F862  039A                    FDB     HSDTA-*         ; DEFAULT HSDTA
F864  02B7                    FDB     BSON-*          ; DEFAULT BSON
F866  02D2                    FDB     BSDTA-*         ; DEFAULT BSDTA
F868  02BF                    FDB     BSOFF-*         ; DEFAULT BSOFF
F86A  6892                    FDB     PAUSER-*        ; DEFAULT PAUSE ROUTINE
F86C  047D                    FDB     EXP1-*          ; DEFAULT EXPRESSION ANALYZER
F86E  012D                    FDB     CMDTB2-*        ; DEFAULT SECOND COMMAND TABLE
                      * CONSTANTS
F870  A000            INTVS   FDB     ACIA            ; DEFAULT ACIA
F872  0005                    FCB     DFTCHP,DFTNLP   ; DEFAULT NULL PADDS
F874  0000                    FDB     0               ; DEFAULT ECHO
F876  0000                    FDB     PTM             ; DEFAULT PTM
F878  0000                    FDB     0               ; INITIAL STACK TRACE LEVEL
F87A  00                      FCB     0               ; INITIAL BREAKPOINT COUNT
F87B  00                      FCB     0               ; SWI BREAKPOINT LEVEL
F87C  39                      FCB     $39             ; DEFAULT PAUSE ROUTINE (RTS)
F87D                  INTVE   EQU     *
                      *B
                      ***********************************************
                      *            ASSIST09 SWI HANDLER
                      * THE SWI HANDLER PROVIDES ALL INTERFACING NECESSARY
                      * FOR A USER PROGRAM. A FUNCTION BYTE IS ASSUMED TO
                      * FOLLOW THE SWI INSTRUCTION. IT IS BOUND CHECKED
                      * AND THE PROPER ROUTINE IS GIVEN CONTROL. THIS
                      * INVOCATION MAY ALSO BE A BREAKPOINT INTERRUPT.
                      * IF SO, THE BREAKPOINT HANDLER IS ENTERED.
                      * INPUT: MACHINE STATE DEFINED FOR SWI
                      * OUTPUT: VARIES ACCORDING TO FUNCTION CALLED. PC ON
                      * CALLERS STACK INCREMENTED BY ONE IF VALID CALL.
                      * VOLATILE REGISTERS: SEE FUNCTIONS CALLED
                      * STATE: RUNS DISABLED UNLESS FUNCTION CLEARS I FLAG.
                      ************************************************
                      * SWI FUNCTION VECTOR TABLE
F87D  0194            SWIVTB  FDB     ZINCH-SWIVTB    ; INCHNP
F87F  01B1                    FDB     ZOTCH1-SWIVTB   ; OUTCH
F881  01CB                    FDB     ZPDTA1-SWIVTB   ; PDATA1
F883  01C3                    FDB     ZPDATA-SWIVTB   ; PDATA
F885  0175                    FDB     ZOT2HS-SWIVTB   ; OUT2HS
F887  0173                    FDB     ZOT4HS-SWIVTB   ; OUT4HS
F889  01C0                    FDB     ZPCRLF-SWIVTB   ; PCRLF
F88B  0179                    FDB     ZSPACE-SWIVTB   ; SPACE
F88D  0055                    FDB     ZMONTR-SWIVTB   ; MONITR
F88F  017D                    FDB     ZVSWTH-SWIVTB   ; VCTRSW
F891  0256                    FDB     ZBKPNT-SWIVTB   ; BREAKPOINT
F893  01D1                    FDB     ZPAUSE-SWIVTB   ; TASK PAUSE
                      
F895  6A8D67F7        SWIR    DEC     SWICNT,PCR      ; UP "SWI" LEVEL FOR TRACE
F899  170225                  LBSR    LDDP            ; SETUP PAGE AND VERIFY STACK
                      * CHECK FOR BREAKPOINT TRAP
F89C  EE6A                    LDU     10,S            ; LOAD PROGRAM COUNTER
F89E  335F                    LEAU    -1,U            ; BACK TO SWI ADDRESS
F8A0  0DFB                    TST     <SWIBFL         ; ? THIS "SWI" BREAKPOINT
F8A2  2611                    BNE     SWIDNE          ; BRANCH IF SO TO LET THROUGH
F8A4  17069B                  LBSR    CBKLDR          ; OBTAIN BREAKPOINT POINTERS
F8A7  50                      NEGB                    ; OBTAIN POSITIVE COUNT
F8A8  5A              SWILP   DECB                    ; COUNT DOWN
F8A9  2B0A                    BMI     SWIDNE          ; BRANCH WHEN DONE
F8AB  11A3A1                  CMPU    ,Y++            ; ? WAS THIS A BREAKPOINT
F8AE  26F8                    BNE     SWILP           ; BRANCH IF NOT
F8B0  EF6A                    STU     10,S            ; SET PROGRAM COUNTER BACK
F8B2  16021E                  LBRA    ZBKPNT          ; GO DO BREAKPOINT
F8B5  0FFB            SWIDNE  CLR     <SWIBFL         ; CLEAR IN CASE SET
F8B7  3706                    PULU    D               ; OBTAIN FUNCTION BYTE, UP PC
F8B9  C10B                    CMPB    #NUMFUN         ; ? TOO HIGH
F8BB  1022020F                LBHI    ERROR           ; YES, DO BREAKPOINT
F8BF  EF6A                    STU     10,S            ; BUMP PROGRAM COUNTER PAST SWI
F8C1  58                      ASLB                    ; FUNCTION CODE TIMES TWO
F8C2  338CB8                  LEAU    SWIVTB,PCR      ; OBTAIN VECTOR BRANCH ADDRESS
F8C5  ECC5                    LDD     B,U             ; LOAD OFFSET
F8C7  6ECB                    JMP     D,U             ; JUMP TO ROUTINE
                      
                      **********************************************
                      * REGISTERS TO FUNCTION ROUTINES:
                      *  DP-> WORK AREA PAGE
                      *  D,Y,U=UNRELIABLE           X=AS CALLED FROM USER
                      *  S=AS FROM SWI INTERRUPT
                      *********************************************
                      
                      **************************************************
                      *            [SWI FUNCTION 8]
                      *              MONITOR ENTRY
                      *  FIREUP THE ASSIST09 MONITOR.
                      *  THE STACK WITH ITS VALUES FOR THE DIRECT PAGE
                      *  REGISTER AND CONDITION CODE FLAGS ARE USED AS IS.
                      *   1) INITIALIZE CONSOLE I/O
                      *   2) OPTIONALLY PRINT SIGNON
                      *   3) INITIALIZE PTM FOR SINGLE STEPPING
                      *   4) ENTER COMMAND PROCESSOR
                      * INPUT: A=0 INIT CONSOLE AND PRINT STARTUP MESSAGE
                      *        A#0 OMIT CONSOLE INIT AND STARTUP MESSAGE
                      *************************************************
                      
F8C9  4153534953543039 SIGNON  FCC     /ASSIST09/      ; SIGNON EYE-CATCHER
F8D1  04                      FCB     EOT
F8D2  10DF97          ZMONTR  STS     <RSTACK         ; SAVE FOR BAD STACK RECOVERY
F8D5  6D61                    TST     1,S             ; ? INIT CONSOLE AND SEND MSG
F8D7  260D                    BNE     ZMONT2          ; BRANCH IF NOT
F8D9  AD9D67F9                JSR     [VECTAB+XCION,PCR] ; READY CONSOLE INPUT
F8DD  AD9D67FB                JSR     [VECTAB+XCOON,PCR] ; READY CONSOLE OUTPUT
F8E1  308CE5                  LEAX    SIGNON,PCR         ; READY SIGNON EYE-CATCHER
F8E4  3F                      SWI                     ; PERFORM
F8E5  03                      FCB     PDATA           ; PRINT STRING
F8E6  9EF6            ZMONT2  LDX     <VECTAB+XPTM    ; LOAD PTM ADDRESS
F8E8  270D                    BEQ     CMD             ; BRANCH IF NOT TO USE A PTM
F8EA  6F02                    CLR     PTMTM1-PTM,X    ; SET LATCH TO CLEAR RESET
F8EC  6F03                    CLR     PTMTM1+1-PTM,X  ; AND SET GATE HIGH
F8EE  CC01A6                  LDD     #$01A6          ; SETUP TIMER 1 MODE
F8F1  A701                    STA     PTMC2-PTM,X     ; SETUP FOR CONTROL REGISTER1
F8F3  E784                    STB     PTMC13-PTM,X    ; SET OUTPUT ENABLED/
                      * SINGLE SHOT/ DUAL 8 BIT/INTERNAL MODE/OPERATE
F8F5  6F01                    CLR     PTMC2-PTM,X     ; SET CR2 BACK TO RESET FORM
                      * FALL INTO COMMAND PROCESSOR
                      
                      ***************************************************
                      *          COMMAND HANDLER
                      *  BREAKPOINTS ARE REMOVED AT THIS TIME.
                      *  PROMPT FOR A COMMAND, AND STORE ALL CHARACTERS
                      *  UNTIL A SEPARATOR ON THE STACK.
                      *  SEARCH FOR FIRST MATCHING COMMAND SUBSET,
                      *  CALL IT OR GIVE '?' RESPONSE.
                      *  DURING COMMAND SEARCH:
                      *      B=OFFSET TO NEXT ENTRY ON X
                      *      U=SAVED S
                      *      U-1=ENTRY SIZE+2
                      *      U-2=VALID NUMBER FLAG (>=0 VALID)/COMPARE CNT
                      *      U-3=CARRIAGE RETURN FLAG (0=CR HAS BEEN DONE)
                      *      U-4=START OF COMMAND STORE
                      *      S+0=END OF COMMAND STORE
                      ***********************************************
                      
F8F7  3F              CMD     SWI                     ; TO NEW LINE
F8F8  06                      FCB     PCRLF           ; FUNCTION
                      * DISARM THE BREAKPOINTS
F8F9  170646          CMDNEP  LBSR    CBKLDR          ; OBTAIN BREAKPOINT POINTERS
F8FC  2A0C                    BPL     CMDNOL          ; BRANCH IF NOT ARMED OR NONE
F8FE  50                      NEGB                    ; MAKE POSITIVE
F8FF  D7FA                    STB     <BKPTCT         ; FLAG AS DISARMED
F901  5A              CMDDDL  DECB                    ; ? FINISHED
F902  2B06                    BMI     CMDNOL          ; BRANCH IF SO
F904  A630                    LDA     -NUMBKP*2,Y     ; LOAD OPCODE STORED
F906  A7B1                    STA     [,Y++]          ; STORE BACK OVER "SWI"
F908  20F7                    BRA     CMDDDL          ; LOOP UNTIL DONE
F90A  AE6A            CMDNOL  LDX     10,S            ; LOAD USERS PROGRAM COUNTER
F90C  9F93                    STX     <PCNTER         ; SAVE FOR EXPRESSION ANALYZER
F90E  863E                    LDA     #PROMPT         ; LOAD PROMPT CHARACTER
F910  3F                      SWI                     ; SEND TO OUTPUT HANDLER
F911  01                      FCB     OUTCH           ; FUNCTION
F912  33E4                    LEAU    ,S              ; REMEMBER STACK RESTORE ADDRESS
F914  DF95                    STU     <PSTACK         ; REMEMBER STACK FOR ERROR USE
F916  4F                      CLRA                    ; PREPARE ZERO
F917  5F                      CLRB                    ; PREPARE ZERO
F918  DD9B                    STD     <NUMBER         ; CLEAR NUMBER BUILD AREA
F91A  DD8F                    STD     <MISFLG         ; CLEAR MISCEL. AND SWICNT FLAGS
F91C  DD91                    STD     <TRACEC         ; CLEAR TRACE COUNT
F91E  C602                    LDB     #2              ; SET D TO TWO
F920  3407                    PSHS    D,CC            ; PLACE DEFAULTS ONTO STACK
                      * CHECK FOR "QUICK" COMMANDS.
F922  170454                  LBSR    READ            ; OBTAIN FIRST CHARACTER
F925  308D0581                LEAX    CDOT+2,PCR      ; PRESET FOR SINGLE TRACE
F929  812E                    CMPA    #'.             ; ? QUICK TRACE
F92B  275A                    BEQ     CMDXQT          ; BRANCH EQUAL FOR TRACE ONE
F92D  308D04E9                LEAX    CMPADP+2,PCR    ; READY MEMORY ENTRY POINT
F931  812F                    CMPA    #'/             ; ? OPEN LAST USED MEMORY
F933  2752                    BEQ     CMDXQT          ; BRANCH TO DO IT IF SO
                      * PROCESS NEXT CHARACTER
F935  8120            CMD2    CMPA    #'              ; ? BLANK OR DELIMITER
F937  2314                    BLS    CMDGOT           ; BRANCH YES, WE HAVE IT
F939  3402                    PSHS   A                ; BUILD ONTO STACK
F93B  6C5F                    INC    -1,U             ; COUNT THIS CHARACTER
F93D  812F                    CMPA   #'/              ; ? MEMORY COMMAND
F93F  274F                    BEQ    CMDMEM           ; BRANCH IF SO
F941  17040B                  LBSR   BLDHXC           ; TREAT AS HEX VALUE
F944  2702                    BEQ    CMD3             ; BRANCH IF STILL VALID NUMBER
F946  6A5E                    DEC    -2,U             ; FLAG AS INVALID NUMBER
F948  17042E          CMD3    LBSR   READ             ; OBTAIN NEXT CHARACTER
F94B  20E8                    BRA    CMD2             ; TEST NEXT CHARACTER
                      * GOT COMMAND, NOW SEARCH TABLES
F94D  800D            CMDGOT  SUBA   #CR              ; SET ZERO IF CARRIAGE RETURN
F94F  A75D                    STA    -3,U             ; SETUP FLAG
F951  9EC4                    LDX    <VECTAB+XCMDL1   ; START WITH FIRST CMD LIST
F953  E680            CMDSCH  LDB    ,X+              ; LOAD ENTRY LENGTH
F955  2A10                    BPL    CMDSME           ; BRANCH IF NOT LIST END
F957  9EEE                    LDX    <VECTAB+XCMDL2   ; NOW TO SECOND CMD LITS
F959  5C                      INCB                    ; ? TO CONTINUE TO DEFAULT LIST
F95A  27F7                    BEQ     CMDSCH          ; BRANCH IF SO
F95C  10DE95          CMDBAD  LDS     <PSTACK         ; RESTORE STACK
F95F  308D015A                LEAX    ERRMSG,PCR      ; POINT TO ERROR STRING
F963  3F                      SWI                     ; SEND OUT
F964  02                      FCB     PDATA1          ; TO CONSOLE
F965  2090                    BRA     CMD             ; AND TRY AGAIN
                      * SEARCH NEXT ENTRY
F967  5A              CMDSME  DECB                    ; TAKE ACCOUNT OF LENGTH BYTE
F968  E15F                    CMPB    -1,U            ; ? ENTERED LONGER THAN ENTRY
F96A  2403                    BHS     CMDSIZ          ; BRANCH IF NOT TOO LONG
F96C  3A              CMDFLS  ABX                     ; SKIP TO NEXT ENTRY
F96D  20E4                    BRA     CMDSCH          ; AND TRY NEXT
F96F  315D            CMDSIZ  LEAY    -3,U            ; PREPARE TO COMPARE
F971  A65F                    LDA     -1,U            ; LOAD SIZE+2
F973  8002                    SUBA    #2              ; TO ACTUAL SIZE ENTERED
F975  A75E                    STA     -2,U            ; SAVE SIZE FOR COUNTDOWN
F977  5A              CMDCMP  DECB                    ; DOWN ONE BYTE
F978  A680                    LDA     ,X+             ; NEXT COMMAND CHARACTER
F97A  A1A2                    CMPA    ,-Y             ; ? SAME AS THAT ENTERED
F97C  26EE                    BNE     CMDFLS          ; BRANCH TO FLUSH IF NOT
F97E  6A5E                    DEC     -2,U            ; COUNT DOWN LENGTH OF ENTRY
F980  26F5                    BNE     CMDCMP          ; BRANCH IF MORE TO TEST
F982  3A                      ABX                     ; TO NEXT ENTRY
F983  EC1E                    LDD     -2,X            ; LOAD OFFSET
F985  308B                    LEAX    D,X             ; COMPUTE ROUTINE ADDRESS+2
F987  6D5D            CMDXQT  TST     -3,U            ; SET CC FOR CARRIAGE RETURN TEST
F989  32C4                    LEAS    ,U              ; DELETE STACK WORK AREA
F98B  AD1E                    JSR     -2,X            ; CALL COMMAND
F98D  16FF7A                  LBRA    CMDNOL          ; GO GET NEXT COMMAND
F990  6D5E            CMDMEM  TST     -2,U            ; ? VALID HEX NUMBER ENTERED
F992  2BC8                    BMI     CMDBAD          ; BRANCH ERROR IF NOT
F994  3088AE                  LEAX    <CMEMN-CMPADP,X ; TO DIFFERENT ENTRY
F997  DC9B                    LDD     <NUMBER         ; LOAD NUMBER ENTERED
F999  20EC                    BRA     CMDXQT          ; AND ENTER MEMORY COMMAND
                      
                      ** COMMANDS ARE ENTERED AS A SUBROUTINE WITH:
                      **    DPR->ASSIST09 DIRECT PAGE WORK AREA
                      **    Z=1 CARRIAGE RETURN ENTERED
                      **    Z=0 NON CARRIAGE RETURN DELIMITER
                      **    S=NORMAL RETURN ADDRESS
                      ** THE LABEL "CMDBAD" MAY BE ENTERED TO ISSUE AN
                      ** AN ERROR FLAG (*).
                      **************************************************
                      *       ASSIST09 COMMAND TABLES
                      * THESE ARE THE DEFAULT COMMAND TABLES. EXTERNAL
                      * TABLES OF THE SAME FORMAT MAY EXTEND/REPLACE
                      * THESE BY USING THE VECTOR SWAP FUNCTION.
                      *
                      * ENTRY FORMAT:
                      *    +0...TOTAL SIZE OF ENTRY (INCLUDING THIS BYTE)
                      *    +1...COMMAND STRING
                      *    +N...TWO BYTE OFFSET TO COMMAND (ENTRYADDR-*)
                      *
                      * THE TABLES TERMINATE WITH A ONE BYTE -1 OR -2.
                      * THE -1 CONTINUES THE COMMAND SEARCH WITH THE
                      *        SECOND COMMAND TABLE.
                      * THE -2 TERMINATES COMMAND SEARCHES.
                      *****************************************************
                      
                      * THIS IS THE DEFAULT LIST FOR THE SECOND COMMAND
                      * LIST ENTRY.
                      
F99B  FE              CMDTB2  FCB     -2              ; STOP COMMAND SEARCHES
                      
                      * THIS IS THE DEFAULT LIST FOR THE FIRST COMMAND
                      * LIST ENTRY.
                      
F99C                  CMDTBL  EQU     *               ; MONITOR COMMAND TABLE
F99C  04                      FCB     4
F99D  42                      FCC     /B/             ; 'BREAKPOINT' COMMAND
F99E  054D                    FDB     CBKPT-*
F9A0  04                      FCB     4
F9A1  43                      FCC     /C/             ; 'CALL' COMMAND
F9A2  0417                    FDB     CCALL-*
F9A4  04                      FCB     4
F9A5  44                      FCC     /D/             ; 'DISPLAY' COMMAND
F9A6  049D                    FDB     CDISP-*
F9A8  04                      FCB     4
F9A9  45                      FCC     /E/             ; 'ENCODE' COMMAND
F9AA  059F                    FDB     CENCDE-*
F9AC  04                      FCB     4
F9AD  47                      FCC     /G/             ; 'GO' COMMAND
F9AE  03D2                    FDB     CGO-*
F9B0  04                      FCB     4
F9B1  4C                      FCC     /L/             ; 'LOAD' COMMAND
F9B2  04DD                    FDB     CLOAD-*
F9B4  04                      FCB     4
F9B5  4D                      FCC     /M/             ; 'MEMORY' COMMAND
F9B6  040D                    FDB     CMEM-*
F9B8  04                      FCB     4
F9B9  4E                      FCC     /N/             ; 'NULLS' COMMAND
F9BA  04FD                    FDB     CNULLS-*
F9BC  04                      FCB     4
F9BD  4F                      FCC     /O/             ; 'OFFSET' COMMAND
F9BE  050A                    FDB     COFFS-*
F9C0  04                      FCB     4
F9C1  50                      FCC     /P/             ; 'PUNCH' COMMAND
F9C2  04AF                    FDB     CPUNCH-*
F9C4  04                      FCB     4
F9C5  52                      FCC     /R/             ; 'REGISTERS' COMMAND
F9C6  0284                    FDB     CREG-*
F9C8  04                      FCB     4
F9C9  53                      FCC     /S/             ; 'STLEVEL' COMMAND
F9CA  04F2                    FDB     CSTLEV-*
F9CC  04                      FCB     4
F9CD  54                      FCC     /T/             ; 'TRACE' COMMAND
F9CE  04D6                    FDB     CTRACE-*
F9D0  04                      FCB     4
F9D1  56                      FCC     /V/             ; 'VERIFY' COMMAND
F9D2  04CF                    FDB     CVER-*
F9D4  04                      FCB     4
F9D5  57                      FCC     /W/             ; 'WINDOW' COMMAND
F9D6  0468                    FDB     CWINDO-*
F9D8  FF                      FCB     -1              ; END, CONTINUE WITH THE SECOND
                      
                      *************************************************
                      *             [SWI FUNCTIONS 4 AND 5]
                      *      4 - OUT2HS - DECODE BYTE TO HEX AND ADD SPACE
                      *      5 - OUT4HS - DECODE WORD TO HEX AND ADD SPACE
                      * INPUT: X->BYTE OR WORD TO DECODE
                      * OUTPUT: CHARACTERS SENT TO OUTPUT HANDLER
                      *         X->NEXT BYTE OR WORD
                      *************************************************
F9D9  A680            ZOUT2H  LDA     ,X+             ; LOAD NEXT BYTE
F9DB  3406                    PSHS    D               ; SAVE - DO NOT REREAD
F9DD  C610                    LDB     #16             ; SHIFT BY 4 BITS
F9DF  3D                      MUL                     ; WITH MULTIPLY
F9E0  8D04                    BSR     ZOUTHX          ; SEND OUT AS HEX
F9E2  3506                    PULS    D               ; RESTORE BYTES
F9E4  840F                    ANDA    #$0F            ; ISOLATE RIGHT HEX
F9E6  8B90            ZOUTHX  ADDA    #$90            ; PREPARE A-F ADJUST
F9E8  19                      DAA                     ; ADJUST
F9E9  8940                    ADCA    #$40            ; PREPARE CHARACTER BITS
F9EB  19                      DAA                     ; ADJUST
F9EC  6E9D66EE        SEND    JMP     [VECTAB+XCODTA,PCR] ; SEND TO OUT HANDLER
                      
F9F0  8DE7            ZOT4HS  BSR     ZOUT2H          ; CONVERT FIRST BYTE
F9F2  8DE5            ZOT2HS  BSR     ZOUT2H          ; CONVERT BYTE TO HEX
F9F4  AF64                    STX     4,S             ; UPDATE USERS X REGISTER
                      * FALL INTO SPACE ROUTINE
                      
                      *************************************************
                      *            [SWI FUNCTION 7]
                      *         SPACE - SEND BLANK TO OUTPUT HANDLER
                      * INPUT: NONE
                      * OUTPUT: BLANK SEND TO CONSOLE HANDLER
                      *************************************************
F9F6  8620            ZSPACE  LDA     #'              ; LOAD BLANK
F9F8  203D                    BRA     ZOTCH2          ; SEND AND RETURN
                      
                      ***********************************************
                      *             [SWI FUNCTION 9]
                      *          SWAP VECTOR TABLE ENTRY
                      * INPUT: A=VECTOR TABLE CODE (OFFSET)
                      * X=0 OR REPLACEMENT VALUE
                      * OUTPUT: X=PREVIOUS VALUE
                      ***********************************************
F9FA  A661            ZVSWTH  LDA     1,S             ; LOAD REQUESTERS A
F9FC  8134                    CMPA    #HIVTR          ; ? SUB-CODE TOO HIGH
F9FE  2239                    BHI     ZOTCH3          ; IGNORE CALL IF SO
FA00  109EC2                  LDY     <VECTAB+XAVTBL  ; LOAD VECTOR TABLE ADDRESS
FA03  EEA6                    LDU     A,Y             ; U=OLD ENTRY
FA05  EF64                    STU     4,S             ; RETURN OLD VALUE TO CALLERS X
FA07  AF7E                    STX     -2,S            ; ? X=0
FA09  272E                    BEQ     ZOTCH3          ; YES, DO NOT CHANGE ENTRY
FA0B  AFA6                    STX     A,Y             ; REPLACE ENTRY
FA0D  202A                    BRA     ZOTCH3          ; RETURN FROM SWI
                      *D
                      
                      ************************************************
                      *               [SWI FUNCTION 0]
                      *  INCHNP - OBTAIN INPUT CHAR IN A (NO PARITY)
                      * NULLS AND RUBOUTS ARE IGNORED.
                      * AUTOMATIC LINE FEED IS SENT UPON RECEIVING A
                      * CARRIAGE RETURN.
                      * UNLESS WE ARE LOADING FROM TAPE.
                      ************************************************
FA0F  8D5D            ZINCHP  BSR     XQPAUS          ; RELEASE PROCESSOR
FA11  8D5F            ZINCH   BSR     XQCIDT          ; CALL INPUT DATA APPENDAGE
FA13  24FA                    BCC     ZINCHP          ; LOOP IF NONE AVAILABLE
FA15  4D                      TSTA                    ; ? TEST FOR NULL
FA16  27F9                    BEQ     ZINCH           ; IGNORE NULL
FA18  817F                    CMPA    #$7F            ; ? RUBOUT
FA1A  27F5                    BEQ     ZINCH           ; BRANCH YES TO IGNORE
FA1C  A761                    STA     1,S             ; STORE INTO CALLERS A
FA1E  0D8F                    TST     <MISFLG         ; ? LOAD IN PROGRESS
FA20  2617                    BNE     ZOTCH3          ; BRANCH IF SO TO NOT ECHO
FA22  810D                    CMPA    #CR             ; ? CARRIAGE RETURN
FA24  2604                    BNE     ZIN2            ; NO, TEST ECHO BYTE
FA26  860A                    LDA     #LF             ; LOAD LINE FEED
FA28  8DC2                    BSR     SEND            ; ALWAYS ECHO LINE FEED
FA2A  0DF4            ZIN2    TST     <VECTAB+XECHO   ; ? ECHO DESIRED
FA2C  260B                    BNE     ZOTCH3          ; NO, RETURN
                      * FALL THROUGH TO OUTCH
                      ************************************************
                      *            [SWI FUNCTION 1]
                      *        OUTCH - OUTPUT CHARACTER FROM A
                      * INPUT: NONE
                      * OUTPUT: IF LINEFEED IS THE OUTPUT CHARACTER THEN
                      * C=0 NO CTL-X RECEIVED, C=1 CTL-X RECEIVED
                      ************************************************
FA2E  A661            ZOTCH1  LDA     1,S             ; LOAD CHARACTER TO SEND
FA30  308C09                  LEAX    <ZPCRLS,PCR     ; DEFAULT FOR LINE FEED
FA33  810A                    CMPA    #LF             ; ? LINE FEED
FA35  270F                    BEQ     ZPDTLP          ; BRANCH TO CHECK PAUSE IF SO
FA37  8DB3            ZOTCH2  BSR     SEND            ; SEND TO OUTPUT ROUTINE
FA39  0C90            ZOTCH3  INC     <SWICNT         ; BUMP UP "SWI" TRACE NEST LEVEL
FA3B  3B                      RTI                     ; RETURN FROM "SWI" FUNCTION
                      
                      **************************************************
                      * [SWI FUNCTION 6]
                      * PCRLF - SEND CR/LF TO CONSOLE HANDLER
                      * INPUT: NONE
                      * OUTPUT: CR AND LF SENT TO HANDLER
                      * C=0 NO CTL-X, C=1 CTL-X RECEIVED
                      **************************************************
FA3C  04              ZPCRLS  FCB     EOT             ; NULL STRING
FA3D  308CFC          ZPCRLF LEAX     ZPCRLS,PCR      ; READY CR,LF STRING
                      * FALL INTO CR/LF CODE
                      
                      **************************************************
                      * [SWI FUNCTION 3]
                      * PDATA - OUTPUT CR/LF AND STRING
                      * INPUT: X->STRING
                      * OUTPUT: CR/LF AND STRING SENT TO OUTPUT CONSOLE
                      * HANDLER.
                      * C=0 NO CTL-X, C=1 CTL-X RECEIVED
                      * NOTE: LINE FEED MUST FOLLOW CARRIAGE RETURN FOR
                      * PROPER PUNCH DATA.
                      **************************************************
                      
FA40  860D            ZPDATA  LDA     #CR             ; LOAD CARRIAGE RETURN
FA42  8DA8                    BSR     SEND            ; SEND IT
FA44  860A                    LDA     #LF             ; LOAD LINE FEED
                      * FALL INTO PDATA1
                      
                      *************************************************
                      * [SWI FUNCTION 2]
                      * PDATA1 - OUTPUT STRING TILL EOT ($04)
                      * THIS ROUTINE PAUSES IF AN INPUT BYTE BECOMES
                      * AVAILABLE DURING OUTPUT TRANSMISSION UNTIL A
                      * SECOND IS RECEIVED.
                      * INPUT: X->STRING
                      * OUTPUT: STRING SENT TO OUTPUT CONSOLE DRIVER
                      * C=0 NO CTL-X, C=1 CTL-X RECEIVED
                      *************************************************
                      
FA46  8DA4            ZPDTLP  BSR     SEND            ; SEND CHARACTER TO DRIVER
FA48  A680            ZPDTA1  LDA     ,X+             ; LOAD NEXT CHARACTER
FA4A  8104                    CMPA    #EOT            ; ? EOT
FA4C  26F8                    BNE     ZPDTLP          ; LOOP IF NOT
                      * FALL INTO PAUSE CHECK FUNCTION
                      
                      ********************************************
                      * [SWI FUNCTION 12]
                      * PAUSE - RETURN TO TASK DISPATCHING AND CHECK
                      * FOR FREEZE CONDITION OR CTL-X BREAK
                      * THIS FUNCTION ENTERS THE TASK PAUSE HANDLER SO
                      * OPTIONALLY OTHER 6809 PROCESSES MAY GAIN CONTROL.
                      * UPON RETURN, CHECK FOR A 'FREEZE' CONDITION
                      * WITH A RESULTING WAIT LOOP, OR CONDITION CODE
                      * RETURN IF A CONTROL-X IS ENTERED FROM THE INPUT
                      * HANDLER.
                      * OUTPUT: C=1 IF CTL-X HAS ENTERED, C=0 OTHERWISE
                      ******************************************
                      
FA4E  8D1E            ZPAUSE  BSR     XQPAUS          ; RELEASE CONTROL AT EVERY LINE
FA50  8D06                    BSR     CHKABT          ; CHECK FOR FREEZE OR ABORT
FA52  1FA9                    TFR     CC,B            ; PREPARE TO REPLACE CC
FA54  E7E4                    STB     ,S              ; OVERLAY OLD ONE ON STACK
FA56  20E1                    BRA     ZOTCH3          ; RETURN FROM "SWI"
                      
                      * CHKABT - SCAN FOR INPUT PAUSE/ABORT DURING OUTPUT
                      * OUTPUT: C=0 OK, C=1 ABORT (CTL-X ISSUED)
                      * VOLATILE: U,X,D
FA58  8D18            CHKABT  BSR     XQCIDT          ; ATTEMPT INPUT
FA5A  2405                    BCC     CHKRTN          ; BRANCH NO TO RETURN
FA5C  8118                    CMPA    #CAN            ; ? CTL-X FOR ABORT
FA5E  2602                    BNE     CHKWT           ; BRANCH NO TO PAUSE
FA60  53              CHKSEC  COMB                    ; SET CARRY
FA61  39              CHKRTN  RTS                     ; RETURN TO CALLER WITH CC SET
FA62  8D0A            CHKWT   BSR     XQPAUS          ; PAUSE FOR A MOMENT
FA64  8D0C                    BSR     XQCIDT          ; ? KEY FOR START
FA66  24FA                    BCC     CHKWT           ; LOOP UNTIL RECEIVED
FA68  8118                    CMPA    #CAN            ; ? ABORT SIGNALED FROM WAIT
FA6A  27F4                    BEQ     CHKSEC          ; BRANCH YES
FA6C  4F                      CLRA                    ; SET C=0 FOR NO ABORT
FA6D  39                      RTS                     ; AND RETURN
                      
                      * SAVE MEMORY WITH JUMPS
FA6E  6E9D6678        XQPAUS  JMP   [VECTAB+XPAUSE,PCR] ; TO PAUSE ROUTINE
FA72  AD9D6662        XQCIDT  JSR   [VECTAB+XCIDTA,PCR] ; TO INPUT ROUTINE
FA76  847F                    ANDA  #$7F              ; STRIP PARITY
FA78  39                      RTS                     ; RETURN TO CALLER
                      
                      ********************************************
                      * NMI DEFAULT INTERRUPT HANDLER
                      * THE NMI HANDLER IS USED FOR TRACING INSTRUCTIONS.
                      * TRACE PRINTOUTS OCCUR ONLY AS LONG AS THE STACK
                      * TRACE LEVEL IS NOT BREACHED BY FALLING BELOW IT.
                      * TRACING CONTINUES UNTIL THE COUNT TURNS ZERO OR
                      * A CTL-X IS ENTERED FROM THE INPUT CONSOLE DEVICE.
                      *********************************************
                      
FA79  4F502D04        MSHOWP  FCB     'O,'P,'-,EOT    ; OPCODE PREP
                      
FA7D  8D42            NMIR    BSR     LDDP            ; LOAD PAGE AND VERIFY STACK
FA7F  0D8F                    TST     <MISFLG         ; ? THRU A BREAKPOINT
FA81  2634                    BNE     NMICON          ; BRANCH IF SO TO CONTINUE
FA83  0D90                    TST     <SWICNT         ; ? INHIBIT "SWI" DURING TRACE
FA85  2B29                    BMI     NMITRC          ; BRANCH YES
FA87  306C                    LEAX    12,S            ; OBTAIN USERS STACK POINTER
FA89  9CF8                    CMPX    <SLEVEL         ; ? TO TRACE HERE
FA8B  2523                    BLO     NMITRC          ; BRANCH IF TOO LOW TO DISPLAY
FA8D  308CE9                  LEAX    MSHOWP,PCR      ; LOAD OP PREP
FA90  3F                      SWI                     ; SEND TO CONSOLE
FA91  02                      FCB     PDATA1          ; FUNCTION
FA92  098E                    ROL     <DELIM          ; SAVE CARRY BIT
FA94  308D6601                LEAX    LASTOP,PCR      ; POINT TO LAST OP
FA98  3F                      SWI                     ; SEND OUT AS HEX
FA99  05                      FCB     OUT4HS          ; FUNCTION
FA9A  8D17                    BSR     REGPRS          ; FOLLOW MEMORY WITH REGISTERS
FA9C  2537                    BCS     ZBKCMD          ; BRANCH IF "CANCEL"
FA9E  068E                    ROR     <DELIM          ; RESTORE CARRY BIT
FAA0  2533                    BCS     ZBKCMD          ; BRANCH IF "CANCEL"
FAA2  9E91                    LDX     <TRACEC         ; LOAD TRACE COUNT
FAA4  272F                    BEQ     ZBKCMD          ; IF ZERO TO COMMAND HANDLER
FAA6  301F                    LEAX    -1,X            ; MINUS ONE
FAA8  9F91                    STX     <TRACEC         ; REFRESH
FAAA  2729                    BEQ     ZBKCMD          ; STOP TRACE WHEN ZERO
FAAC  8DAA                    BSR     CHKABT          ; ? ABORT THE TRACE
FAAE  2525                    BCS     ZBKCMD          ; BRANCH YES TO COMMAND HANDLER
FAB0  1603F7          NMITRC  LBRA    CTRCE3          ; NO, TRACE ANOTHER INSTRUCTION
                      
FAB3  1701B9          REGPRS  LBSR    REGPRT          ; PRINT REGISTERS AS FROM COMMAND
FAB6  39                      RTS                     ; RETURN TO CALLER
                      
                      * JUST EXECUTED THRU A BRKPNT. NOW CONTINUE NORMALLY
                      
FAB7  0F8F            NMICON  CLR     <MISFLG        ; CLEAR THRU FLAG
FAB9  1702EB                  LBSR    ARMBK2         ; ARM BREAKPOINTS
FABC  3B              RTI     RTI                    ; AND CONTINUE USERS PROGRAM
                      
                      * LDDP - SETUP DIRECT PAGE REGISTER, VERIFY STACK.
                      * AN INVALID STACK CAUSES A RETURN TO THE COMMAND
                      * HANDLER.
                      * INPUT: FULLY STACKED REGISTERS FROM AN INTERRUPT
                      * OUTPUT: DPR LOADED TO WORK PAGE
                      
FABD  3F072004        ERRMSG  FCB     '?,BELL,$20,EOT ; ERROR RESPONSE
                      
FAC1  E68D65D8        LDDP    LDB     BASEPG,PCR      ; LOAD DIRECT PAGE HIGH BYTE
FAC5  1F9B                    TFR     B,DP            ; SETUP DIRECT PAGE REGISTER
FAC7  A163                    CMPA    3,S             ; ? IS STACK VALID
FAC9  2725                    BEQ     RTS             ; YES, RETURN
FACB  10DE97                  LDS     <RSTACK         ; RESET TO INITIAL STACK POINTER
FACE  308CEC          ERROR   LEAX    ERRMSG,PCR      ; LOAD ERROR REPORT
FAD1  3F                      SWI                     ; SEND OUT BEFORE REGISTERS
FAD2  03                      FCB     PDATA           ; ON NEXT LINE
                      * FALL INTO BREAKPOINT HANDLER
                      
                      **********************************************
                      * [SWI FUNCTION 10]
                      * BREAKPOINT PROGRAM FUNCTION
                      * PRINT REGISTERS AND GO TO COMMAND HANLER
                      ***********************************************
                      
FAD3  8DDE            ZBKPNT  BSR     REGPRS          ; PRINT OUT REGISTERS
FAD5  16FE21          ZBKCMD  LBRA    CMDNEP          ; NOW ENTER COMMAND HANDLER
                      
                      ********************************************
                      * IRQ, RESERVED, SWI2 AND SWI3 INTERRUPT HANDLERS
                      * THE DEFAULT HANDLING IS TO CAUSE A BREAKPOINT.
                      ********************************************
FAD8                  SWI2R   EQU     *               ; SWI2 ENTRY
FAD8                  SWI3R   EQU     *               ; SWI3 ENTRY
FAD8                  IRQR    EQU     *               ; IRQ ENTRY
FAD8  8DE7            RSRVDR  BSR     LDDP            ; SET BASE PAGE, VALIDATE STACK
FADA  20F7                    BRA     ZBKPNT          ; FORCE A BREAKPOINT
                      
                      ******************************************
                      * FIRQ HANDLER
                      * JUST RETURN FOR THE FIRQ INTERRUPT
                      ******************************************
FABC                  FIRQR   EQU     RTI             ; IMMEDIATE RETURN
                      
                      **************************************************
                      * DEFAULT I/O DRIVERS
                      **************************************************
                      * CIDTA - RETURN CONSOLE INPUT CHARACTER
                      * OUTPUT: C=0 IF NO DATA READY, C=1 A=CHARACTER
                      * U VOLATILE
                      
FADC  DEF0            CIDTA   LDU     <VECTAB+XACIA   ; LOAD ACIA ADDRESS
FADE  A6C4                    LDA     ,U              ; LOAD STATUS REGISTER
FAE0  44                      LSRA                    ; TEST RECEIVER REGISTER FLAG
FAE1  2402                    BCC     CIRTN           ; RETURN IF NOTHING
FAE3  A641                    LDA     1,U             ; LOAD DATA BYTE
FAE5  39              CIRTN   RTS                     ; RETURN TO CALLER
                      
                      * CION - INPUT CONSOLE INITIALIZATION
                      * COON - OUTPUT CONSOLE INITIALIZATION
                      * A,X VOLATILE
FAE6                  CION   EQU      *
FAE6  8613            COON   LDA      #$13            ; RESET ACIA CODE
FAE8  9EF0                   LDX      <VECTAB+XACIA   ; LOAD ACIA ADDRESS
FAEA  A784                   STA      ,X              ; STORE INTO STATUS REGISTER
FAEC  8615                   LDA      #$15            ; SET CONTROL
FAEE  A784                   STA      ,X              ; REGISTER UP
FAF0  39              RTS    RTS                      ; RETURN TO CALLER
                      
                      * THE FOLLOWING HAVE NO DUTIES TO PERFORM
FAF0                  CIOFF EQU       RTS             ; CONSOLE INPUT OFF
FAF0                  COOFF EQU       RTS             ; CONSOLE OUTPUT OFF
                      
                      * CODTA - OUTPUT CHARACTER TO CONSOLE DEVICE
                      * INPUT: A=CHARACTER TO SEND
                      * OUTPUT: CHAR SENT TO TERMINAL WITH PROPER PADDING
                      * ALL REGISTERS TRANSPARENT
                      
FAF1  3447            CODTA   PSHS    U,D,CC          ; SAVE REGISTERS,WORK BYTE
FAF3  DEF0                    LDU     <VECTAB+XACIA   ; ADDRESS ACIA
FAF5  8D1B                    BSR     CODTAO          ; CALL OUTPUT CHAR SUBROUTINE
FAF7  8110                    CMPA    #DLE            ; ? DATA LINE ESCAPE
FAF9  2712                    BEQ     CODTRT          ; YES, RETURN
FAFB  D6F2                    LDB     <VECTAB+XPAD    ; DEFAULT TO CHAR PAD COUNT
FAFD  810D                    CMPA    #CR             ; ? CR
FAFF  2602                    BNE     CODTPD          ; BRANCH NO
FB01  D6F3                    LDB     <VECTAB+XPAD+1  ; LOAD NEW LINE PAD COUNT
FB03  4F              CODTPD  CLRA                    ; CREATE NULL
FB04  E7E4                    STB     ,S              ; SAVE COUNT
FB06  8C                      FCB     SKIP2           ; ENTER LOOP
FB07  8D09            CODTLP  BSR     CODTAO          ; SEND NULL
FB09  6AE4                    DEC     ,S              ; ? FINISHED
FB0B  2AFA                    BPL     CODTLP          ; NO, CONTINUE WITH MORE
FB0D  35C7            CODTRT  PULS    PC,U,D,CC       ; RESTORE REGISTERS AND RETURN
                      
FB0F  17FF5C          CODTAD  LBSR    XQPAUS          ; TEMPORARY GIVE UP CONTROL
FB12  E6C4            CODTAO  LDB     ,U              ; LOAD ACIA CONTROL REGISTER
FB14  C502                    BITB    #$02            ; ? TX REGISTER CLEAR >LSAB FIXME
FB16  27F7                    BEQ     CODTAD          ; RELEASE CONTROL IF NOT
FB18  A741                    STA     1,U             ; STORE INTO DATA REGISTER
FB1A  39                      RTS                     ; RETURN TO CALLER
                      *E
                      
                      * BSON - TURN ON READ/VERIFY/PUNCH MECHANISM
                      * A IS VOLATILE
                      
FB1B  8611            BSON    LDA     #$11            ; SET READ CODE
FB1D  6D66                    TST     6,S             ; ? READ OR VERIFY
FB1F  2601                    BNE     BSON2           ; BRANCH YES
FB21  4C                      INCA                    ; SET TO WRITE
FB22  3F              BSON2   SWI                     ; PERFORM OUTPUT
FB23  01                      FCB     OUTCH           ; FUNCTION
FB24  0C8F                    INC     <MISFLG         ; SET LOAD IN PROGRESS FLAG
FB26  39                      RTS                     ; RETURN TO CALLER
                      
                      * BSOFF - TURN OFF READ/VERIFY/PUNCH MECHANISM
                      * A,X VOLATILE
                      
FB27  8614            BSOFF   LDA     #$14            ; TO DC4 - STOP
FB29  3F                      SWI                     ; SEND OUT
FB2A  01                      FCB     OUTCH           ; FUNCTION
FB2B  4A                      DECA                    ; CHANGE TO DC3 (X-OFF)
FB2C  3F                      SWI                     ; SEND OUT
FB2D  01                      FCB     OUTCH           ; FUNCTION
FB2E  0A8F                    DEC     <MISFLG         ; CLEAR LOAD IN PROGRESS FLAG
FB30  8E61A8                  LDX     #25000          ; DELAY 1 SECOND (2MHZ CLOCK)
FB33  301F            BSOFLP  LEAX    -1,X            ; COUNT DOWN
FB35  26FC                    BNE     BSOFLP          ; LOOP TILL DONE
FB37  39                      RTS                     ; RETURN TO CALLER
                      
                      * BSDTA - READ/VERIFY/PUNCH HANDLER
                      * INPUT: S+6=CODE BYTE, VERIFY(-1),PUNCH(0),LOAD(1)
                      * S+4=START ADDRESS
                      * S+2=STOP ADDRESS
                      * S+0=RETURN ADDRESS
                      * OUTPUT: Z=1 NORMAL COMPLETION, Z=0 INVALID LOAD/VER
                      * REGISTERS ARE VOLATILE
FB38  EE62            BSDTA   LDU     2,S             ; U=TO ADDRESS OR OFFSET
FB3A  6D66                    TST     6,S             ; ? PUNCH
FB3C  2754                    BEQ     BSDPUN          ; BRANCH YES
                      
                      * DURING READ/VERIFY: S+2=MSB ADDRESS SAVE BYTE
                      * S+1=BYTE COUNTER
                      * S+0=CHECKSUM
                      * U HOLDS OFFSET
FB3E  327D                    LEAS    -3,S            ; ROOM FOR WORK/COUNTER/CHECKSUM
FB40  3F              BSDLD1  SWI                     ; GET NEXT CHARACTER
FB41  00                      FCB     INCHNP          ; FUNCTION
FB42  8153            BSDLD2  CMPA    #'S             ; ? START OF S1/S9
FB44  26FA                    BNE     BSDLD1          ; BRANCH NOT
FB46  3F                      SWI                     ; GET NEXT CHARACTER
FB47  00                      FCB     INCHNP          ; FUNCTION
FB48  8139                    CMPA    #'9             ; ? HAVE S9
FB4A  2722                    BEQ     BSDSRT          ; YES, RETURN GOOD CODE
FB4C  8131                    CMPA    #'1             ; ? HAVE NEW RECORD
FB4E  26F2                    BNE     BSDLD2          ; BRANCH IF NOT
FB50  6FE4                    CLR     ,S              ; CLEAR CHECKSUM
FB52  8D21                    BSR     BYTE            ; OBTAIN BYTE COUNT
FB54  E761                    STB     1,S             ; SAVE FOR DECREMENT
                      
                      * READ ADDRESS
FB56  8D1D                    BSR     BYTE            ; OBTAIN HIGH VALUE
FB58  E762                    STB     2,S             ; SAVE IT
FB5A  8D19                    BSR     BYTE            ; OBTAIN LOW VALUE
FB5C  A662                    LDA     2,S             ; MAKE D=VALUE
FB5E  31CB                    LEAY    D,U             ; Y=ADDRESS+OFFSET
                      * STORE TEXT
FB60  8D13            BSDNXT  BSR     BYTE            ; NEXT BYTE
FB62  270C                    BEQ     BSDEOL          ; BRANCH IF CHECKSUM
FB64  6D69                    TST     9,S             ; ? VERIFY ONLY
FB66  2B02                    BMI     BSDCMP          ; YES, ONLY COMPARE
FB68  E7A4                    STB     ,Y              ; STORE INTO MEMORY
FB6A  E1A0            BSDCMP  CMPB    ,Y+             ; ? VALID RAM
FB6C  27F2                    BEQ     BSDNXT          ; YES, CONTINUE READING
FB6E  3592            BSDSRT  PULS    PC,X,A          ; RETURN WITH Z SET PROPER
FB70  4C              BSDEOL  INCA                    ; ? VALID CHECKSUM
FB71  27CD                    BEQ     BSDLD1          ; BRANCH YES
FB73  20F9                    BRA     BSDSRT          ; RETURN Z=0 INVALID
                      
                      * BYTE BUILDS 8 BIT VALUE FROM TWO HEX DIGITS IN
FB75  8D12            BYTE    BSR     BYTHEX         ; OBTAIN FIRST HEX
FB77  C610                    LDB     #16            ; PREPARE SHIFT
FB79  3D                      MUL                    ; OVER TO A
FB7A  8D0D                    BSR     BYTHEX         ; OBTAIN SECOND HEX
FB7C  3404                    PSHS    B              ; SAVE HIGH HEX
FB7E  ABE0                    ADDA    ,S+            ; COMBINE BOTH SIDES
FB80  1F89                    TFR     A,B            ; SEND BACK IN B
FB82  AB62                    ADDA    2,S            ; COMPUTE NEW CHECKSUM
FB84  A762                    STA     2,S            ; STORE BACK
FB86  6A63                    DEC     3,S            ; DECREMENT BYTE COUNT
FB88  39              BYTRTS  RTS                    ; RETURN TO CALLER
                      
FB89  3F              BYTHEX  SWI                    ; GET NEXT HEX
FB8A  00                      FCB     INCHNP         ; CHARACTER
FB8B  1701D4                  LBSR    CNVHEX         ; CONVERT TO HEX
FB8E  27F8                    BEQ     BYTRTS         ; RETURN IF VALID HEX
FB90  35F2                    PULS    PC,U,Y,X,A     ; RETURN TO CALLER WITH Z=0
                      
                      * PUNCH STACK USE: S+8=TO ADDRESS
                      *                  S+6=RETURN ADDRESS
                      *                  S+4=SAVED PADDING VALUES
                      *                  S+2 FROM ADDRESS
                      *                  S+1=FRAME COUNT/CHECKSUM
                      *                  S+0=BYTE COUNT
                      
FB92  DEF2            BSDPUN  LDU     <VECTAB+XPAD    ; LOAD PADDING VALUES
FB94  AE64                    LDX     4,S             ; X=FROM ADDRESS
FB96  3456                    PSHS    U,X,D           ; CREATE STACK WORK AREA
FB98  CC0018                  LDD     #24             ; SET A=0, B=24
FB9B  D7F2                    STB     <VECTAB+XPAD    ; SETUP 24 CHARACTER PADS
FB9D  3F                      SWI                     ; SEND NULLS OUT
FB9E  01                      FCB     OUTCH           ; FUNCTION
FB9F  C604                    LDB     #4              ; SETUP NEW LINE PAD TO 4
FBA1  DDF2                    STD     <VECTAB+XPAD    ; SETUP PUNCH PADDING
                      * CALCULATE SIZE
FBA3  EC68            BSPGO   LDD     8,S             ; LOAD TO
FBA5  A362                    SUBD    2,S             ; MINUS FROM=LENGTH
FBA7  10830018                CMPD    #24             ; ? MORE THAN 23
FBAB  2502                    BLO     BSPOK           ; NO, OK
FBAD  C617                    LDB     #23             ; FORCE TO 23 MAX
FBAF  5C              BSPOK   INCB                    ; PREPARE COUNTER
FBB0  E7E4                    STB     ,S              ; STORE BYTE COUNT
FBB2  CB03                    ADDB    #3              ; ADJUST TO FRAME COUNT
FBB4  E761                    STB     1,S             ; SAVE
                      
                      *PUNCH CR,LF,NULS,S,1
FBB6  308C33                 LEAX     <BSPSTR,PCR     ; LOAD START RECORD HEADER
FBB9  3F                     SWI                      ; SEND OUT
FBBA  03                     FCB      PDATA           ; FUNCTION
                      * SEND FRAME COUNT
FBBB  5F                     CLRB                     ; INITIALIZE CHECKSUM
FBBC  3061                   LEAX     1,S             ; POINT TO FRAME COUNT AND ADDR
FBBE  8D27                   BSR      BSPUN2          ; SEND FRAME COUNT
                      *DATA ADDRESS
FBC0  8D25                  BSR       BSPUN2          ; SEND ADDRESS HI
FBC2  8D23                  BSR       BSPUN2          ; SEND ADDRESS LOW
                      *PUNCH DATA
FBC4  AE62                   LDX      2,S             ; LOAD START DATA ADDRESS
FBC6  8D1F            BSPMRE BSR      BSPUN2          ; SEND OUT NEXT BYTE
FBC8  6AE4                   DEC      ,S              ; ? FINAL BYTE
FBCA  26FA                   BNE      BSPMRE          ; LOOP IF NOT DONE
FBCC  AF62                   STX      2,S             ; UPDATE FROM ADDRESS VALUE
                      *PUNCH CHECKSUM
FBCE  53                     COMB                     ; COMPLEMENT
FBCF  E761                   STB      1,S             ; STORE FOR SENDOUT
FBD1  3061                   LEAX     1,S             ; POINT TO IT
FBD3  8D14                   BSR      BSPUNC          ; SEND OUT AS HEX
FBD5  AE68                   LDX      8,S             ; LOAD TOP ADDRESS
FBD7  AC62                   CMPX     2,S             ; ? DONE
FBD9  24C8                   BHS      BSPGO           ; BRANCH NOT
FBDB  308C11                 LEAX     <BSPEOF,PCR     ; PREPARE END OF FILE
FBDE  3F                     SWI                      ; SEND OUT STRING
FBDF  03                     FCB      PDATA           ; FUNCTION
FBE0  EC64                   LDD      4,S             ; RECOVER PAD COUNTS
FBE2  DDF2                   STD      <VECTAB+XPAD    ; RESTORE
FBE4  4F                     CLRA                     ; SET Z=1 FOR OK RETURN
FBE5  35D6                   PULS     PC,U,X,D        ; RETURN WITH OK CODE
FBE7  EB84            BSPUN2 ADDB     ,X              ; ADD TO CHECKSUM
FBE9  16FDED          BSPUNC LBRA     ZOUT2H          ; SEND OUT AS HEX AND RETURN
                      
FBEC  530104          BSPSTR FCB      'S,1,EOT        ; CR,LF,NULLS,S,1
FBEF  53393033303030304643 BSPEOF FCC      /S9030000FC/         ; EOF STRING
FBF9  0D0A04                 FCB      CR,LF,EOT
                      
                      * HSDTA - HIGH SPEED PRINT MEMORY
                      * INPUT: S+4=START ADDRESS
                      * S+2=STOP ADDRESS
                      * S+0=RETURN ADDRESS
                      * X,D VOLATILE
                      
                      * SEND TITLE
                      
FBFC  3F              HSDTA   SWI                     ; SEND NEW LINE
FBFD  06                      FCB     PCRLF           ; FUNCTION
FBFE  C606                    LDB     #6              ; PREPARE 6 SPACES
FC00  3F              HSBLNK  SWI                     ; SEND BLANK
FC01  07                      FCB     SPACE           ; FUNCTION
FC02  5A                      DECB                    ; COUNT DOWN
FC03  26FB                    BNE     HSBLNK          ; LOOP IF MORE
FC05  5F                      CLRB                    ; SETUP BYTE COUNT
FC06  1F98            HSHTTL  TFR     B,A             ; PREPARE FOR CONVERT
FC08  17FDDB                  LBSR    ZOUTHX          ; CONVERT TO A HEX DIGIT
FC0B  3F                      SWI                     ; SEND BLANK
FC0C  07                      FCB     SPACE           ; FUNCTION
FC0D  3F                      SWI                     ; SEND ANOTHER
FC0E  07                      FCB     SPACE           ; BLANK
FC0F  5C                      INCB                    ; UP ANOTHER
FC10  C110                    CMPB    #$10            ; ? PAST 'F'
FC12  25F2                    BLO     HSHTTL          ; LOOP UNTIL SO
FC14  3F              HSHLNE  SWI                     ; TO NEXT LINE
FC15  06                      FCB     PCRLF           ; FUNCTION
FC16  252F                    BCS     HSDRTN          ; RETURN IF USER ENTERED CTL-X
FC18  3064                    LEAX    4,S             ; POINT AT ADDRESS TO CONVERT
FC1A  3F                      SWI                     ; PRINT OUT ADDRESS
FC1B  05                      FCB     OUT4HS          ; FUNCTION
FC1C  AE64                    LDX     4,S             ; LOAD ADDRESS PROPER
FC1E  C610                    LDB     #16             ; NEXT SIXTEEN
FC20  3F              HSHNXT  SWI                     ; CONVERT BYTE TO HEX AND SEND
FC21  04                      FCB     OUT2HS          ; FUNCTION
FC22  5A                      DECB                    ; COUNT DOWN
FC23  26FB                    BNE     HSHNXT          ; LOOP IF NOT SIXTEENTH
FC25  3F                      SWI                     ; SEND BLANK
FC26  07                      FCB     SPACE           ; FUNCTION
FC27  AE64                    LDX     4,S             ; RELOAD FROM ADDRESS
FC29  C610                    LDB     #16             ; COUNT
FC2B  A680            HSHCHR  LDA     ,X+             ; NEXT BYTE
FC2D  2B04                    BMI     HSHDOT          ; TOO LARGE, TO A DOT
FC2F  8120                    CMPA    #'              ; ? LOWER THAN A BLANK
FC31  2402                    BHS     HSHCOK          ; NO, BRANCH OK
FC33  862E            HSHDOT  LDA     #'.             ; CONVERT INVALID TO A BLANK
FC35  3F              HSHCOK  SWI                     ; SEND CHARACTER
FC36  01                      FCB     OUTCH           ; FUNCTION
FC37  5A                      DECB                    ; ? DONE
FC38  26F1                    BNE     HSHCHR          ; BRANCH NO
FC3A  AC62                    CMPX    2,S             ; ? PAST LAST ADDRESS
FC3C  2409                    BHS     HSDRTN          ; QUIT IF SO
FC3E  AF64                    STX     4,S             ; UPDATE FROM ADDRESS
FC40  A665                    LDA     5,S             ; LOAD LOW BYTE ADDRESS
FC42  48                      ASLA                    ; ? TO SECTION BOUNDARY
FC43  26CF                    BNE     HSHLNE          ; BRANCH IF NOT
FC45  20B5                    BRA     HSDTA           ; BRANCH IF SO
FC47  3F              HSDRTN  SWI                     ; SEND NEW LINE
FC48  06                      FCB     PCRLF           ; FUNCTION
FC49  39                      RTS                     ; RETURN TO CALLER
                      *F
                      
                      ***********************************************
                      *     A S S I S T 0 9    C O M M A N D S
                      ***********************************************
                      
                      *************REGISTERS - DISPLAY AND CHANGE REGISTERS
FC4A  8D23            CREG    BSR     REGPRT          ; PRINT REGISTERS
FC4C  4C                      INCA                    ; SET FOR CHANGE FUNCTION
FC4D  8D21                    BSR     REGCHG          ; GO CHANGE, DISPLAY REGISTERS
FC4F  39                      RTS                     ; RETURN TO COMMAND PROCESSOR
                      
                      ********************************************
                      * REGPRT - PRINT/CHANGE REGISTERS SUBROUTINE
                      * WILL ABORT TO 'CMDBAD' IF OVERFLOW DETECTED DURING
                      * A CHANGE OPERATION. CHANGE DISPLAYS REGISTERS WHEN
                      * DONE.
                      
                      * REGISTER MASK LIST CONSISTS OF:
                      * A) CHARACTERS DENOTING REGISTER
                      * B) ZERO FOR ONE BYTE, -1 FOR TWO
                      * C) OFFSET ON STACK TO REGISTER POSITION
                      * INPUT: SP+4=STACKED REGISTERS
                      * A=0 PRINT, A#0 PRINT AND CHANGE
                      * OUTPUT: (ONLY FOR REGISTER DISPLAY)
                      * C=1 CONTROL-X ENTERED, C=0 OTHERWISE
                      * VOLATILE: D,X (CHANGE)
                      * B,X (DISPLAY)
                      *******************************************
                      
FC50  5043FF13        REGMSK  FCB     'P,'C,-1,19     ; PC REG
FC54  41000A                  FCB     'A,0,10         ; A REG
FC57  42000B                  FCB     'B,0,11         ; B REG
FC5A  58FF0D                  FCB     'X,-1,13        ; X REG
FC5D  59FF0F                  FCB     'Y,-1,15        ; Y REG
FC60  55FF11                  FCB     'U,-1,17        ; U REG
FC63  53FF01                  FCB     'S,-1,1         ; S REG
FC66  43430009                FCB     'C,'C,0,9       ; CC REG
FC6A  4450000C                FCB     'D,'P,0,12      ; DP REG
FC6E  00                      FCB     0               ; END OF LIST
                      
FC6F  4F              REGPRT  CLRA                    ; SETUP PRINT ONLY FLAG
FC70  30E810          REGCHG  LEAX    4+12,S          ; READY STACK VALUE
FC73  3432                    PSHS    Y,X,A           ; SAVE ON STACK WITH OPTION
FC75  318CD8                  LEAY    REGMSK,PCR      ; LOAD REGISTER MASK
FC78  ECA0            REGP1   LDD     ,Y+             ; LOAD NEXT CHAR OR <=0
FC7A  4D                      TSTA                    ; ? END OF CHARACTERS
FC7B  2F04                    BLE     REGP2           ; BRANCH NOT CHARACTER
FC7D  3F                      SWI                     ; SEND TO CONSOLE
FC7E  01                      FCB     OUTCH           ; FUNCTION BYTE
FC7F  20F7                    BRA     REGP1           ; CHECK NEXT
FC81  862D            REGP2   LDA     #'-             ; READY '-'
FC83  3F                      SWI                     ; SEND OUT
FC84  01                      FCB     OUTCH           ; WITH OUTCH
FC85  30E5                    LEAX    B,S             ; X->REGISTER TO PRINT
FC87  6DE4                    TST     ,S              ; ? CHANGE OPTION
FC89  2612                    BNE     REGCNG          ; BRANCH YES
FC8B  6D3F                    TST     -1,Y            ; ? ONE OR TWO BYTES
FC8D  2703                    BEQ     REGP3           ; BRANCH ZERO MEANS ONE
FC8F  3F                      SWI                     ; PERFORM WORD HEX
FC90  05                      FCB     OUT4HS          ; FUNCTION
FC91  8C                      FCB     SKIP2           ; SKIP BYTE PRINT
FC92  3F              REGP3   SWI                     ; PERFORM BYTE HEX
FC93  04                      FCB     OUT2HS          ; FUNCTION
FC94  ECA0            REG4    LDD     ,Y+             ; TO FRONT OF NEXT ENTRY
FC96  5D                      TSTB                    ; ? END OF ENTRIES
FC97  26DF                    BNE     REGP1           ; LOOP IF MORE
FC99  3F                      SWI                     ; FORCE NEW LINE
FC9A  06                      FCB     PCRLF           ; FUNCTION
FC9B  35B2            REGRTN  PULS    PC,Y,X,A        ; RESTORE STACK AND RETURN
                      
FC9D  8D40            REGCNG  BSR     BLDNNB          ; INPUT BINARY NUMBER
FC9F  2710                    BEQ     REGNXC          ; IF CHANGE THEN JUMP
FCA1  810D                    CMPA    #CR             ; ? NO MORE DESIRED
FCA3  271E                    BEQ     REGAGN          ; BRANCH NOPE
FCA5  E63F                    LDB     -1,Y            ; LOAD SIZE FLAG
FCA7  5A                      DECB                    ; MINUS ONE
FCA8  50                      NEGB                    ; MAKE POSITIVE
FCA9  58                      ASLB                    ; TIMES TWO (=2 OR =4)
FCAA  3F              REGSKP  SWI                     ; PERFORM SPACES
FCAB  07                      FCB     SPACE           ; FUNCTION
FCAC  5A                      DECB
FCAD  26FB                    BNE     REGSKP          ; LOOP IF MORE
FCAF  20E3                    BRA     REG4            ; CONTINUE WITH NEXT REGISTER
FCB1  A7E4            REGNXC  STA     ,S              ; SAVE DELIMITER IN OPTION
                      *                               ; (ALWAYS > 0)
FCB3  DC9B                    LDD     <NUMBER         ; OBTAIN BINARY RESULT
FCB5  6D3F                    TST     -1,Y            ; ? TWO BYTES WORTH
FCB7  2602                    BNE     REGTWO          ; BRANCH YES
FCB9  A682                    LDA     ,-X             ; SETUP FOR TWO
FCBB  ED84            REGTWO  STD     ,X              ; STORE IN NEW VALUE
FCBD  A6E4                    LDA     ,S              ; RECOVER DELIMITER
FCBF  810D                    CMPA    #CR             ; ? END OF CHANGES
FCC1  26D1                    BNE     REG4            ; NO, KEEP ON TRUCK'N
                      * MOVE STACKED DATA TO NEW STACK IN CASE STACK
                      * POINTER HAS CHANGED
FCC3  308D638A        REGAGN  LEAX    TSTACK,PCR      ; LOAD TEMP AREA
FCC7  C615                    LDB     #21             ; LOAD COUNT
FCC9  3502            REGTF1  PULS    A               ; NEXT BYTE
FCCB  A780                    STA     ,X+             ; STORE INTO TEMP
FCCD  5A                      DECB                    ; COUNT DOWN
FCCE  26F9                    BNE     REGTF1          ; LOOP IF MORE
FCD0  10EE88EC                LDS     -20,X           ; LOAD NEW STACK POINTER
FCD4  C615                    LDB     #21             ; LOAD COUNT AGAIN
FCD6  A682            REGTF2 LDA      ,-X             ; NEXT TO STORE
FCD8  3402                   PSHS     A               ; BACK ONTO NEW STACK
FCDA  5A                     DECB                     ; COUNT DOWN
FCDB  26F9                   BNE      REGTF2          ; LOOP IF MORE
FCDD  20BC                   BRA      REGRTN          ; GO RESTART COMMAND
                      
                      *********************************************
                      * BLDNUM - BUILDS BINARY VALUE FROM INPUT HEX
                      * THE ACTIVE EXPRESSION HANDLER IS USED.
                      * INPUT: S=RETURN ADDRESS
                      * OUTPUT: A=DELIMITER WHICH TERMINATED VALUE
                      * (IF DELM NOT ZERO)
                      * "NUMBER"=WORD BINARY RESULT
                      * Z=1 IF INPUT RECEIVED, Z=0 IF NO HEX RECEIVED
                      * REGISTERS ARE TRANSPARENT
                      **********************************************
                      * EXECUTE SINGLE OR EXTENDED ROM EXPRESSION HANDLER
                      *
                      * THE FLAG "DELIM" IS USED AS FOLLOWS:
                      * DELIM=0 NO LEADING BLANKS, NO FORCED TERMINATOR
                      * DELIM=CHR ACCEPT LEADING 'CHR'S, FORCED TERMINATOR
FCDF  4F              BLDNNB  CLRA                    ; NO DYNAMIC DELIMITER
FCE0  8C                      FCB     SKIP2           ; SKIP NEXT INSTRUCTION
                      * BUILD WITH LEADING BLANKS
FCE1  8620            BLDNUM  LDA     #'              ; ALLOW LEADING BLANKS
FCE3  978E                    STA     <DELIM          ; STORE AS DELIMITER
FCE5  6E9D6403                JMP     [VECTAB+XEXPAN,PCR]   ; TO EXP ANALYZER
                      * THIS IS THE DEFAULT SINGLE ROM ANALYZER. WE ACCEPT:
                      * 1) HEX INPUT
                      * 2) 'M' FOR LAST MEMORY EXAMINE ADDRESS
                      * 3) 'P' FOR PROGRAM COUNTER ADDRESS
                      * 4) 'W' FOR WINDOW VALUE
                      * 5) '@' FOR INDIRECT VALUE
                      
FCE9  3414            EXP1    PSHS    X,B             ; SAVE REGISTERS
FCEB  8D5C            EXPDLM  BSR     BLDHXI          ; CLEAR NUMBER, CHECK FIRST CHAR
FCED  2718                    BEQ     EXP2            ; IF HEX DIGIT CONTINUE BUILDING
                      * SKIP BLANKS IF DESIRED
FCEF  918E                    CMPA    <DELIM          ; ? CORRECT DELIMITER
FCF1  27F8                    BEQ     EXPDLM          ; YES, IGNORE IT
                      * TEST FOR M OR P
FCF3  9E9E                    LDX     <ADDR           ; DEFAULT FOR 'M'
FCF5  814D                    CMPA    #'M             ; ? MEMORY EXAMINE ADDR WANTED
FCF7  2716                    BEQ     EXPTDL          ; BRANCH IF SO
FCF9  9E93                    LDX     <PCNTER         ; DEFAULT FOR 'P'
FCFB  8150                    CMPA    #'P             ; ? LAST PROGRAM COUNTER WANTED
FCFD  2710                    BEQ     EXPTDL          ; BRANCH IF SO
FCFF  9EA0                    LDX     <WINDOW         ; DEFAULT TO WINDOW
FD01  8157                    CMPA    #'W             ; ? WINDOW WANTED
FD03  270A                    BEQ     EXPTDL
                      
FD05  3594            EXPRTN  PULS    PC,X,B          ; RETURN AND RESTORE REGISTERS
                      * GOT HEX, NOW CONTINUE BUILDING
FD07  8D44            EXP2    BSR     BLDHEX          ; COMPUTE NEXT DIGIT
FD09  27FC                    BEQ     EXP2            ; CONTINUE IF MORE
FD0B  200A                    BRA     EXPCDL          ; SEARCH FOR +/-
                      * STORE VALUE AND CHECK IF NEED DELIMITER
FD0D  AE84            EXPTDI  LDX     ,X              ; INDIRECTION DESIRED
FD0F  9F9B            EXPTDL  STX     <NUMBER         ; STORE RESULT
FD11  0D8E                    TST     <DELIM          ; ? TO FORCE A DELIMITER
FD13  27F0                    BEQ     EXPRTN          ; RETURN IF NOT WITH VALUE
FD15  8D62                    BSR     READ            ; OBTAIN NEXT CHARACTER
                      * TEST FOR + OR -
FD17  9E9B            EXPCDL  LDX     <NUMBER         ; LOAD LAST VALUE
FD19  812B                    CMPA    #'+             ; ? ADD OPERATOR
FD1B  260E                    BNE     EXPCHM          ; BRANCH NOT
FD1D  8D23                    BSR     EXPTRM          ; COMPUTE NEXT TERM
FD1F  3402                    PSHS    A               ; SAVE DELIMITER
FD21  DC9B                    LDD     <NUMBER         ; LOAD NEW TERM
FD23  308B            EXPADD  LEAX    D,X             ; ADD TO X
FD25  9F9B                    STX     <NUMBER         ; STORE AS NEW RESULT
FD27  3502                    PULS    A               ; RESTORE DELIMITER
FD29  20EC                    BRA     EXPCDL          ; NOW TEST IT
FD2B  812D            EXPCHM  CMPA    #'-             ; ? SUBTRACT OPERATOR
FD2D  2707                    BEQ     EXPSUB          ; BRANCH IF SO
FD2F  8140                    CMPA    #'@             ; ? INDIRECTION DESIRED
FD31  27DA                    BEQ     EXPTDI          ; BRANCH IF SO
FD33  5F                      CLRB                    ; SET DELIMITER RETURN
FD34  20CF                    BRA     EXPRTN          ; AND RETURN TO CALLER
FD36  8D0A            EXPSUB  BSR     EXPTRM          ; OBTAIN NEXT TERM
FD38  3402                    PSHS    A               ; SAVE DELIMITER
FD3A  DC9B                    LDD     <NUMBER         ; LOAD UP NEXT TERM
FD3C  40                      NEGA                    ; NEGATE A
FD3D  50                      NEGB                    ; NEGATE B
FD3E  8200                    SBCA    #0              ; CORRECT FOR A
FD40  20E1                    BRA     EXPADD          ; GO ADD TO EXPRESSION
                      * COMPUTE NEXT EXPRESSION TERM
                      * OUTPUT: X=OLD VALUE
                      * 'NUMBER'=NEXT TERM
FD42  8D9D            EXPTRM  BSR     BLDNUM          ; OBTAIN NEXT VALUE
FD44  2732                    BEQ     CNVRTS          ; RETURN IF VALID NUMBER
FD46  16FC13          BLDBAD  LBRA    CMDBAD          ; ABORT COMMAND IF INVALID
                      
                      *********************************************
                      * BUILD BINARY VALUE USING INPUT CHARACTERS.
                      * INPUT: A=ASCII HEX VALUE OR DELIMITER
                      * SP+0=RETURN ADDRESS
                      * SP+2=16 BIT RESULT AREA
                      * OUTPUT: Z=1 A=BINARY VALUE
                      * Z=0 IF INVALID HEX CHARACTER (A UNCHANGED)
                      * VOLATILE: D
                      ****************************************
FD49  0F9B            BLDHXI  CLR     <NUMBER         ; CLEAR NUMBER
FD4B  0F9C                    CLR     <NUMBER+1       ; CLEAR NUMBER
FD4D  8D2A            BLDHEX  BSR     READ            ; GET INPUT CHARACTER
FD4F  8D11            BLDHXC  BSR     CNVHEX          ; CONVERT AND TEST CHARACTER
FD51  2625                    BNE     CNVRTS          ; RETURN IF NOT A NUMBER
FD53  C610                    LDB     #16             ; PREPARE SHIFT
FD55  3D                      MUL                     ; BY FOUR PLACES
FD56  8604                    LDA     #4              ; ROTATE BINARY INTO VALUE
FD58  58              BLDSHF  ASLB                    ; OBTAIN NEXT BIT
FD59  099C                    ROL     <NUMBER+1       ; INTO LOW BYTE
FD5B  099B                    ROL     <NUMBER         ; INTO HI BYTE
FD5D  4A                      DECA                    ; COUNT DOWN
FD5E  26F8                    BNE     BLDSHF          ; BRANCH IF MORE TO DO
FD60  2014                    BRA     CNVOK           ; SET GOOD RETURN CODE
                      
                      ****************************************
                      * CONVERT ASCII CHARACTER TO BINARY BYTE
                      * INPUT: A=ASCII
                      * OUTPUT: Z=1 A=BINARY VALUE
                      * Z=0 IF INVALID
                      * ALL REGISTERS TRANSPARENT
                      * (A UNALTERED IF INVALID HEX)
                      **************************************
FD62  8130            CNVHEX  CMPA    #'0             ; ? LOWER THAN A ZERO
FD64  2512                    BLO     CNVRTS          ; BRANCH NOT VALUE
FD66  8139                    CMPA    #'9             ; ? POSSIBLE A-F
FD68  2F0A                    BLE     CNVGOT          ; BRANCH NO TO ACCEPT
FD6A  8141                    CMPA    #'A             ; ? LESS THEN TEN
FD6C  250A                    BLO     CNVRTS          ; RETURN IF MINUS (INVALID)
FD6E  8146                    CMPA    #'F             ; ? NOT TOO LARGE
FD70  2206                    BHI     CNVRTS          ; NO, RETURN TOO LARGE
FD72  8007                    SUBA    #7              ; DOWN TO BINARY
FD74  840F            CNVGOT  ANDA    #$0F            ; CLEAR HIGH HEX
FD76  1A04            CNVOK   ORCC    #4              ; FORCE ZERO ON FOR VALID HEX
FD78  39              CNVRTS  RTS                     ; RETURN TO CALLER
                      
                      * GET INPUT CHAR, ABORT COMMAND IF CONTROL-X (CANCEL)
FD79  3F              READ     SWI                    ; GET NEXT CHARACTER
FD7A  00                       FCB    INCHNP          ; FUNCTION
FD7B  8118                     CMPA   #CAN            ; ? ABORT COMMAND
FD7D  27C7                     BEQ    BLDBAD          ; BRANCH TO ABORT IF SO
FD7F  39                       RTS                    ; RETURN TO CALLER
                      *G
                      
                      ***************GO - START PROGRAM EXECUTION
FD80  8D01            CGO      BSR    GOADDR          ; BUILD ADDRESS IF NEEDED
FD82  3B                       RTI                    ; START EXECUTING
                      
                      * FIND OPTIONAL NEW PROGRAM COUNTER. ALSO ARM THE
                      * BREAKPOINTS.
FD83  3530            GOADDR   PULS   Y,X             ; RECOVER RETURN ADDRESS
FD85  3410                     PSHS   X               ; STORE RETURN BACK
FD87  2619                     BNE    GONDFT          ; IF NO CARRIAGE RETURN THEN NEW PC
                      
                      * DEFAULT PROGRAM COUNTER, SO FALL THROUGH IF
                      * IMMEDIATE BREAKPOINT.
FD89  1701B6                   LBSR   CBKLDR          ; SEARCH BREAKPOINTS
FD8C  AE6C                     LDX    12,S            ; LOAD PROGRAM COUNTER
FD8E  5A              ARMBLP  DECB                    ; COUNT DOWN
FD8F  2B16                    BMI     ARMBK2          ; DONE, NONE TO SINGLE TRACE
FD91  A630                    LDA     -NUMBKP*2,Y     ; PRE-FETCH OPCODE
FD93  ACA1                    CMPX    ,Y++            ; ? IS THIS A BREAKPOINT
FD95  26F7                    BNE     ARMBLP          ; LOOP IF NOT
FD97  813F                    CMPA    #$3F            ; ? SWI BREAKPOINTED
FD99  2602                    BNE     ARMNSW          ; NO, SKIP SETTING OF PASS FLAG
FD9B  97FB                    STA     <SWIBFL         ; SHOW UPCOMING SWI NOT BRKPNT
FD9D  0C8F            ARMNSW  INC     <MISFLG         ; FLAG THRU A BREAKPOINT
FD9F  160106                  LBRA    CDOT            ; DO SINGLE TRACE W/O BREAKPOINTS
                      
                      * OBTAIN NEW PROGRAM COUNTER
FDA2  1700BB          GONDFT  LBSR    CDNUM           ; OBTAIN NEW PROGRAM COUNTER
FDA5  ED6C                    STD     12,S            ; STORE INTO STACK
FDA7  170198          ARMBK2  LBSR    CBKLDR          ; OBTAIN TABLE
FDAA  00FA                    NEG     <BKPTCT         ; COMPLEMENT TO SHOW ARMED
FDAC  5A              ARMLOP  DECB                    ; ? DONE
FDAD  2BC9                    BMI     CNVRTS          ; RETURN WHEN DONE
FDAF  A6B4                    LDA     [,Y]            ; LOAD OPCODE
FDB1  A730                    STA     -NUMBKP*2,Y     ; STORE INTO OPCODE TABLE
FDB3  863F                    LDA     #$3F            ; READY "SWI" OPCODE
FDB5  A7B1                    STA     [,Y++]          ; STORE AND MOVE UP TABLE
FDB7  20F3                    BRA     ARMLOP          ; AND CONTINUE
                      
                      *******************CALL - CALL ADDRESS AS SUBROUTINE
FDB9  8DC8            CCALL   BSR     GOADDR          ; FETCH ADDRESS IF NEEDED
FDBB  357F                    PULS    U,Y,X,DP,D,CC   ; RESTORE USERS REGISTERS
FDBD  ADF1                    JSR     [,S++]          ; CALL USER SUBROUTINE
FDBF  3F              CGOBRK  SWI                     ; PERFORM BREAKPOINT
FDC0  0A                      FCB     BRKPT           ; FUNCTION
FDC1  20FC                    BRA     CGOBRK          ; LOOP UNTIL USER CHANGES PC
                      
                      ****************MEMORY - DISPLAY/CHANGE MEMORY
                      * CMEMN AND CMPADP ARE DIRECT ENTRY POINTS FROM
                      * THE COMMAND HANDLER FOR QUICK COMMANDS
FDC3  17009A          CMEM    LBSR    CDNUM           ; OBTAIN ADDRESS
FDC6  DD9E            CMEMN   STD     <ADDR           ; STORE DEFAULT
FDC8  9E9E            CMEM2   LDX     <ADDR           ; LOAD POINTER
FDCA  17FC0C                  LBSR    ZOUT2H          ; SEND OUT HEX VALUE OF BYTE
FDCD  862D                    LDA     #'-             ; LOAD DELIMITER
FDCF  3F                      SWI                     ; SEND OUT
FDD0  01                      FCB     OUTCH           ; FUNCTION
FDD1  17FF0B          CMEM4   LBSR    BLDNNB          ; OBTAIN NEW BYTE VALUE
FDD4  270A                    BEQ     CMENUM          ; BRANCH IF NUMBER
                      * COMA - SKIP BYTE
FDD6  812C                    CMPA    #',             ; ? COMMA
FDD8  260E                    BNE     CMNOTC          ; BRANCH NOT
FDDA  9F9E                    STX     <ADDR           ; UPDATE POINTER
FDDC  3001                    LEAX    1,X             ; TO NEXT BYTE
FDDE  20F1                    BRA     CMEM4           ; AND INPUT IT
FDE0  D69C            CMENUM  LDB     <NUMBER+1       ; LOAD LOW BYTE VALUE
FDE2  8D47                    BSR     MUPDAT          ; GO OVERLAY MEMORY BYTE
FDE4  812C                    CMPA    #',             ; ? CONTINUE WITH NO DISPLAY
FDE6  27E9                    BEQ     CMEM4           ; BRANCH YES
                      * QUOTED STRING
FDE8  8127            CMNOTC  CMPA    #$27            ; ? QUOTED STRING
FDEA  260C                    BNE     CMNOTQ          ; BRANCH NO
FDEC  8D8B            CMESTR  BSR     READ            ; OBTAIN NEXT CHARACTER
FDEE  8127                    CMPA    #$27            ; ? END OF QUOTED STRING
FDF0  270C                    BEQ     CMSPCE          ; YES, QUIT STRING MODE
FDF2  1F89                    TFR     A,B             ; TO B FOR SUBROUTINE
FDF4  8D35                    BSR     MUPDAT          ; GO UPDATE BYTE
FDF6  20F4                    BRA     CMESTR          ; GET NEXT CHARACTER
                      * BLANK - NEXT BYTE
FDF8  8120            CMNOTQ  CMPA    #$20            ; ? BLANK FOR NEXT BYTE
FDFA  2606                    BNE     CMNOTB          ; BRANCH NOT
FDFC  9F9E                    STX     <ADDR           ; UPDATE POINTER
FDFE  3F              CMSPCE  SWI                     ; GIVE SPACE
FDFF  07                      FCB     SPACE           ; FUNCTION
FE00  20C6                    BRA     CMEM2           ; NOW PROMPT FOR NEXT
                      
                      * LINE FEED - NEXT BYTE WITH ADDRESS
FE02  810A            CMNOTB  CMPA    #LF             ; ? LINE FEED FOR NEXT BYTE
FE04  2608                    BNE     CMNOTL          ; BRANCH NO
FE06  860D                    LDA     #CR             ; GIVE CARRIAGE RETURN
FE08  3F                      SWI                     ; TO CONSOLE
FE09  01                      FCB     OUTCH           ; HANDLER
FE0A  9F9E                    STX     <ADDR           ; STORE NEXT ADDRESS
FE0C  200A                    BRA     CMPADP          ; BRANCH TO SHOW
                      
                      * UP ARROW - PREVIOUS BYTE AND ADDRESS
FE0E  815E            CMNOTL  CMPA    #'^             ; ? UP ARROW FOR PREVIOUS BYTE
FE10  260A                    BNE     CMNOTU          ; BRANCH NOT
FE12  301E                    LEAX    -2,X            ; DOWN TO PREVIOUS BYTE
FE14  9F9E                    STX     <ADDR           ; STORE NEW POINTER
FE16  3F              CMPADS  SWI                     ; FORCE NEW LINE
FE17  06                      FCB     PCRLF           ; FUNCTION
FE18  8D07            CMPADP  BSR     PRTADR          ; GO PRINT ITS VALUE
FE1A  20AC                    BRA     CMEM2           ; THEN PROMPT FOR INPUT
                      
                      * SLASH - NEXT BYTE WITH ADDRESS
FE1C  812F            CMNOTU  CMPA    #'/             ; ? SLASH FOR CURRENT DISPLAY
FE1E  27F6                    BEQ     CMPADS          ; YES, SEND ADDRESS
FE20  39                      RTS                     ; RETURN FROM COMMAND
                      
                      * PRINT CURRENT ADDRESS
FE21  9E9E            PRTADR  LDX     <ADDR           ; LOAD POINTER VALUE
FE23  3410                    PSHS    X               ; SAVE X ON STACK
FE25  30E4                    LEAX    ,S              ; POINT TO IT FOR DISPLAY
FE27  3F                      SWI                     ; DISPLAY POINTER IN HEX
FE28  05                      FCB     OUT4HS          ; FUNCTION
FE29  3590                    PULS    PC,X            ; RECOVER POINTER AND RETURN
                      
                      * UPDATE BYTE
FE2B  9E9E            MUPDAT  LDX     <ADDR           ; LOAD NEXT BYTE POINTER
FE2D  E780                    STB     ,X+             ; STORE AND INCREMENT X
FE2F  E11F                    CMPB    -1,X            ; ? SUCCESFULL STORE
FE31  2603                    BNE     MUPBAD          ; BRANCH FOR '?' IF NOT
FE33  9F9E                    STX     <ADDR           ; STORE NEW POINTER VALUE
FE35  39                      RTS                     ; BACK TO CALLER
FE36  3402            MUPBAD  PSHS    A               ; SAVE A REGISTER
FE38  863F                    LDA     #'?             ; SHOW INVALID
FE3A  3F                      SWI                     ; SEND OUT
FE3B  01                      FCB     OUTCH           ; FUNCTION
FE3C  3582                    PULS    PC,A            ; RETURN TO CALLER
                      
                      ********************WINDOW - SET WINDOW VALUE
FE3E  8D20            CWINDO  BSR     CDNUM           ; OBTAIN WINDOW VALUE
FE40  DDA0                    STD     <WINDOW         ; STORE IT IN
FE42  39                      RTS                     ; END COMMAND
                      
                      ******************DISPLAY - HIGH SPEED DISPLAY MEMORY
FE43  8D1B            CDISP   BSR     CDNUM           ; FETCH ADDRESS
FE45  C4F0                    ANDB    #$F0            ; FORCE TO 16 BOUNDARY
FE47  1F02                    TFR     D,Y             ; SAVE IN Y
FE49  302F                    LEAX    15,Y            ; DEFAULT LENGTH
FE4B  2504                    BCS     CDISPS          ; BRANCH IF END OF INPUT
FE4D  8D11                    BSR     CDNUM           ; OBTAIN COUNT
FE4F  30AB                    LEAX    D,Y             ; ASSUME COUNT, COMPUTE END ADDR
FE51  3430            CDISPS  PSHS    Y,X             ; SETUP PARAMETERS FOR HSDATA
FE53  10A362                  CMPD    2,S             ; ? WAS IT COUNT
FE56  2302                    BLS     CDCNT           ; BRANCH YES
FE58  EDE4                    STD     ,S              ; STORE HIGH ADDRESS
FE5A  AD9D6284        CDCNT   JSR     [VECTAB+XHSDTA,PCR] ; CALL PRINT ROUTINE
FE5E  35E0                    PULS    PC,U,Y          ; CLEAN STACK AND END COMMAND
                      
                      * OBTAIN NUMBER - ABORT IF NONE
                      * ONLY DELIMITERS OF CR, BLANK, OR '/' ARE ACCEPTED
                      * OUTPUT: D=VALUE, C=1 IF CARRIAGE RETURN DELMITER,
                      * ELSE C=0
FE60  17FE7E          CDNUM   LBSR    BLDNUM          ; OBTAIN NUMBER
FE63  2609                    BNE     CDBADN          ; BRANCH IF INVALID
FE65  812F                    CMPA    #'/             ; ? VALID DELIMITER
FE67  2205                    BHI     CDBADN          ; BRANCH IF NOT FOR ERROR
FE69  810E                    CMPA    #CR+1           ; LEAVE COMPARE FOR CARRIAGE RET
FE6B  DC9B                    LDD     <NUMBER         ; LOAD NUMBER
FE6D  39                      RTS                     ; RETURN WITH COMPARE
FE6E  16FAEB          CDBADN  LBRA    CMDBAD          ; RETURN TO ERROR MECHANISM
                      
                      *****************PUNCH - PUNCH MEMORY IN S1-S9 FORMAT
FE71  8DED            CPUNCH  BSR     CDNUM           ; OBTAIN START ADDRESS
FE73  1F02                    TFR     D,Y             ; SAVE IN Y
FE75  8DE9                    BSR     CDNUM           ; OBTAIN END ADDRESS
FE77  6FE2                    CLR     ,-S             ; SETUP PUNCH FUNCTION CODE
FE79  3426                    PSHS    Y,D             ; STORE VALUES ON STACK
FE7B  AD9D6265        CCALBS  JSR     [VECTAB+XBSON,PCR] ; INITIALIZE HANDLER
FE7F  AD9D6263                JSR     [VECTAB+XBSDTA,PCR] ; PERFORM FUNCTION
FE83  3401                    PSHS    CC              ; SAVE RETURN CODE
FE85  AD9D625F                JSR     [VECTAB+XBSOFF,PCR] ; TURN OFF HANDLER
FE89  3501                    PULS    CC              ; OBTAIN CONDITION CODE SAVED
FE8B  26E1                    BNE     CDBADN          ; BRANCH IF ERROR
FE8D  35B2                    PULS    PC,Y,X,A        ; RETURN FROM COMMAND
                      
                      *****************LOAD - LOAD MEMORY FROM S1-S9 FORMAT
FE8F  8D01            CLOAD   BSR     CLVOFS          ; CALL SETUP AND PASS CODE
FE91  01                      FCB     1               ; LOAD FUNCTION CODE FOR PACKET
                      
FE92  33F1            CLVOFS  LEAU    [,S++]          ; LOAD CODE IN HIGH BYTE OF U
FE94  33D4                    LEAU    [,U]            ; NOT CHANGING CC AND RESTORE S
FE96  2703                    BEQ     CLVDFT          ; BRANCH IF CARRIAGE RETURN NEXT
FE98  8DC6                    BSR     CDNUM           ; OBTAIN OFFSET
FE9A  8C                      FCB     SKIP2           ; SKIP DEFAULT OFFSET
FE9B  4F              CLVDFT  CLRA                    ; CREATE ZERO OFFSET
FE9C  5F                      CLRB                    ; AS DEFAULT
FE9D  344E                    PSHS    U,DP,D          ; SETUP CODE, NULL WORD, OFFSET
FE9F  20DA                    BRA     CCALBS          ; ENTER CALL TO BS ROUTINES
                      
                      ******************VERIFY - COMPARE MEMORY WITH FILES
FEA1  8DEF            CVER    BSR     CLVOFS          ; COMPUTE OFFSET IF ANY
FEA3  FF                      FCB     -1              ; VERIFY FNCTN CODE FOR PACKET
                      
                      *******************TRACE - TRACE INSTRUCTIONS
                      ******************* . - SINGLE STEP TRACE
FEA4  8DBA            CTRACE  BSR     CDNUM           ; OBTAIN TRACE COUNT
FEA6  DD91                    STD     <TRACEC         ; STORE COUNT
FEA8  3262            CDOT    LEAS    2,S             ; RID COMMAND RETURN FROM STACK
FEAA  EEF80A          CTRCE3  LDU     [10,S]          ; LOAD OPCODE TO EXECUTE
FEAD  DF99                    STU     <LASTOP         ; STORE FOR TRACE INTERRUPT
FEAF  DEF6                    LDU     <VECTAB+XPTM    ; LOAD PTM ADDRESS
FEB1  CC0701                  LDD     #$0701          ; 7,1 CYCLES DOWN+CYCLES UP
FEB4  ED42                    STD     PTMTM1-PTM,U    ; START NMI TIMEOUT
FEB6  3B                      RTI                     ; RETURN FOR ONE INSTRUCTION
                      
                      *************NULLS  -  SET NEW LINE AND CHAR PADDING
FEB7  8DA7            CNULLS  BSR     CDNUM           ; OBTAIN NEW LINE PAD
FEB9  DDF2                    STD     <VECTAB+XPAD    ; RESET VALUES
FEBB  39                      RTS                     ; END COMMAND
                      
                      ******************STLEVEL - SET STACK TRACE LEVEL
FEBC  2705            CSTLEV  BEQ     STLDFT          ; TAKE DEFAULT
FEBE  8DA0                    BSR     CDNUM           ; OBTAIN NEW STACK LEVEL
FEC0  DDF8                    STD     <SLEVEL         ; STORE NEW ENTRY
FEC2  39                      RTS                     ; TO COMMAND HANDLER
FEC3  306E            STLDFT  LEAX    14,S            ; COMPUTE NMI COMPARE
FEC5  9FF8                    STX     <SLEVEL         ; AND STORE IT
FEC7  39                      RTS                     ; END COMMAND
                      
                      ******************OFFSET - COMPUTE SHORT AND LONG
                      ******************                  BRANCH OFFSETS
FEC8  8D96            COFFS   BSR     CDNUM           ; OBTAIN INSTRUCTION ADDRESS
FECA  1F01                    TFR     D,X             ; USE AS FROM ADDRESS
FECC  8D92                    BSR     CDNUM           ; OBTAIN TO ADDRESS
                      * D=TO INSTRUCTION, X=FROM INSTRUCTION OFFSET BYTE(S)
FECE  3001                    LEAX    1,X             ; ADJUST FOR *+2 SHORT BRANCH
FED0  3430                    PSHS    Y,X             ; STORE WORK WORD AND VALUE ON S
FED2  A3E4                    SUBD    ,S              ; FIND OFFSET
FED4  EDE4                    STD     ,S              ; SAVE OVER STACK
FED6  3061                    LEAX    1,S             ; POINT FOR ONE BYTE DISPLAY
FED8  1D                      SEX                     ; SIGN EXTEND LOW BYTE
FED9  A1E4                    CMPA    ,S              ; ? VALID ONE BYTE OFFSET
FEDB  2602                    BNE     COFNO1          ; BRANCH IF NOT
FEDD  3F                      SWI                     ; SHOW ONE BYTE OFFSET
FEDE  04                      FCB     OUT2HS          ; FUNCTION
FEDF  EEE4            COFNO1  LDU     ,S              ; RELOAD OFFSET
FEE1  335F                    LEAU    -1,U            ; CONVERT TO LONG BRANCH OFFSET
FEE3  EF84                    STU     ,X              ; STORE BACK WHERE X POINTS NOW
FEE5  3F                      SWI                     ; SHOW TWO BYTE OFFSET
FEE6  05                      FCB     OUT4HS          ; FUNCTION
FEE7  3F                      SWI                     ; FORCE NEW LINE
FEE8  06                      FCB     PCRLF           ; FUNCTION
FEE9  3596                    PULS    PC,X,D          ; RESTORE STACK AND END COMMAND
                      *H
                      
                      *************BREAKPOINT - DISPLAY/ENTER/DELETE/CLEAR
                      *************             BREAKPOINTS
FEEB  2723            CBKPT   BEQ     CBKDSP          ; BRANCH DISPLAY OF JUST 'B'
FEED  17FDF1                  LBSR    BLDNUM          ; ATTEMPT VALUE ENTRY
FEF0  272C                    BEQ     CBKADD          ; BRANCH TO ADD IF SO
FEF2  812D                    CMPA    #'-             ; ? CORRECT DELIMITER
FEF4  263F                    BNE     CBKERR          ; NO, BRANCH FOR ERROR
FEF6  17FDE8                  LBSR    BLDNUM          ; ATTEMPT DELETE VALUE
FEF9  2703                    BEQ     CBKDLE          ; GOT ONE, GO DELETE IT
FEFB  0FFA                    CLR     <BKPTCT         ; WAS 'B -', SO ZERO COUNT
FEFD  39              CBKRTS  RTS                     ; END COMMAND
                      * DELETE THE ENTRY
FEFE  8D40            CBKDLE  BSR     CBKSET          ; SETUP REGISTERS AND VALUE
FF00  5A              CBKDLP  DECB                    ; ? ANY ENTRIES IN TABLE
FF01  2B32                    BMI     CBKERR          ; BRANCH NO, ERROR
FF03  ACA1                    CMPX    ,Y++            ; ? IS THIS THE ENTRY
FF05  26F9                    BNE     CBKDLP          ; NO, TRY NEXT
                      * FOUND, NOW MOVE OTHERS UP IN ITS PLACE
FF07  AEA1            CBKDLM  LDX     ,Y++            ; LOAD NEXT ONE UP
FF09  AF3C                    STX     -4,Y            ; MOVE DOWN BY ONE
FF0B  5A                      DECB                    ; ? DONE
FF0C  2AF9                    BPL     CBKDLM          ; NO, CONTINUE MOVE
FF0E  0AFA                    DEC     <BKPTCT         ; DECREMENT BREAKPOINT COUNT
FF10  8D2E            CBKDSP  BSR     CBKSET          ; SETUP REGISTERS AND LOAD VALUE
FF12  27E9                    BEQ     CBKRTS          ; RETURN IF NONE TO DISPLY
FF14  30A1            CBKDSL  LEAX    ,Y++            ; POINT TO NEXT ENTRY
FF16  3F                      SWI                     ; DISPLAY IN HEX
FF17  05                      FCB     OUT4HS          ; FUNCTION
FF18  5A                      DECB                    ; COUNT DOWN
FF19  26F9                    BNE     CBKDSL          ; LOOP IF NGABLE RAM
FF1B  3F                      SWI                     ; SKIP TO NEW LINK
FF1C  06                      FCB     PCRLF           ; FUNCTIONRTS
FF1D  39                      RTS
                      
                      * ADD NEW ENTRY
FF1E  8D20            CBKADD  BSR     CBKSET          ; SETUP REGISTERS
FF20  C108                    CMPB    #NUMBKP         ; ? ALREADY FULL
FF22  2711                    BEQ     CBKERR          ; BRANCH ERROR IF SO
FF24  A684                    LDA     ,X              ; LOAD BYTE TO TRAP
FF26  E784                    STB     ,X              ; TRY TO CHANGE
FF28  E184                    CMPB    ,X              ; ? CHANGEABLE RAM
FF2A  2609                    BNE     CBKERR          ; BRANCH ERROR IF NOT
FF2C  A784                    STA ,X                  ; RESTORE BYTE
FF2E  5A              CBKADL  DECB                    ; COUNT DOWN
FF2F  2B07                    BMI     CBKADT          ; BRANCH IF DONE TO ADD IT
FF31  ACA1                    CMPX    ,Y++            ; ? ENTRY ALREADY HERE
FF33  26F9                    BNE     CBKADL          ; LOOP IF NOT
FF35  16FA24          CBKERR  LBRA    CMDBAD          ; RETURN TO ERROR PRODUCE
FF38  AFA4            CBKADT  STX ,Y                  ; ADD THIS ENTRY
FF3A  6F31                    CLR     -NUMBKP*2+1,Y   ; CLEAR OPTIONAL BYTE
FF3C  0CFA                    INC     <BKPTCT         ; ADD ONE TO COUNT
FF3E  20D0                    BRA     CBKDSP          ; AND NOW DISPLAY ALL OF 'EM
                      * SETUP REGISTERS FOR SCAN
FF40  9E9B            CBKSET  LDX     <NUMBER         ; LOAD VALUE DESIRED
FF42  318D616C        CBKLDR  LEAY    BKPTBL,PCR      ; LOAD START OF TABLE
FF46  D6FA                    LDB     <BKPTCT         ; LOAD ENTRY COUNT
FF48  39                      RTS                     ; RETURN
                      
                      *****************ENCODE  -  ENCODE A POSTBYTE
FF49  6FE2            CENCDE  CLR     ,-S             ; DEFAULT TO NOT INDIRECT
FF4B  5F                      CLRB                    ; ZERO POSTBYTE VALUE
FF4C  308C3F                  LEAX    <CONV1,PCR      ; START TABLE SEARCH
FF4F  3F                      SWI                     ; OBTAIN FIRST CHARACTER
FF50  00                      FCB     INCHNP          ; FUNCTION
FF51  815B                    CMPA    #'[             ; ? INDIRECT HERE
FF53  2606                    BNE     CEN2            ; BRANCH IF NOT
FF55  8610                    LDA     #$10            ; SET INDIRECT BIT ON
FF57  A7E4                    STA     ,S              ; SAVE FOR LATER
FF59  3F              CENGET  SWI                     ; OBTAIN NEXT CHARACTER
FF5A  00                      FCB     INCHNP          ; FUNCTION
FF5B  810D            CEN2    CMPA    #CR             ; ? END OF ENTRY
FF5D  270C                    BEQ     CEND1           ; BRANCH YES
FF5F  6D84            CENLP1  TST     ,X              ; ? END OF TABLE
FF61  2BD2                    BMI     CBKERR          ; BRANCH ERROR IF SO
FF63  A181                    CMPA    ,X++            ; ? THIS THE CHARACTER
FF65  26F8                    BNE     CENLP1          ; BRANCH IF NOT
FF67  EB1F                    ADDB    -1,X            ; ADD THIS VALUE
FF69  20EE                    BRA     CENGET          ; GET NEXT INPUT
FF6B  308C49          CEND1   LEAX    <CONV2,PCR      ; POINT AT TABLE 2
FF6E  1F98                    TFR     B,A             ; SAVE COPY IN A
FF70  8460                    ANDA    #$60            ; ISOLATE REGISTER MASK
FF72  AAE4                    ORA     ,S              ; ADD IN INDIRECTION BIT
FF74  A7E4                    STA     ,S              ; SAVE BACK AS POSTBYTE SKELETON
FF76  C49F                    ANDB    #$9F            ; CLEAR REGISTER BITS
FF78  6D84            CENLP2  TST     ,X              ; ? END OF TABLE
FF7A  27B9                    BEQ     CBKERR          ; BRANCH ERROR IF SO
FF7C  E181                    CMPB    ,X++            ; ? SAME VALUE
FF7E  26F8                    BNE     CENLP2          ; LOOP IF NOT
FF80  E61F                    LDB     -1,X            ; LOAD RESULT VALUE
FF82  EAE4                    ORB     ,S              ; ADD TO BASE SKELETON
FF84  E7E4                    STB     ,S              ; SAVE POSTBYTE ON STACK
FF86  30E4                    LEAX    ,S              ; POINT TO IT
FF88  3F                      SWI                     ; SEND OUT AS HEX
FF89  04                      FCB     OUT2HS          ; FUNCTION
FF8A  3F                      SWI                     ; TO NEXT LINE
FF8B  06                      FCB     PCRLF           ; FUNCTION
FF8C  3584                    PULS    PC,B            ; END OF COMMAND
                      
                      * TABLE ONE DEFINES VALID INPUT IN SEQUENCE
FF8E                  CONV1
FF8E  4104420544064801         FCB     'A,$04,'B,$05,'D,$06,'H,$01
FF96  4801480148002C00         FCB     'H,$01,'H,$01,'H,$00,',,$00
FF9E  2D092D0153705930         FCB     '-,$09,'-,$01,'S,$70,'Y,$30
FFA6  555058102B072B01         FCB     'U,$50,'X,$10,'+,$07,'+,$01
FFAE  5080430052005D00         FCB     'P,$80,'C,$00,'R,$00,'],$00
FFB6  FF                      FCB     $FF             ; END OF TABLE
                      
                      * CONV2 USES ABOVE CONVERSION TO SET POSTBYTE
                      * BIT SKELETON.
FFB7                  CONV2
FFB7  10841100                FDB     $1084,$1100     ; R,      H,R
FFBB  12881389                FDB     $1288,$1389     ; HH,R    HHHH,R
FFBF  14861585                FDB     $1486,$1585     ; A,R     B,R
FFC3  168B1780                FDB     $168B,$1780     ; D,R     ,R+
FFC7  18811982                FDB     $1881,$1982     ; ,R++    ,-R
FFCB  1A83828C                FDB     $1A83,$828C     ; ,--R    HH,PCR
FFCF  838D039F                FDB     $838D,$039F     ; HHHH,PCR [HHHH]
FFD3  00                      FCB     0               ; END OF TABLE
                      
                      ****************************************************
                      *            DEFAULT INTERRUPT TRANSFERS           *
                      ****************************************************
FFD4  6E9D60EE        RSRVD   JMP     [VECTAB+XRSVD,PCR]      ; RESERVED VECTOR
FFD8  6E9D60EC        SWI3    JMP     [VECTAB+XSWI3,PCR]      ; SWI3 VECTOR
FFDC  6E9D60EA        SWI2    JMP     [VECTAB+XSWI2,PCR]      ; SWI2 VECTOR
FFE0  6E9D60E8        FIRQ    JMP     [VECTAB+XFIRQ,PCR]      ; FIRQ VECTOR
FFE4  6E9D60E6        IRQ     JMP     [VECTAB+XIRQ,PCR]       ; IRQ VECTOR
FFE8  6E9D60E4        SWI     JMP     [VECTAB+XSWI,PCR]       ; SWI VECTOR
FFEC  6E9D60E2        NMI     JMP     [VECTAB+XNMI,PCR]       ; NMI VECTOR
                      
                      ******************************************************
                      *            ASSIST09 HARDWARE VECTOR TABLE
                      * THIS TABLE IS USED IF THE ASSIST09 ROM ADDRESSES
                      * THE MC6809 HARDWARE VECTORS.
                      ******************************************************
FFF0                          ORG     ROMBEG+ROMSIZ-16 ; SETUP HARDWARE VECTORS
FFF0  FFD4                    FDB     RSRVD           ; RESERVED SLOT
FFF2  FFD8                    FDB     SWI3            ; SOFTWARE INTERRUPT 3
FFF4  FFDC                    FDB     SWI2            ; SOFTWARE INTERRUPT 2
FFF6  FFE0                    FDB     FIRQ            ; FAST INTERRUPT REQUEST
FFF8  FFE4                    FDB     IRQ             ; INTERRUPT REQUEST
FFFA  FFE8                    FDB     SWI             ; SOFTWARE INTERRUPT
FFFC  FFEC                    FDB     NMI             ; NON-MASKABLE INTERRUPT
FFFE  F837                    FDB     RESET           ; RESTART
