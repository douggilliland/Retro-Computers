0001                         *************************************
0002                         * COPYRIGHT (C) MOTOROLA, INC. 1979 *
0003                         *************************************
0004                         
0005                         *************************************
0006                         * THIS IS THE BASE ASSIST09 ROM.
0007                         * IT MAY RUN WITH OR WITHOUT THE
0008                         * EXTENSION ROM WHICH
0009                         * WHEN PRESENT WILL BE AUTOMATICALLY
0010                         * INCORPORATED BY THE BLDVTR
0011                         * SUBROUTINE.
0012                         *************************************
0013                         
0014                         *********************************************
0015                         * GLOBAL MODULE EQUATES
0016                         ********************************************
0017 f800                    ROMBEG  EQU     $F800           ; ROM START ASSEMBLY ADDRESS
0018 ffff6800                    RAMOFS  EQU     -$9800          ; ROM OFFSET TO RAM WORK PAGE
0019 0800                    ROMSIZ  EQU     2048            ; ROM SIZE
0020 f000                    ROM2OF  EQU     ROMBEG-ROMSIZ   ; START OF EXTENSION ROM
0021 a000                    ACIA    EQU     $A000           ; DEFAULT ACIA ADDRESS
0022 0000                    PTM     EQU     $0000           ; DEFAULT PTM ADDRESS
0023 0000                    DFTCHP  EQU     0               ; DEFAULT CHARACTER PAD COUNT
0024 0005                    DFTNLP  EQU     5               ; DEFAULT NEW LINE PAD COUNT
0025 003e                    PROMPT  EQU     '>              ; PROMPT CHARACTER
0026 0008                    NUMBKP  EQU     8               ; NUMBER OF BREAKPOINTS
0027                         *********************************************
0028                         
0029                         *********************************************
0030                         * MISCELANEOUS EQUATES
0031                         *********************************************
0032 0004                    EOT     EQU     $04             ; END OF TRANSMISSION
0033 0007                    BELL    EQU     $07             ; BELL CHARACTER
0034 000a                    LF      EQU     $0A             ; LINE FEED
0035 000d                    CR      EQU     $0D             ; CARRIAGE RETURN
0036 0010                    DLE     EQU     $10             ; DATA LINK ESCAPE
0037 0018                    CAN     EQU     $18             ; CANCEL (CTL-X)
0038                         
0039                         * PTM ACCESS DEFINITIONS
0040 0001                    PTMSTA  EQU     PTM+1           ; READ STATUS REGISTER
0041 0000                    PTMC13  EQU     PTM             ; CONTROL REGISTERS 1 AND 3
0042 0001                    PTMC2   EQU     PTM+1           ; CONTROL REGISTER 2
0043 0002                    PTMTM1  EQU     PTM+2           ; LATCH 1
0044 0004                    PTMTM2  EQU     PTM+4           ; LATCH 2
0045 0006                    PTMTM3  EQU     PTM+6           ; LATCH 3
0046 008c                    SKIP2   EQU     $8C             ; "CMPX #" OPCODE - SKIPS TWO BYTES
0047                         
0048                         *******************************************
0049                         * ASSIST09 MONITOR SWI FUNCTIONS
0050                         * THE FOLLOWING EQUATES DEFINE FUNCTIONS PROVIDED
0051                         * BY THE ASSIST09 MONITOR VIA THE SWI INSTRUCTION.
0052                         ******************************************
0053 0000                    INCHNP  EQU     0               ; INPUT CHAR IN A REG - NO PARITY
0054 0001                    OUTCH   EQU     1               ; OUTPUT CHAR FROM A REG
0055 0002                    PDATA1  EQU     2               ; OUTPUT STRING
0056 0003                    PDATA   EQU     3               ; OUTPUT CR/LF THEN STRING
0057 0004                    OUT2HS  EQU     4               ; OUTPUT TWO HEX AND SPACE
0058 0005                    OUT4HS  EQU     5               ; OUTPUT FOUR HEX AND SPACE
0059 0006                    PCRLF   EQU     6               ; OUTPUT CR/LF
0060 0007                    SPACE   EQU     7               ; OUTPUT A SPACE
0061 0008                    MONITR  EQU     8               ; ENTER ASSIST09 MONITOR
0062 0009                    VCTRSW  EQU     9               ; VECTOR EXAMINE/SWITCH
0063 000a                    BRKPT   EQU     10              ; USER PROGRAM BREAKPOINT
0064 000b                    PAUSE   EQU     11              ; TASK PAUSE FUNCTION
0065 000b                    NUMFUN  EQU     11              ; NUMBER OF AVAILABLE FUNCTIONS
0066                         
0067                         * NEXT SUB-CODES FOR ACCESSING THE VECTOR TABLE.
0068                         * THEY ARE EQUIVALENT TO OFFSETS IN THE TABLE.
0069                         * RELATIVE POSITIONING MUST BE MAINTAINED
0070                         
0071 0000                    .AVTBL  EQU     0               ; ADDRESS OF VECTOR TABLE
0072 0002                    .CMDL1  EQU     2               ; FIRST COMMAND LIST
0073 0004                    .RSVD   EQU     4               ; RESERVED HARDWARE VECTOR
0074 0006                    .SWI3   EQU     6               ; SWI3 ROUTINE
0075 0008                    .SWI2   EQU     8               ; SWI2 ROUTINE
0076 000a                    .FIRQ   EQU     10              ; FIRQ ROUTINE
0077 000c                    .IRQ    EQU     12              ; IRQ ROUTINE
0078 000e                    .SWI    EQU     14              ; SWI ROUTINE
0079 0010                    .NMI    EQU     16              ; NMI ROUTINE
0080 0012                    .RESET  EQU     18              ; RESET ROUTINE
0081 0014                    .CION   EQU     20              ; CONSOLE ON
0082 0016                    .CIDTA  EQU     22              ; CONSOLE INPUT DATA
0083 0018                    .CIOFF  EQU     24              ; CONSOLE INPUT OFF
0084 001a                    .COON   EQU     26              ; CONSOLE OUTPUT ON
0085 001c                    .CODTA  EQU     28              ; CONSOLE OUTPUT DATA
0086 001e                    .COOFF  EQU     30              ; CONSOLE OUTPUT OFF
0087 0020                    .HSDTA  EQU     32              ; HIGH SPEED PRINTDATA
0088 0022                    .BSON   EQU     34              ; PUNCH/LOAD ON
0089 0024                    .BSDTA  EQU     36              ; PUNCH/LOAD DATA
0090 0026                    .BSOFF  EQU     38              ; PUNCH/LOAD OFF
0091 0028                    .PAUSE  EQU     40              ; TASK PAUSE ROUTINE
0092 002a                    .EXPAN  EQU     42              ; EXPRESSION ANALYZER
0093 002c                    .CMDL2  EQU     44              ; SECOND COMMAND LIST
0094 002e                    .ACIA   EQU     46              ; ACIA ADDRESS
0095 0030                    .PAD    EQU     48              ; CHARACTER PAD AND NEW LINE PAD
0096 0032                    .ECHO   EQU     50              ; ECHO/LOAD AND NULL BKPT FLAG
0097 0034                    .PTM    EQU     52              ; PTM ADDRESS
0098 001b                    NUMVTR  EQU     52/2+1          ; NUMBER OF VECTORS
0099 0034                    HIVTR   EQU     52              ; HIGHEST VECTOR OFFSET
0100                         
0101                         ******************************************
0102                         *           WORK AREA
0103                         * THIS WORK AREA IS ASSIGNED TO THE PAGE ADDRESSED BY
0104                         * -$1800,PCR FROM THE BASE ADDRESS OF THE ASSIST09
0105                         * ROM. THE DIRECT PAGE REGISTER DURING MOST ROUTINE
0106                         * OPERATIONS WILL POINT TO THIS WORK AREA. THE STACK
0107                         * INITIALLY STARTS UNDER THE RESERVED WORK AREAS AS
0108                         * DEFINED HEREIN.
0109                         ******************************************
0110 6000                    WORKPG  EQU     ROMBEG+RAMOFS   ; SETUP DIRECT PAGE ADDRESS
0111                         *       SETDP   =WORKPG         ; NOTIFY ASSEMBLER
0112 6100                            ORG     WORKPG+256      ; READY PAGE DEFINITIONS
0113                         
0114                         * THE FOLLOWING THRU BKPTOP MUST RESIDE IN THIS ORDER
0115                         * FOR PROPER INITIALIZATION
0116 60fc                            ORG     *-4
0117 60fc                    PAUSER  EQU     *               ; PAUSE ROUTINE
0118 60fb                            ORG     *-1
0119 60fb                    SWIBFL  EQU     *               ; BYPASS SWI AS BREAKPOINT FLAG
0120 60fa                            ORG     *-1
0121 60fa                    BKPTCT  EQU     *               ; BREAKPOINT COUNT
0122 60f8                            ORG     *-2             ; SLEVEL EQU
0123 60f8                    SLEVEL  EQU     *               ; STACK TRACE LEVEL
0124 60c2                            ORG     -NUMVTR*2+*
0125 60c2                    VECTAB  EQU     *               ; VECTOR TABLE
0126 60b2                            ORG     -2*NUMBKP+*
0127 60b2                    BKPTBL  EQU     *               ; BREAKPOINT TABLE
0128 60a2                            ORG     -2*NUMBKP+*
0129 60a2                    BKPTOP  EQU     *               ; BREAKPOINT OPCODE TABLE
0130 60a0                            ORG     *-2
0131 60a0                    WINDOW  EQU     *               ; WINDOW
0132 609e                            ORG     *-2
0133 609e                    ADDR    EQU     *               ; ADDRESS POINTER VALUE
0134 609d                            ORG     *-1
0135 609d                    BASEPG  EQU     *               ; BASE PAGE VALUE
0136 609b                            ORG     *-2
0137 609b                    NUMBER  EQU     *               ; BINARY BUILD AREA
0138 6099                            ORG     *-2
0139 6099                    LASTOP  EQU     *               ; LAST OPCODE TRACED
0140 6097                            ORG     *-2
0141 6097                    RSTACK  EQU     *               ; RESET STACK POINTER
0142 6095                            ORG     *-2
0143 6095                    PSTACK  EQU     *               ; COMMAND RECOVERY STACK
0144 6093                            ORG     *-2
0145 6093                    PCNTER  EQU     *               ; LAST PROGRAM COUNTER
0146 6091                            ORG     *-2
0147 6091                    TRACEC  EQU     *               ; TRACE COUNT
0148 6090                            ORG     *-1
0149 6090                    SWICNT  EQU     *               ; TRACE "SWI" NEST LEVEL COUNT
0150 608f                            ORG     *-1             ; (MISFLG MUST FOLLOW SWICNT)
0151 608f                    MISFLG  EQU     *               ; LOAD CMD/THRU BREAKPOINT FLAG
0152 608e                            ORG     *-1
0153 608e                    DELIM   EQU     *               ; EXPRESSION DELIMITER/WORK BYTE
0154 6066                            ORG     *-40
0155 6066                    ROM2WK  EQU     *               ; EXTENSION ROM RESERVED AREA
0156 6051                            ORG     *-21
0157 6051                    TSTACK  EQU     *               ; TEMPORARY STACK HOLD
0158 6051                    STACK   EQU     *               ; START OF INITIAL STACK
0159                         
0160                         * Fill from start of ROM ($C000) to starting location of ROM code
0161                         *  ($F800) with all ones.
0162                         
0163 c000                            ORG     $C000
0164 c000 ff ff ff ff ff ff          FILL    $FF, ROMBEG-*   ; Fill ROM with FFs until $DB00
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff
0165                         
0166                         ******************************************
0167                         * DEFAULT THE ROM BEGINNING ADDRESS TO 'ROMBEG'
0168                         * ASSIST09 IS POSITION ADDRESS INDEPENDENT, HOWEVER
0169                         * WE ASSEMBLE ASSUMING CONTROL OF THE HARDWARE VECTORS.
0170                         * NOTE THAT THE WORK RAM PAGE MUST BE 'RAMOFS'
0171                         * FROM THE ROM BEGINNING ADDRESS.
0172                         ********************************************
0173 f800                            ORG     ROMBEG          ; ROM ASSEMBLY/DEFAULT ADDRESS
0174                         
0175                         *****************************************************
0176                         * BLDVTR - BUILD ASSIST09 VECTOR TABLE
0177                         * HARDWARE RESET CALLS THIS SUBROUTINE TO BUILD THE
0178                         * ASSIST09 VECTOR TABLE. THIS SUBROUTINE RESIDES AT
0179                         * THE FIRST BYTE OF THE ASSIST09 ROM, AND CAN BE
0180                         * CALLED VIA EXTERNAL CONTROL CODE FOR REMOTE
0181                         * ASSIST09 EXECUTION.
0182                         * INPUT: S->VALID STACK RAM
0183                         * OUTPUT: U->VECTOR TABLE ADDRESS
0184                         * DPR->ASSIST09 WORK AREA PAGE
0185                         * THE VECTOR TABLE AND DEFAULTS ARE INITIALIZED
0186                         * ALL REGISTERS VOLATILE
0187                         *************************************************
0188 f800 30 8d 68 be        BLDVTR  LEAX    VECTAB,PCR      ; ADDRESS VECTOR TABLE
0189 f804 1f 10                      TFR     X,D             ; OBTAIN BASE PAGE ADDRESS
0190 f806 1f 8b                      TFR     A,DP            ; SETUP DPR
0191 f808 97 9d                      STA     <BASEPG         ; STORE FOR QUICK REFERENCE
0192 f80a 33 84                      LEAU    ,X              ; RETURN TABLE TO CALLER
0193 f80c 31 8c 35                   LEAY    <INITVT,PCR     ; LOAD FROM ADDR
0194 f80f ef 81                      STU     ,X++            ; INIT VECTOR TABLE ADDRESS
0195 f811 c6 16                      LDB     #NUMVTR-5       ; NUMBER RELOCATABLE VECTORS
0196 f813 34 04                      PSHS    B               ; STORE INDEX ON STACK
0197 f815 1f 20              BLD2    TFR     Y,D             ; PREPARE ADDRESS RESOLVE
0198 f817 e3 a1                      ADDD    ,Y++            ; TO ABSOLUTE ADDRESS
0199 f819 ed 81                      STD     ,X++            ; INTO VECTOR TABLE
0200 f81b 6a e4                      DEC     ,S              ; COUNT DOWN
0201 f81d 26 f6                      BNE     BLD2            ; BRANCH IF MORE TO INSERT
0202 f81f c6 0d                      LDB     #INTVE-INTVS    ; STATIC VALUE INIT LENGTH
0203 f821 a6 a0              BLD3    LDA     ,Y+             ; LOAD NEXT BYTE
0204 f823 a7 80                      STA     ,X+             ; STORE INTO POSITION
0205 f825 5a                         DECB                    ; COUNT DOWN
0206 f826 26 f9                      BNE     BLD3            ; LOOP UNTIL DONE
0207 f828 31 8d f7 d4                LEAY    ROM2OF,PCR      ; TEST POSSIBLE EXTENSION ROM
0208 f82c 8e 20 fe                   LDX     #$20FE          ; LOAD "BRA *" FLAG PATTERN
0209 f82f ac a1                      CMPX    ,Y++            ; ? EXTENDED ROM HERE
0210 f831 26 02                      BNE     BLDRTN          ; BRANCH NOT OUR ROM TO RETURN
0211 f833 ad a4                      JSR     ,Y              ; CALL EXTENDED ROM INITIALIZE
0212 f835 35 84              BLDRTN  PULS    PC,B            ; RETURN TO INITIALIZER
0213                         
0214                         *****************************************************
0215                         *                RESET ENTRY POINT
0216                         * HARDWARE RESET ENTERS HERE IF ASSIST09 IS ENABLED
0217                         * TO RECEIVE THE MC6809 HARDWARE VECTORS. WE CALL
0218                         * THE BLDVTR SUBROUTINE TO INITIALIZE THE VECTOR
0219                         * TABLE, STACK, AND THEN FIREUP THE MONITOR VIA SWI
0220                         * CALL.
0221                         *******************************************************
0222 f837 32 8d 68 16        RESET   LEAS    STACK,PCR       ; SETUP INITIAL STACK
0223 f83b 8d c3                      BSR     BLDVTR          ; BUILD VECTOR TABLE
0224 f83d 4f                 RESET2  CLRA                    ; ISSUE STARTUP MESSAGE
0225 f83e 1f 8b                      TFR     A,DP            ; DEFAULT TO PAGE ZERO
0226 f840 3f                         SWI                     ; PERFORM MONITOR FIREUP
0227 f841 08                         FCB     MONITR          ; TO ENTER COMMAND PROCESSING
0228 f842 20 f9                      BRA     RESET2          ; REENTER MONITOR IF 'CONTINUE'
0229                         
0230                         ******************************************************
0231                         *        INITVT - INITIAL VECTOR TABLE
0232                         * THIS TABLE IS RELOCATED TO RAM AND REPRESENTS THE
0233                         * INITIAL STATE OF THE VECTOR TABLE. ALL ADDRESSES
0234                         * ARE CONVERTED TO ABSOLUTE FORM. THIS TABLE STARTS
0235                         * WITH THE SECOND ENTRY, ENDS WITH STATIC CONSTANT
0236                         * INITIALIZATION DATA WHICH CARRIES BEYOND THE TABLE.
0237                         ************************************************
0238 f844 01 58              INITVT  FDB     CMDTBL-*        ; DEFAULT FIRST COMMAND TABLE
0239 f846 02 92                      FDB     RSRVDR-*        ; DEFAULT UNDEFINED HARDWARE VECTOR
0240 f848 02 90                      FDB     SWI3R-*         ; DEFAULT SWI3
0241 f84a 02 8e                      FDB     SWI2R-*         ; DEFAULT SWI2
0242 f84c 02 70                      FDB     FIRQR-*         ; DEFAULT FIRQ
0243 f84e 02 8a                      FDB     IRQR-*          ; DEFAULT IRQ ROUTINE
0244 f850 00 45                      FDB     SWIR-*          ; DEFAULT SWI ROUTINE
0245 f852 02 2b                      FDB     NMIR-*          ; DEFAULT NMI ROUTINE
0246 f854 ff e3                      FDB     RESET-*         ; RESTART VECTOR
0247 f856 02 90                      FDB     CION-*          ; DEFAULT CION
0248 f858 02 84                      FDB     CIDTA-*         ; DEFAULT CIDTA
0249 f85a 02 96                      FDB     CIOFF-*         ; DEFAULT CIOFF
0250 f85c 02 8a                      FDB     COON-*          ; DEFAULT COON
0251 f85e 02 93                      FDB     CODTA-*         ; DEFAULT CODTA
0252 f860 02 90                      FDB     COOFF-*         ; DEFAULT COOFF
0253 f862 03 9a                      FDB     HSDTA-*         ; DEFAULT HSDTA
0254 f864 02 b7                      FDB     BSON-*          ; DEFAULT BSON
0255 f866 02 d2                      FDB     BSDTA-*         ; DEFAULT BSDTA
0256 f868 02 bf                      FDB     BSOFF-*         ; DEFAULT BSOFF
0257 f86a 68 92                      FDB     PAUSER-*        ; DEFAULT PAUSE ROUTINE
0258 f86c 04 7d                      FDB     EXP1-*          ; DEFAULT EXPRESSION ANALYZER
0259 f86e 01 2d                      FDB     CMDTB2-*        ; DEFAULT SECOND COMMAND TABLE
0260                         * CONSTANTS
0261 f870 a0 00              INTVS   FDB     ACIA            ; DEFAULT ACIA
0262 f872 00 05                      FCB     DFTCHP,DFTNLP   ; DEFAULT NULL PADDS
0263 f874 00 00                      FDB     0               ; DEFAULT ECHO
0264 f876 00 00                      FDB     PTM             ; DEFAULT PTM
0265 f878 00 00                      FDB     0               ; INITIAL STACK TRACE LEVEL
0266 f87a 00                         FCB     0               ; INITIAL BREAKPOINT COUNT
0267 f87b 00                         FCB     0               ; SWI BREAKPOINT LEVEL
0268 f87c 39                         FCB     $39             ; DEFAULT PAUSE ROUTINE (RTS)
0269 f87d                    INTVE   EQU     *
0270                         *B
0271                         ***********************************************
0272                         *            ASSIST09 SWI HANDLER
0273                         * THE SWI HANDLER PROVIDES ALL INTERFACING NECESSARY
0274                         * FOR A USER PROGRAM. A FUNCTION BYTE IS ASSUMED TO
0275                         * FOLLOW THE SWI INSTRUCTION. IT IS BOUND CHECKED
0276                         * AND THE PROPER ROUTINE IS GIVEN CONTROL. THIS
0277                         * INVOCATION MAY ALSO BE A BREAKPOINT INTERRUPT.
0278                         * IF SO, THE BREAKPOINT HANDLER IS ENTERED.
0279                         * INPUT: MACHINE STATE DEFINED FOR SWI
0280                         * OUTPUT: VARIES ACCORDING TO FUNCTION CALLED. PC ON
0281                         * CALLERS STACK INCREMENTED BY ONE IF VALID CALL.
0282                         * VOLATILE REGISTERS: SEE FUNCTIONS CALLED
0283                         * STATE: RUNS DISABLED UNLESS FUNCTION CLEARS I FLAG.
0284                         ************************************************
0285                         * SWI FUNCTION VECTOR TABLE
0286 f87d 01 94              SWIVTB  FDB     ZINCH-SWIVTB    ; INCHNP
0287 f87f 01 b1                      FDB     ZOTCH1-SWIVTB   ; OUTCH
0288 f881 01 cb                      FDB     ZPDTA1-SWIVTB   ; PDATA1
0289 f883 01 c3                      FDB     ZPDATA-SWIVTB   ; PDATA
0290 f885 01 75                      FDB     ZOT2HS-SWIVTB   ; OUT2HS
0291 f887 01 73                      FDB     ZOT4HS-SWIVTB   ; OUT4HS
0292 f889 01 c0                      FDB     ZPCRLF-SWIVTB   ; PCRLF
0293 f88b 01 79                      FDB     ZSPACE-SWIVTB   ; SPACE
0294 f88d 00 55                      FDB     ZMONTR-SWIVTB   ; MONITR
0295 f88f 01 7d                      FDB     ZVSWTH-SWIVTB   ; VCTRSW
0296 f891 02 56                      FDB     ZBKPNT-SWIVTB   ; BREAKPOINT
0297 f893 01 d1                      FDB     ZPAUSE-SWIVTB   ; TASK PAUSE
0298                         
0299 f895 6a 8d 67 f7        SWIR    DEC     SWICNT,PCR      ; UP "SWI" LEVEL FOR TRACE
0300 f899 17 02 25                   LBSR    LDDP            ; SETUP PAGE AND VERIFY STACK
0301                         * CHECK FOR BREAKPOINT TRAP
0302 f89c ee 6a                      LDU     10,S            ; LOAD PROGRAM COUNTER
0303 f89e 33 5f                      LEAU    -1,U            ; BACK TO SWI ADDRESS
0304 f8a0 0d fb                      TST     <SWIBFL         ; ? THIS "SWI" BREAKPOINT
0305 f8a2 26 11                      BNE     SWIDNE          ; BRANCH IF SO TO LET THROUGH
0306 f8a4 17 06 9b                   LBSR    CBKLDR          ; OBTAIN BREAKPOINT POINTERS
0307 f8a7 50                         NEGB                    ; OBTAIN POSITIVE COUNT
0308 f8a8 5a                 SWILP   DECB                    ; COUNT DOWN
0309 f8a9 2b 0a                      BMI     SWIDNE          ; BRANCH WHEN DONE
0310 f8ab 11 a3 a1                   CMPU    ,Y++            ; ? WAS THIS A BREAKPOINT
0311 f8ae 26 f8                      BNE     SWILP           ; BRANCH IF NOT
0312 f8b0 ef 6a                      STU     10,S            ; SET PROGRAM COUNTER BACK
0313 f8b2 16 02 1e                   LBRA    ZBKPNT          ; GO DO BREAKPOINT
0314 f8b5 0f fb              SWIDNE  CLR     <SWIBFL         ; CLEAR IN CASE SET
0315 f8b7 37 06                      PULU    D               ; OBTAIN FUNCTION BYTE, UP PC
0316 f8b9 c1 0b                      CMPB    #NUMFUN         ; ? TOO HIGH
0317 f8bb 10 22 02 0f                LBHI    ERROR           ; YES, DO BREAKPOINT
0318 f8bf ef 6a                      STU     10,S            ; BUMP PROGRAM COUNTER PAST SWI
0319 f8c1 58                         ASLB                    ; FUNCTION CODE TIMES TWO
0320 f8c2 33 8c b8                   LEAU    SWIVTB,PCR      ; OBTAIN VECTOR BRANCH ADDRESS
0321 f8c5 ec c5                      LDD     B,U             ; LOAD OFFSET
0322 f8c7 6e cb                      JMP     D,U             ; JUMP TO ROUTINE
0323                         
0324                         **********************************************
0325                         * REGISTERS TO FUNCTION ROUTINES:
0326                         *  DP-> WORK AREA PAGE
0327                         *  D,Y,U=UNRELIABLE           X=AS CALLED FROM USER
0328                         *  S=AS FROM SWI INTERRUPT
0329                         *********************************************
0330                         
0331                         **************************************************
0332                         *            [SWI FUNCTION 8]
0333                         *              MONITOR ENTRY
0334                         *  FIREUP THE ASSIST09 MONITOR.
0335                         *  THE STACK WITH ITS VALUES FOR THE DIRECT PAGE
0336                         *  REGISTER AND CONDITION CODE FLAGS ARE USED AS IS.
0337                         *   1) INITIALIZE CONSOLE I/O
0338                         *   2) OPTIONALLY PRINT SIGNON
0339                         *   3) INITIALIZE PTM FOR SINGLE STEPPING
0340                         *   4) ENTER COMMAND PROCESSOR
0341                         * INPUT: A=0 INIT CONSOLE AND PRINT STARTUP MESSAGE
0342                         *        A#0 OMIT CONSOLE INIT AND STARTUP MESSAGE
0343                         *************************************************
0344                         
0345 f8c9 41 53 53 49 53 54  SIGNON  FCC     /ASSIST09/      ; SIGNON EYE-CATCHER
     30 39
0346 f8d1 04                         FCB     EOT
0347 f8d2 10 df 97           ZMONTR  STS     <RSTACK         ; SAVE FOR BAD STACK RECOVERY
0348 f8d5 6d 61                      TST     1,S             ; ? INIT CONSOLE AND SEND MSG
0349 f8d7 26 0d                      BNE     ZMONT2          ; BRANCH IF NOT
0350 f8d9 ad 9d 67 f9                JSR     [VECTAB+.CION,PCR] ; READY CONSOLE INPUT
0351 f8dd ad 9d 67 fb                JSR     [VECTAB+.COON,PCR] ; READY CONSOLE OUTPUT
0352 f8e1 30 8c e5                   LEAX    SIGNON,PCR         ; READY SIGNON EYE-CATCHER
0353 f8e4 3f                         SWI                     ; PERFORM
0354 f8e5 03                         FCB     PDATA           ; PRINT STRING
0355 f8e6 9e f6              ZMONT2  LDX     <VECTAB+.PTM    ; LOAD PTM ADDRESS
0356 f8e8 27 0d                      BEQ     CMD             ; BRANCH IF NOT TO USE A PTM
0357 f8ea 6f 02                      CLR     PTMTM1-PTM,X    ; SET LATCH TO CLEAR RESET
0358 f8ec 6f 03                      CLR     PTMTM1+1-PTM,X  ; AND SET GATE HIGH
0359 f8ee cc 01 a6                   LDD     #$01A6          ; SETUP TIMER 1 MODE
0360 f8f1 a7 01                      STA     PTMC2-PTM,X     ; SETUP FOR CONTROL REGISTER1
0361 f8f3 e7 84                      STB     PTMC13-PTM,X    ; SET OUTPUT ENABLED/
0362                         * SINGLE SHOT/ DUAL 8 BIT/INTERNAL MODE/OPERATE
0363 f8f5 6f 01                      CLR     PTMC2-PTM,X     ; SET CR2 BACK TO RESET FORM
0364                         * FALL INTO COMMAND PROCESSOR
0365                         
0366                         ***************************************************
0367                         *          COMMAND HANDLER
0368                         *  BREAKPOINTS ARE REMOVED AT THIS TIME.
0369                         *  PROMPT FOR A COMMAND, AND STORE ALL CHARACTERS
0370                         *  UNTIL A SEPARATOR ON THE STACK.
0371                         *  SEARCH FOR FIRST MATCHING COMMAND SUBSET,
0372                         *  CALL IT OR GIVE '?' RESPONSE.
0373                         *  DURING COMMAND SEARCH:
0374                         *      B=OFFSET TO NEXT ENTRY ON X
0375                         *      U=SAVED S
0376                         *      U-1=ENTRY SIZE+2
0377                         *      U-2=VALID NUMBER FLAG (>=0 VALID)/COMPARE CNT
0378                         *      U-3=CARRIAGE RETURN FLAG (0=CR HAS BEEN DONE)
0379                         *      U-4=START OF COMMAND STORE
0380                         *      S+0=END OF COMMAND STORE
0381                         ***********************************************
0382                         
0383 f8f7 3f                 CMD     SWI                     ; TO NEW LINE
0384 f8f8 06                         FCB     PCRLF           ; FUNCTION
0385                         * DISARM THE BREAKPOINTS
0386 f8f9 17 06 46           CMDNEP  LBSR    CBKLDR          ; OBTAIN BREAKPOINT POINTERS
0387 f8fc 2a 0c                      BPL     CMDNOL          ; BRANCH IF NOT ARMED OR NONE
0388 f8fe 50                         NEGB                    ; MAKE POSITIVE
0389 f8ff d7 fa                      STB     <BKPTCT         ; FLAG AS DISARMED
0390 f901 5a                 CMDDDL  DECB                    ; ? FINISHED
0391 f902 2b 06                      BMI     CMDNOL          ; BRANCH IF SO
0392 f904 a6 30                      LDA     -NUMBKP*2,Y     ; LOAD OPCODE STORED
0393 f906 a7 b1                      STA     [,Y++]          ; STORE BACK OVER "SWI"
0394 f908 20 f7                      BRA     CMDDDL          ; LOOP UNTIL DONE
0395 f90a ae 6a              CMDNOL  LDX     10,S            ; LOAD USERS PROGRAM COUNTER
0396 f90c 9f 93                      STX     <PCNTER         ; SAVE FOR EXPRESSION ANALYZER
0397 f90e 86 3e                      LDA     #PROMPT         ; LOAD PROMPT CHARACTER
0398 f910 3f                         SWI                     ; SEND TO OUTPUT HANDLER
0399 f911 01                         FCB     OUTCH           ; FUNCTION
0400 f912 33 e4                      LEAU    ,S              ; REMEMBER STACK RESTORE ADDRESS
0401 f914 df 95                      STU     <PSTACK         ; REMEMBER STACK FOR ERROR USE
0402 f916 4f                         CLRA                    ; PREPARE ZERO
0403 f917 5f                         CLRB                    ; PREPARE ZERO
0404 f918 dd 9b                      STD     <NUMBER         ; CLEAR NUMBER BUILD AREA
0405 f91a dd 8f                      STD     <MISFLG         ; CLEAR MISCEL. AND SWICNT FLAGS
0406 f91c dd 91                      STD     <TRACEC         ; CLEAR TRACE COUNT
0407 f91e c6 02                      LDB     #2              ; SET D TO TWO
0408 f920 34 07                      PSHS    D,CC            ; PLACE DEFAULTS ONTO STACK
0409                         * CHECK FOR "QUICK" COMMANDS.
0410 f922 17 04 54                   LBSR    READ            ; OBTAIN FIRST CHARACTER
0411 f925 30 8d 05 81                LEAX    CDOT+2,PCR      ; PRESET FOR SINGLE TRACE
0412 f929 81 2e                      CMPA    #'.             ; ? QUICK TRACE
0413 f92b 27 5a                      BEQ     CMDXQT          ; BRANCH EQUAL FOR TRACE ONE
0414 f92d 30 8d 04 e9                LEAX    CMPADP+2,PCR    ; READY MEMORY ENTRY POINT
0415 f931 81 2f                      CMPA    #'/             ; ? OPEN LAST USED MEMORY
0416 f933 27 52                      BEQ     CMDXQT          ; BRANCH TO DO IT IF SO
0417                         * PROCESS NEXT CHARACTER
0418 f935 81 20              CMD2    CMPA    #'              ; ? BLANK OR DELIMITER
0419 f937 23 14                      BLS    CMDGOT           ; BRANCH YES, WE HAVE IT
0420 f939 34 02                      PSHS   A                ; BUILD ONTO STACK
0421 f93b 6c 5f                      INC    -1,U             ; COUNT THIS CHARACTER
0422 f93d 81 2f                      CMPA   #'/              ; ? MEMORY COMMAND
0423 f93f 27 4f                      BEQ    CMDMEM           ; BRANCH IF SO
0424 f941 17 04 0b                   LBSR   BLDHXC           ; TREAT AS HEX VALUE
0425 f944 27 02                      BEQ    CMD3             ; BRANCH IF STILL VALID NUMBER
0426 f946 6a 5e                      DEC    -2,U             ; FLAG AS INVALID NUMBER
0427 f948 17 04 2e           CMD3    LBSR   READ             ; OBTAIN NEXT CHARACTER
0428 f94b 20 e8                      BRA    CMD2             ; TEST NEXT CHARACTER
0429                         * GOT COMMAND, NOW SEARCH TABLES
0430 f94d 80 0d              CMDGOT  SUBA   #CR              ; SET ZERO IF CARRIAGE RETURN
0431 f94f a7 5d                      STA    -3,U             ; SETUP FLAG
0432 f951 9e c4                      LDX    <VECTAB+.CMDL1   ; START WITH FIRST CMD LIST
0433 f953 e6 80              CMDSCH  LDB    ,X+              ; LOAD ENTRY LENGTH
0434 f955 2a 10                      BPL    CMDSME           ; BRANCH IF NOT LIST END
0435 f957 9e ee                      LDX    <VECTAB+.CMDL2   ; NOW TO SECOND CMD LITS
0436 f959 5c                         INCB                    ; ? TO CONTINUE TO DEFAULT LIST
0437 f95a 27 f7                      BEQ     CMDSCH          ; BRANCH IF SO
0438 f95c 10 de 95           CMDBAD  LDS     <PSTACK         ; RESTORE STACK
0439 f95f 30 8d 01 5a                LEAX    ERRMSG,PCR      ; POINT TO ERROR STRING
0440 f963 3f                         SWI                     ; SEND OUT
0441 f964 02                         FCB     PDATA1          ; TO CONSOLE
0442 f965 20 90                      BRA     CMD             ; AND TRY AGAIN
0443                         * SEARCH NEXT ENTRY
0444 f967 5a                 CMDSME  DECB                    ; TAKE ACCOUNT OF LENGTH BYTE
0445 f968 e1 5f                      CMPB    -1,U            ; ? ENTERED LONGER THAN ENTRY
0446 f96a 24 03                      BHS     CMDSIZ          ; BRANCH IF NOT TOO LONG
0447 f96c 3a                 CMDFLS  ABX                     ; SKIP TO NEXT ENTRY
0448 f96d 20 e4                      BRA     CMDSCH          ; AND TRY NEXT
0449 f96f 31 5d              CMDSIZ  LEAY    -3,U            ; PREPARE TO COMPARE
0450 f971 a6 5f                      LDA     -1,U            ; LOAD SIZE+2
0451 f973 80 02                      SUBA    #2              ; TO ACTUAL SIZE ENTERED
0452 f975 a7 5e                      STA     -2,U            ; SAVE SIZE FOR COUNTDOWN
0453 f977 5a                 CMDCMP  DECB                    ; DOWN ONE BYTE
0454 f978 a6 80                      LDA     ,X+             ; NEXT COMMAND CHARACTER
0455 f97a a1 a2                      CMPA    ,-Y             ; ? SAME AS THAT ENTERED
0456 f97c 26 ee                      BNE     CMDFLS          ; BRANCH TO FLUSH IF NOT
0457 f97e 6a 5e                      DEC     -2,U            ; COUNT DOWN LENGTH OF ENTRY
0458 f980 26 f5                      BNE     CMDCMP          ; BRANCH IF MORE TO TEST
0459 f982 3a                         ABX                     ; TO NEXT ENTRY
0460 f983 ec 1e                      LDD     -2,X            ; LOAD OFFSET
0461 f985 30 8b                      LEAX    D,X             ; COMPUTE ROUTINE ADDRESS+2
0462 f987 6d 5d              CMDXQT  TST     -3,U            ; SET CC FOR CARRIAGE RETURN TEST
0463 f989 32 c4                      LEAS    ,U              ; DELETE STACK WORK AREA
0464 f98b ad 1e                      JSR     -2,X            ; CALL COMMAND
0465 f98d 16 ff 7a                   LBRA    CMDNOL          ; GO GET NEXT COMMAND
0466 f990 6d 5e              CMDMEM  TST     -2,U            ; ? VALID HEX NUMBER ENTERED
0467 f992 2b c8                      BMI     CMDBAD          ; BRANCH ERROR IF NOT
0468 f994 30 88 ae                   LEAX    <CMEMN-CMPADP,X ; TO DIFFERENT ENTRY
0469 f997 dc 9b                      LDD     <NUMBER         ; LOAD NUMBER ENTERED
0470 f999 20 ec                      BRA     CMDXQT          ; AND ENTER MEMORY COMMAND
0471                         
0472                         ** COMMANDS ARE ENTERED AS A SUBROUTINE WITH:
0473                         **    DPR->ASSIST09 DIRECT PAGE WORK AREA
0474                         **    Z=1 CARRIAGE RETURN ENTERED
0475                         **    Z=0 NON CARRIAGE RETURN DELIMITER
0476                         **    S=NORMAL RETURN ADDRESS
0477                         ** THE LABEL "CMDBAD" MAY BE ENTERED TO ISSUE AN
0478                         ** AN ERROR FLAG (*).
0479                         **************************************************
0480                         *       ASSIST09 COMMAND TABLES
0481                         * THESE ARE THE DEFAULT COMMAND TABLES. EXTERNAL
0482                         * TABLES OF THE SAME FORMAT MAY EXTEND/REPLACE
0483                         * THESE BY USING THE VECTOR SWAP FUNCTION.
0484                         *
0485                         * ENTRY FORMAT:
0486                         *    +0...TOTAL SIZE OF ENTRY (INCLUDING THIS BYTE)
0487                         *    +1...COMMAND STRING
0488                         *    +N...TWO BYTE OFFSET TO COMMAND (ENTRYADDR-*)
0489                         *
0490                         * THE TABLES TERMINATE WITH A ONE BYTE -1 OR -2.
0491                         * THE -1 CONTINUES THE COMMAND SEARCH WITH THE
0492                         *        SECOND COMMAND TABLE.
0493                         * THE -2 TERMINATES COMMAND SEARCHES.
0494                         *****************************************************
0495                         
0496                         * THIS IS THE DEFAULT LIST FOR THE SECOND COMMAND
0497                         * LIST ENTRY.
0498                         
0499 f99b fe                 CMDTB2  FCB     -2              ; STOP COMMAND SEARCHES
0500                         
0501                         * THIS IS THE DEFAULT LIST FOR THE FIRST COMMAND
0502                         * LIST ENTRY.
0503                         
0504 f99c                    CMDTBL  EQU     *               ; MONITOR COMMAND TABLE
0505 f99c 04                         FCB     4
0506 f99d 42                         FCC     /B/             ; 'BREAKPOINT' COMMAND
0507 f99e 05 4d                      FDB     CBKPT-*
0508 f9a0 04                         FCB     4
0509 f9a1 43                         FCC     /C/             ; 'CALL' COMMAND
0510 f9a2 04 17                      FDB     CCALL-*
0511 f9a4 04                         FCB     4
0512 f9a5 44                         FCC     /D/             ; 'DISPLAY' COMMAND
0513 f9a6 04 9d                      FDB     CDISP-*
0514 f9a8 04                         FCB     4
0515 f9a9 45                         FCC     /E/             ; 'ENCODE' COMMAND
0516 f9aa 05 9f                      FDB     CENCDE-*
0517 f9ac 04                         FCB     4
0518 f9ad 47                         FCC     /G/             ; 'GO' COMMAND
0519 f9ae 03 d2                      FDB     CGO-*
0520 f9b0 04                         FCB     4
0521 f9b1 4c                         FCC     /L/             ; 'LOAD' COMMAND
0522 f9b2 04 dd                      FDB     CLOAD-*
0523 f9b4 04                         FCB     4
0524 f9b5 4d                         FCC     /M/             ; 'MEMORY' COMMAND
0525 f9b6 04 0d                      FDB     CMEM-*
0526 f9b8 04                         FCB     4
0527 f9b9 4e                         FCC     /N/             ; 'NULLS' COMMAND
0528 f9ba 04 fd                      FDB     CNULLS-*
0529 f9bc 04                         FCB     4
0530 f9bd 4f                         FCC     /O/             ; 'OFFSET' COMMAND
0531 f9be 05 0a                      FDB     COFFS-*
0532 f9c0 04                         FCB     4
0533 f9c1 50                         FCC     /P/             ; 'PUNCH' COMMAND
0534 f9c2 04 af                      FDB     CPUNCH-*
0535 f9c4 04                         FCB     4
0536 f9c5 52                         FCC     /R/             ; 'REGISTERS' COMMAND
0537 f9c6 02 84                      FDB     CREG-*
0538 f9c8 04                         FCB     4
0539 f9c9 53                         FCC     /S/             ; 'STLEVEL' COMMAND
0540 f9ca 04 f2                      FDB     CSTLEV-*
0541 f9cc 04                         FCB     4
0542 f9cd 54                         FCC     /T/             ; 'TRACE' COMMAND
0543 f9ce 04 d6                      FDB     CTRACE-*
0544 f9d0 04                         FCB     4
0545 f9d1 56                         FCC     /V/             ; 'VERIFY' COMMAND
0546 f9d2 04 cf                      FDB     CVER-*
0547 f9d4 04                         FCB     4
0548 f9d5 57                         FCC     /W/             ; 'WINDOW' COMMAND
0549 f9d6 04 68                      FDB     CWINDO-*
0550 f9d8 ff                         FCB     -1              ; END, CONTINUE WITH THE SECOND
0551                         
0552                         *************************************************
0553                         *             [SWI FUNCTIONS 4 AND 5]
0554                         *      4 - OUT2HS - DECODE BYTE TO HEX AND ADD SPACE
0555                         *      5 - OUT4HS - DECODE WORD TO HEX AND ADD SPACE
0556                         * INPUT: X->BYTE OR WORD TO DECODE
0557                         * OUTPUT: CHARACTERS SENT TO OUTPUT HANDLER
0558                         *         X->NEXT BYTE OR WORD
0559                         *************************************************
0560 f9d9 a6 80              ZOUT2H  LDA     ,X+             ; LOAD NEXT BYTE
0561 f9db 34 06                      PSHS    D               ; SAVE - DO NOT REREAD
0562 f9dd c6 10                      LDB     #16             ; SHIFT BY 4 BITS
0563 f9df 3d                         MUL                     ; WITH MULTIPLY
0564 f9e0 8d 04                      BSR     ZOUTHX          ; SEND OUT AS HEX
0565 f9e2 35 06                      PULS    D               ; RESTORE BYTES
0566 f9e4 84 0f                      ANDA    #$0F            ; ISOLATE RIGHT HEX
0567 f9e6 8b 90              ZOUTHX  ADDA    #$90            ; PREPARE A-F ADJUST
0568 f9e8 19                         DAA                     ; ADJUST
0569 f9e9 89 40                      ADCA    #$40            ; PREPARE CHARACTER BITS
0570 f9eb 19                         DAA                     ; ADJUST
0571 f9ec 6e 9d 66 ee        SEND    JMP     [VECTAB+.CODTA,PCR] ; SEND TO OUT HANDLER
0572                         
0573 f9f0 8d e7              ZOT4HS  BSR     ZOUT2H          ; CONVERT FIRST BYTE
0574 f9f2 8d e5              ZOT2HS  BSR     ZOUT2H          ; CONVERT BYTE TO HEX
0575 f9f4 af 64                      STX     4,S             ; UPDATE USERS X REGISTER
0576                         * FALL INTO SPACE ROUTINE
0577                         
0578                         *************************************************
0579                         *            [SWI FUNCTION 7]
0580                         *         SPACE - SEND BLANK TO OUTPUT HANDLER
0581                         * INPUT: NONE
0582                         * OUTPUT: BLANK SEND TO CONSOLE HANDLER
0583                         *************************************************
0584 f9f6 86 20              ZSPACE  LDA     #'              ; LOAD BLANK
0585 f9f8 20 3d                      BRA     ZOTCH2          ; SEND AND RETURN
0586                         
0587                         ***********************************************
0588                         *             [SWI FUNCTION 9]
0589                         *          SWAP VECTOR TABLE ENTRY
0590                         * INPUT: A=VECTOR TABLE CODE (OFFSET)
0591                         * X=0 OR REPLACEMENT VALUE
0592                         * OUTPUT: X=PREVIOUS VALUE
0593                         ***********************************************
0594 f9fa a6 61              ZVSWTH  LDA     1,S             ; LOAD REQUESTERS A
0595 f9fc 81 34                      CMPA    #HIVTR          ; ? SUB-CODE TOO HIGH
0596 f9fe 22 39                      BHI     ZOTCH3          ; IGNORE CALL IF SO
0597 fa00 10 9e c2                   LDY     <VECTAB+.AVTBL  ; LOAD VECTOR TABLE ADDRESS
0598 fa03 ee a6                      LDU     A,Y             ; U=OLD ENTRY
0599 fa05 ef 64                      STU     4,S             ; RETURN OLD VALUE TO CALLERS X
0600 fa07 af 7e                      STX     -2,S            ; ? X=0
0601 fa09 27 2e                      BEQ     ZOTCH3          ; YES, DO NOT CHANGE ENTRY
0602 fa0b af a6                      STX     A,Y             ; REPLACE ENTRY
0603 fa0d 20 2a                      BRA     ZOTCH3          ; RETURN FROM SWI
0604                         *D
0605                         
0606                         ************************************************
0607                         *               [SWI FUNCTION 0]
0608                         *  INCHNP - OBTAIN INPUT CHAR IN A (NO PARITY)
0609                         * NULLS AND RUBOUTS ARE IGNORED.
0610                         * AUTOMATIC LINE FEED IS SENT UPON RECEIVING A
0611                         * CARRIAGE RETURN.
0612                         * UNLESS WE ARE LOADING FROM TAPE.
0613                         ************************************************
0614 fa0f 8d 5d              ZINCHP  BSR     XQPAUS          ; RELEASE PROCESSOR
0615 fa11 8d 5f              ZINCH   BSR     XQCIDT          ; CALL INPUT DATA APPENDAGE
0616 fa13 24 fa                      BCC     ZINCHP          ; LOOP IF NONE AVAILABLE
0617 fa15 4d                         TSTA                    ; ? TEST FOR NULL
0618 fa16 27 f9                      BEQ     ZINCH           ; IGNORE NULL
0619 fa18 81 7f                      CMPA    #$7F            ; ? RUBOUT
0620 fa1a 27 f5                      BEQ     ZINCH           ; BRANCH YES TO IGNORE
0621 fa1c a7 61                      STA     1,S             ; STORE INTO CALLERS A
0622 fa1e 0d 8f                      TST     <MISFLG         ; ? LOAD IN PROGRESS
0623 fa20 26 17                      BNE     ZOTCH3          ; BRANCH IF SO TO NOT ECHO
0624 fa22 81 0d                      CMPA    #CR             ; ? CARRIAGE RETURN
0625 fa24 26 04                      BNE     ZIN2            ; NO, TEST ECHO BYTE
0626 fa26 86 0a                      LDA     #LF             ; LOAD LINE FEED
0627 fa28 8d c2                      BSR     SEND            ; ALWAYS ECHO LINE FEED
0628 fa2a 0d f4              ZIN2    TST     <VECTAB+.ECHO   ; ? ECHO DESIRED
0629 fa2c 26 0b                      BNE     ZOTCH3          ; NO, RETURN
0630                         * FALL THROUGH TO OUTCH
0631                         ************************************************
0632                         *            [SWI FUNCTION 1]
0633                         *        OUTCH - OUTPUT CHARACTER FROM A
0634                         * INPUT: NONE
0635                         * OUTPUT: IF LINEFEED IS THE OUTPUT CHARACTER THEN
0636                         * C=0 NO CTL-X RECEIVED, C=1 CTL-X RECEIVED
0637                         ************************************************
0638 fa2e a6 61              ZOTCH1  LDA     1,S             ; LOAD CHARACTER TO SEND
0639 fa30 30 8c 09                   LEAX    <ZPCRLS,PCR     ; DEFAULT FOR LINE FEED
0640 fa33 81 0a                      CMPA    #LF             ; ? LINE FEED
0641 fa35 27 0f                      BEQ     ZPDTLP          ; BRANCH TO CHECK PAUSE IF SO
0642 fa37 8d b3              ZOTCH2  BSR     SEND            ; SEND TO OUTPUT ROUTINE
0643 fa39 0c 90              ZOTCH3  INC     <SWICNT         ; BUMP UP "SWI" TRACE NEST LEVEL
0644 fa3b 3b                         RTI                     ; RETURN FROM "SWI" FUNCTION
0645                         
0646                         **************************************************
0647                         * [SWI FUNCTION 6]
0648                         * PCRLF - SEND CR/LF TO CONSOLE HANDLER
0649                         * INPUT: NONE
0650                         * OUTPUT: CR AND LF SENT TO HANDLER
0651                         * C=0 NO CTL-X, C=1 CTL-X RECEIVED
0652                         **************************************************
0653 fa3c 04                 ZPCRLS  FCB     EOT             ; NULL STRING
0654 fa3d 30 8c fc           ZPCRLF LEAX     ZPCRLS,PCR      ; READY CR,LF STRING
0655                         * FALL INTO CR/LF CODE
0656                         
0657                         **************************************************
0658                         * [SWI FUNCTION 3]
0659                         * PDATA - OUTPUT CR/LF AND STRING
0660                         * INPUT: X->STRING
0661                         * OUTPUT: CR/LF AND STRING SENT TO OUTPUT CONSOLE
0662                         * HANDLER.
0663                         * C=0 NO CTL-X, C=1 CTL-X RECEIVED
0664                         * NOTE: LINE FEED MUST FOLLOW CARRIAGE RETURN FOR
0665                         * PROPER PUNCH DATA.
0666                         **************************************************
0667                         
0668 fa40 86 0d              ZPDATA  LDA     #CR             ; LOAD CARRIAGE RETURN
0669 fa42 8d a8                      BSR     SEND            ; SEND IT
0670 fa44 86 0a                      LDA     #LF             ; LOAD LINE FEED
0671                         * FALL INTO PDATA1
0672                         
0673                         *************************************************
0674                         * [SWI FUNCTION 2]
0675                         * PDATA1 - OUTPUT STRING TILL EOT ($04)
0676                         * THIS ROUTINE PAUSES IF AN INPUT BYTE BECOMES
0677                         * AVAILABLE DURING OUTPUT TRANSMISSION UNTIL A
0678                         * SECOND IS RECEIVED.
0679                         * INPUT: X->STRING
0680                         * OUTPUT: STRING SENT TO OUTPUT CONSOLE DRIVER
0681                         * C=0 NO CTL-X, C=1 CTL-X RECEIVED
0682                         *************************************************
0683                         
0684 fa46 8d a4              ZPDTLP  BSR     SEND            ; SEND CHARACTER TO DRIVER
0685 fa48 a6 80              ZPDTA1  LDA     ,X+             ; LOAD NEXT CHARACTER
0686 fa4a 81 04                      CMPA    #EOT            ; ? EOT
0687 fa4c 26 f8                      BNE     ZPDTLP          ; LOOP IF NOT
0688                         * FALL INTO PAUSE CHECK FUNCTION
0689                         
0690                         ********************************************
0691                         * [SWI FUNCTION 12]
0692                         * PAUSE - RETURN TO TASK DISPATCHING AND CHECK
0693                         * FOR FREEZE CONDITION OR CTL-X BREAK
0694                         * THIS FUNCTION ENTERS THE TASK PAUSE HANDLER SO
0695                         * OPTIONALLY OTHER 6809 PROCESSES MAY GAIN CONTROL.
0696                         * UPON RETURN, CHECK FOR A 'FREEZE' CONDITION
0697                         * WITH A RESULTING WAIT LOOP, OR CONDITION CODE
0698                         * RETURN IF A CONTROL-X IS ENTERED FROM THE INPUT
0699                         * HANDLER.
0700                         * OUTPUT: C=1 IF CTL-X HAS ENTERED, C=0 OTHERWISE
0701                         ******************************************
0702                         
0703 fa4e 8d 1e              ZPAUSE  BSR     XQPAUS          ; RELEASE CONTROL AT EVERY LINE
0704 fa50 8d 06                      BSR     CHKABT          ; CHECK FOR FREEZE OR ABORT
0705 fa52 1f a9                      TFR     CC,B            ; PREPARE TO REPLACE CC
0706 fa54 e7 e4                      STB     ,S              ; OVERLAY OLD ONE ON STACK
0707 fa56 20 e1                      BRA     ZOTCH3          ; RETURN FROM "SWI"
0708                         
0709                         * CHKABT - SCAN FOR INPUT PAUSE/ABORT DURING OUTPUT
0710                         * OUTPUT: C=0 OK, C=1 ABORT (CTL-X ISSUED)
0711                         * VOLATILE: U,X,D
0712 fa58 8d 18              CHKABT  BSR     XQCIDT          ; ATTEMPT INPUT
0713 fa5a 24 05                      BCC     CHKRTN          ; BRANCH NO TO RETURN
0714 fa5c 81 18                      CMPA    #CAN            ; ? CTL-X FOR ABORT
0715 fa5e 26 02                      BNE     CHKWT           ; BRANCH NO TO PAUSE
0716 fa60 53                 CHKSEC  COMB                    ; SET CARRY
0717 fa61 39                 CHKRTN  RTS                     ; RETURN TO CALLER WITH CC SET
0718 fa62 8d 0a              CHKWT   BSR     XQPAUS          ; PAUSE FOR A MOMENT
0719 fa64 8d 0c                      BSR     XQCIDT          ; ? KEY FOR START
0720 fa66 24 fa                      BCC     CHKWT           ; LOOP UNTIL RECEIVED
0721 fa68 81 18                      CMPA    #CAN            ; ? ABORT SIGNALED FROM WAIT
0722 fa6a 27 f4                      BEQ     CHKSEC          ; BRANCH YES
0723 fa6c 4f                         CLRA                    ; SET C=0 FOR NO ABORT
0724 fa6d 39                         RTS                     ; AND RETURN
0725                         
0726                         * SAVE MEMORY WITH JUMPS
0727 fa6e 6e 9d 66 78        XQPAUS  JMP   [VECTAB+.PAUSE,PCR] ; TO PAUSE ROUTINE
0728 fa72 ad 9d 66 62        XQCIDT  JSR   [VECTAB+.CIDTA,PCR] ; TO INPUT ROUTINE
0729 fa76 84 7f                      ANDA  #$7F              ; STRIP PARITY
0730 fa78 39                         RTS                     ; RETURN TO CALLER
0731                         
0732                         ********************************************
0733                         * NMI DEFAULT INTERRUPT HANDLER
0734                         * THE NMI HANDLER IS USED FOR TRACING INSTRUCTIONS.
0735                         * TRACE PRINTOUTS OCCUR ONLY AS LONG AS THE STACK
0736                         * TRACE LEVEL IS NOT BREACHED BY FALLING BELOW IT.
0737                         * TRACING CONTINUES UNTIL THE COUNT TURNS ZERO OR
0738                         * A CTL-X IS ENTERED FROM THE INPUT CONSOLE DEVICE.
0739                         *********************************************
0740                         
0741 fa79 4f 50 2d 04        MSHOWP  FCB     'O,'P,'-,EOT    ; OPCODE PREP
0742                         
0743 fa7d 8d 42              NMIR    BSR     LDDP            ; LOAD PAGE AND VERIFY STACK
0744 fa7f 0d 8f                      TST     <MISFLG         ; ? THRU A BREAKPOINT
0745 fa81 26 34                      BNE     NMICON          ; BRANCH IF SO TO CONTINUE
0746 fa83 0d 90                      TST     <SWICNT         ; ? INHIBIT "SWI" DURING TRACE
0747 fa85 2b 29                      BMI     NMITRC          ; BRANCH YES
0748 fa87 30 6c                      LEAX    12,S            ; OBTAIN USERS STACK POINTER
0749 fa89 9c f8                      CMPX    <SLEVEL         ; ? TO TRACE HERE
0750 fa8b 25 23                      BLO     NMITRC          ; BRANCH IF TOO LOW TO DISPLAY
0751 fa8d 30 8c e9                   LEAX    MSHOWP,PCR      ; LOAD OP PREP
0752 fa90 3f                         SWI                     ; SEND TO CONSOLE
0753 fa91 02                         FCB     PDATA1          ; FUNCTION
0754 fa92 09 8e                      ROL     <DELIM          ; SAVE CARRY BIT
0755 fa94 30 8d 66 01                LEAX    LASTOP,PCR      ; POINT TO LAST OP
0756 fa98 3f                         SWI                     ; SEND OUT AS HEX
0757 fa99 05                         FCB     OUT4HS          ; FUNCTION
0758 fa9a 8d 17                      BSR     REGPRS          ; FOLLOW MEMORY WITH REGISTERS
0759 fa9c 25 37                      BCS     ZBKCMD          ; BRANCH IF "CANCEL"
0760 fa9e 06 8e                      ROR     <DELIM          ; RESTORE CARRY BIT
0761 faa0 25 33                      BCS     ZBKCMD          ; BRANCH IF "CANCEL"
0762 faa2 9e 91                      LDX     <TRACEC         ; LOAD TRACE COUNT
0763 faa4 27 2f                      BEQ     ZBKCMD          ; IF ZERO TO COMMAND HANDLER
0764 faa6 30 1f                      LEAX    -1,X            ; MINUS ONE
0765 faa8 9f 91                      STX     <TRACEC         ; REFRESH
0766 faaa 27 29                      BEQ     ZBKCMD          ; STOP TRACE WHEN ZERO
0767 faac 8d aa                      BSR     CHKABT          ; ? ABORT THE TRACE
0768 faae 25 25                      BCS     ZBKCMD          ; BRANCH YES TO COMMAND HANDLER
0769 fab0 16 03 f7           NMITRC  LBRA    CTRCE3          ; NO, TRACE ANOTHER INSTRUCTION
0770                         
0771 fab3 17 01 b9           REGPRS  LBSR    REGPRT          ; PRINT REGISTERS AS FROM COMMAND
0772 fab6 39                         RTS                     ; RETURN TO CALLER
0773                         
0774                         * JUST EXECUTED THRU A BRKPNT. NOW CONTINUE NORMALLY
0775                         
0776 fab7 0f 8f              NMICON  CLR     <MISFLG        ; CLEAR THRU FLAG
0777 fab9 17 02 eb                   LBSR    ARMBK2         ; ARM BREAKPOINTS
0778 fabc 3b                 RTI     RTI                    ; AND CONTINUE USERS PROGRAM
0779                         
0780                         * LDDP - SETUP DIRECT PAGE REGISTER, VERIFY STACK.
0781                         * AN INVALID STACK CAUSES A RETURN TO THE COMMAND
0782                         * HANDLER.
0783                         * INPUT: FULLY STACKED REGISTERS FROM AN INTERRUPT
0784                         * OUTPUT: DPR LOADED TO WORK PAGE
0785                         
0786 fabd 3f 07 20 04        ERRMSG  FCB     '?,BELL,$20,EOT ; ERROR RESPONSE
0787                         
0788 fac1 e6 8d 65 d8        LDDP    LDB     BASEPG,PCR      ; LOAD DIRECT PAGE HIGH BYTE
0789 fac5 1f 9b                      TFR     B,DP            ; SETUP DIRECT PAGE REGISTER
0790 fac7 a1 63                      CMPA    3,S             ; ? IS STACK VALID
0791 fac9 27 25                      BEQ     RTS             ; YES, RETURN
0792 facb 10 de 97                   LDS     <RSTACK         ; RESET TO INITIAL STACK POINTER
0793 face 30 8c ec           ERROR   LEAX    ERRMSG,PCR      ; LOAD ERROR REPORT
0794 fad1 3f                         SWI                     ; SEND OUT BEFORE REGISTERS
0795 fad2 03                         FCB     PDATA           ; ON NEXT LINE
0796                         * FALL INTO BREAKPOINT HANDLER
0797                         
0798                         **********************************************
0799                         * [SWI FUNCTION 10]
0800                         * BREAKPOINT PROGRAM FUNCTION
0801                         * PRINT REGISTERS AND GO TO COMMAND HANLER
0802                         ***********************************************
0803                         
0804 fad3 8d de              ZBKPNT  BSR     REGPRS          ; PRINT OUT REGISTERS
0805 fad5 16 fe 21           ZBKCMD  LBRA    CMDNEP          ; NOW ENTER COMMAND HANDLER
0806                         
0807                         ********************************************
0808                         * IRQ, RESERVED, SWI2 AND SWI3 INTERRUPT HANDLERS
0809                         * THE DEFAULT HANDLING IS TO CAUSE A BREAKPOINT.
0810                         ********************************************
0811 fad8                    SWI2R   EQU     *               ; SWI2 ENTRY
0812 fad8                    SWI3R   EQU     *               ; SWI3 ENTRY
0813 fad8                    IRQR    EQU     *               ; IRQ ENTRY
0814 fad8 8d e7              RSRVDR  BSR     LDDP            ; SET BASE PAGE, VALIDATE STACK
0815 fada 20 f7                      BRA     ZBKPNT          ; FORCE A BREAKPOINT
0816                         
0817                         ******************************************
0818                         * FIRQ HANDLER
0819                         * JUST RETURN FOR THE FIRQ INTERRUPT
0820                         ******************************************
0821 fabc                    FIRQR   EQU     RTI             ; IMMEDIATE RETURN
0822                         
0823                         **************************************************
0824                         * DEFAULT I/O DRIVERS
0825                         **************************************************
0826                         * CIDTA - RETURN CONSOLE INPUT CHARACTER
0827                         * OUTPUT: C=0 IF NO DATA READY, C=1 A=CHARACTER
0828                         * U VOLATILE
0829                         
0830 fadc de f0              CIDTA   LDU     <VECTAB+.ACIA   ; LOAD ACIA ADDRESS
0831 fade a6 c4                      LDA     ,U              ; LOAD STATUS REGISTER
0832 fae0 44                         LSRA                    ; TEST RECEIVER REGISTER FLAG
0833 fae1 24 02                      BCC     CIRTN           ; RETURN IF NOTHING
0834 fae3 a6 41                      LDA     1,U             ; LOAD DATA BYTE
0835 fae5 39                 CIRTN   RTS                     ; RETURN TO CALLER
0836                         
0837                         * CION - INPUT CONSOLE INITIALIZATION
0838                         * COON - OUTPUT CONSOLE INITIALIZATION
0839                         * A,X VOLATILE
0840 fae6                    CION   EQU      *
0841 fae6 86 13              COON   LDA      #$13            ; RESET ACIA CODE
0842 fae8 9e f0                     LDX      <VECTAB+.ACIA   ; LOAD ACIA ADDRESS
0843 faea a7 84                     STA      ,X              ; STORE INTO STATUS REGISTER
0844 faec 86 15                     LDA      #$15            ; SET CONTROL
0845 faee a7 84                     STA      ,X              ; REGISTER UP
0846 faf0 39                 RTS    RTS                      ; RETURN TO CALLER
0847                         
0848                         * THE FOLLOWING HAVE NO DUTIES TO PERFORM
0849 faf0                    CIOFF EQU       RTS             ; CONSOLE INPUT OFF
0850 faf0                    COOFF EQU       RTS             ; CONSOLE OUTPUT OFF
0851                         
0852                         * CODTA - OUTPUT CHARACTER TO CONSOLE DEVICE
0853                         * INPUT: A=CHARACTER TO SEND
0854                         * OUTPUT: CHAR SENT TO TERMINAL WITH PROPER PADDING
0855                         * ALL REGISTERS TRANSPARENT
0856                         
0857 faf1 34 47              CODTA   PSHS    U,D,CC          ; SAVE REGISTERS,WORK BYTE
0858 faf3 de f0                      LDU     <VECTAB+.ACIA   ; ADDRESS ACIA
0859 faf5 8d 1b                      BSR     CODTAO          ; CALL OUTPUT CHAR SUBROUTINE
0860 faf7 81 10                      CMPA    #DLE            ; ? DATA LINE ESCAPE
0861 faf9 27 12                      BEQ     CODTRT          ; YES, RETURN
0862 fafb d6 f2                      LDB     <VECTAB+.PAD    ; DEFAULT TO CHAR PAD COUNT
0863 fafd 81 0d                      CMPA    #CR             ; ? CR
0864 faff 26 02                      BNE     CODTPD          ; BRANCH NO
0865 fb01 d6 f3                      LDB     <VECTAB+.PAD+1  ; LOAD NEW LINE PAD COUNT
0866 fb03 4f                 CODTPD  CLRA                    ; CREATE NULL
0867 fb04 e7 e4                      STB     ,S              ; SAVE COUNT
0868 fb06 8c                         FCB     SKIP2           ; ENTER LOOP
0869 fb07 8d 09              CODTLP  BSR     CODTAO          ; SEND NULL
0870 fb09 6a e4                      DEC     ,S              ; ? FINISHED
0871 fb0b 2a fa                      BPL     CODTLP          ; NO, CONTINUE WITH MORE
0872 fb0d 35 c7              CODTRT  PULS    PC,U,D,CC       ; RESTORE REGISTERS AND RETURN
0873                         
0874 fb0f 17 ff 5c           CODTAD  LBSR    XQPAUS          ; TEMPORARY GIVE UP CONTROL
0875 fb12 e6 c4              CODTAO  LDB     ,U              ; LOAD ACIA CONTROL REGISTER
0876 fb14 c5 02                      BITB    #$02            ; ? TX REGISTER CLEAR >LSAB FIXME
0877 fb16 27 f7                      BEQ     CODTAD          ; RELEASE CONTROL IF NOT
0878 fb18 a7 41                      STA     1,U             ; STORE INTO DATA REGISTER
0879 fb1a 39                         RTS                     ; RETURN TO CALLER
0880                         *E
0881                         
0882                         * BSON - TURN ON READ/VERIFY/PUNCH MECHANISM
0883                         * A IS VOLATILE
0884                         
0885 fb1b 86 11              BSON    LDA     #$11            ; SET READ CODE
0886 fb1d 6d 66                      TST     6,S             ; ? READ OR VERIFY
0887 fb1f 26 01                      BNE     BSON2           ; BRANCH YES
0888 fb21 4c                         INCA                    ; SET TO WRITE
0889 fb22 3f                 BSON2   SWI                     ; PERFORM OUTPUT
0890 fb23 01                         FCB     OUTCH           ; FUNCTION
0891 fb24 0c 8f                      INC     <MISFLG         ; SET LOAD IN PROGRESS FLAG
0892 fb26 39                         RTS                     ; RETURN TO CALLER
0893                         
0894                         * BSOFF - TURN OFF READ/VERIFY/PUNCH MECHANISM
0895                         * A,X VOLATILE
0896                         
0897 fb27 86 14              BSOFF   LDA     #$14            ; TO DC4 - STOP
0898 fb29 3f                         SWI                     ; SEND OUT
0899 fb2a 01                         FCB     OUTCH           ; FUNCTION
0900 fb2b 4a                         DECA                    ; CHANGE TO DC3 (X-OFF)
0901 fb2c 3f                         SWI                     ; SEND OUT
0902 fb2d 01                         FCB     OUTCH           ; FUNCTION
0903 fb2e 0a 8f                      DEC     <MISFLG         ; CLEAR LOAD IN PROGRESS FLAG
0904 fb30 8e 61 a8                   LDX     #25000          ; DELAY 1 SECOND (2MHZ CLOCK)
0905 fb33 30 1f              BSOFLP  LEAX    -1,X            ; COUNT DOWN
0906 fb35 26 fc                      BNE     BSOFLP          ; LOOP TILL DONE
0907 fb37 39                         RTS                     ; RETURN TO CALLER
0908                         
0909                         * BSDTA - READ/VERIFY/PUNCH HANDLER
0910                         * INPUT: S+6=CODE BYTE, VERIFY(-1),PUNCH(0),LOAD(1)
0911                         * S+4=START ADDRESS
0912                         * S+2=STOP ADDRESS
0913                         * S+0=RETURN ADDRESS
0914                         * OUTPUT: Z=1 NORMAL COMPLETION, Z=0 INVALID LOAD/VER
0915                         * REGISTERS ARE VOLATILE
0916 fb38 ee 62              BSDTA   LDU     2,S             ; U=TO ADDRESS OR OFFSET
0917 fb3a 6d 66                      TST     6,S             ; ? PUNCH
0918 fb3c 27 54                      BEQ     BSDPUN          ; BRANCH YES
0919                         
0920                         * DURING READ/VERIFY: S+2=MSB ADDRESS SAVE BYTE
0921                         * S+1=BYTE COUNTER
0922                         * S+0=CHECKSUM
0923                         * U HOLDS OFFSET
0924 fb3e 32 7d                      LEAS    -3,S            ; ROOM FOR WORK/COUNTER/CHECKSUM
0925 fb40 3f                 BSDLD1  SWI                     ; GET NEXT CHARACTER
0926 fb41 00                         FCB     INCHNP          ; FUNCTION
0927 fb42 81 53              BSDLD2  CMPA    #'S             ; ? START OF S1/S9
0928 fb44 26 fa                      BNE     BSDLD1          ; BRANCH NOT
0929 fb46 3f                         SWI                     ; GET NEXT CHARACTER
0930 fb47 00                         FCB     INCHNP          ; FUNCTION
0931 fb48 81 39                      CMPA    #'9             ; ? HAVE S9
0932 fb4a 27 22                      BEQ     BSDSRT          ; YES, RETURN GOOD CODE
0933 fb4c 81 31                      CMPA    #'1             ; ? HAVE NEW RECORD
0934 fb4e 26 f2                      BNE     BSDLD2          ; BRANCH IF NOT
0935 fb50 6f e4                      CLR     ,S              ; CLEAR CHECKSUM
0936 fb52 8d 21                      BSR     BYTE            ; OBTAIN BYTE COUNT
0937 fb54 e7 61                      STB     1,S             ; SAVE FOR DECREMENT
0938                         
0939                         * READ ADDRESS
0940 fb56 8d 1d                      BSR     BYTE            ; OBTAIN HIGH VALUE
0941 fb58 e7 62                      STB     2,S             ; SAVE IT
0942 fb5a 8d 19                      BSR     BYTE            ; OBTAIN LOW VALUE
0943 fb5c a6 62                      LDA     2,S             ; MAKE D=VALUE
0944 fb5e 31 cb                      LEAY    D,U             ; Y=ADDRESS+OFFSET
0945                         * STORE TEXT
0946 fb60 8d 13              BSDNXT  BSR     BYTE            ; NEXT BYTE
0947 fb62 27 0c                      BEQ     BSDEOL          ; BRANCH IF CHECKSUM
0948 fb64 6d 69                      TST     9,S             ; ? VERIFY ONLY
0949 fb66 2b 02                      BMI     BSDCMP          ; YES, ONLY COMPARE
0950 fb68 e7 a4                      STB     ,Y              ; STORE INTO MEMORY
0951 fb6a e1 a0              BSDCMP  CMPB    ,Y+             ; ? VALID RAM
0952 fb6c 27 f2                      BEQ     BSDNXT          ; YES, CONTINUE READING
0953 fb6e 35 92              BSDSRT  PULS    PC,X,A          ; RETURN WITH Z SET PROPER
0954 fb70 4c                 BSDEOL  INCA                    ; ? VALID CHECKSUM
0955 fb71 27 cd                      BEQ     BSDLD1          ; BRANCH YES
0956 fb73 20 f9                      BRA     BSDSRT          ; RETURN Z=0 INVALID
0957                         
0958                         * BYTE BUILDS 8 BIT VALUE FROM TWO HEX DIGITS IN
0959 fb75 8d 12              BYTE    BSR     BYTHEX         ; OBTAIN FIRST HEX
0960 fb77 c6 10                      LDB     #16            ; PREPARE SHIFT
0961 fb79 3d                         MUL                    ; OVER TO A
0962 fb7a 8d 0d                      BSR     BYTHEX         ; OBTAIN SECOND HEX
0963 fb7c 34 04                      PSHS    B              ; SAVE HIGH HEX
0964 fb7e ab e0                      ADDA    ,S+            ; COMBINE BOTH SIDES
0965 fb80 1f 89                      TFR     A,B            ; SEND BACK IN B
0966 fb82 ab 62                      ADDA    2,S            ; COMPUTE NEW CHECKSUM
0967 fb84 a7 62                      STA     2,S            ; STORE BACK
0968 fb86 6a 63                      DEC     3,S            ; DECREMENT BYTE COUNT
0969 fb88 39                 BYTRTS  RTS                    ; RETURN TO CALLER
0970                         
0971 fb89 3f                 BYTHEX  SWI                    ; GET NEXT HEX
0972 fb8a 00                         FCB     INCHNP         ; CHARACTER
0973 fb8b 17 01 d4                   LBSR    CNVHEX         ; CONVERT TO HEX
0974 fb8e 27 f8                      BEQ     BYTRTS         ; RETURN IF VALID HEX
0975 fb90 35 f2                      PULS    PC,U,Y,X,A     ; RETURN TO CALLER WITH Z=0
0976                         
0977                         * PUNCH STACK USE: S+8=TO ADDRESS
0978                         *                  S+6=RETURN ADDRESS
0979                         *                  S+4=SAVED PADDING VALUES
0980                         *                  S+2 FROM ADDRESS
0981                         *                  S+1=FRAME COUNT/CHECKSUM
0982                         *                  S+0=BYTE COUNT
0983                         
0984 fb92 de f2              BSDPUN  LDU     <VECTAB+.PAD    ; LOAD PADDING VALUES
0985 fb94 ae 64                      LDX     4,S             ; X=FROM ADDRESS
0986 fb96 34 56                      PSHS    U,X,D           ; CREATE STACK WORK AREA
0987 fb98 cc 00 18                   LDD     #24             ; SET A=0, B=24
0988 fb9b d7 f2                      STB     <VECTAB+.PAD    ; SETUP 24 CHARACTER PADS
0989 fb9d 3f                         SWI                     ; SEND NULLS OUT
0990 fb9e 01                         FCB     OUTCH           ; FUNCTION
0991 fb9f c6 04                      LDB     #4              ; SETUP NEW LINE PAD TO 4
0992 fba1 dd f2                      STD     <VECTAB+.PAD    ; SETUP PUNCH PADDING
0993                         * CALCULATE SIZE
0994 fba3 ec 68              BSPGO   LDD     8,S             ; LOAD TO
0995 fba5 a3 62                      SUBD    2,S             ; MINUS FROM=LENGTH
0996 fba7 10 83 00 18                CMPD    #24             ; ? MORE THAN 23
0997 fbab 25 02                      BLO     BSPOK           ; NO, OK
0998 fbad c6 17                      LDB     #23             ; FORCE TO 23 MAX
0999 fbaf 5c                 BSPOK   INCB                    ; PREPARE COUNTER
1000 fbb0 e7 e4                      STB     ,S              ; STORE BYTE COUNT
1001 fbb2 cb 03                      ADDB    #3              ; ADJUST TO FRAME COUNT
1002 fbb4 e7 61                      STB     1,S             ; SAVE
1003                         
1004                         *PUNCH CR,LF,NULS,S,1
1005 fbb6 30 8c 33                  LEAX     <BSPSTR,PCR     ; LOAD START RECORD HEADER
1006 fbb9 3f                        SWI                      ; SEND OUT
1007 fbba 03                        FCB      PDATA           ; FUNCTION
1008                         * SEND FRAME COUNT
1009 fbbb 5f                        CLRB                     ; INITIALIZE CHECKSUM
1010 fbbc 30 61                     LEAX     1,S             ; POINT TO FRAME COUNT AND ADDR
1011 fbbe 8d 27                     BSR      BSPUN2          ; SEND FRAME COUNT
1012                         *DATA ADDRESS
1013 fbc0 8d 25                    BSR       BSPUN2          ; SEND ADDRESS HI
1014 fbc2 8d 23                    BSR       BSPUN2          ; SEND ADDRESS LOW
1015                         *PUNCH DATA
1016 fbc4 ae 62                     LDX      2,S             ; LOAD START DATA ADDRESS
1017 fbc6 8d 1f              BSPMRE BSR      BSPUN2          ; SEND OUT NEXT BYTE
1018 fbc8 6a e4                     DEC      ,S              ; ? FINAL BYTE
1019 fbca 26 fa                     BNE      BSPMRE          ; LOOP IF NOT DONE
1020 fbcc af 62                     STX      2,S             ; UPDATE FROM ADDRESS VALUE
1021                         *PUNCH CHECKSUM
1022 fbce 53                        COMB                     ; COMPLEMENT
1023 fbcf e7 61                     STB      1,S             ; STORE FOR SENDOUT
1024 fbd1 30 61                     LEAX     1,S             ; POINT TO IT
1025 fbd3 8d 14                     BSR      BSPUNC          ; SEND OUT AS HEX
1026 fbd5 ae 68                     LDX      8,S             ; LOAD TOP ADDRESS
1027 fbd7 ac 62                     CMPX     2,S             ; ? DONE
1028 fbd9 24 c8                     BHS      BSPGO           ; BRANCH NOT
1029 fbdb 30 8c 11                  LEAX     <BSPEOF,PCR     ; PREPARE END OF FILE
1030 fbde 3f                        SWI                      ; SEND OUT STRING
1031 fbdf 03                        FCB      PDATA           ; FUNCTION
1032 fbe0 ec 64                     LDD      4,S             ; RECOVER PAD COUNTS
1033 fbe2 dd f2                     STD      <VECTAB+.PAD    ; RESTORE
1034 fbe4 4f                        CLRA                     ; SET Z=1 FOR OK RETURN
1035 fbe5 35 d6                     PULS     PC,U,X,D        ; RETURN WITH OK CODE
1036 fbe7 eb 84              BSPUN2 ADDB     ,X              ; ADD TO CHECKSUM
1037 fbe9 16 fd ed           BSPUNC LBRA     ZOUT2H          ; SEND OUT AS HEX AND RETURN
1038                         
1039 fbec 53 01 04           BSPSTR FCB      'S,1,EOT        ; CR,LF,NULLS,S,1
1040 fbef 53 39 30 33 30 30  BSPEOF FCC      /S9030000FC/         ; EOF STRING
     30 30 46 43
1041 fbf9 0d 0a 04                  FCB      CR,LF,EOT
1042                         
1043                         * HSDTA - HIGH SPEED PRINT MEMORY
1044                         * INPUT: S+4=START ADDRESS
1045                         * S+2=STOP ADDRESS
1046                         * S+0=RETURN ADDRESS
1047                         * X,D VOLATILE
1048                         
1049                         * SEND TITLE
1050                         
1051 fbfc 3f                 HSDTA   SWI                     ; SEND NEW LINE
1052 fbfd 06                         FCB     PCRLF           ; FUNCTION
1053 fbfe c6 06                      LDB     #6              ; PREPARE 6 SPACES
1054 fc00 3f                 HSBLNK  SWI                     ; SEND BLANK
1055 fc01 07                         FCB     SPACE           ; FUNCTION
1056 fc02 5a                         DECB                    ; COUNT DOWN
1057 fc03 26 fb                      BNE     HSBLNK          ; LOOP IF MORE
1058 fc05 5f                         CLRB                    ; SETUP BYTE COUNT
1059 fc06 1f 98              HSHTTL  TFR     B,A             ; PREPARE FOR CONVERT
1060 fc08 17 fd db                   LBSR    ZOUTHX          ; CONVERT TO A HEX DIGIT
1061 fc0b 3f                         SWI                     ; SEND BLANK
1062 fc0c 07                         FCB     SPACE           ; FUNCTION
1063 fc0d 3f                         SWI                     ; SEND ANOTHER
1064 fc0e 07                         FCB     SPACE           ; BLANK
1065 fc0f 5c                         INCB                    ; UP ANOTHER
1066 fc10 c1 10                      CMPB    #$10            ; ? PAST 'F'
1067 fc12 25 f2                      BLO     HSHTTL          ; LOOP UNTIL SO
1068 fc14 3f                 HSHLNE  SWI                     ; TO NEXT LINE
1069 fc15 06                         FCB     PCRLF           ; FUNCTION
1070 fc16 25 2f                      BCS     HSDRTN          ; RETURN IF USER ENTERED CTL-X
1071 fc18 30 64                      LEAX    4,S             ; POINT AT ADDRESS TO CONVERT
1072 fc1a 3f                         SWI                     ; PRINT OUT ADDRESS
1073 fc1b 05                         FCB     OUT4HS          ; FUNCTION
1074 fc1c ae 64                      LDX     4,S             ; LOAD ADDRESS PROPER
1075 fc1e c6 10                      LDB     #16             ; NEXT SIXTEEN
1076 fc20 3f                 HSHNXT  SWI                     ; CONVERT BYTE TO HEX AND SEND
1077 fc21 04                         FCB     OUT2HS          ; FUNCTION
1078 fc22 5a                         DECB                    ; COUNT DOWN
1079 fc23 26 fb                      BNE     HSHNXT          ; LOOP IF NOT SIXTEENTH
1080 fc25 3f                         SWI                     ; SEND BLANK
1081 fc26 07                         FCB     SPACE           ; FUNCTION
1082 fc27 ae 64                      LDX     4,S             ; RELOAD FROM ADDRESS
1083 fc29 c6 10                      LDB     #16             ; COUNT
1084 fc2b a6 80              HSHCHR  LDA     ,X+             ; NEXT BYTE
1085 fc2d 2b 04                      BMI     HSHDOT          ; TOO LARGE, TO A DOT
1086 fc2f 81 20                      CMPA    #'              ; ? LOWER THAN A BLANK
1087 fc31 24 02                      BHS     HSHCOK          ; NO, BRANCH OK
1088 fc33 86 2e              HSHDOT  LDA     #'.             ; CONVERT INVALID TO A BLANK
1089 fc35 3f                 HSHCOK  SWI                     ; SEND CHARACTER
1090 fc36 01                         FCB     OUTCH           ; FUNCTION
1091 fc37 5a                         DECB                    ; ? DONE
1092 fc38 26 f1                      BNE     HSHCHR          ; BRANCH NO
1093 fc3a ac 62                      CPX     2,S             ; ? PAST LAST ADDRESS
1094 fc3c 24 09                      BHS     HSDRTN          ; QUIT IF SO
1095 fc3e af 64                      STX     4,S             ; UPDATE FROM ADDRESS
1096 fc40 a6 65                      LDA     5,S             ; LOAD LOW BYTE ADDRESS
1097 fc42 48                         ASLA                    ; ? TO SECTION BOUNDARY
1098 fc43 26 cf                      BNE     HSHLNE          ; BRANCH IF NOT
1099 fc45 20 b5                      BRA     HSDTA           ; BRANCH IF SO
1100 fc47 3f                 HSDRTN  SWI                     ; SEND NEW LINE
1101 fc48 06                         FCB     PCRLF           ; FUNCTION
1102 fc49 39                         RTS                     ; RETURN TO CALLER
1103                         *F
1104                         
1105                         ***********************************************
1106                         *     A S S I S T 0 9    C O M M A N D S
1107                         ***********************************************
1108                         
1109                         *************REGISTERS - DISPLAY AND CHANGE REGISTERS
1110 fc4a 8d 23              CREG    BSR     REGPRT          ; PRINT REGISTERS
1111 fc4c 4c                         INCA                    ; SET FOR CHANGE FUNCTION
1112 fc4d 8d 21                      BSR     REGCHG          ; GO CHANGE, DISPLAY REGISTERS
1113 fc4f 39                         RTS                     ; RETURN TO COMMAND PROCESSOR
1114                         
1115                         ********************************************
1116                         * REGPRT - PRINT/CHANGE REGISTERS SUBROUTINE
1117                         * WILL ABORT TO 'CMDBAD' IF OVERFLOW DETECTED DURING
1118                         * A CHANGE OPERATION. CHANGE DISPLAYS REGISTERS WHEN
1119                         * DONE.
1120                         
1121                         * REGISTER MASK LIST CONSISTS OF:
1122                         * A) CHARACTERS DENOTING REGISTER
1123                         * B) ZERO FOR ONE BYTE, -1 FOR TWO
1124                         * C) OFFSET ON STACK TO REGISTER POSITION
1125                         * INPUT: SP+4=STACKED REGISTERS
1126                         * A=0 PRINT, A#0 PRINT AND CHANGE
1127                         * OUTPUT: (ONLY FOR REGISTER DISPLAY)
1128                         * C=1 CONTROL-X ENTERED, C=0 OTHERWISE
1129                         * VOLATILE: D,X (CHANGE)
1130                         * B,X (DISPLAY)
1131                         *******************************************
1132                         
1133 fc50 50 43 ff 13        REGMSK  FCB     'P,'C,-1,19     ; PC REG
1134 fc54 41 00 0a                   FCB     'A,0,10         ; A REG
1135 fc57 42 00 0b                   FCB     'B,0,11         ; B REG
1136 fc5a 58 ff 0d                   FCB     'X,-1,13        ; X REG
1137 fc5d 59 ff 0f                   FCB     'Y,-1,15        ; Y REG
1138 fc60 55 ff 11                   FCB     'U,-1,17        ; U REG
1139 fc63 53 ff 01                   FCB     'S,-1,1         ; S REG
1140 fc66 43 43 00 09                FCB     'C,'C,0,9       ; CC REG
1141 fc6a 44 50 00 0c                FCB     'D,'P,0,12      ; DP REG
1142 fc6e 00                         FCB     0               ; END OF LIST
1143                         
1144 fc6f 4f                 REGPRT  CLRA                    ; SETUP PRINT ONLY FLAG
1145 fc70 30 e8 10           REGCHG  LEAX    4+12,S          ; READY STACK VALUE
1146 fc73 34 32                      PSHS    Y,X,A           ; SAVE ON STACK WITH OPTION
1147 fc75 31 8c d8                   LEAY    REGMSK,PCR      ; LOAD REGISTER MASK
1148 fc78 ec a0              REGP1   LDD     ,Y+             ; LOAD NEXT CHAR OR <=0
1149 fc7a 4d                         TSTA                    ; ? END OF CHARACTERS
1150 fc7b 2f 04                      BLE     REGP2           ; BRANCH NOT CHARACTER
1151 fc7d 3f                         SWI                     ; SEND TO CONSOLE
1152 fc7e 01                         FCB     OUTCH           ; FUNCTION BYTE
1153 fc7f 20 f7                      BRA     REGP1           ; CHECK NEXT
1154 fc81 86 2d              REGP2   LDA     #'-             ; READY '-'
1155 fc83 3f                         SWI                     ; SEND OUT
1156 fc84 01                         FCB     OUTCH           ; WITH OUTCH
1157 fc85 30 e5                      LEAX    B,S             ; X->REGISTER TO PRINT
1158 fc87 6d e4                      TST     ,S              ; ? CHANGE OPTION
1159 fc89 26 12                      BNE     REGCNG          ; BRANCH YES
1160 fc8b 6d 3f                      TST     -1,Y            ; ? ONE OR TWO BYTES
1161 fc8d 27 03                      BEQ     REGP3           ; BRANCH ZERO MEANS ONE
1162 fc8f 3f                         SWI                     ; PERFORM WORD HEX
1163 fc90 05                         FCB     OUT4HS          ; FUNCTION
1164 fc91 8c                         FCB     SKIP2           ; SKIP BYTE PRINT
1165 fc92 3f                 REGP3   SWI                     ; PERFORM BYTE HEX
1166 fc93 04                         FCB     OUT2HS          ; FUNCTION
1167 fc94 ec a0              REG4    LDD     ,Y+             ; TO FRONT OF NEXT ENTRY
1168 fc96 5d                         TSTB                    ; ? END OF ENTRIES
1169 fc97 26 df                      BNE     REGP1           ; LOOP IF MORE
1170 fc99 3f                         SWI                     ; FORCE NEW LINE
1171 fc9a 06                         FCB     PCRLF           ; FUNCTION
1172 fc9b 35 b2              REGRTN  PULS    PC,Y,X,A        ; RESTORE STACK AND RETURN
1173                         
1174 fc9d 8d 40              REGCNG  BSR     BLDNNB          ; INPUT BINARY NUMBER
1175 fc9f 27 10                      BEQ     REGNXC          ; IF CHANGE THEN JUMP
1176 fca1 81 0d                      CMPA    #CR             ; ? NO MORE DESIRED
1177 fca3 27 1e                      BEQ     REGAGN          ; BRANCH NOPE
1178 fca5 e6 3f                      LDB     -1,Y            ; LOAD SIZE FLAG
1179 fca7 5a                         DECB                    ; MINUS ONE
1180 fca8 50                         NEGB                    ; MAKE POSITIVE
1181 fca9 58                         ASLB                    ; TIMES TWO (=2 OR =4)
1182 fcaa 3f                 REGSKP  SWI                     ; PERFORM SPACES
1183 fcab 07                         FCB     SPACE           ; FUNCTION
1184 fcac 5a                         DECB
1185 fcad 26 fb                      BNE     REGSKP          ; LOOP IF MORE
1186 fcaf 20 e3                      BRA     REG4            ; CONTINUE WITH NEXT REGISTER
1187 fcb1 a7 e4              REGNXC  STA     ,S              ; SAVE DELIMITER IN OPTION
1188                         *                               ; (ALWAYS > 0)
1189 fcb3 dc 9b                      LDD     <NUMBER         ; OBTAIN BINARY RESULT
1190 fcb5 6d 3f                      TST     -1,Y            ; ? TWO BYTES WORTH
1191 fcb7 26 02                      BNE     REGTWO          ; BRANCH YES
1192 fcb9 a6 82                      LDA     ,-X             ; SETUP FOR TWO
1193 fcbb ed 84              REGTWO  STD     ,X              ; STORE IN NEW VALUE
1194 fcbd a6 e4                      LDA     ,S              ; RECOVER DELIMITER
1195 fcbf 81 0d                      CMPA    #CR             ; ? END OF CHANGES
1196 fcc1 26 d1                      BNE     REG4            ; NO, KEEP ON TRUCK'N
1197                         * MOVE STACKED DATA TO NEW STACK IN CASE STACK
1198                         * POINTER HAS CHANGED
1199 fcc3 30 8d 63 8a        REGAGN  LEAX    TSTACK,PCR      ; LOAD TEMP AREA
1200 fcc7 c6 15                      LDB     #21             ; LOAD COUNT
1201 fcc9 35 02              REGTF1  PULS    A               ; NEXT BYTE
1202 fccb a7 80                      STA     ,X+             ; STORE INTO TEMP
1203 fccd 5a                         DECB                    ; COUNT DOWN
1204 fcce 26 f9                      BNE     REGTF1          ; LOOP IF MORE
1205 fcd0 10 ee 88 ec                LDS     -20,X           ; LOAD NEW STACK POINTER
1206 fcd4 c6 15                      LDB     #21             ; LOAD COUNT AGAIN
1207 fcd6 a6 82              REGTF2 LDA      ,-X             ; NEXT TO STORE
1208 fcd8 34 02                     PSHS     A               ; BACK ONTO NEW STACK
1209 fcda 5a                        DECB                     ; COUNT DOWN
1210 fcdb 26 f9                     BNE      REGTF2          ; LOOP IF MORE
1211 fcdd 20 bc                     BRA      REGRTN          ; GO RESTART COMMAND
1212                         
1213                         *********************************************
1214                         * BLDNUM - BUILDS BINARY VALUE FROM INPUT HEX
1215                         * THE ACTIVE EXPRESSION HANDLER IS USED.
1216                         * INPUT: S=RETURN ADDRESS
1217                         * OUTPUT: A=DELIMITER WHICH TERMINATED VALUE
1218                         * (IF DELM NOT ZERO)
1219                         * "NUMBER"=WORD BINARY RESULT
1220                         * Z=1 IF INPUT RECEIVED, Z=0 IF NO HEX RECEIVED
1221                         * REGISTERS ARE TRANSPARENT
1222                         **********************************************
1223                         * EXECUTE SINGLE OR EXTENDED ROM EXPRESSION HANDLER
1224                         *
1225                         * THE FLAG "DELIM" IS USED AS FOLLOWS:
1226                         * DELIM=0 NO LEADING BLANKS, NO FORCED TERMINATOR
1227                         * DELIM=CHR ACCEPT LEADING 'CHR'S, FORCED TERMINATOR
1228 fcdf 4f                 BLDNNB  CLRA                    ; NO DYNAMIC DELIMITER
1229 fce0 8c                         FCB     SKIP2           ; SKIP NEXT INSTRUCTION
1230                         * BUILD WITH LEADING BLANKS
1231 fce1 86 20              BLDNUM  LDA     #'              ; ALLOW LEADING BLANKS
1232 fce3 97 8e                      STA     <DELIM          ; STORE AS DELIMITER
1233 fce5 6e 9d 64 03                JMP     [VECTAB+.EXPAN,PCR]   ; TO EXP ANALYZER
1234                         * THIS IS THE DEFAULT SINGLE ROM ANALYZER. WE ACCEPT:
1235                         * 1) HEX INPUT
1236                         * 2) 'M' FOR LAST MEMORY EXAMINE ADDRESS
1237                         * 3) 'P' FOR PROGRAM COUNTER ADDRESS
1238                         * 4) 'W' FOR WINDOW VALUE
1239                         * 5) '@' FOR INDIRECT VALUE
1240                         
1241 fce9 34 14              EXP1    PSHS    X,B             ; SAVE REGISTERS
1242 fceb 8d 5c              EXPDLM  BSR     BLDHXI          ; CLEAR NUMBER, CHECK FIRST CHAR
1243 fced 27 18                      BEQ     EXP2            ; IF HEX DIGIT CONTINUE BUILDING
1244                         * SKIP BLANKS IF DESIRED
1245 fcef 91 8e                      CMPA    <DELIM          ; ? CORRECT DELIMITER
1246 fcf1 27 f8                      BEQ     EXPDLM          ; YES, IGNORE IT
1247                         * TEST FOR M OR P
1248 fcf3 9e 9e                      LDX     <ADDR           ; DEFAULT FOR 'M'
1249 fcf5 81 4d                      CMPA    #'M             ; ? MEMORY EXAMINE ADDR WANTED
1250 fcf7 27 16                      BEQ     EXPTDL          ; BRANCH IF SO
1251 fcf9 9e 93                      LDX     <PCNTER         ; DEFAULT FOR 'P'
1252 fcfb 81 50                      CMPA    #'P             ; ? LAST PROGRAM COUNTER WANTED
1253 fcfd 27 10                      BEQ     EXPTDL          ; BRANCH IF SO
1254 fcff 9e a0                      LDX     <WINDOW         ; DEFAULT TO WINDOW
1255 fd01 81 57                      CMPA    #'W             ; ? WINDOW WANTED
1256 fd03 27 0a                      BEQ     EXPTDL
1257                         
1258 fd05 35 94              EXPRTN  PULS    PC,X,B          ; RETURN AND RESTORE REGISTERS
1259                         * GOT HEX, NOW CONTINUE BUILDING
1260 fd07 8d 44              EXP2    BSR     BLDHEX          ; COMPUTE NEXT DIGIT
1261 fd09 27 fc                      BEQ     EXP2            ; CONTINUE IF MORE
1262 fd0b 20 0a                      BRA     EXPCDL          ; SEARCH FOR +/-
1263                         * STORE VALUE AND CHECK IF NEED DELIMITER
1264 fd0d ae 84              EXPTDI  LDX     ,X              ; INDIRECTION DESIRED
1265 fd0f 9f 9b              EXPTDL  STX     <NUMBER         ; STORE RESULT
1266 fd11 0d 8e                      TST     <DELIM          ; ? TO FORCE A DELIMITER
1267 fd13 27 f0                      BEQ     EXPRTN          ; RETURN IF NOT WITH VALUE
1268 fd15 8d 62                      BSR     READ            ; OBTAIN NEXT CHARACTER
1269                         * TEST FOR + OR -
1270 fd17 9e 9b              EXPCDL  LDX     <NUMBER         ; LOAD LAST VALUE
1271 fd19 81 2b                      CMPA    #'+             ; ? ADD OPERATOR
1272 fd1b 26 0e                      BNE     EXPCHM          ; BRANCH NOT
1273 fd1d 8d 23                      BSR     EXPTRM          ; COMPUTE NEXT TERM
1274 fd1f 34 02                      PSHS    A               ; SAVE DELIMITER
1275 fd21 dc 9b                      LDD     <NUMBER         ; LOAD NEW TERM
1276 fd23 30 8b              EXPADD  LEAX    D,X             ; ADD TO X
1277 fd25 9f 9b                      STX     <NUMBER         ; STORE AS NEW RESULT
1278 fd27 35 02                      PULS    A               ; RESTORE DELIMITER
1279 fd29 20 ec                      BRA     EXPCDL          ; NOW TEST IT
1280 fd2b 81 2d              EXPCHM  CMPA    #'-             ; ? SUBTRACT OPERATOR
1281 fd2d 27 07                      BEQ     EXPSUB          ; BRANCH IF SO
1282 fd2f 81 40                      CMPA    #'@             ; ? INDIRECTION DESIRED
1283 fd31 27 da                      BEQ     EXPTDI          ; BRANCH IF SO
1284 fd33 5f                         CLRB                    ; SET DELIMITER RETURN
1285 fd34 20 cf                      BRA     EXPRTN          ; AND RETURN TO CALLER
1286 fd36 8d 0a              EXPSUB  BSR     EXPTRM          ; OBTAIN NEXT TERM
1287 fd38 34 02                      PSHS    A               ; SAVE DELIMITER
1288 fd3a dc 9b                      LDD     <NUMBER         ; LOAD UP NEXT TERM
1289 fd3c 40                         NEGA                    ; NEGATE A
1290 fd3d 50                         NEGB                    ; NEGATE B
1291 fd3e 82 00                      SBCA    #0              ; CORRECT FOR A
1292 fd40 20 e1                      BRA     EXPADD          ; GO ADD TO EXPRESSION
1293                         * COMPUTE NEXT EXPRESSION TERM
1294                         * OUTPUT: X=OLD VALUE
1295                         * 'NUMBER'=NEXT TERM
1296 fd42 8d 9d              EXPTRM  BSR     BLDNUM          ; OBTAIN NEXT VALUE
1297 fd44 27 32                      BEQ     CNVRTS          ; RETURN IF VALID NUMBER
1298 fd46 16 fc 13           BLDBAD  LBRA    CMDBAD          ; ABORT COMMAND IF INVALID
1299                         
1300                         *********************************************
1301                         * BUILD BINARY VALUE USING INPUT CHARACTERS.
1302                         * INPUT: A=ASCII HEX VALUE OR DELIMITER
1303                         * SP+0=RETURN ADDRESS
1304                         * SP+2=16 BIT RESULT AREA
1305                         * OUTPUT: Z=1 A=BINARY VALUE
1306                         * Z=0 IF INVALID HEX CHARACTER (A UNCHANGED)
1307                         * VOLATILE: D
1308                         ****************************************
1309 fd49 0f 9b              BLDHXI  CLR     <NUMBER         ; CLEAR NUMBER
1310 fd4b 0f 9c                      CLR     <NUMBER+1       ; CLEAR NUMBER
1311 fd4d 8d 2a              BLDHEX  BSR     READ            ; GET INPUT CHARACTER
1312 fd4f 8d 11              BLDHXC  BSR     CNVHEX          ; CONVERT AND TEST CHARACTER
1313 fd51 26 25                      BNE     CNVRTS          ; RETURN IF NOT A NUMBER
1314 fd53 c6 10                      LDB     #16             ; PREPARE SHIFT
1315 fd55 3d                         MUL                     ; BY FOUR PLACES
1316 fd56 86 04                      LDA     #4              ; ROTATE BINARY INTO VALUE
1317 fd58 58                 BLDSHF  ASLB                    ; OBTAIN NEXT BIT
1318 fd59 09 9c                      ROL     <NUMBER+1       ; INTO LOW BYTE
1319 fd5b 09 9b                      ROL     <NUMBER         ; INTO HI BYTE
1320 fd5d 4a                         DECA                    ; COUNT DOWN
1321 fd5e 26 f8                      BNE     BLDSHF          ; BRANCH IF MORE TO DO
1322 fd60 20 14                      BRA     CNVOK           ; SET GOOD RETURN CODE
1323                         
1324                         ****************************************
1325                         * CONVERT ASCII CHARACTER TO BINARY BYTE
1326                         * INPUT: A=ASCII
1327                         * OUTPUT: Z=1 A=BINARY VALUE
1328                         * Z=0 IF INVALID
1329                         * ALL REGISTERS TRANSPARENT
1330                         * (A UNALTERED IF INVALID HEX)
1331                         **************************************
1332 fd62 81 30              CNVHEX  CMPA    #'0             ; ? LOWER THAN A ZERO
1333 fd64 25 12                      BLO     CNVRTS          ; BRANCH NOT VALUE
1334 fd66 81 39                      CMPA    #'9             ; ? POSSIBLE A-F
1335 fd68 2f 0a                      BLE     CNVGOT          ; BRANCH NO TO ACCEPT
1336 fd6a 81 41                      CMPA    #'A             ; ? LESS THEN TEN
1337 fd6c 25 0a                      BLO     CNVRTS          ; RETURN IF MINUS (INVALID)
1338 fd6e 81 46                      CMPA    #'F             ; ? NOT TOO LARGE
1339 fd70 22 06                      BHI     CNVRTS          ; NO, RETURN TOO LARGE
1340 fd72 80 07                      SUBA    #7              ; DOWN TO BINARY
1341 fd74 84 0f              CNVGOT  ANDA    #$0F            ; CLEAR HIGH HEX
1342 fd76 1a 04              CNVOK   ORCC    #4              ; FORCE ZERO ON FOR VALID HEX
1343 fd78 39                 CNVRTS  RTS                     ; RETURN TO CALLER
1344                         
1345                         * GET INPUT CHAR, ABORT COMMAND IF CONTROL-X (CANCEL)
1346 fd79 3f                 READ     SWI                    ; GET NEXT CHARACTER
1347 fd7a 00                          FCB    INCHNP          ; FUNCTION
1348 fd7b 81 18                       CMPA   #CAN            ; ? ABORT COMMAND
1349 fd7d 27 c7                       BEQ    BLDBAD          ; BRANCH TO ABORT IF SO
1350 fd7f 39                          RTS                    ; RETURN TO CALLER
1351                         *G
1352                         
1353                         ***************GO - START PROGRAM EXECUTION
1354 fd80 8d 01              CGO      BSR    GOADDR          ; BUILD ADDRESS IF NEEDED
1355 fd82 3b                          RTI                    ; START EXECUTING
1356                         
1357                         * FIND OPTIONAL NEW PROGRAM COUNTER. ALSO ARM THE
1358                         * BREAKPOINTS.
1359 fd83 35 30              GOADDR   PULS   Y,X             ; RECOVER RETURN ADDRESS
1360 fd85 34 10                       PSHS   X               ; STORE RETURN BACK
1361 fd87 26 19                       BNE    GONDFT          ; IF NO CARRIAGE RETURN THEN NEW PC
1362                         
1363                         * DEFAULT PROGRAM COUNTER, SO FALL THROUGH IF
1364                         * IMMEDIATE BREAKPOINT.
1365 fd89 17 01 b6                    LBSR   CBKLDR          ; SEARCH BREAKPOINTS
1366 fd8c ae 6c                       LDX    12,S            ; LOAD PROGRAM COUNTER
1367 fd8e 5a                 ARMBLP  DECB                    ; COUNT DOWN
1368 fd8f 2b 16                      BMI     ARMBK2          ; DONE, NONE TO SINGLE TRACE
1369 fd91 a6 30                      LDA     -NUMBKP*2,Y     ; PRE-FETCH OPCODE
1370 fd93 ac a1                      CMPX    ,Y++            ; ? IS THIS A BREAKPOINT
1371 fd95 26 f7                      BNE     ARMBLP          ; LOOP IF NOT
1372 fd97 81 3f                      CMPA    #$3F            ; ? SWI BREAKPOINTED
1373 fd99 26 02                      BNE     ARMNSW          ; NO, SKIP SETTING OF PASS FLAG
1374 fd9b 97 fb                      STA     <SWIBFL         ; SHOW UPCOMING SWI NOT BRKPNT
1375 fd9d 0c 8f              ARMNSW  INC     <MISFLG         ; FLAG THRU A BREAKPOINT
1376 fd9f 16 01 06                   LBRA    CDOT            ; DO SINGLE TRACE W/O BREAKPOINTS
1377                         
1378                         * OBTAIN NEW PROGRAM COUNTER
1379 fda2 17 00 bb           GONDFT  LBSR    CDNUM           ; OBTAIN NEW PROGRAM COUNTER
1380 fda5 ed 6c                      STD     12,S            ; STORE INTO STACK
1381 fda7 17 01 98           ARMBK2  LBSR    CBKLDR          ; OBTAIN TABLE
1382 fdaa 00 fa                      NEG     <BKPTCT         ; COMPLEMENT TO SHOW ARMED
1383 fdac 5a                 ARMLOP  DECB                    ; ? DONE
1384 fdad 2b c9                      BMI     CNVRTS          ; RETURN WHEN DONE
1385 fdaf a6 b4                      LDA     [,Y]            ; LOAD OPCODE
1386 fdb1 a7 30                      STA     -NUMBKP*2,Y     ; STORE INTO OPCODE TABLE
1387 fdb3 86 3f                      LDA     #$3F            ; READY "SWI" OPCODE
1388 fdb5 a7 b1                      STA     [,Y++]          ; STORE AND MOVE UP TABLE
1389 fdb7 20 f3                      BRA     ARMLOP          ; AND CONTINUE
1390                         
1391                         *******************CALL - CALL ADDRESS AS SUBROUTINE
1392 fdb9 8d c8              CCALL   BSR     GOADDR          ; FETCH ADDRESS IF NEEDED
1393 fdbb 35 7f                      PULS    U,Y,X,DP,D,CC   ; RESTORE USERS REGISTERS
1394 fdbd ad f1                      JSR     [,S++]          ; CALL USER SUBROUTINE
1395 fdbf 3f                 CGOBRK  SWI                     ; PERFORM BREAKPOINT
1396 fdc0 0a                         FCB     BRKPT           ; FUNCTION
1397 fdc1 20 fc                      BRA     CGOBRK          ; LOOP UNTIL USER CHANGES PC
1398                         
1399                         ****************MEMORY - DISPLAY/CHANGE MEMORY
1400                         * CMEMN AND CMPADP ARE DIRECT ENTRY POINTS FROM
1401                         * THE COMMAND HANDLER FOR QUICK COMMANDS
1402 fdc3 17 00 9a           CMEM    LBSR    CDNUM           ; OBTAIN ADDRESS
1403 fdc6 dd 9e              CMEMN   STD     <ADDR           ; STORE DEFAULT
1404 fdc8 9e 9e              CMEM2   LDX     <ADDR           ; LOAD POINTER
1405 fdca 17 fc 0c                   LBSR    ZOUT2H          ; SEND OUT HEX VALUE OF BYTE
1406 fdcd 86 2d                      LDA     #'-             ; LOAD DELIMITER
1407 fdcf 3f                         SWI                     ; SEND OUT
1408 fdd0 01                         FCB     OUTCH           ; FUNCTION
1409 fdd1 17 ff 0b           CMEM4   LBSR    BLDNNB          ; OBTAIN NEW BYTE VALUE
1410 fdd4 27 0a                      BEQ     CMENUM          ; BRANCH IF NUMBER
1411                         * COMA - SKIP BYTE
1412 fdd6 81 2c                      CMPA    #',             ; ? COMMA
1413 fdd8 26 0e                      BNE     CMNOTC          ; BRANCH NOT
1414 fdda 9f 9e                      STX     <ADDR           ; UPDATE POINTER
1415 fddc 30 01                      LEAX    1,X             ; TO NEXT BYTE
1416 fdde 20 f1                      BRA     CMEM4           ; AND INPUT IT
1417 fde0 d6 9c              CMENUM  LDB     <NUMBER+1       ; LOAD LOW BYTE VALUE
1418 fde2 8d 47                      BSR     MUPDAT          ; GO OVERLAY MEMORY BYTE
1419 fde4 81 2c                      CMPA    #',             ; ? CONTINUE WITH NO DISPLAY
1420 fde6 27 e9                      BEQ     CMEM4           ; BRANCH YES
1421                         * QUOTED STRING
1422 fde8 81 27              CMNOTC  CMPA    #$27            ; ? QUOTED STRING
1423 fdea 26 0c                      BNE     CMNOTQ          ; BRANCH NO
1424 fdec 8d 8b              CMESTR  BSR     READ            ; OBTAIN NEXT CHARACTER
1425 fdee 81 27                      CMPA    #$27            ; ? END OF QUOTED STRING
1426 fdf0 27 0c                      BEQ     CMSPCE          ; YES, QUIT STRING MODE
1427 fdf2 1f 89                      TFR     A,B             ; TO B FOR SUBROUTINE
1428 fdf4 8d 35                      BSR     MUPDAT          ; GO UPDATE BYTE
1429 fdf6 20 f4                      BRA     CMESTR          ; GET NEXT CHARACTER
1430                         * BLANK - NEXT BYTE
1431 fdf8 81 20              CMNOTQ  CMPA    #$20            ; ? BLANK FOR NEXT BYTE
1432 fdfa 26 06                      BNE     CMNOTB          ; BRANCH NOT
1433 fdfc 9f 9e                      STX     <ADDR           ; UPDATE POINTER
1434 fdfe 3f                 CMSPCE  SWI                     ; GIVE SPACE
1435 fdff 07                         FCB     SPACE           ; FUNCTION
1436 fe00 20 c6                      BRA     CMEM2           ; NOW PROMPT FOR NEXT
1437                         
1438                         * LINE FEED - NEXT BYTE WITH ADDRESS
1439 fe02 81 0a              CMNOTB  CMPA    #LF             ; ? LINE FEED FOR NEXT BYTE
1440 fe04 26 08                      BNE     CMNOTL          ; BRANCH NO
1441 fe06 86 0d                      LDA     #CR             ; GIVE CARRIAGE RETURN
1442 fe08 3f                         SWI                     ; TO CONSOLE
1443 fe09 01                         FCB     OUTCH           ; HANDLER
1444 fe0a 9f 9e                      STX     <ADDR           ; STORE NEXT ADDRESS
1445 fe0c 20 0a                      BRA     CMPADP          ; BRANCH TO SHOW
1446                         
1447                         * UP ARROW - PREVIOUS BYTE AND ADDRESS
1448 fe0e 81 5e              CMNOTL  CMPA    #'^             ; ? UP ARROW FOR PREVIOUS BYTE
1449 fe10 26 0a                      BNE     CMNOTU          ; BRANCH NOT
1450 fe12 30 1e                      LEAX    -2,X            ; DOWN TO PREVIOUS BYTE
1451 fe14 9f 9e                      STX     <ADDR           ; STORE NEW POINTER
1452 fe16 3f                 CMPADS  SWI                     ; FORCE NEW LINE
1453 fe17 06                         FCB     PCRLF           ; FUNCTION
1454 fe18 8d 07              CMPADP  BSR     PRTADR          ; GO PRINT ITS VALUE
1455 fe1a 20 ac                      BRA     CMEM2           ; THEN PROMPT FOR INPUT
1456                         
1457                         * SLASH - NEXT BYTE WITH ADDRESS
1458 fe1c 81 2f              CMNOTU  CMPA    #'/             ; ? SLASH FOR CURRENT DISPLAY
1459 fe1e 27 f6                      BEQ     CMPADS          ; YES, SEND ADDRESS
1460 fe20 39                         RTS                     ; RETURN FROM COMMAND
1461                         
1462                         * PRINT CURRENT ADDRESS
1463 fe21 9e 9e              PRTADR  LDX     <ADDR           ; LOAD POINTER VALUE
1464 fe23 34 10                      PSHS    X               ; SAVE X ON STACK
1465 fe25 30 e4                      LEAX    ,S              ; POINT TO IT FOR DISPLAY
1466 fe27 3f                         SWI                     ; DISPLAY POINTER IN HEX
1467 fe28 05                         FCB     OUT4HS          ; FUNCTION
1468 fe29 35 90                      PULS    PC,X            ; RECOVER POINTER AND RETURN
1469                         
1470                         * UPDATE BYTE
1471 fe2b 9e 9e              MUPDAT  LDX     <ADDR           ; LOAD NEXT BYTE POINTER
1472 fe2d e7 80                      STB     ,X+             ; STORE AND INCREMENT X
1473 fe2f e1 1f                      CMPB    -1,X            ; ? SUCCESFULL STORE
1474 fe31 26 03                      BNE     MUPBAD          ; BRANCH FOR '?' IF NOT
1475 fe33 9f 9e                      STX     <ADDR           ; STORE NEW POINTER VALUE
1476 fe35 39                         RTS                     ; BACK TO CALLER
1477 fe36 34 02              MUPBAD  PSHS    A               ; SAVE A REGISTER
1478 fe38 86 3f                      LDA     #'?             ; SHOW INVALID
1479 fe3a 3f                         SWI                     ; SEND OUT
1480 fe3b 01                         FCB     OUTCH           ; FUNCTION
1481 fe3c 35 82                      PULS    PC,A            ; RETURN TO CALLER
1482                         
1483                         ********************WINDOW - SET WINDOW VALUE
1484 fe3e 8d 20              CWINDO  BSR     CDNUM           ; OBTAIN WINDOW VALUE
1485 fe40 dd a0                      STD     <WINDOW         ; STORE IT IN
1486 fe42 39                         RTS                     ; END COMMAND
1487                         
1488                         ******************DISPLAY - HIGH SPEED DISPLAY MEMORY
1489 fe43 8d 1b              CDISP   BSR     CDNUM           ; FETCH ADDRESS
1490 fe45 c4 f0                      ANDB    #$F0            ; FORCE TO 16 BOUNDARY
1491 fe47 1f 02                      TFR     D,Y             ; SAVE IN Y
1492 fe49 30 2f                      LEAX    15,Y            ; DEFAULT LENGTH
1493 fe4b 25 04                      BCS     CDISPS          ; BRANCH IF END OF INPUT
1494 fe4d 8d 11                      BSR     CDNUM           ; OBTAIN COUNT
1495 fe4f 30 ab                      LEAX    D,Y             ; ASSUME COUNT, COMPUTE END ADDR
1496 fe51 34 30              CDISPS  PSHS    Y,X             ; SETUP PARAMETERS FOR HSDATA
1497 fe53 10 a3 62                   CMPD    2,S             ; ? WAS IT COUNT
1498 fe56 23 02                      BLS     CDCNT           ; BRANCH YES
1499 fe58 ed e4                      STD     ,S              ; STORE HIGH ADDRESS
1500 fe5a ad 9d 62 84        CDCNT   JSR     [VECTAB+.HSDTA,PCR] ; CALL PRINT ROUTINE
1501 fe5e 35 e0                      PULS    PC,U,Y          ; CLEAN STACK AND END COMMAND
1502                         
1503                         * OBTAIN NUMBER - ABORT IF NONE
1504                         * ONLY DELIMITERS OF CR, BLANK, OR '/' ARE ACCEPTED
1505                         * OUTPUT: D=VALUE, C=1 IF CARRIAGE RETURN DELMITER,
1506                         * ELSE C=0
1507 fe60 17 fe 7e           CDNUM   LBSR    BLDNUM          ; OBTAIN NUMBER
1508 fe63 26 09                      BNE     CDBADN          ; BRANCH IF INVALID
1509 fe65 81 2f                      CMPA    #'/             ; ? VALID DELIMITER
1510 fe67 22 05                      BHI     CDBADN          ; BRANCH IF NOT FOR ERROR
1511 fe69 81 0e                      CMPA    #CR+1           ; LEAVE COMPARE FOR CARRIAGE RET
1512 fe6b dc 9b                      LDD     <NUMBER         ; LOAD NUMBER
1513 fe6d 39                         RTS                     ; RETURN WITH COMPARE
1514 fe6e 16 fa eb           CDBADN  LBRA    CMDBAD          ; RETURN TO ERROR MECHANISM
1515                         
1516                         *****************PUNCH - PUNCH MEMORY IN S1-S9 FORMAT
1517 fe71 8d ed              CPUNCH  BSR     CDNUM           ; OBTAIN START ADDRESS
1518 fe73 1f 02                      TFR     D,Y             ; SAVE IN Y
1519 fe75 8d e9                      BSR     CDNUM           ; OBTAIN END ADDRESS
1520 fe77 6f e2                      CLR     ,-S             ; SETUP PUNCH FUNCTION CODE
1521 fe79 34 26                      PSHS    Y,D             ; STORE VALUES ON STACK
1522 fe7b ad 9d 62 65        CCALBS  JSR     [VECTAB+.BSON,PCR] ; INITIALIZE HANDLER
1523 fe7f ad 9d 62 63                JSR     [VECTAB+.BSDTA,PCR] ; PERFORM FUNCTION
1524 fe83 34 01                      PSHS    CC              ; SAVE RETURN CODE
1525 fe85 ad 9d 62 5f                JSR     [VECTAB+.BSOFF,PCR] ; TURN OFF HANDLER
1526 fe89 35 01                      PULS    CC              ; OBTAIN CONDITION CODE SAVED
1527 fe8b 26 e1                      BNE     CDBADN          ; BRANCH IF ERROR
1528 fe8d 35 b2                      PULS    PC,Y,X,A        ; RETURN FROM COMMAND
1529                         
1530                         *****************LOAD - LOAD MEMORY FROM S1-S9 FORMAT
1531 fe8f 8d 01              CLOAD   BSR     CLVOFS          ; CALL SETUP AND PASS CODE
1532 fe91 01                         FCB     1               ; LOAD FUNCTION CODE FOR PACKET
1533                         
1534 fe92 33 f1              CLVOFS  LEAU    [,S++]          ; LOAD CODE IN HIGH BYTE OF U
1535 fe94 33 d4                      LEAU    [,U]            ; NOT CHANGING CC AND RESTORE S
1536 fe96 27 03                      BEQ     CLVDFT          ; BRANCH IF CARRIAGE RETURN NEXT
1537 fe98 8d c6                      BSR     CDNUM           ; OBTAIN OFFSET
1538 fe9a 8c                         FCB     SKIP2           ; SKIP DEFAULT OFFSET
1539 fe9b 4f                 CLVDFT  CLRA                    ; CREATE ZERO OFFSET
1540 fe9c 5f                         CLRB                    ; AS DEFAULT
1541 fe9d 34 4e                      PSHS    U,DP,D          ; SETUP CODE, NULL WORD, OFFSET
1542 fe9f 20 da                      BRA     CCALBS          ; ENTER CALL TO BS ROUTINES
1543                         
1544                         ******************VERIFY - COMPARE MEMORY WITH FILES
1545 fea1 8d ef              CVER    BSR     CLVOFS          ; COMPUTE OFFSET IF ANY
1546 fea3 ff                         FCB     -1              ; VERIFY FNCTN CODE FOR PACKET
1547                         
1548                         *******************TRACE - TRACE INSTRUCTIONS
1549                         ******************* . - SINGLE STEP TRACE
1550 fea4 8d ba              CTRACE  BSR     CDNUM           ; OBTAIN TRACE COUNT
1551 fea6 dd 91                      STD     <TRACEC         ; STORE COUNT
1552 fea8 32 62              CDOT    LEAS    2,S             ; RID COMMAND RETURN FROM STACK
1553 feaa ee f8 0a           CTRCE3  LDU     [10,S]          ; LOAD OPCODE TO EXECUTE
1554 fead df 99                      STU     <LASTOP         ; STORE FOR TRACE INTERRUPT
1555 feaf de f6                      LDU     <VECTAB+.PTM    ; LOAD PTM ADDRESS
1556 feb1 cc 07 01                   LDD     #$0701          ; 7,1 CYCLES DOWN+CYCLES UP
1557 feb4 ed 42                      STD     PTMTM1-PTM,U    ; START NMI TIMEOUT
1558 feb6 3b                         RTI                     ; RETURN FOR ONE INSTRUCTION
1559                         
1560                         *************NULLS  -  SET NEW LINE AND CHAR PADDING
1561 feb7 8d a7              CNULLS  BSR     CDNUM           ; OBTAIN NEW LINE PAD
1562 feb9 dd f2                      STD     <VECTAB+.PAD    ; RESET VALUES
1563 febb 39                         RTS                     ; END COMMAND
1564                         
1565                         ******************STLEVEL - SET STACK TRACE LEVEL
1566 febc 27 05              CSTLEV  BEQ     STLDFT          ; TAKE DEFAULT
1567 febe 8d a0                      BSR     CDNUM           ; OBTAIN NEW STACK LEVEL
1568 fec0 dd f8                      STD     <SLEVEL         ; STORE NEW ENTRY
1569 fec2 39                         RTS                     ; TO COMMAND HANDLER
1570 fec3 30 6e              STLDFT  LEAX    14,S            ; COMPUTE NMI COMPARE
1571 fec5 9f f8                      STX     <SLEVEL         ; AND STORE IT
1572 fec7 39                         RTS                     ; END COMMAND
1573                         
1574                         ******************OFFSET - COMPUTE SHORT AND LONG
1575                         ******************                  BRANCH OFFSETS
1576 fec8 8d 96              COFFS   BSR     CDNUM           ; OBTAIN INSTRUCTION ADDRESS
1577 feca 1f 01                      TFR     D,X             ; USE AS FROM ADDRESS
1578 fecc 8d 92                      BSR     CDNUM           ; OBTAIN TO ADDRESS
1579                         * D=TO INSTRUCTION, X=FROM INSTRUCTION OFFSET BYTE(S)
1580 fece 30 01                      LEAX    1,X             ; ADJUST FOR *+2 SHORT BRANCH
1581 fed0 34 30                      PSHS    Y,X             ; STORE WORK WORD AND VALUE ON S
1582 fed2 a3 e4                      SUBD    ,S              ; FIND OFFSET
1583 fed4 ed e4                      STD     ,S              ; SAVE OVER STACK
1584 fed6 30 61                      LEAX    1,S             ; POINT FOR ONE BYTE DISPLAY
1585 fed8 1d                         SEX                     ; SIGN EXTEND LOW BYTE
1586 fed9 a1 e4                      CMPA    ,S              ; ? VALID ONE BYTE OFFSET
1587 fedb 26 02                      BNE     COFNO1          ; BRANCH IF NOT
1588 fedd 3f                         SWI                     ; SHOW ONE BYTE OFFSET
1589 fede 04                         FCB     OUT2HS          ; FUNCTION
1590 fedf ee e4              COFNO1  LDU     ,S              ; RELOAD OFFSET
1591 fee1 33 5f                      LEAU    -1,U            ; CONVERT TO LONG BRANCH OFFSET
1592 fee3 ef 84                      STU     ,X              ; STORE BACK WHERE X POINTS NOW
1593 fee5 3f                         SWI                     ; SHOW TWO BYTE OFFSET
1594 fee6 05                         FCB     OUT4HS          ; FUNCTION
1595 fee7 3f                         SWI                     ; FORCE NEW LINE
1596 fee8 06                         FCB     PCRLF           ; FUNCTION
1597 fee9 35 96                      PULS    PC,X,D          ; RESTORE STACK AND END COMMAND
1598                         *H
1599                         
1600                         *************BREAKPOINT - DISPLAY/ENTER/DELETE/CLEAR
1601                         *************             BREAKPOINTS
1602 feeb 27 23              CBKPT   BEQ     CBKDSP          ; BRANCH DISPLAY OF JUST 'B'
1603 feed 17 fd f1                   LBSR    BLDNUM          ; ATTEMPT VALUE ENTRY
1604 fef0 27 2c                      BEQ     CBKADD          ; BRANCH TO ADD IF SO
1605 fef2 81 2d                      CMPA    #'-             ; ? CORRECT DELIMITER
1606 fef4 26 3f                      BNE     CBKERR          ; NO, BRANCH FOR ERROR
1607 fef6 17 fd e8                   LBSR    BLDNUM          ; ATTEMPT DELETE VALUE
1608 fef9 27 03                      BEQ     CBKDLE          ; GOT ONE, GO DELETE IT
1609 fefb 0f fa                      CLR     <BKPTCT         ; WAS 'B -', SO ZERO COUNT
1610 fefd 39                 CBKRTS  RTS                     ; END COMMAND
1611                         * DELETE THE ENTRY
1612 fefe 8d 40              CBKDLE  BSR     CBKSET          ; SETUP REGISTERS AND VALUE
1613 ff00 5a                 CBKDLP  DECB                    ; ? ANY ENTRIES IN TABLE
1614 ff01 2b 32                      BMI     CBKERR          ; BRANCH NO, ERROR
1615 ff03 ac a1                      CMPX    ,Y++            ; ? IS THIS THE ENTRY
1616 ff05 26 f9                      BNE     CBKDLP          ; NO, TRY NEXT
1617                         * FOUND, NOW MOVE OTHERS UP IN ITS PLACE
1618 ff07 ae a1              CBKDLM  LDX     ,Y++            ; LOAD NEXT ONE UP
1619 ff09 af 3c                      STX     -4,Y            ; MOVE DOWN BY ONE
1620 ff0b 5a                         DECB                    ; ? DONE
1621 ff0c 2a f9                      BPL     CBKDLM          ; NO, CONTINUE MOVE
1622 ff0e 0a fa                      DEC     <BKPTCT         ; DECREMENT BREAKPOINT COUNT
1623 ff10 8d 2e              CBKDSP  BSR     CBKSET          ; SETUP REGISTERS AND LOAD VALUE
1624 ff12 27 e9                      BEQ     CBKRTS          ; RETURN IF NONE TO DISPLY
1625 ff14 30 a1              CBKDSL  LEAX    ,Y++            ; POINT TO NEXT ENTRY
1626 ff16 3f                         SWI                     ; DISPLAY IN HEX
1627 ff17 05                         FCB     OUT4HS          ; FUNCTION
1628 ff18 5a                         DECB                    ; COUNT DOWN
1629 ff19 26 f9                      BNE     CBKDSL          ; LOOP IF NGABLE RAM
1630 ff1b 3f                         SWI                     ; SKIP TO NEW LINK
1631 ff1c 06                         FCB     PCRLF           ; FUNCTIONRTS
1632 ff1d 39                         RTS
1633                         
1634                         * ADD NEW ENTRY
1635 ff1e 8d 20              CBKADD  BSR     CBKSET          ; SETUP REGISTERS
1636 ff20 c1 08                      CMPB    #NUMBKP         ; ? ALREADY FULL
1637 ff22 27 11                      BEQ     CBKERR          ; BRANCH ERROR IF SO
1638 ff24 a6 84                      LDA     ,X              ; LOAD BYTE TO TRAP
1639 ff26 e7 84                      STB     ,X              ; TRY TO CHANGE
1640 ff28 e1 84                      CMPB    ,X              ; ? CHANGEABLE RAM
1641 ff2a 26 09                      BNE     CBKERR          ; BRANCH ERROR IF NOT
1642 ff2c a7 84                      STA ,X                  ; RESTORE BYTE
1643 ff2e 5a                 CBKADL  DECB                    ; COUNT DOWN
1644 ff2f 2b 07                      BMI     CBKADT          ; BRANCH IF DONE TO ADD IT
1645 ff31 ac a1                      CMPX    ,Y++            ; ? ENTRY ALREADY HERE
1646 ff33 26 f9                      BNE     CBKADL          ; LOOP IF NOT
1647 ff35 16 fa 24           CBKERR  LBRA    CMDBAD          ; RETURN TO ERROR PRODUCE
1648 ff38 af a4              CBKADT  STX ,Y                  ; ADD THIS ENTRY
1649 ff3a 6f 31                      CLR     -NUMBKP*2+1,Y   ; CLEAR OPTIONAL BYTE
1650 ff3c 0c fa                      INC     <BKPTCT         ; ADD ONE TO COUNT
1651 ff3e 20 d0                      BRA     CBKDSP          ; AND NOW DISPLAY ALL OF 'EM
1652                         * SETUP REGISTERS FOR SCAN
1653 ff40 9e 9b              CBKSET  LDX     <NUMBER         ; LOAD VALUE DESIRED
1654 ff42 31 8d 61 6c        CBKLDR  LEAY    BKPTBL,PCR      ; LOAD START OF TABLE
1655 ff46 d6 fa                      LDB     <BKPTCT         ; LOAD ENTRY COUNT
1656 ff48 39                         RTS                     ; RETURN
1657                         
1658                         *****************ENCODE  -  ENCODE A POSTBYTE
1659 ff49 6f e2              CENCDE  CLR     ,-S             ; DEFAULT TO NOT INDIRECT
1660 ff4b 5f                         CLRB                    ; ZERO POSTBYTE VALUE
1661 ff4c 30 8c 3f                   LEAX    <CONV1,PCR      ; START TABLE SEARCH
1662 ff4f 3f                         SWI                     ; OBTAIN FIRST CHARACTER
1663 ff50 00                         FCB     INCHNP          ; FUNCTION
1664 ff51 81 5b                      CMPA    #'[             ; ? INDIRECT HERE
1665 ff53 26 06                      BNE     CEN2            ; BRANCH IF NOT
1666 ff55 86 10                      LDA     #$10            ; SET INDIRECT BIT ON
1667 ff57 a7 e4                      STA     ,S              ; SAVE FOR LATER
1668 ff59 3f                 CENGET  SWI                     ; OBTAIN NEXT CHARACTER
1669 ff5a 00                         FCB     INCHNP          ; FUNCTION
1670 ff5b 81 0d              CEN2    CMPA    #CR             ; ? END OF ENTRY
1671 ff5d 27 0c                      BEQ     CEND1           ; BRANCH YES
1672 ff5f 6d 84              CENLP1  TST     ,X              ; ? END OF TABLE
1673 ff61 2b d2                      BMI     CBKERR          ; BRANCH ERROR IF SO
1674 ff63 a1 81                      CMPA    ,X++            ; ? THIS THE CHARACTER
1675 ff65 26 f8                      BNE     CENLP1          ; BRANCH IF NOT
1676 ff67 eb 1f                      ADDB    -1,X            ; ADD THIS VALUE
1677 ff69 20 ee                      BRA     CENGET          ; GET NEXT INPUT
1678 ff6b 30 8c 49           CEND1   LEAX    <CONV2,PCR      ; POINT AT TABLE 2
1679 ff6e 1f 98                      TFR     B,A             ; SAVE COPY IN A
1680 ff70 84 60                      ANDA    #$60            ; ISOLATE REGISTER MASK
1681 ff72 aa e4                      ORA     ,S              ; ADD IN INDIRECTION BIT
1682 ff74 a7 e4                      STA     ,S              ; SAVE BACK AS POSTBYTE SKELETON
1683 ff76 c4 9f                      ANDB    #$9F            ; CLEAR REGISTER BITS
1684 ff78 6d 84              CENLP2  TST     ,X              ; ? END OF TABLE
1685 ff7a 27 b9                      BEQ     CBKERR          ; BRANCH ERROR IF SO
1686 ff7c e1 81                      CMPB    ,X++            ; ? SAME VALUE
1687 ff7e 26 f8                      BNE     CENLP2          ; LOOP IF NOT
1688 ff80 e6 1f                      LDB     -1,X            ; LOAD RESULT VALUE
1689 ff82 ea e4                      ORB     ,S              ; ADD TO BASE SKELETON
1690 ff84 e7 e4                      STB     ,S              ; SAVE POSTBYTE ON STACK
1691 ff86 30 e4                      LEAX    ,S              ; POINT TO IT
1692 ff88 3f                         SWI                     ; SEND OUT AS HEX
1693 ff89 04                         FCB     OUT2HS          ; FUNCTION
1694 ff8a 3f                         SWI                     ; TO NEXT LINE
1695 ff8b 06                         FCB     PCRLF           ; FUNCTION
1696 ff8c 35 84                      PULS    PC,B            ; END OF COMMAND
1697                         
1698                         * TABLE ONE DEFINES VALID INPUT IN SEQUENCE
1699                         CONV1
1700 ff8e 41 04 42 05 44 06          FCB     'A,$04,'B,$05,'D,$06,'H,$01
     48 01
1701 ff96 48 01 48 01 48 00          FCB     'H,$01,'H,$01,'H,$00,',,$00
     2c 00
1702 ff9e 2d 09 2d 01 53 70          FCB     '-,$09,'-,$01,'S,$70,'Y,$30
     59 30
1703 ffa6 55 50 58 10 2b 07          FCB     'U,$50,'X,$10,'+,$07,'+,$01
     2b 01
1704 ffae 50 80 43 00 52 00          FCB     'P,$80,'C,$00,'R,$00,'],$00
     5d 00
1705 ffb6 ff                         FCB     $FF             ; END OF TABLE
1706                         
1707                         * CONV2 USES ABOVE CONVERSION TO SET POSTBYTE
1708                         * BIT SKELETON.
1709                         CONV2
1710 ffb7 10 84 11 00                FDB     $1084,$1100     ; R,      H,R
1711 ffbb 12 88 13 89                FDB     $1288,$1389     ; HH,R    HHHH,R
1712 ffbf 14 86 15 85                FDB     $1486,$1585     ; A,R     B,R
1713 ffc3 16 8b 17 80                FDB     $168B,$1780     ; D,R     ,R+
1714 ffc7 18 81 19 82                FDB     $1881,$1982     ; ,R++    ,-R
1715 ffcb 1a 83 82 8c                FDB     $1A83,$828C     ; ,--R    HH,PCR
1716 ffcf 83 8d 03 9f                FDB     $838D,$039F     ; HHHH,PCR [HHHH]
1717 ffd3 00                         FCB     0               ; END OF TABLE
1718                         
1719                         ****************************************************
1720                         *            DEFAULT INTERRUPT TRANSFERS           *
1721                         ****************************************************
1722 ffd4 6e 9d 60 ee        RSRVD   JMP     [VECTAB+.RSVD,PCR]      ; RESERVED VECTOR
1723 ffd8 6e 9d 60 ec        SWI3    JMP     [VECTAB+.SWI3,PCR]      ; SWI3 VECTOR
1724 ffdc 6e 9d 60 ea        SWI2    JMP     [VECTAB+.SWI2,PCR]      ; SWI2 VECTOR
1725 ffe0 6e 9d 60 e8        FIRQ    JMP     [VECTAB+.FIRQ,PCR]      ; FIRQ VECTOR
1726 ffe4 6e 9d 60 e6        IRQ     JMP     [VECTAB+.IRQ,PCR]       ; IRQ VECTOR
1727 ffe8 6e 9d 60 e4        SWI     JMP     [VECTAB+.SWI,PCR]       ; SWI VECTOR
1728 ffec 6e 9d 60 e2        NMI     JMP     [VECTAB+.NMI,PCR]       ; NMI VECTOR
1729                         
1730                         ******************************************************
1731                         *            ASSIST09 HARDWARE VECTOR TABLE
1732                         * THIS TABLE IS USED IF THE ASSIST09 ROM ADDRESSES
1733                         * THE MC6809 HARDWARE VECTORS.
1734                         ******************************************************
1735 fff0                            ORG     ROMBEG+ROMSIZ-16 ; SETUP HARDWARE VECTORS
1736 fff0 ff d4                      FDB     RSRVD           ; RESERVED SLOT
1737 fff2 ff d8                      FDB     SWI3            ; SOFTWARE INTERRUPT 3
1738 fff4 ff dc                      FDB     SWI2            ; SOFTWARE INTERRUPT 2
1739 fff6 ff e0                      FDB     FIRQ            ; FAST INTERRUPT REQUEST
1740 fff8 ff e4                      FDB     IRQ             ; INTERRUPT REQUEST
1741 fffa ff e8                      FDB     SWI             ; SOFTWARE INTERRUPT
1742 fffc ff ec                      FDB     NMI             ; NON-MASKABLE INTERRUPT
1743 fffe f8 37                      FDB     RESET           ; RESTART
