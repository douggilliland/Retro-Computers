;
;	Title: 		Binary to-Decimal ASCII
;
;	Name:		BN2DEC
;
;	Purpose:	Converts a 16-bit signed binary number to ASCII data
;
;	Entry:		Register D = Value to convert 
;			Register X = Output buffer address
;
;	Exit:		The first byte of the buffer is the length,
;			followed by the characters
;
;	Registers Used: CC, D, X, Y
;
;	Time:		Approximately 1000 cycles
;
;	Size:		Program 99 bytes
;			Data up to 5 bytes on stack
;
;	SAVE ORIGINAL DATA IN BUFFER
;	TAKE ABSOLUTE VALUE IF DATA NEGATIVE
;
BN2DEC:
	STD	1,X			; SAVE DATA IN BUFFER
	BPL	CNVERT			; BRANCH IF DATA POSITIVE
	LDD	#0			; ELSE TAKE ABSOLUTE VALUE
	SUBD	1,X
;
; INITIALIZE STRING LENGTH TO ZERO
;
CNVERT:
	CLR	,X			; STRING LENGTH = 0
;
; DIVIDE BINARY DATA BY 10 BY
; SUBTRACTING POWERS OF TEN 
;
DIV10:
	LDY	#-1000			; START QUOTIENT AT -1000
;
; FIND NUMBER 0F THOUSANDS IN QUOTIENT
;
THOUSD:
	LEAY	1000,Y			; ADD 1000 TO QUOTIENT
	SUBD	#10000			; SUBTRACT 10000 FROM DIVIDEND
	BCC	THOUSD			; BRANCH IF DIFFERENCE STILL POSITIVE 
	ADDD	#10000			; ELSE ADD BACK LAST 10000
;
; FIND NUMBER OF HUNDREDS IN QUOTIENT
;
	LEAY	-100,Y			; START NUMBER OF HUNDREDS AT -1
HUNDD:
	LEAY	100,Y			; ADD 100 TO QUOTIENT
	SUBD	#1000			; SUBTRACT 1000 FROM DIVIDEND
	BCC	HUNDD			; BRANCH IF DIFFERENCE STILL POSITIVE
	ADDD	#1000			; ELSE ADD BACK LAST 1000
;
; FIND NUMBER OF TENS IN QUOTIENT
;
	LEAY	-10,Y			; STARTNUMBER OF TENS AT -1
	LEAY	10,Y			; ADD 10 TO QUOTIENT
TENSD:
	SUBD	#100			; SUBTRACT 100 FROM DIVIDEND
	BCC	TENSD			; BRANCH IF DIFFERENCE STILL POSITIVE
	ADDD	#100			; ELSE ADD BACK LAST 100
;
; FIND NUMBER OF ONES IN QUOTIENT
;
	LEAY	-1,Y			; START NUMBER OF ONES AT -1
	LEAY	1,Y			; ADD 1 TO QUOTIENT
ONESD:
	SUBD	#10			; SUBTRACT 10 FROM DIVIDEND
	BCC	ONESD			; BRANCH IF DIFFERENCE STILL POSITIVE
	ADDD	#10			; ELSE ADD BACK LAST 10
	STB	,-S			; SAVE REMAINDER IN STACK
					; THIS IS NEXT DIGIT, MOVING LEFT
					; LEAST SIGNIFICANT DIGIT GOES INTO STACK
					; FIRST
	INC	,X			; ADD 1 TO LENGTH BYTE

	TFR	Y,D			; MAKE QUOTIENT INTO NEN DIVIDEND 
	CMPD	#0			; CHECK IF DIVIDEND ZERO
	BNE	DIV10			; BRANCH IF NOT DIVIDE BY 10 AGAIN
;
; CHECK IF ORIGINAL BINARY DATA WNAS NEGATIVE
; IF SO, PUT ASCII AT FRONT OF BUFFER
;
	LDA	,X+			; GET LENGTH BYTE (NOT INCLUDING SIGN)
	LDB	,X			; GET HIGH BYTE OF DATA
	BPL	BUFLOAD			; BRANCH IF DATA POSITIVE
	LDB	#'-'			; OTHERWISE, GET ASCII MINUS SIGN
	STB	,X+			; STORE MINUS SIGN IN BUFFER
	INC	-2,X			; ADD 1 TO LENGTH BYTE FOR SIGN
;
; MOVE STRING OF DIGITS FROM STACK TO BUFFER 
; HOST SIGNIFICANT DIGIT IS AT TOP OF STACK
; CONVERT DIGITS TO ASCII BY ADDING ASCII 0
;
BUFLOAD:
	LDB	,S+			; GET NEXT DIGIT FROM STACK, MOVING RIGHT
	ADDB	#'0'			; CONVERT DIGIT TO ASCII
	STB	,X+			; SAVE DIGIT IN BUFFER
	DECA				; DECREMENT BYTE COUNTER
	BNE	BUFLOAD			; LOOP IF MORE BYTES LEFT
	RTS
;
; SAMPLE EXECUTION
;
SC1E:
	; CONVERT 0 TO ASCII '0'

	LDD	#0			; D=0
	LDX	#BUFFER			; X=BASE ADDRESS OF BUFFER
	JSR	BN2DEC			; CONVERT
					; BUFFER SHOULD CONTAIN
					; BINARY 1 (LENGTH)
					; ASCII 0 (STRING)

	; CONVERT 32767 TO ASCII '32767'

	LDD	#32767			; D=32767
	LDX	#BUFFER			; X=BASE ADDRESS OF BUFFER
	JSR	BN2DEC			; CONVERT
					; BUFFER SHOULD CONTAIN
					; BINARY 5 (LENGTH)
					; ASCII 32767 (STRING)

	; CONVERT -32767 TO ASCII '-32767'

	LDD	#-32767			; D=-32767
	LDX	#BUFFER			; X=BASE ADDRESS OF BUFFER
	JSR	BN2DEC			; CONVERT
					; BUFFER SHOULD CONTAIN
					; BINARY 6 (LENGTH)
					; ASCII (SIGN)
					; ASCII 32767 (STRING)
BUFFER:
	RMB	7			; BUFFER
	END
