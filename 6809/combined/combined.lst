0001                         ************************************************************************
0002                         ;
0003                         ; Microsoft Color Computer Basic
0004                         
0005 a000                    UART      EQU  $A000
0006 a001                    RECEV     EQU  UART+1
0007 a001                    TRANS     EQU  UART+1
0008 a000                    USTAT     EQU  UART
0009 a000                    UCTRL     EQU  UART
0010                         
0011 0008                    BS        EQU  8              ; BACKSPACE
0012 000d                    CR        EQU  $D             ; ENTER KEY
0013 001b                    ESC       EQU  $1B            ; ESCAPE CODE
0014 0020                    SPACE     EQU  $20            ; SPACE (BLANK)
0015 003a                    STKBUF    EQU  58             ; STACK BUFFER ROOM
0016 00fa                    LBUFMX    EQU  250            ; MAX NUMBER OF CHARS IN A BASIC LINE
0017 00fa                    MAXLIN    EQU  $FA            ; MAXIMUM MS BYTE OF LINE NUMBER
0018                         * PSEUDO OPS
0019 0021                    SKP1      EQU  $21            ; OP CODE OF BRN - SKIP ONE BYTE
0020 008c                    SKP2      EQU  $8C            ; OP CODE OF CMPX # - SKIP TWO BYTES
0021 0086                    SKP1LD    EQU  $86            ; OP CODE OF LDA # - SKIP THE NEXT BYTE
0022                         *                             ; AND LOAD THE VALUE OF THAT BYTE INTO ACCA - THIS
0023                         *                             ; IS USUALLY USED TO LOAD ACCA WITH A NON ZERO VALUE
0024 0015                    RTS_LOW   EQU  $15            ; 6850 ACIA CONTROL REGISTER: RX INT DISABLED, RTS LOW, TX INT DISABLED, 8N1, CLK/16
0025 0000                              ORG  0
0026 0000                    ENDFLG    RMB  1              ; STOP/END FLAG: POSITIVE=STOP, NEG=END
0027 0001                    CHARAC    RMB  1              ; TERMINATOR FLAG 1
0028 0002                    ENDCHR    RMB  1              ; TERMINATOR FLAG 2
0029 0003                    TMPLOC    RMB  1              ; SCRATCH VARIABLE
0030 0004                    IFCTR     RMB  1              ; IF COUNTER - HOW MANY IF STATEMENTS IN A LINE
0031 0005                    DIMFLG    RMB  1              ; *DV* ARRAY FLAG 0=EVALUATE, 1=DIMENSIONING
0032 0006                    VALTYP    RMB  1              ; *DV* *PV TYPE FLAG: 0=NUMERIC, $FF=STRING
0033 0007                    GARBFL    RMB  1              ; *TV STRING SPACE HOUSEKEEPING FLAG
0034 0008                    ARYDIS    RMB  1              ; DISABLE ARRAY SEARCH: 00=ALLOW SEARCH
0035 0009                    INPFLG    RMB  1              ; *TV INPUT FLAG: READ=0, INPUT<>0
0036 000a                    RELFLG    RMB  1              ; *TV RELATIONAL OPERATOR FLAG
0037 000b                    TEMPPT    RMB  2              ; *PV TEMPORARY STRING STACK POINTER
0038 000d                    LASTPT    RMB  2              ; *PV ADDR OF LAST USED STRING STACK ADDRESS
0039 000f                    TEMPTR    RMB  2              ; TEMPORARY POINTER
0040 0011                    TMPTR1    RMB  2              ; TEMPORARY DESCRIPTOR STORAGE (STACK SEARCH)
0041 0013                    FPA2      RMB  4              ; FLOATING POINT ACCUMULATOR #2 MANTISSA
0042 0017                    BOTSTK    RMB  2              ; BOTTOM OF STACK AT LAST CHECK
0043 0019                    TXTTAB    RMB  2              ; *PV BEGINNING OF BASIC PROGRAM
0044 001b                    VARTAB    RMB  2              ; *PV START OF VARIABLES
0045 001d                    ARYTAB    RMB  2              ; *PV START OF ARRAYS
0046 001f                    ARYEND    RMB  2              ; *PV END OF ARRAYS (+1)
0047 0021                    FRETOP    RMB  2              ; *PV START OF STRING STORAGE (TOP OF FREE RAM)
0048 0023                    STRTAB    RMB  2              ; *PV START OF STRING VARIABLES
0049 0025                    FRESPC    RMB  2              ; UTILITY STRING POINTER
0050 0027                    MEMSIZ    RMB  2              ; *PV TOP OF STRING SPACE
0051 0029                    OLDTXT    RMB  2              ; SAVED LINE NUMBER DURING A "STOP"
0052 002b                    BINVAL    RMB  2              ; BINARY VALUE OF A CONVERTED LINE NUMBER
0053 002d                    OLDPTR    RMB  2              ; SAVED INPUT PTR DURING A "STOP"
0054 002f                    TINPTR    RMB  2              ; TEMPORARY INPUT POINTER STORAGE
0055 0031                    DATTXT    RMB  2              ; *PV 'DATA' STATEMENT LINE NUMBER POINTER
0056 0033                    DATPTR    RMB  2              ; *PV 'DATA' STATEMENT ADDRESS POINTER
0057 0035                    DATTMP    RMB  2              ; DATA POINTER FOR 'INPUT' & 'READ'
0058 0037                    VARNAM    RMB  2              ; *TV TEMP STORAGE FOR A VARIABLE NAME
0059 0039                    VARPTR    RMB  2              ; *TV POINTER TO A VARIABLE DESCRIPTOR
0060 003b                    VARDES    RMB  2              ; TEMP POINTER TO A VARIABLE DESCRIPTOR
0061 003d                    RELPTR    RMB  2              ; POINTER TO RELATIONAL OPERATOR PROCESSING ROUTINE
0062 003f                    TRELFL    RMB  1              ; TEMPORARY RELATIONAL OPERATOR FLAG BYTE
0063                         * FLOATING POINT ACCUMULATORS #3,4 & 5 ARE MOSTLY
0064                         * USED AS SCRATCH PAD VARIABLES.
0065                         ** FLOATING POINT ACCUMULATOR #3 :PACKED: ($40-$44)
0066 0040                    V40       RMB  1
0067 0041                    V41       RMB  1
0068 0042                    V42       RMB  1
0069 0043                    V43       RMB  1
0070 0044                    V44       RMB  1
0071                         ** FLOATING POINT ACCUMULATOR #4 :PACKED: ($45-$49)
0072 0045                    V45       RMB  1
0073 0046                    V46       RMB  1
0074 0047                    V47       RMB  1
0075 0048                    V48       RMB  2
0076                         ** FLOATING POINT ACCUMULATOR #5 :PACKED: ($4A-$4E)
0077 004a                    V4A       RMB  1
0078 004b                    V4B       RMB  2
0079 004d                    V4D       RMB  2
0080                         ** FLOATING POINT ACCUMULATOR #0
0081 004f                    FP0EXP    RMB  1              ; *PV FLOATING POINT ACCUMULATOR #0 EXPONENT
0082 0050                    FPA0      RMB  4              ; *PV FLOATING POINT ACCUMULATOR #0 MANTISSA
0083 0054                    FP0SGN    RMB  1              ; *PV FLOATING POINT ACCUMULATOR #0 SIGN
0084 0055                    COEFCT    RMB  1              ; POLYNOMIAL COEFFICIENT COUNTER
0085 0056                    STRDES    RMB  5              ; TEMPORARY STRING DESCRIPTOR
0086 005b                    FPCARY    RMB  1              ; FLOATING POINT CARRY BYTE
0087                         ** FLOATING POINT ACCUMULATOR #1
0088 005c                    FP1EXP    RMB  1              ; *PV FLOATING POINT ACCUMULATOR #1 EXPONENT
0089 005d                    FPA1      RMB  4              ; *PV FLOATING POINT ACCUMULATOR #1 MANTISSA
0090 0061                    FP1SGN    RMB  1              ; *PV FLOATING POINT ACCUMULATOR #1 SIGN
0091 0062                    RESSGN    RMB  1              ; SIGN OF RESULT OF FLOATING POINT OPERATION
0092 0063                    FPSBYT    RMB  1              ; FLOATING POINT SUB BYTE (FIFTH BYTE)
0093 0064                    COEFPT    RMB  2              ; POLYNOMIAL COEFFICIENT POINTER
0094 0066                    LSTTXT    RMB  2              ; CURRENT LINE POINTER DURING LIST
0095 0068                    CURLIN    RMB  2              ; *PV CURRENT LINE # OF BASIC PROGRAM, $FFFF = DIRECT
0096 006a                    DEVCFW    RMB  1              ; *TV TAB FIELD WIDTH
0097 006b                    DEVLCF    RMB  1              ; *TV TAB ZONE
0098 006c                    DEVPOS    RMB  1              ; *TV PRINT POSITION
0099 006d                    DEVWID    RMB  1              ; *TV PRINT WIDTH
0100 006e                    RSTFLG    RMB  1              ; *PV WARM START FLAG: $55=WARM, OTHER=COLD
0101 006f                    RSTVEC    RMB  2              ; *PV WARM START VECTOR - JUMP ADDRESS FOR WARM START
0102 0071                    TOPRAM    RMB  2              ; *PV TOP OF RAM
0103 0073                    IKEYIM    RMB  1              ; *TV INKEY$ RAM IMAGE
0104 0074                    ZERO      RMB  2              ; *PV DUMMY - THESE TWO BYTES ARE ALWAYS ZERO
0105                         * THE FOLLOWING BYTES ARE MOVED DOWN FROM ROM
0106 0076                    LPTCFW    RMB  1              ; 16
0107 0077                    LPTLCF    RMB  1              ; 112
0108 0078                    LPTWID    RMB  1              ; 132
0109 0079                    LPTPOS    RMB  1              ; 0
0110 007a                    EXECJP    RMB  2              ; LB4AA
0111                         
0112                         * THIS ROUTINE PICKS UP THE NEXT INPUT CHARACTER FROM
0113                         * BASIC. THE ADDRESS OF THE NEXT BASIC BYTE TO BE
0114                         * INTERPRETED IS STORED AT CHARAD.
0115 007c 0c 84              GETNCH    INC  <CHARAD+1      ; *PV INCREMENT LS BYTE OF INPUT POINTER
0116 007e 26 02                        BNE  GETCCH         ; *PV BRANCH IF NOT ZERO (NO CARRY)
0117 0080 0c 83                        INC  <CHARAD        ; *PV INCREMENT MS BYTE OF INPUT POINTER
0118 0082 b6                 GETCCH    FCB  $B6            ; *PV OP CODE OF LDA EXTENDED
0119 0083                    CHARAD    RMB  2              ; *PV THESE 2 BYTES CONTAIN ADDRESS OF THE CURRENT
0120                         *         *    CHARACTER WHICH THE BASIC INTERPRETER IS
0121                         *         *    PROCESSING
0122 0085 7e c1 c2                     JMP  BROMHK         ; JUMP BACK INTO THE BASIC RUM
0123                         
0124 0088                    VAB       RMB  1              ; = LOW ORDER FOUR BYTES OF THE PRODUCT
0125 0089                    VAC       RMB  1              ; = OF A FLOATING POINT MULTIPLICATION
0126 008a                    VAD       RMB  1              ; = THESE BYTES ARE USE AS RANDOM DATA
0127 008b                    VAE       RMB  1              ; = BY THE RND STATEMENT
0128                         
0129                         * EXTENDED BASIC VARIABLES
0130 008c                    TRCFLG    RMB  1              ; *PV TRACE FLAG 0=OFF ELSE=ON
0131 008d                    USRADR    RMB  2              ; *PV ADDRESS OF THE START OF USR VECTORS
0132                         
0133                         * EXTENDED BASIC SCRATCH PAD VARIABLES
0134 008f                    VCF       RMB  2
0135 0091                    VD1       RMB  2
0136 0093                    VD3       RMB  2
0137 0095                    VD5       RMB  2
0138 0097                    VD7       RMB  1
0139 0098                    VD8       RMB  1
0140 0099                    VD9       RMB  1
0141 009a                    VDA       RMB  1
0142 009b                    SW3VEC    RMB  3
0143 009e                    SW2VEC    RMB  3
0144 00a1                    SWIVEC    RMB  3
0145 00a4                    NMIVEC    RMB  3
0146 00a7                    IRQVEC    RMB  3
0147 00aa                    FRQVEC    RMB  3
0148 00ad                    USRJMP    RMB  3              ; JUMP ADDRESS FOR BASIC'S USR FUNCTION
0149 00b0                    RVSEED    RMB  1              ; * FLOATING POINT RANDOM NUMBER SEED EXPONENT
0150 00b1                              RMB  4              ; * MANTISSA: INITIALLY SET TO $804FC75259
0151                         
0152                         **** USR FUNCTION VECTOR ADDRESSES (EX BASIC ONLY)
0153 00b5                    USR0      RMB  2              ; USR 0 VECTOR
0154 00b7                              RMB  2              ; USR 1
0155 00b9                              RMB  2              ; USR 2
0156 00bb                              RMB  2              ; USR 3
0157 00bd                              RMB  2              ; USR 4
0158 00bf                              RMB  2              ; USR 5
0159 00c1                              RMB  2              ; USR 6
0160 00c3                              RMB  2              ; USR 7
0161 00c5                              RMB  2              ; USR 8
0162 00c7                              RMB  2              ; USR 9
0163                         
0164 00c9                    STRSTK    RMB  8*5            ; STRING DESCRIPTOR STACK
0165 00f1                    LINHDR    RMB  2              ; LINE INPUT BUFFER HEADER
0166 00f3                    LINBUF    RMB  LBUFMX+1       ; BASIC LINE INPUT BUFFER
0167 01ee                    STRBUF    RMB  41             ; STRING BUFFER
0168                         
0169 0217                    PROGST    RMB  1              ; START OF PROGRAM SPACE
0170                         *         INTERRUPT VECTORS
0171                         *          ORG  $FFF2
0172                         *SWI3      RMB  2
0173                         *SWI2      RMB  2
0174                         *FIRQ      RMB  2
0175                         *IRQ       RMB  2
0176                         *SWI       RMB  2
0177                         *NMI       RMB  2
0178                         *RESETV    RMB  2
0179                         
0180 c000                              ORG  $C000
0181                         
0182                         * JUMP TO BASIC COLD START AT START OF ROM FOR CONVENIENCE
0183 c000 7e c0 49                     JMP   RESVEC
0184                         
0185                         * CONSOLE IN
0186 c003 8d 03              LA171     BSR  KEYIN          ; GET A CHARACTER FROM CONSOLE IN
0187 c005 27 fc                        BEQ  LA171          ; LOOP IF NO KEY DOWN
0188 c007 39                           RTS
0189                         
0190                         *
0191                         * THIS ROUTINE GETS A KEYSTROKE FROM THE KEYBOARD IF A KEY
0192                         * IS DOWN. IT RETURNS ZERO TRUE IF THERE WAS NO KEY DOWN.
0193                         *
0194                         *
0195                         LA1C1
0196 c008 b6 a0 00           KEYIN     LDA  USTAT
0197 c00b 85 01                        BITA #1
0198 c00d 27 06                        BEQ  NOCHAR
0199 c00f b6 a0 01                     LDA  RECEV
0200 c012 84 7f                        ANDA #$7F
0201 c014 39                           RTS
0202 c015 4f                 NOCHAR    CLRA
0203 c016 39                           RTS
0204                         
0205                         
0206                         
0207                         * CONSOLE OUT
0208 c017 8d 24              PUTCHR    BSR  WAITACIA
0209 c019 34 02                        PSHS A              ;
0210 c01b 81 0d                        CMPA #CR            ; IS IT CARRIAGE RETURN?
0211 c01d 27 0b                        BEQ  NEWLINE        ; YES
0212 c01f b7 a0 01                     STA  TRANS
0213 c022 0c 79                        INC  LPTPOS         ; INCREMENT CHARACTER COUNTER
0214 c024 96 79                        LDA  LPTPOS         ; CHECK FOR END OF LINE PRINTER LINE
0215 c026 91 78                        CMPA LPTWID         ; AT END OF LINE PRINTER LINE?
0216 c028 25 10                        BLO  PUTEND         ; NO
0217 c02a 0f 79              NEWLINE   CLR  LPTPOS         ; RESET CHARACTER COUNTER
0218 c02c 8d 0f                        BSR  WAITACIA
0219 c02e 86 0d                        LDA  #13
0220 c030 b7 a0 01                     STA  TRANS
0221 c033 8d 08                        BSR  WAITACIA
0222 c035 86 0a                        LDA  #10            ; DO LINEFEED AFTER CR
0223 c037 b7 a0 01                     STA  TRANS
0224 c03a 35 02              PUTEND    PULS A              ;
0225 c03c 39                           RTS
0226                         
0227 c03d 34 02              WAITACIA  PSHS A
0228 c03f b6 a0 00           WRWAIT    LDA  USTAT
0229 c042 85 02                        BITA #2
0230 c044 27 f9                        BEQ  WRWAIT
0231 c046 35 02                        PULS A              ;
0232 c048 39                           RTS
0233                         
0234                         *
0235                         RESVEC
0236 c049 10 ce 01 ee        LA00E     LDS  #LINBUF+LBUFMX+1 ; SET STACK TO TOP OF LINE INPUT BUFFER
0237 c04d 96 6e                        LDA  RSTFLG         ; GET WARM START FLAG
0238 c04f 81 55                        CMPA #$55           ; IS IT A WARM START?
0239 c051 26 0a                        BNE  BACDST         ; NO - D0 A COLD START
0240 c053 9e 6f                        LDX  RSTVEC         ; WARM START VECTOR
0241 c055 a6 84                        LDA  ,X             ; GET FIRST BYTE OF WARM START ADDR
0242 c057 81 12                        CMPA #$12           ; IS IT NOP?
0243 c059 26 02                        BNE  BACDST         ; NO - DO A COLD START
0244 c05b 6e 84                        JMP  ,X             ; YES, G0 THERE
0245                         
0246                         * COLD START ENTRY
0247                         
0248 c05d 8e 02 18           BACDST    LDX  #PROGST+1      ; POINT X TO CLEAR 1ST 1K OF RAM
0249 c060 6f 83              LA077     CLR  ,--X           ; MOVE POINTER DOWN TWO-CLEAR BYTE
0250 c062 30 01                        LEAX 1,X            ; ADVANCE POINTER ONE
0251 c064 26 fa                        BNE  LA077          ; KEEP GOING IF NOT AT BOTTOM OF PAGE 0
0252 c066 8e 02 17                     LDX  #PROGST        ; SET TO START OF PROGRAM SPACE
0253 c069 6f 80                        CLR  ,X+            ; CLEAR 1ST BYTE OF BASIC PROGRAM
0254 c06b 9f 19                        STX  TXTTAB         ; BEGINNING OF BASIC PROGRAM
0255 c06d a6 02              LA084     LDA  2,X            ; LOOK FOR END OF MEMORY
0256 c06f 43                           COMA                ; * COMPLEMENT IT AND PUT IT BACK
0257 c070 a7 02                        STA  2,X            ; * INTO SYSTEM MEMORY
0258 c072 a1 02                        CMPA 2,X            ; IS IT RAM?
0259 c074 26 06                        BNE  LA093          ; BRANCH IF NOT (ROM, BAD RAM OR NO RAM)
0260 c076 30 01                        LEAX 1,X            ; MOVE POINTER UP ONE
0261 c078 63 01                        COM  1,X            ; RE-COMPLEMENT TO RESTORE BYTE
0262 c07a 20 f1                        BRA  LA084          ; KEEP LOOKING FOR END OF RAM
0263 c07c 9f 71              LA093     STX  TOPRAM         ; SAVE ABSOLUTE TOP OF RAM
0264 c07e 9f 27                        STX  MEMSIZ         ; SAVE TOP OF STRING SPACE
0265 c080 9f 23                        STX  STRTAB         ; SAVE START OF STRING VARIABLES
0266 c082 30 89 ff 38                  LEAX -200,X         ; CLEAR 200 - DEFAULT STRING SPACE TO 200 BYTES
0267 c086 9f 21                        STX  FRETOP         ; SAVE START OF STRING SPACE
0268 c088 1f 14                        TFR  X,S            ; PUT STACK THERE
0269 c08a 8e c0 d1                     LDX  #LA10D         ; POINT X TO ROM SOURCE DATA
0270 c08d ce 00 76                     LDU  #LPTCFW        ; POINT U TO RAM DESTINATION
0271 c090 c6 12                        LDB  #18            ; MOVE 18 BYTES
0272 c092 bd c1 b1                     JSR  LA59A          ; MOVE 18 BYTES FROM ROM TO RAM
0273 c095 ce 00 a7                     LDU  #IRQVEC        ; POINT U TO NEXT RAM DESTINATION
0274 c098 c6 04                        LDB  #4             ; MOVE 4 MORE BYTES
0275 c09a bd c1 b1                     JSR  LA59A          ; MOVE 4 BYTES FROM ROM TO RAM
0276 c09d 86 39                        LDA  #$39
0277 c09f 97 f0                        STA  LINHDR-1       ; PUT RTS IN LINHDR-1
0278 c0a1 bd c4 bd                     JSR  LAD19          ; G0 DO A 'NEW'
0279                         * EXTENDED BASIC INITIALISATION
0280 c0a4 8e 00 b5                     LDX  #USR0          ; INITIALIZE ADDRESS OF START OF
0281 c0a7 9f 8d                        STX  USRADR         ; USR JUMP TABLE
0282                         * INITIALIZE THE USR CALLS TO 'FC ERROR'
0283 c0a9 ce cb d1                     LDU  #LB44A         ; ADDRESS OF 'FC ERROR' ROUTINE
0284 c0ac c6 0a                        LDB  #10            ; 10 USR CALLS IN EX BASIC
0285 c0ae ef 81              L8031     STU  ,X++           ; STORE 'FC' ERROR AT USR ADDRESSES
0286 c0b0 5a                           DECB                ; FINISHED ALL 10?
0287 c0b1 26 fb                        BNE  L8031          ; NO
0288                         
0289                         * INITIALISE ACIA
0290 c0b3 86 15                        LDA  #RTS_LOW       ; DIV16 CLOCK -> 7372800 / 4 / 16 = 115200
0291 c0b5 b7 a0 00                     STA  UCTRL
0292 c0b8 8e c1 06                     LDX  #LA147-1       ; POINT X TO COLOR BASIC COPYRIGHT MESSAGE
0293 c0bb bd d0 e8                     JSR  LB99C          ; PRINT 'COLOR BASIC'
0294 c0be 8e c0 c9                     LDX  #BAWMST        ; WARM START ADDRESS
0295 c0c1 9f 6f                        STX  RSTVEC         ; SAVE IT
0296 c0c3 86 55                        LDA  #$55           ; WARM START FLAG
0297 c0c5 97 6e                        STA  RSTFLG         ; SAVE IT
0298 c0c7 20 04                        BRA  LA0F3          ; GO TO BASIC'S MAIN LOOP
0299 c0c9 12                 BAWMST    NOP                 ; NOP REQ'D FOR WARM START
0300 c0ca bd c4 d7                     JSR  LAD33          ; DO PART OF A NEW
0301 c0cd 7e c4 25           LA0F3     JMP  LAC73          ; GO TO MAIN LOOP OF BASIC
0302                         *
0303                         * FIRQ SERVICE ROUTINE
0304                         BFRQSV
0305 c0d0 3b                           RTI
0306                         *
0307                         * THESE BYTES ARE MOVED TO ADDRESSES $76 - $85 THE DIRECT PAGE
0308 c0d1 10                 LA10D     FCB  16             ; TAB FIELD WIDTH
0309 c0d2 40                           FCB  64             ; LAST TAB ZONE
0310 c0d3 50                           FCB  80             ; PRINTER WIDTH
0311 c0d4 00                           FCB  0              ; LINE PRINTER POSITION
0312 c0d5 cb d1                        FDB  LB44A          ; ARGUMENT OF EXEC COMMAND - SET TO 'FC' ERROR
0313                         * LINE INPUT ROUTINE
0314 c0d7 0c 84                        INC  CHARAD+1
0315 c0d9 26 02                        BNE  LA123
0316 c0db 0c 83                        INC  CHARAD
0317 c0dd b6 00 00           LA123     LDA  >0000
0318 c0e0 7e c1 c2                     JMP  BROMHK
0319                         *
0320                         * THESE BYTES ARE MOVED TO ADDRESSES $A7-$B1
0321 c0e3 7e c1 c1                     JMP  BIRQSV         ; IRQ SERVICE
0322 c0e6 7e c0 d0                     JMP  BFRQSV         ; FIRQ SERVICE
0323 c0e9 7e cb d1                     JMP  LB44A          ; USR ADDRESS FOR 8K BASIC (INITIALIZED TO 'FC' ERROR)
0324 c0ec 80                           FCB  $80            ; *RANDOM SEED
0325 c0ed 4f c7                        FDB  $4FC7          ; *RANDON SEED OF MANTISSA
0326 c0ef 52 59                        FDB  $5259          ; *.811635157
0327                         * BASIC COMMAND INTERPRETATION TABLE ROM IMAGE
0328 c0f1 32                 COMVEC    FCB  50             ; 50 BASIC COMMANDS
0329 c0f2 c2 20                        FDB  LAA66          ; POINTS TO RESERVED WORDS
0330 c0f4 c3 2d                        FDB  LAB67          ; POINTS TO JUMP TABLE FOR COMMANDS
0331 c0f6 1d                           FCB  29             ; 29 BASIC SECONDARY COMMANDS
0332 c0f7 c2 c0                        FDB  LAB1A          ; POINTS TO SECONDARY FUNCTION RESERVED WORDS
0333 c0f9 c1 d1                        FDB  LAA29          ; POINTS TO SECONDARY FUNCTION JUMP TABLE
0334 c0fb 00 00                        FDB  0              ; NO MORE TABLES (RES WORDS=0)
0335 c0fd 00 00                        FDB  0              ; NO MORE TABLES
0336 c0ff 00 00                        FDB  0              ; NO MORE TABLES
0337 c101 00 00                        FDB  0              ; NO MORE TABLES
0338 c103 00 00                        FDB  0              ; NO MORE TABLES
0339 c105 00 00                        FDB  0              ; NO MORE TABLES (SECONDARY FNS =0)
0340                         
0341                         * COPYRIGHT MESSAGES
0342 c107 36 38 30 39 20 45  LA147     FCC  "6809 EXTENDED BASIC"
     58 54 45 4e 44 45
     44 20 42 41 53 49
     43
0343 c11a 0d                           FCB  CR
0344 c11b 28 43 29 20 31 39            FCC  "(C) 1982 BY MICROSOFT"
     38 32 20 42 59 20
     4d 49 43 52 4f 53
     4f 46 54
0345 c130 0d 0d              LA156     FCB  CR,CR
0346 c132 00                 LA165     FCB  $00
0347                         
0348                         
0349 c133 34 16              LA35F     PSHS X,B,A          ; SAVE REGISTERS
0350 c135 9e 76                        LDX  LPTCFW         ; TAB FIELD WIDTH AND TAB ZONE
0351 c137 dc 78                        LDD  LPTWID         ; PRINTER WIDTH AND POSITION
0352 c139 9f 6a              LA37C     STX  DEVCFW         ; SAVE TAB FIELD WIDTH AND ZONE
0353 c13b d7 6c                        STB  DEVPOS         ; SAVE PRINT POSITION
0354 c13d 97 6d                        STA  DEVWID         ; SAVE PRINT WIDTH
0355 c13f 35 96                        PULS A,B,X,PC       ; RESTORE REGISTERS
0356                         
0357                         * THIS IS THE ROUTINE THAT GETS AN INPUT LINE FOR BASIC
0358                         * EXIT WITH BREAK KEY: CARRY = 1
0359                         * EXIT WITH ENTER KEY: CARRY = 0
0360                         LA38D
0361 c141 0f 73              LA390     CLR  IKEYIM         ; RESET BREAK CHECK KEY TEMP KEY STORAGE
0362 c143 8e 00 f4                     LDX  #LINBUF+1      ; INPUT LINE BUFFER
0363 c146 c6 01                        LDB  #1             ; ACCB CHAR COUNTER: SET TO 1 TO ALLOW A
0364                         *         BACKSPACE AS FIRST CHARACTER
0365 c148 bd c0 03           LA39A     JSR  LA171          ; GO GET A CHARACTER FROM CONSOLE IN
0366 c14b 81 08                        CMPA #BS            ; BACKSPACE
0367 c14d 26 07                        BNE  LA3B4          ; NO
0368 c14f 5a                           DECB                ; YES - DECREMENT CHAR COUNTER
0369 c150 27 ef                        BEQ  LA390          ; BRANCH IF BACK AT START OF LINE AGAIN
0370 c152 30 1f                        LEAX -1,X           ; DECREMENT BUFFER POINTER
0371 c154 20 34                        BRA  LA3E8          ; ECHO CHAR TO SCREEN
0372 c156 81 15              LA3B4     CMPA #$15           ; SHIFT RIGHT ARROW?
0373 c158 26 0a                        BNE  LA3C2          ; NO
0374                         * YES, RESET BUFFER TO BEGINNING AND ERASE CURRENT LINE
0375 c15a 5a                 LA3B8     DECB                ; DEC CHAR CTR
0376 c15b 27 e4                        BEQ  LA390          ; GO BACK TO START IF CHAR CTR = 0
0377 c15d 86 08                        LDA  #BS            ; BACKSPACE?
0378 c15f bd c0 17                     JSR  PUTCHR         ; SEND TO CONSOLE OUT (SCREEN)
0379 c162 20 f6                        BRA  LA3B8          ; KEEP GOING
0380 c164 81 03              LA3C2     CMPA #3             ; BREAK KEY?
0381 c166 1a 01                        ORCC #1             ; SET CARRY FLAG
0382 c168 27 05                        BEQ  LA3CD          ; BRANCH IF BREAK KEY DOWN
0383 c16a 81 0d              LA3C8     CMPA #CR            ; ENTER KEY?
0384 c16c 26 0d                        BNE  LA3D9          ; NO
0385 c16e 4f                 LA3CC     CLRA                ; CLEAR CARRY FLAG IF ENTER KEY - END LINE ENTRY
0386 c16f 34 01              LA3CD     PSHS CC             ; SAVE CARRY FLAG
0387 c171 bd d0 a8                     JSR  LB958          ; SEND CR TO SCREEN
0388 c174 6f 84                        CLR  ,X             ; MAKE LAST BYTE IN INPUT BUFFER = 0
0389 c176 8e 00 f3                     LDX  #LINBUF        ; RESET INPUT BUFFER POINTER
0390 c179 35 81                        PULS CC,PC          ; RESTORE CARRY FLAG
0391                         
0392                         * INSERT A CHARACTER INTO THE BASIC LINE INPUT BUFFER
0393 c17b 81 20              LA3D9     CMPA #$20           ; IS IT CONTROL CHAR?
0394 c17d 25 c9                        BLO  LA39A          ; BRANCH IF CONTROL CHARACTER
0395 c17f 81 7b                        CMPA #'z+1          ; *
0396 c181 24 c5                        BCC  LA39A          ; * IGNORE IF > LOWER CASE Z
0397 c183 c1 fa                        CMPB #LBUFMX        ; HAVE 250 OR MORE CHARACTERS BEEN ENTERED?
0398 c185 24 c1                        BCC  LA39A          ; YES, IGNORE ANY MORE
0399 c187 a7 80                        STA  ,X+            ; PUT IT IN INPUT BUFFER
0400 c189 5c                           INCB                ; INCREMENT CHARACTER COUNTER
0401 c18a bd c0 17           LA3E8     JSR  PUTCHR         ; ECHO IT TO SCREEN
0402 c18d 20 b9                        BRA  LA39A          ; GO SET SOME MORE
0403                         
0404                         
0405                         * EXEC
0406 c18f 27 05              EXEC      BEQ  LA545          ; BRANCH IF NO ARGUMENT
0407 c191 bd ce c4                     JSR  LB73D          ; EVALUATE ARGUMENT - ARGUMENT RETURNED IN X
0408 c194 9f 7a                        STX  EXECJP         ; STORE X TO EXEC JUMP ADDRESS
0409 c196 6e 9f 00 7a        LA545     JMP  [EXECJP]       ; GO DO IT
0410                         
0411                         * BREAK CHECK
0412 c19a 7e c5 a6           LA549     JMP  LADEB          ; GO DO BREAK KEY CHECK
0413                         
0414                         * INKEY$
0415 c19d 96 73              INKEY     LDA  IKEYIM         ; WAS A KEY DOWN IN THE BREAK CHECK?
0416 c19f 26 03                        BNE  LA56B          ; YES
0417 c1a1 bd c0 08                     JSR  KEYIN          ; GO GET A KEY
0418 c1a4 0f 73              LA56B     CLR  IKEYIM         ; CLEAR INKEY RAM IMAGE
0419 c1a6 97 53                        STA  FPA0+3         ; STORE THE KEY IN FPA0
0420 c1a8 10 26 0c 6a                  LBNE LB68F          ; CONVERT FPA0+3 TO A STRING
0421 c1ac 97 56                        STA  STRDES         ; SET LENGTH OF STRING = 0 IF NO KEY DOWN
0422 c1ae 7e ce 22                     JMP  LB69B          ; PUT A NULL STRING ONTO THE STRING STACK
0423                         
0424                         * MOVE ACCB BYTES FROM (X) TO (U)
0425 c1b1 a6 80              LA59A     LDA  ,X+            ; GET BYTE FROM X
0426 c1b3 a7 c0                        STA  ,U+            ; STORE IT AT U
0427 c1b5 5a                           DECB                ; MOVED ALL BYTES?
0428 c1b6 26 f9                        BNE  LA59A          ; NO
0429 c1b8 39                 LA5A1     RTS
0430                         
0431 c1b9 39                 LA5C4     RTS
0432                         
0433                         ** THIS ROUTINE WILL SCAN OFF THE FILE NAME FROM A BASIC LINE
0434                         ** AND RETURN A SYNTAX ERROR IF THERE ARE ANY CHARACTERS
0435                         ** FOLLOWING THE END OF THE NAME
0436 c1ba 9d 82              LA5C7     JSR  GETCCH         ; GET CURRENT INPUT CHAR FROM BASIC LINE
0437 c1bc 27 fb              LA5C9     BEQ  LA5C4          ; RETURN IF END OF LINE
0438 c1be 7e ca 03                     JMP  LB277          ; SYNTAX ERROR IF ANY MORE CHARACTERS
0439                         * IRQ SERVICE
0440                         BIRQSV
0441 c1c1 3b                 LA9C5     RTI                 ; RETURN FROM INTERRUPT
0442                         
0443                         * SET CARRY IF NUMERIC - RETURN WITH
0444                         * ZERO FLAG SET IF ACCA = 0 OR 3A(:) - END
0445                         * OF BASIC LINE OR SUB LINE
0446 c1c2 81 3a              BROMHK    CMPA #'9+1          ; IS THIS CHARACTER >=(ASCII 9)+1?
0447 c1c4 24 0a                        BHS  LAA28          ; BRANCH IF > 9; Z SET IF = COLON
0448 c1c6 81 20                        CMPA #SPACE         ; SPACE?
0449 c1c8 26 02                        BNE  LAA24          ; NO - SET CARRY IF NUMERIC
0450 c1ca 0e 7c                        JMP  GETNCH         ; IF SPACE, GET NECT CHAR (IGNORE SPACES)
0451 c1cc 80 30              LAA24     SUBA #'0            ; * SET CARRY IF
0452 c1ce 80 d0                        SUBA #-'0           ; * CHARACTER > ASCII 0
0453 c1d0 39                 LAA28     RTS
0454                         
0455                         * DISPATCH TABLE FOR SECONDARY FUNCTIONS
0456                         * TOKENS ARE PRECEEDED BY $FF
0457                         * FIRST SET ALWAYS HAS ONE PARAMETER
0458                         FUNC_TAB
0459 c1d1 d3 c6              LAA29     FDB  SGN            ; SGN
0460 c1d3 d4 3a                        FDB  INT            ; INT
0461 c1d5 d3 df                        FDB  ABS            ; ABS
0462 c1d7 00 ad                        FDB  USRJMP         ; USR
0463 0083                    TOK_USR   EQU  *-FUNC_TAB/2+$7F
0464 ff83                    TOK_FF_USR EQU  *-FUNC_TAB/2+$FF7F
0465 c1d9 d6 6b                        FDB  RND            ; RND
0466 c1db d6 c0                        FDB  SIN            ; SIN
0467 c1dd ce d7                        FDB  PEEK           ; PEEK
0468 c1df ce 08                        FDB  LEN            ; LEN
0469 c1e1 cc 84                        FDB  STR            ; STR$
0470 c1e3 ce 9d                        FDB  VAL            ; VAL
0471 c1e5 ce 27                        FDB  ASC            ; ASC
0472 c1e7 ce 13                        FDB  CHR            ; CHR$
0473 c1e9 d7 70                        FDB  ATN            ; ATN
0474 c1eb d7 38                        FDB  COS            ; COS
0475 c1ed d7 41                        FDB  TAN            ; TAN
0476 c1ef d8 b2                        FDB  EXP            ; EXP
0477 c1f1 d8 e4                        FDB  FIX            ; FIX
0478 c1f3 d8 06                        FDB  LOG            ; LOG
0479 c1f5 da 6c                        FDB  POS            ; POS
0480 c1f7 d8 40                        FDB  SQR            ; SQR
0481 c1f9 df 3e                        FDB  HEXDOL         ; HEX$
0482                         * LEFT, RIGHT AND MID ARE TREATED SEPARATELY
0483 c1fb ce 32                        FDB  LEFT           ; LEFT$
0484 0095                    TOK_LEFT  EQU  *-FUNC_TAB/2+$7F
0485 c1fd ce 4f                        FDB  RIGHT          ; RIGHT$
0486 c1ff ce 56                        FDB  MID            ; MID$
0487 0097                    TOK_MID   EQU  *-FUNC_TAB/2+$7F
0488                         * REMAINING FUNCTIONS
0489 c201 c1 9d                        FDB  INKEY          ; INKEY$
0490 0098                    TOK_INKEY EQU  *-FUNC_TAB/2+$7F
0491 c203 cc 75                        FDB  MEM            ; MEM
0492 c205 da 74                        FDB  VARPT          ; VARPTR
0493 c207 db 34                        FDB  INSTR          ; INSTR
0494 c209 db 04                        FDB  STRING         ; STRING$
0495 001d                    NUM_SEC_FNS EQU  *-FUNC_TAB/2
0496                         
0497                         * THIS TABLE CONTAINS PRECEDENCES AND DISPATCH ADDRESSES FOR ARITHMETIC
0498                         * AND LOGICAL OPERATORS - THE NEGATION OPERATORS DO NOT ACT ON TWO OPERANDS
0499                         * S0 THEY ARE NOT LISTED IN THIS TABLE. THEY ARE TREATED SEPARATELY IN THE
0500                         * EXPRESSION EVALUATION ROUTINE. THEY ARE:
0501                         * UNARY NEGATION (-), PRECEDENCE &7D AND LOGICAL NEGATION (NOT), PRECEDENCE $5A
0502                         * THE RELATIONAL OPERATORS < > = ARE ALSO NOT LISTED, PRECEDENCE $64.
0503                         * A PRECEDENCE VALUE OF ZERO INDICATES END OF EXPRESSION OR PARENTHESES
0504                         *
0505 c20b 79                 LAA51     FCB  $79
0506 c20c d1 11                        FDB  LB9C5          ; +
0507 c20e 79                           FCB  $79
0508 c20f d1 08                        FDB  LB9BC          ; -
0509 c211 7b                           FCB  $7B
0510 c212 d2 18                        FDB  LBACC          ; *
0511 c214 7b                           FCB  $7B
0512 c215 d2 dd                        FDB  LBB91          ; /
0513 c217 7f                           FCB  $7F
0514 c218 d8 49                        FDB  L8489          ; EXPONENTIATION
0515 c21a 50                           FCB  $50
0516 c21b ca 5c                        FDB  LB2D5          ; AND
0517 c21d 46                           FCB  $46
0518 c21e ca 5b                        FDB  LB2D4          ; OR
0519                         
0520                         * THIS IS THE RESERVED WORD TABLE
0521                         * FIRST PART OF THE TABLE CONTAINS EXECUTABLE COMMANDS
0522 c220 46 4f              LAA66     FCC  "FO"           ; 80
0523 c222 d2                           FCB  $80+'R
0524 c223 47                           FCC  "G"            ; 81
0525 c224 cf                           FCB  $80+'O
0526 0081                    TOK_GO    EQU  $81
0527 c225 52 45                        FCC  "RE"           ; 82
0528 c227 cd                           FCB  $80+'M
0529 c228 a7                           FCB  ''+$80         ; 83
0530 c229 45 4c 53                     FCC  "ELS"          ; 84
0531 c22c c5                           FCB  $80+'E
0532 c22d 49                           FCC  "I"            ; 85
0533 c22e c6                           FCB  $80+'F
0534 c22f 44 41 54                     FCC  "DAT"          ; 86
0535 c232 c1                           FCB  $80+'A
0536 c233 50 52 49 4e                  FCC  "PRIN"         ; 87
0537 c237 d4                           FCB  $80+'T
0538 c238 4f                           FCC  "O"            ; 88
0539 c239 ce                           FCB  $80+'N
0540 c23a 49 4e 50 55                  FCC  "INPU"         ; 89
0541 c23e d4                           FCB  $80+'T
0542 c23f 45 4e                        FCC  "EN"           ; 8A
0543 c241 c4                           FCB  $80+'D
0544 c242 4e 45 58                     FCC  "NEX"          ; 8B
0545 c245 d4                           FCB  $80+'T
0546 c246 44 49                        FCC  "DI"           ; 8C
0547 c248 cd                           FCB  $80+'M
0548 c249 52 45 41                     FCC  "REA"          ; 8D
0549 c24c c4                           FCB  $80+'D
0550 c24d 52 55                        FCC  "RU"           ; 8E
0551 c24f ce                           FCB  $80+'N
0552 c250 52 45 53 54 4f 52            FCC  "RESTOR"       ; 8F
0553 c256 c5                           FCB  $80+'E
0554 c257 52 45 54 55 52               FCC  "RETUR"        ; 90
0555 c25c ce                           FCB  $80+'N
0556 c25d 53 54 4f                     FCC  "STO"          ; 91
0557 c260 d0                           FCB  $80+'P
0558 c261 50 4f 4b                     FCC  "POK"          ; 92
0559 c264 c5                           FCB  $80+'E
0560 c265 43 4f 4e                     FCC  "CON"          ; 93
0561 c268 d4                           FCB  $80+'T
0562 c269 4c 49 53                     FCC  "LIS"          ; 94
0563 c26c d4                           FCB  $80+'T
0564 c26d 43 4c 45 41                  FCC  "CLEA"         ; 95
0565 c271 d2                           FCB  $80+'R
0566 c272 4e 45                        FCC  "NE"           ; 96
0567 c274 d7                           FCB  $80+'W
0568 c275 45 58 45                     FCC  "EXE"          ; 97
0569 c278 c3                           FCB  $80+'C
0570 c279 54 52 4f                     FCC  "TRO"          ; 98
0571 c27c ce                           FCB  $80+'N
0572 c27d 54 52 4f 46                  FCC  "TROF"         ; 99
0573 c281 c6                           FCB  $80+'F
0574 c282 44 45                        FCC  "DE"           ; 9A
0575 c284 cc                           FCB  $80+'L
0576 c285 44 45                        FCC  "DE"           ; 9B
0577 c287 c6                           FCB  $80+'F
0578 c288 4c 49 4e                     FCC  "LIN"          ; 9C
0579 c28b c5                           FCB  $80+'E
0580 c28c 52 45 4e 55                  FCC  "RENU"         ; 9D
0581 c290 cd                           FCB  $80+'M
0582 c291 45 44 49                     FCC  "EDI"          ; 9E
0583 c294 d4                           FCB  $80+'T
0584                         * END OF EXECUTABLE COMMANDS. THE REMAINDER OF THE TABLE ARE NON-EXECUTABLE TOKENS
0585 c295 54 41 42                     FCC  "TAB"          ; 9F
0586 c298 a8                           FCB  $80+'(
0587 009f                    TOK_TAB   EQU  $9F
0588 c299 54                           FCC  "T"            ; A0
0589 c29a cf                           FCB  $80+'O
0590 00a0                    TOK_TO    EQU  $A0
0591 c29b 53 55                        FCC  "SU"           ; A1
0592 c29d c2                           FCB  $80+'B
0593 00a1                    TOK_SUB   EQU  $A1
0594 c29e 54 48 45                     FCC  "THE"          ; A2
0595 c2a1 ce                           FCB  $80+'N
0596 00a2                    TOK_THEN  EQU  $A2
0597 c2a2 4e 4f                        FCC  "NO"           ; A3
0598 c2a4 d4                           FCB  $80+'T
0599 00a3                    TOK_NOT   EQU  $A3
0600 c2a5 53 54 45                     FCC  "STE"          ; A4
0601 c2a8 d0                           FCB  $80+'P
0602 00a4                    TOK_STEP  EQU  $A4
0603 c2a9 4f 46                        FCC  "OF"           ; A5
0604 c2ab c6                           FCB  $80+'F
0605 c2ac ab                           FCB  '++$80         ; A6
0606 00a6                    TOK_PLUS  EQU  $A6
0607 c2ad ad                           FCB  '-+$80         ; A7
0608 00a7                    TOK_MINUS EQU  $A7
0609 c2ae aa                           FCB  '*+$80         ; A8
0610 c2af af                           FCB  '/+$80         ; A9
0611 c2b0 de                           FCB  '^+$80         ; AA
0612 c2b1 41 4e                        FCC  "AN"           ; AB
0613 c2b3 c4                           FCB  $80+'D
0614 c2b4 4f                           FCC  "O"            ; AC
0615 c2b5 d2                           FCB  $80+'R
0616 c2b6 be                           FCB  '>+$80         ; AD
0617 00ad                    TOK_GREATER EQU  $AD
0618 c2b7 bd                           FCB  '=+$80         ; AE
0619 00ae                    TOK_EQUALS EQU  $AE
0620 c2b8 bc                           FCB  '<+$80         ; AF
0621 c2b9 46                           FCC  "F"            ; B0
0622 c2ba ce                           FCB  $80+'N
0623 00b0                    TOK_FN    EQU  $B0
0624 c2bb 55 53 49 4e                  FCC  "USIN"         ; B1
0625 c2bf c7                           FCB  $80+'G
0626 00b1                    TOK_USING EQU  $B1
0627                         *
0628                         
0629                         * FIRST SET ALWAYS HAS ONE PARAMETER
0630 c2c0 53 47              LAB1A     FCC  "SG"           ; 80
0631 c2c2 ce                           FCB  $80+'N
0632 c2c3 49 4e                        FCC  "IN"           ; 81
0633 c2c5 d4                           FCB  $80+'T
0634 c2c6 41 42                        FCC  "AB"           ; 82
0635 c2c8 d3                           FCB  $80+'S
0636 c2c9 55 53                        FCC  "US"           ; 83
0637 c2cb d2                           FCB  $80+'R
0638 c2cc 52 4e                        FCC  "RN"           ; 84
0639 c2ce c4                           FCB  $80+'D
0640 c2cf 53 49                        FCC  "SI"           ; 85
0641 c2d1 ce                           FCB  $80+'N
0642 c2d2 50 45 45                     FCC  "PEE"          ; 86
0643 c2d5 cb                           FCB  $80+'K
0644 c2d6 4c 45                        FCC  "LE"           ; 87
0645 c2d8 ce                           FCB  $80+'N
0646 c2d9 53 54 52                     FCC  "STR"          ; 88
0647 c2dc a4                           FCB  $80+'$
0648 c2dd 56 41                        FCC  "VA"           ; 89
0649 c2df cc                           FCB  $80+'L
0650 c2e0 41 53                        FCC  "AS"           ; 8A
0651 c2e2 c3                           FCB  $80+'C
0652 c2e3 43 48 52                     FCC  "CHR"          ; 8B
0653 c2e6 a4                           FCB  $80+'$
0654 c2e7 41 54                        FCC  "AT"           ; 8C
0655 c2e9 ce                           FCB  $80+'N
0656 c2ea 43 4f                        FCC  "CO"           ; 8D
0657 c2ec d3                           FCB  $80+'S
0658 c2ed 54 41                        FCC  "TA"           ; 8E
0659 c2ef ce                           FCB  $80+'N
0660 c2f0 45 58                        FCC  "EX"           ; 8F
0661 c2f2 d0                           FCB  $80+'P
0662 c2f3 46 49                        FCC  "FI"           ; 90
0663 c2f5 d8                           FCB  $80+'X
0664 c2f6 4c 4f                        FCC  "LO"           ; 91
0665 c2f8 c7                           FCB  $80+'G
0666 c2f9 50 4f                        FCC  "PO"           ; 92
0667 c2fb d3                           FCB  $80+'S
0668 c2fc 53 51                        FCC  "SQ"           ; 93
0669 c2fe d2                           FCB  $80+'R
0670 c2ff 48 45 58                     FCC  "HEX"          ; 94
0671 c302 a4                           FCB  $80+'$
0672                         * LEFT, RIGHT AND MID ARE TREATED SEPARATELY
0673 c303 4c 45 46 54                  FCC  "LEFT"         ; 95
0674 c307 a4                           FCB  $80+'$
0675 c308 52 49 47 48 54               FCC  "RIGHT"        ; 96
0676 c30d a4                           FCB  $80+'$
0677 c30e 4d 49 44                     FCC  "MID"          ; 97
0678 c311 a4                           FCB  $80+'$
0679                         * REMAINING FUNCTIONS
0680 c312 49 4e 4b 45 59               FCC  "INKEY"        ; 98
0681 c317 a4                           FCB  $80+'$
0682 c318 4d 45                        FCC  "ME"           ; 99
0683 c31a cd                           FCB  $80+'M
0684 c31b 56 41 52 50 54               FCC  "VARPT"        ; 9A
0685 c320 d2                           FCB  $80+'R
0686 c321 49 4e 53 54                  FCC  "INST"         ; 9B
0687 c325 d2                           FCB  $80+'R
0688 c326 53 54 52 49 4e 47            FCC  "STRING"       ; 9C
0689 c32c a4                           FCB  $80+'$
0690                         
0691                         *
0692                         * DISPATCH TABLE FOR COMMANDS TOKEN #
0693                         CMD_TAB
0694 c32d c4 eb              LAB67     FDB  FOR            ; 80
0695 c32f c6 36                        FDB  GO             ; 81
0696 c331 c6 93                        FDB  REM            ; 82
0697 0082                    TOK_REM   EQU  *-CMD_TAB/2+$7F
0698 c333 c6 93                        FDB  REM            ; 83 (')
0699 0083                    TOK_SNGL_Q EQU  *-CMD_TAB/2+$7F
0700 c335 c6 93                        FDB  REM            ; 84 (ELSE)
0701 0084                    TOK_ELSE  EQU  *-CMD_TAB/2+$7F
0702 c337 c6 c4                        FDB  IF             ; 85
0703 0085                    TOK_IF    EQU  *-CMD_TAB/2+$7F
0704 c339 c6 90                        FDB  DATA           ; 86
0705 0086                    TOK_DATA  EQU  *-CMD_TAB/2+$7F
0706 c33b d0 6d                        FDB  PRINT          ; 87
0707 0087                    TOK_PRINT EQU  *-CMD_TAB/2+$7F
0708 c33d c6 f2                        FDB  ON             ; 88
0709 c33f c7 9f                        FDB  INPUT          ; 89
0710 0089                    TOK_INPUT EQU  *-CMD_TAB/2+$7F
0711 c341 c5 bd                        FDB  END            ; 8A
0712 c343 c8 84                        FDB  NEXT           ; 8B
0713 c345 ca d5                        FDB  DIM            ; 8C
0714 c347 c7 d9                        FDB  READ           ; 8D
0715 c349 c6 2b                        FDB  RUN            ; 8E
0716 c34b c5 9f                        FDB  RESTOR         ; 8F
0717 c34d c6 70                        FDB  RETURN         ; 90
0718 c34f c5 c1                        FDB  STOP           ; 91
0719 c351 ce de                        FDB  POKE           ; 92
0720 c353 c5 e6                        FDB  CONT           ; 93
0721 c355 ce e5                        FDB  LIST           ; 94
0722 c357 c5 f7                        FDB  CLEAR          ; 95
0723 c359 c4 bb                        FDB  NEW            ; 96
0724 c35b c1 8f                        FDB  EXEC           ; 97
0725 c35d da 67                        FDB  TRON           ; 98
0726 c35f da 68                        FDB  TROFF          ; 99
0727 c361 dc e3                        FDB  DEL            ; 9A
0728 c363 dc 27                        FDB  DEF            ; 9B
0729 c365 e3 d1                        FDB  LINE           ; 9C
0730 c367 dd 6d                        FDB  RENUM          ; 9D
0731 c369 d8 f3                        FDB  EDIT           ; 9E
0732 009e                    TOK_HIGH_EXEC EQU  *-CMD_TAB/2+$7F
0733                         
0734                         * ERROR MESSAGES AND THEIR NUMBERS AS USED INTERNALLY
0735 c36b 4e 46              LABAF     FCC  "NF"           ; 0 NEXT WITHOUT FOR
0736 c36d 53 4e                        FCC  "SN"           ; 1 SYNTAX ERROR
0737 c36f 52 47                        FCC  "RG"           ; 2 RETURN WITHOUT GOSUB
0738 c371 4f 44                        FCC  "OD"           ; 3 OUT OF DATA
0739 c373 46 43                        FCC  "FC"           ; 4 ILLEGAL FUNCTION CALL
0740 c375 4f 56                        FCC  "OV"           ; 5 OVERFLOW
0741 c377 4f 4d                        FCC  "OM"           ; 6 OUT OF MEMORY
0742 c379 55 4c                        FCC  "UL"           ; 7 UNDEFINED LINE NUMBER
0743 c37b 42 53                        FCC  "BS"           ; 8 BAD SUBSCRIPT
0744 c37d 44 44                        FCC  "DD"           ; 9 REDIMENSIONED ARRAY
0745 c37f 2f 30                        FCC  "/0"           ; 10 DIVISION BY ZERO
0746 c381 49 44                        FCC  "ID"           ; 11 ILLEGAL DIRECT STATEMENT
0747 c383 54 4d                        FCC  "TM"           ; 12 TYPE MISMATCH
0748 c385 4f 53                        FCC  "OS"           ; 13 OUT OF STRING SPACE
0749 c387 4c 53                        FCC  "LS"           ; 14 STRING TOO LONG
0750 c389 53 54                        FCC  "ST"           ; 15 STRING FORMULA TOO COMPLEX
0751 c38b 43 4e                        FCC  "CN"           ; 16 CAN'T CONTINUE
0752 c38d 46 44                        FCC  "FD"           ; 17 BAD FILE DATA
0753 c38f 41 4f                        FCC  "AO"           ; 18 FILE ALREADY OPEN
0754 c391 44 4e                        FCC  "DN"           ; 19 DEVICE NUMBER ERROR
0755 c393 49 4f                        FCC  "IO"           ; 20 I/O ERROR
0756 c395 46 4d                        FCC  "FM"           ; 21 BAD FILE MODE
0757 c397 4e 4f                        FCC  "NO"           ; 22 FILE NOT OPEN
0758 c399 49 45                        FCC  "IE"           ; 23 INPUT PAST END OF FILE
0759 c39b 44 53                        FCC  "DS"           ; 24 DIRECT STATEMENT IN FILE
0760                         * ADDITIONAL ERROR MESSAGES ADDED BY EXTENDED BASIC
0761 c39d 55 46              L890B     FCC  "UF"           ; 25 UNDEFINED FUNCTION (FN) CALL
0762 c39f 4e 45              L890D     FCC  "NE"           ; 26 FILE NOT FOUND
0763                         
0764 c3a1 20 45 52 52 4f 52  LABE1     FCC  " ERROR"
0765 c3a7 00                           FCB  $00
0766 c3a8 20 49 4e 20        LABE8     FCC  " IN "
0767 c3ac 00                           FCB  $00
0768 c3ad 0d                 LABED     FCB  CR
0769 c3ae 4f 4b              LABEE     FCC  "OK"
0770 c3b0 0d 00                        FCB  CR,$00
0771 c3b2 0d                 LABF2     FCB  CR
0772 c3b3 42 52 45 41 4b               FCC  "BREAK"
0773 c3b8 00                           FCB  $00
0774                         
0775                         * SEARCH THE STACK FOR 'GOSUB/RETURN' OR 'FOR/NEXT' DATA.
0776                         * THE 'FOR/NEXT' INDEX VARIABLE DESCRIPTOR ADDRESS BEING
0777                         * SOUGHT IS STORED IN VARDES. EACH BLOCK OF FOR/NEXT DATA IS 18
0778                         * BYTES WITH A $80 LEADER BYTE AND THE GOSUB/RETURN DATA IS 5 BYTES
0779                         * WITH AN $A6 LEADER BYTE. THE FIRST NON "FOR/NEXT" DATA
0780                         * IS CONSIDERED 'GOSUB/RETURN'
0781 c3b9 30 64              LABF9     LEAX 4,S            ; POINT X TO 3RD ADDRESS ON STACK - IGNORE THE
0782                         *         FIRST TWO RETURN ADDRESSES ON THE STACK
0783 c3bb c6 12              LABFB     LDB  #18            ; 18 BYTES SAVED ON STACK FOR EACH 'FOR' LOOP
0784 c3bd 9f 0f                        STX  TEMPTR         ; SAVE POINTER
0785 c3bf a6 84                        LDA  ,X             ; GET 1ST BYTE
0786 c3c1 80 80                        SUBA #$80           ; * CHECK FOR TYPE OF STACK JUMP FOUND
0787 c3c3 26 15                        BNE  LAC1A          ; * BRANCH IF NOT 'FOR/NEXT'
0788 c3c5 ae 01                        LDX  1,X            ; = GET INDEX VARIABLE DESCRIPTOR
0789 c3c7 9f 11                        STX  TMPTR1         ; = POINTER AND SAVE IT IN TMPTR1
0790 c3c9 9e 3b                        LDX  VARDES         ; GET INDEX VARIABLE BEING SEARCHED FOR
0791 c3cb 27 09                        BEQ  LAC16          ; BRANCH IF DEFAULT INDEX VARIABLE - USE THE
0792                         *                             ; FIRST 'FOR/NEXT' DATA FOUND ON STACK
0793                         *                             ; IF NO INDEX VARIABLE AFTER 'NEXT'
0794 c3cd 9c 11                        CMPX TMPTR1         ; DOES THE STACK INDEX MATCH THE ONE
0795                         *                             ; BEING SEARCHED FOR?
0796 c3cf 27 09                        BEQ  LAC1A          ; YES
0797 c3d1 9e 0f                        LDX  TEMPTR         ; * RESTORE INITIAL POINTER, ADD
0798 c3d3 3a                           ABX                 ; * 18 TO IT AND LOOK FOR
0799 c3d4 20 e5                        BRA  LABFB          ; * NEXT BLOCK OF DATA
0800 c3d6 9e 11              LAC16     LDX  TMPTR1         ; = GET 1ST INDEX VARIABLE FOUND AND
0801 c3d8 9f 3b                        STX  VARDES         ; = SAVE AS 'NEXT' INDEX
0802 c3da 9e 0f              LAC1A     LDX  TEMPTR         ; POINT X TO START OF 'FOR/NEXT' DATA
0803 c3dc 4d                           TSTA                ; SET ZERO FLAG IF 'FOR/NEXT' DATA
0804 c3dd 39                           RTS
0805                         * CHECK FOR MEMORY SPACE FOR NEW TOP OF
0806                         * ARRAYS AND MOVE ARRAYS TO NEW LOCATION
0807 c3de 8d 17              LAC1E     BSR  LAC37          ; ACCD = NEW BOTTOM OF FREE RAM - IS THERE
0808                         *                             ; ROOM FOR THE STACK?
0809                         * MOVE BYTES FROM V43(X) TO V41(U) UNTIL (X) = V47 AND
0810                         * SAVE FINAL VALUE OF U IN V45
0811 c3e0 de 41              LAC20     LDU  V41            ; POINT U TO DESTINATION ADDRESS (V41)
0812 c3e2 33 41                        LEAU 1,U            ; ADD ONE TO U - COMPENSATE FOR FIRST PSHU
0813 c3e4 9e 43                        LDX  V43            ; POINT X TO SOURCE ADDRESS (V43)
0814 c3e6 30 01                        LEAX 1,X            ; ADD ONE - COMPENSATE FOR FIRST LDA ,X
0815 c3e8 a6 82              LAC28     LDA  ,-X            ; GRAB A BYTE FROM SOURCE
0816 c3ea 36 02                        PSHU A              ; MOVE IT TO DESTINATION
0817 c3ec 9c 47                        CMPX V47            ; DONE?
0818 c3ee 26 f8                        BNE  LAC28          ; NO - KEEP MOVING BYTES
0819 c3f0 df 45                        STU  V45            ; SAVE FINAL DESTINATION ADDRESS
0820 c3f2 39                 LAC32     RTS
0821                         * CHECK TO SEE IF THERE IS ROOM TO STORE 2*ACCB
0822                         * BYTES IN FREE RAM - OM ERROR IF NOT
0823 c3f3 4f                 LAC33     CLRA                ; * ACCD CONTAINS NUMBER OF EXTRA
0824 c3f4 58                           ASLB                ; * BYTES TO PUT ON STACK
0825 c3f5 d3 1f                        ADDD ARYEND         ; END OF PROGRAM AND VARIABLES
0826 c3f7 c3 00 3a           LAC37     ADDD #STKBUF        ; ADD STACK BUFFER - ROOM FOR STACK?
0827 c3fa 25 08                        BCS  LAC44          ; BRANCH IF GREATER THAN $FFFF
0828 c3fc 10 df 17                     STS  BOTSTK         ; CURRENT NEW BOTTOM OF STACK STACK POINTER
0829 c3ff 10 93 17                     CMPD BOTSTK         ; ARE WE GOING TO BE BELOW STACK?
0830 c402 25 ee                        BCS  LAC32          ; YES - NO ERROR
0831 c404 c6 0c              LAC44     LDB  #6*2           ; OUT OF MEMORY ERROR
0832                         
0833                         * ERROR SERVICING ROUTINE
0834 c406 bd c4 d7           LAC46     JSR  LAD33          ; RESET STACK, STRING STACK, CONTINUE POINTER
0835 c409 bd d0 ac                     JSR  LB95C          ; SEND A CR TO SCREEN
0836 c40c bd d0 fb                     JSR  LB9AF          ; SEND A '?' TO SCREEN
0837 c40f 8e c3 6b                     LDX  #LABAF         ; POINT TO ERROR TABLE
0838 c412 3a                 LAC60     ABX                 ; ADD MESSAGE NUMBER OFFSET
0839 c413 8d 31                        BSR  LACA0          ; * GET TWO CHARACTERS FROM X AND
0840 c415 8d 2f                        BSR  LACA0          ; * SEND TO CONSOLE OUT (SCREEN)
0841 c417 8e c3 a0                     LDX  #LABE1-1       ; POINT TO "ERROR" MESSAGE
0842 c41a bd d0 e8           LAC68     JSR  LB99C          ; PRINT MESSAGE POINTED TO BY X
0843 c41d 96 68                        LDA  CURLIN         ; GET CURRENT LINE NUMBER (CURL IN)
0844 c41f 4c                           INCA                ; TEST FOR DIRECT MODE
0845 c420 27 03                        BEQ  LAC73          ; BRANCH IF DIRECT MODE
0846 c422 bd d5 11                     JSR  LBDC5          ; PRINT 'IN ****'
0847                         
0848                         * THIS IS THE MAIN LOOP OF BASIC WHEN IN DIRECT MODE
0849 c425 bd d0 ac           LAC73     JSR  LB95C          ; MOVE CURSOR TO START OF LINE
0850 c428 8e c3 ad                     LDX  #LABED         ; POINT X TO 'OK', CR MESSAGE
0851 c42b bd d0 e8                     JSR  LB99C          ; PRINT 'OK', CR
0852 c42e bd c1 41           LAC7C     JSR  LA390          ; GO GET AN INPUT LINE
0853 c431 ce ff ff                     LDU  #$FFFF         ; THE LINE NUMBER FOR DIRECT MODE IS $FFFF
0854 c434 df 68                        STU  CURLIN         ; SAVE IT IN CURLIN
0855 c436 25 f6                        BCS  LAC7C          ; BRANCH IF LINE INPUT TERMINATED BY BREAK
0856 c438 9f 83                        STX  CHARAD         ; SAVE (X) AS CURRENT INPUT POINTER - THIS WILL
0857                         *         ENABLE THE 'LIVE KEYBOARD' (DIRECT) MODE. THE
0858                         *         LINE JUST ENTERED WILL BE INTERPRETED
0859 c43a 9d 7c                        JSR  GETNCH         ; GET NEXT CHARACTER FROM BASIC
0860 c43c 27 f0                        BEQ  LAC7C          ; NO LINE INPUT - GET ANOTHER LINE
0861 c43e 25 0b                        BCS  LACA5          ; BRANCH IF NUMER1C - THERE WAS A LINE NUMBER BEFORE
0862                         *         THE  STATEMENT ENTERED, SO THIS STATEMENT
0863                         *         WILL BE MERGED INTO THE BASIC PROGRAM
0864 c440 bd cf 9a                     JSR  LB821          ; GO CRUNCH LINE
0865 c443 7e c5 74                     JMP  LADC0          ; GO EXECUTE THE STATEMENT (LIVE KEYBOARD)
0866                         *
0867 c446 a6 80              LACA0     LDA  ,X+            ; GET A CHARACTER
0868 c448 7e d0 fd                     JMP  LB9B1          ; SEND TO CONSOLE OUT
0869                         * TAKE A LINE FROM THE LINE INPUT BUFFER
0870                         * AND INSERT IT INTO THE BASIC PROGRAM
0871 c44b bd c7 17           LACA5     JSR  LAF67          ; CONVERT LINE NUMBER TO BINARY
0872 c44e 9e 2b              LACA8     LDX  BINVAL         ; GET CONVERTED LINE NUMBER
0873 c450 9f f1                        STX  LINHDR         ; STORE IT IN LINE INPUT HEADER
0874 c452 bd cf 9a                     JSR  LB821          ; GO CRUNCH THE LINE
0875 c455 d7 03                        STB  TMPLOC         ; SAVE LINE LENGTH
0876 c457 8d 4c                        BSR  LAD01          ; FIND OUT WHERE TO INSERT LINE
0877 c459 25 12                        BCS  LACC8          ; RANCH IF LINE NUMBER DOES NOT ALREADY EXIST
0878 c45b dc 47                        LDD  V47            ; GET ABSOLUTE ADDRESS OF LINE NUMBER
0879 c45d a3 84                        SUBD ,X             ; SUBTRACT ADDRESS OF NEXT LINE NUMBER
0880 c45f d3 1b                        ADDD VARTAB         ; * ADD TO CURRENT END OF PROGRAM - THIS WILL REMOVE
0881 c461 dd 1b                        STD  VARTAB         ; * THE LENGTH OF THIS LINE NUMBER FROM THE PROGRAM
0882 c463 ee 84                        LDU  ,X             ; POINT U TO ADDRESS OF NEXT LINE NUMBER
0883                         * DELETE OLD LINE FROM BASIC PROGRAM
0884 c465 37 02              LACC0     PULU A              ; GET A BYTE FROM WHAT'S LEFT OF PROGRAM
0885 c467 a7 80                        STA  ,X+            ; MOVE IT DOWN
0886 c469 9c 1b                        CMPX VARTAB         ; COMPARE TO END OF BASIC PROGRAM
0887 c46b 26 f8                        BNE  LACC0          ; BRANCH IF NOT AT END
0888 c46d 96 f3              LACC8     LDA  LINBUF         ; * CHECK TO SEE IF THERE IS A LINE IN
0889 c46f 27 1c                        BEQ  LACE9          ; * THE BUFFER AND BRANCH IF NONE
0890 c471 dc 1b                        LDD  VARTAB         ; = SAVE CURRENT END OF
0891 c473 dd 43                        STD  V43            ; = PROGRAM IN V43
0892 c475 db 03                        ADDB TMPLOC         ; * ADD LENGTH OF CRUNCHED LINE,
0893 c477 89 00                        ADCA #0             ; * PROPOGATE CARRY AND SAVE NEW END
0894 c479 dd 41                        STD  V41            ; * OF PROGRAM IN V41
0895 c47b bd c3 de                     JSR  LAC1E          ; = MAKE SURE THERE'S ENOUGH RAM FOR THIS
0896                         *         =    LINE & MAKE A HOLE IN BASIC FOR NEW LINE
0897 c47e ce 00 ef                     LDU  #LINHDR-2      ; POINT U TO LINE TO BE INSERTED
0898 c481 37 02              LACDD     PULU A              ; GET A BYTE FROM NEW LINE
0899 c483 a7 80                        STA  ,X+            ; INSERT IT IN PROGRAM
0900 c485 9c 45                        CMPX V45            ; * COMPARE TO ADDRESS OF END OF INSERTED
0901 c487 26 f8                        BNE  LACDD          ; * LINE AND BRANCH IF NOT DONE
0902 c489 9e 41                        LDX  V41            ; = GET AND SAVE
0903 c48b 9f 1b                        STX  VARTAB         ; = END OF PROGRAM
0904 c48d 8d 36              LACE9     BSR  LAD21          ; RESET INPUT POINTER, CLEAR VARIABLES, INITIALIZE
0905 c48f 8d 02                        BSR  LACEF          ; ADJUST START OF NEXT LINE ADDRESSES
0906 c491 20 9b                        BRA  LAC7C          ; EENTER BASIC'S INPUT LOOP
0907                         * COMPUTE THE START OF NEXT LINE ADDRESSES FOR THE BASIC PROGRAM
0908 c493 9e 19              LACEF     LDX  TXTTAB         ; POINT X TO START OF PROGRAM
0909 c495 ec 84              LACF1     LDD  ,X             ; GET ADDRESS OF NEXT LINE
0910 c497 27 21                        BEQ  LAD16          ; RETURN IF END OF PROGRAM
0911 c499 33 04                        LEAU 4,X            ; POINT U TO START OF BASIC TEXT IN LINE
0912 c49b a6 c0              LACF7     LDA  ,U+            ; * SKIP THROUGH THE LINE UNTIL A
0913 c49d 26 fc                        BNE  LACF7          ; * ZERO (END OF LINE) IS FOUND
0914 c49f ef 84                        STU  ,X             ; SAVE THE NEW START OF NEXT LINE ADDRESS
0915 c4a1 ae 84                        LDX  ,X             ; POINT X TO START OF NEXT LINE
0916 c4a3 20 f0                        BRA  LACF1          ; KEEP GOING
0917                         *
0918                         * FIND A LINE NUMBER IN THE BASIC PROGRAM
0919                         * RETURN WITH CARRY SET IF NO MATCH FOUND
0920 c4a5 dc 2b              LAD01     LDD  BINVAL         ; GET THE LINE NUMBER TO FIND
0921 c4a7 9e 19                        LDX  TXTTAB         ; BEGINNING OF PROGRAM
0922 c4a9 ee 84              LAD05     LDU  ,X             ; GET ADDRESS OF NEXT LINE NUMBER
0923 c4ab 27 09                        BEQ  LAD12          ; BRANCH IF END OF PROG
0924 c4ad 10 a3 02                     CMPD 2,X            ; IS IT A MATCH?
0925 c4b0 23 06                        BLS  LAD14          ; CARRY SET IF LOWER; CARRY CLEAR IF MATCH
0926 c4b2 ae 84                        LDX  ,X             ; X = ADDRESS OF NEXT LINE
0927 c4b4 20 f3                        BRA  LAD05          ; KEEP LOOPING FOR LINE NUMBER
0928 c4b6 1a 01              LAD12     ORCC #1             ; SET CARRY FLAG
0929 c4b8 9f 47              LAD14     STX  V47            ; SAVE MATCH LINE NUMBER OR NUMBER OF LINE JUST AFTER
0930                         *                             ; WHERE IT SHOULD HAVE BEEN
0931 c4ba 39                 LAD16     RTS
0932                         
0933                         * NEW
0934 c4bb 26 fb              NEW       BNE  LAD14          ; BRANCH IF ARGUMENT GIVEN
0935 c4bd 9e 19              LAD19     LDX  TXTTAB         ; GET START OF BASIC
0936 c4bf 6f 80                        CLR  ,X+            ; * PUT 2 ZERO BYTES THERE - ERASE
0937 c4c1 6f 80                        CLR  ,X+            ; * THE BASIC PROGRAM
0938 c4c3 9f 1b                        STX  VARTAB         ; AND THE NEXT ADDRESS IS NOW THE END OF PROGRAM
0939 c4c5 9e 19              LAD21     LDX  TXTTAB         ; GET START OF BASIC
0940 c4c7 bd c6 6b                     JSR  LAEBB          ; PUT INPUT POINTER ONE BEFORE START OF BASIC
0941                         * ERASE ALL VARIABLES
0942 c4ca 9e 27              LAD26     LDX  MEMSIZ         ; * RESET START OF STRING VARIABLES
0943 c4cc 9f 23                        STX  STRTAB         ; * TO TOP OF STRING SPACE
0944 c4ce bd c5 9f                     JSR  RESTOR         ; RESET 'DATA' POINTER TO START OF BASIC
0945 c4d1 9e 1b                        LDX  VARTAB         ; * GET START OF VARIABLES AND USE IT
0946 c4d3 9f 1d                        STX  ARYTAB         ; * TO RESET START OF ARRAYS
0947 c4d5 9f 1f                        STX  ARYEND         ; RESET END OF ARRAYS
0948 c4d7 8e 00 c9           LAD33     LDX  #STRSTK        ; * RESET STRING STACK POINTER TO
0949 c4da 9f 0b                        STX  TEMPPT         ; * BOTTOM OF STRING STACK
0950 c4dc ae e4                        LDX  ,S             ; GET RETURN ADDRESS OFF STACK
0951 c4de 10 de 21                     LDS  FRETOP         ; RESTORE STACK POINTER
0952 c4e1 6f e2                        CLR  ,-S            ; PUT A ZERO BYTE ON STACK - TO CLEAR ANY RETURN OF
0953                         *                             ; FOR/NEXT DATA FROM THE STACK
0954 c4e3 0f 2d                        CLR  OLDPTR         ; RESET 'CONT' ADDRESS SO YOU
0955 c4e5 0f 2e                        CLR  OLDPTR+1       ; 'CAN'T CONTINUE'
0956 c4e7 0f 08                        CLR  ARYDIS         ; CLEAR THE ARRAY DISABLE FLAG
0957 c4e9 6e 84                        JMP  ,X             ; RETURN TO CALLING ROUTINE - THIS IS NECESSARY
0958                         *                             ; SINCE THE STACK WAS RESET
0959                         *
0960                         * FOR
0961                         *
0962                         * THE FOR COMMAND WILL STORE 18 BYTES ON THE STACK FOR
0963                         * EACH FOR-NEXT LOOP WHICH IS BEING PROCESSED. THESE
0964                         * BYTES ARE DEFINED AS FOLLOWS: 0- $80 (FOR FLAG);
0965                         *         1,2=INDEX VARIABLE DESCRIPTOR POINTER; 3-7=FP VALUE OF STEP;
0966                         *         8=STEP DIRECTION: $FF IF NEGATIVE; 0 IF ZERO; 1 IF POSITIVE;
0967                         * 9-13=FP VALUE OF 'TO' PARAMETER;
0968                         * 14,15=CURRENT LINE NUMBER; 16,17=RAM ADDRESS OF THE END
0969                         *         OF   THE LINE CONTAINING THE 'FOR' STATEMENT
0970 c4eb 86 80              FOR       LDA  #$80           ; * SAVE THE DISABLE ARRAY FLAG IN VO8
0971 c4ed 97 08                        STA  ARYDIS         ; * DO NOT ALLOW THE INDEX VARIABLE TO BE AN ARRAY
0972 c4ef bd c7 39                     JSR  LET            ; SET INDEX VARIABLE TO INITIAL VALUE
0973 c4f2 bd c3 b9                     JSR  LABF9          ; SEARCH THE STACK FOR 'FOR/NEXT' DATA
0974 c4f5 32 62                        LEAS 2,S            ; PURGE RETURN ADDRESS OFF OF THE STACK
0975 c4f7 26 04                        BNE  LAD59          ; BRANCH IF INDEX VARIABLE NOT ALREADY BEING USED
0976 c4f9 9e 0f                        LDX  TEMPTR         ; GET (ADDRESS + 18) OF MATCHED 'FOR/NEXT' DATA
0977 c4fb 32 85                        LEAS B,X            ; MOVE THE STACK POINTER TO THE BEGINNING OF THE
0978                         * MATCHED 'FOR/NEXT' DATA SO THE NEW DATA WILL
0979                         * OVERLAY THE OLD DATA. THIS WILL ALSO DESTROY
0980                         * ALL OF THE 'RETURN' AND 'FOR/NEXT' DATA BELOW
0981                         * THIS POINT ON THE STACK
0982 c4fd c6 09              LAD59     LDB  #$09           ; * CHECK FOR ROOM FOR 18 BYTES
0983 c4ff bd c3 f3                     JSR  LAC33          ; * IN FREE RAM
0984 c502 bd c6 98                     JSR  LAEE8          ; GET ADDR OF END OF SUBLINE IN X
0985 c505 dc 68                        LDD  CURLIN         ; GET CURRENT LINE NUMBER
0986 c507 34 16                        PSHS X,B,A          ; SAVE LINE ADDR AND LINE NUMBER ON STACK
0987 c509 c6 a0                        LDB  #TOK_TO        ; TOKEN FOR 'TO'
0988 c50b bd c9 fb                     JSR  LB26F          ; SYNTAX CHECK FOR 'TO'
0989 c50e bd c8 cf                     JSR  LB143          ; 'TM' ERROR IF INDEX VARIABLE SET TO STRING
0990 c511 bd c8 cd                     JSR  LB141          ; EVALUATE EXPRESSION
0991                         *
0992 c514 d6 54                        LDB  FP0SGN         ; GET FPA0 MANTISSA SIGN
0993 c516 ca 7f                        ORB  #$7F           ; FORM A MASK TO SAVE DATA BITS OF HIGH ORDER MANTISSA
0994 c518 d4 50                        ANDB FPA0           ; PUT THE MANTISSA SIGN IN BIT 7 OF HIGH ORDER MANTISSA
0995 c51a d7 50                        STB  FPA0           ; SAVE THE PACKED HIGH ORDER MANTISSA
0996 c51c 10 8e c5 23                  LDY  #LAD7F         ; LOAD FOLLOWING ADDRESS INTO Y AS A RETURN
0997 c520 7e c9 76                     JMP  LB1EA          ; ADDRESS - PUSH FPA0 ONTO THE STACK
0998 c523 8e d2 11           LAD7F     LDX  #LBAC5         ; POINT X TO FLOATING POINT NUMBER 1.0 (DEFAULT STEP VALUE)
0999 c526 bd d3 60                     JSR  LBC14          ; MOVE (X) TO FPA0
1000 c529 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
1001 c52b 81 a4                        CMPA #TOK_STEP      ; STEP TOKEN
1002 c52d 26 05                        BNE  LAD90          ; BRANCH IF NO 'STEP' VALUE
1003 c52f 9d 7c                        JSR  GETNCH         ; GET A CHARACTER FROM BASIC
1004 c531 bd c8 cd                     JSR  LB141          ; EVALUATE NUMERIC EXPRESSION
1005 c534 bd d3 b9           LAD90     JSR  LBC6D          ; CHECK STATUS OF FPA0
1006 c537 bd c9 72                     JSR  LB1E6          ; SAVE STATUS AND FPA0 ON THE STACK
1007 c53a dc 3b                        LDD  VARDES         ; * GET DESCRIPTOR POINTER FOR THE 'STEP'
1008 c53c 34 06                        PSHS B,A            ; * VARIABLE AND SAVE IT ON THE STACK
1009 c53e 86 80                        LDA  #$80           ; = GET THE 'FOR' FLAG AND
1010 c540 34 02                        PSHS A              ; = SAVE IT ON THE STACK
1011                         *
1012                         * MAIN COMMAND INTERPRETATION LOOP
1013 c542 1c af              LAD9E     ANDCC #$AF          ; ENABLE IRQ,FIRQ
1014 c544 8d 60                        BSR  LADEB          ; CHECK FOR KEYBOARD BREAK
1015 c546 9e 83                        LDX  CHARAD         ; GET BASIC'S INPUT POINTER
1016 c548 9f 2f                        STX  TINPTR         ; SAVE IT
1017 c54a a6 80                        LDA  ,X+            ; GET CURRENT INPUT CHAR & MOVE POINTER
1018 c54c 27 07                        BEQ  LADB4          ; BRANCH IF END OF LINE
1019 c54e 81 3a                        CMPA #':            ; CHECK FOR LINE SEPARATOR
1020 c550 27 22                        BEQ  LADC0          ; BRANCH IF COLON
1021 c552 7e ca 03           LADB1     JMP  LB277          ; 'SYNTAX ERROR'-IF NOT LINE SEPARATOR
1022 c555 a6 81              LADB4     LDA  ,X++           ; GET MS BYTE OF ADDRESS OF NEXT BASIC LINE
1023 c557 97 00                        STA  ENDFLG         ; SAVE IN STOP/END FLAG - CAUSE A STOP IF
1024                         *                             ; NEXT LINE ADDRESS IS < $8000; CAUSE
1025                         *                             ; AN END IF ADDRESS > $8000
1026 c559 27 72                        BEQ  LAE15          ; BRANCH TO 'STOP' - END OF PROGRAM
1027 c55b ec 80                        LDD  ,X+            ; GET CURRENT LINE NUMBER
1028 c55d dd 68                        STD  CURLIN         ; SAVE IN CURLIN
1029 c55f 9f 83                        STX  CHARAD         ; SAVE ADDRESS OF FIRST BYTE OF LINE
1030                         * EXTENDED BASIC TRACE
1031 c561 96 8c                        LDA  TRCFLG         ; TEST THE TRACE FLAG
1032 c563 27 0f                        BEQ  LADC0          ; BRANCH IF TRACE OFF
1033 c565 86 5b                        LDA  #$5B           ; <LEFT HAND MARKER FOR TRON LINE NUMBER
1034 c567 bd c0 17                     JSR  PUTCHR         ; OUTPUT A CHARACTER
1035 c56a 96 68                        LDA  CURLIN         ; GET MS BYTE OF LINE NUMBER
1036 c56c bd d5 18                     JSR  LBDCC          ; CONVERT ACCD TO DECIMAL AND PRINT ON SCREEN
1037 c56f 86 5d                        LDA  #$5D           ; > RIGHT HAND MARKER FOR TRON LINE NUMBER
1038 c571 bd c0 17                     JSR  PUTCHR         ; OUTPUT A CHARACTER
1039                         * END OF EXTENDED BASIC TRACE
1040 c574 9d 7c              LADC0     JSR  GETNCH         ; GET A CHARACTER FROM BASIC
1041 c576 8d 02                        BSR  LADC6          ; GO PROCESS COMMAND
1042 c578 20 c8                        BRA  LAD9E          ; GO BACK TO MAIN LOOP
1043 c57a 27 29              LADC6     BEQ  LADEA          ; RETURN IF END OF LINE (RTS - was BEQ LAE40)
1044 c57c 4d                           TSTA                ; CHECK FOR TOKEN - BIT 7 SET (NEGATIVE)
1045 c57d 10 2a 01 b8                  LBPL LET            ; BRANCH IF NOT A TOKEN - GO DO A 'LET' WHICH
1046                         *                             ; IS THE 'DEFAULT' TOKEN FOR MICROSOFT BASIC
1047 c581 81 ff                        CMPA #$FF           ; SECONDARY TOKEN
1048 c583 27 0f                        BEQ  SECTOK
1049 c585 81 9e                        CMPA #TOK_HIGH_EXEC ; SKIPF TOKEN - HIGHEST EXECUTABLE COMMAND IN BASIC
1050 c587 22 c9                        BHI  LADB1          ; 'SYNTAX ERROR' IF NON-EXECUTABLE TOKEN
1051 c589 be c0 f4                     LDX  COMVEC+3       ; GET ADDRESS OF BASIC'S COMMAND TABLE
1052 c58c 48                 LADD4     ASLA                ; X2 (2 BYTE/JUMP ADDRESS) & DISCARD BIT 7
1053 c58d 1f 89                        TFR  A,B            ; SAVE COMMAND OFFSET IN ACCB
1054 c58f 3a                           ABX                 ; NON X POINTS TO COMMAND JUMP ADDR
1055 c590 9d 7c                        JSR  GETNCH         ; GET AN INPUT CHAR
1056                         *
1057                         * HERE IS WHERE WE BRANCH TO DO A 'COMMAND'
1058 c592 6e 94                        JMP  [,X]           ; GO DO A COMMAND
1059                         SECTOK
1060                         * THE ONLY SECONDARY TOKEN THAT CAN ALSO BE AN EXECUTABLE IS
1061                         * THE MID$ REPLACEMENT STATEMENT. SO SPECIAL-CASE CHECK DONE HERE
1062 c594 9d 7c                        JSR  GETNCH         ; GET AN INPUT CHAR
1063 c596 81 97                        CMPA #TOK_MID       ; TOKEN FOR "MID$"
1064 c598 10 27 14 f0                  LBEQ L86D6          ; PROCESS MID$ REPLACEMENT
1065 c59c 7e ca 03                     JMP  LB277          ; SYNTAX ERROR
1066                         
1067                         *
1068                         * RESTORE
1069 c59f 9e 19              RESTOR    LDX  TXTTAB         ; BEGINNING OF PROGRAM ADDRESS
1070 c5a1 30 1f                        LEAX -1,X           ; MOVE TO ONE BYTE BEFORE PROGRAM
1071 c5a3 9f 33              LADE8     STX  DATPTR         ; SAVE NEW DATA POINTER
1072 c5a5 39                 LADEA     RTS
1073                         *
1074                         * BREAK CHECK
1075 c5a6 bd c0 08           LADEB     JSR  LA1C1          ; GET A KEYSTROKE ENTRY
1076 c5a9 27 0a                        BEQ  LADFA          ; RETURN IF NO INPUT
1077 c5ab 81 03              LADF0     CMPA #3             ; CONTROL C? (BREAK)
1078 c5ad 27 12                        BEQ  STOP           ; YES
1079 c5af 81 13                        CMPA #$13           ; CONTROL S? (PAUSE)
1080 c5b1 27 03                        BEQ  LADFB          ; YES
1081 c5b3 97 73                        STA  IKEYIM         ; SAVE KEYSTROKE IN INKEY IMAGE
1082 c5b5 39                 LADFA     RTS
1083 c5b6 bd c0 08           LADFB     JSR  KEYIN          ; GET A KEY
1084 c5b9 27 fb                        BEQ  LADFB          ; BRANCH IF NO KEY DOWN
1085 c5bb 20 ee                        BRA  LADF0          ; CONTINUE - DO A BREAK CHECK
1086                         *
1087                         * END
1088 c5bd 9d 82              END       JSR  GETCCH         ; GET CURRENT INPUT CHAR
1089 c5bf 20 02                        BRA  LAE0B
1090                         *
1091                         * STOP
1092 c5c1 1a 01              STOP      ORCC #$01           ; SET CARRY FLAG
1093 c5c3 26 31              LAE0B     BNE  LAE40          ; BRANCH IF ARGUMENT EXISTS
1094 c5c5 9e 83                        LDX  CHARAD         ; * SAVE CURRENT POSITION OF
1095 c5c7 9f 2f                        STX  TINPTR         ; * BASIC'S INPUT POINTER
1096 c5c9 06 00              LAE11     ROR  ENDFLG         ; ROTATE CARRY INTO BIT 7 OF STOP/END FLAG
1097 c5cb 32 62                        LEAS 2,S            ; PURGE RETURN ADDRESS OFF STACK
1098 c5cd 9e 68              LAE15     LDX  CURLIN         ; GET CURRENT LINE NUMBER
1099 c5cf 8c ff ff                     CMPX #$FFFF         ; DIRECT MODE?
1100 c5d2 27 06                        BEQ  LAE22          ; YES
1101 c5d4 9f 29                        STX  OLDTXT         ; SAVE CURRENT LINE NUMBER
1102 c5d6 9e 2f                        LDX  TINPTR         ; * GET AND SAVE CURRENT POSITION
1103 c5d8 9f 2d                        STX  OLDPTR         ; * OF BASIC'S INPUT POINTER
1104                         LAE22
1105 c5da 8e c3 b1                     LDX  #LABF2-1       ; POINT TO CR, 'BREAK' MESSAGE
1106 c5dd 0d 00                        TST  ENDFLG         ; CHECK STOP/END FLAG
1107 c5df 10 2a fe 42                  LBPL LAC73          ; BRANCH TO MAIN LOOP OF BASIC IF END
1108 c5e3 7e c4 1a                     JMP  LAC68          ; PRINT 'BREAK AT ####' AND GO TO
1109                         *                             ; BASIC'S MAIN LOOP IF 'STOP'
1110                         
1111                         * CONT
1112 c5e6 26 0e              CONT      BNE  LAE40          ; RETURN IF ARGUMENT GIVEN
1113 c5e8 c6 20                        LDB  #2*16          ; 'CAN'T CONTINUE' ERROR
1114 c5ea 9e 2d                        LDX  OLDPTR         ; GET CONTINUE ADDRESS (INPUT POINTER)
1115 c5ec 10 27 fe 16                  LBEQ LAC46          ; 'CN' ERROR IF CONTINUE ADDRESS = 0
1116 c5f0 9f 83                        STX  CHARAD         ; RESET BASIC'S INPUT POINTER
1117 c5f2 9e 29                        LDX  OLDTXT         ; GET LINE NUMBER
1118 c5f4 9f 68                        STX  CURLIN         ; RESET CURRENT LINE NUMBER
1119 c5f6 39                 LAE40     RTS
1120                         *
1121                         * CLEAR
1122 c5f7 27 2c              CLEAR     BEQ  LAE6F          ; BRANCH IF NO ARGUMENT
1123 c5f9 bd cb 6d                     JSR  LB3E6          ; EVALUATE ARGUMENT
1124 c5fc 34 06                        PSHS B,A            ; SAVE AMOUNT OF STRING SPACE ON STACK
1125 c5fe 9e 27                        LDX  MEMSIZ         ; GET CURRENT TOP OF CLEARED SPACE
1126 c600 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
1127 c602 27 0c                        BEQ  LAE5A          ; BRANCH IF NO NEW TOP OF CLEARED SPACE
1128 c604 bd c9 f9                     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
1129 c607 bd ce c4                     JSR  LB73D          ; EVALUATE EXPRESSlON; RETURN VALUE IN X
1130 c60a 30 1f                        LEAX -1,X           ; X = TOP OF CLEARED SPACE
1131 c60c 9c 71                        CMPX TOPRAM         ; COMPARE TO TOP OF RAM
1132 c60e 22 18                        BHI  LAE72          ; 'OM' ERROR IF > TOP OF RAM
1133 c610 1f 10              LAE5A     TFR  X,D            ; ACCD = TOP OF CLEARED SPACE
1134 c612 a3 e1                        SUBD ,S++           ; SUBTRACT OUT AMOUNT OF CLEARED SPACE
1135 c614 25 12                        BCS  LAE72          ; 'OM' ERROR IF FREE MEM < 0
1136 c616 1f 03                        TFR  D,U            ; U = BOTTOM OF CLEARED SPACE
1137 c618 83 00 3a                     SUBD #STKBUF        ; SUBTRACT OUT STACK BUFFER
1138 c61b 25 0b                        BCS  LAE72          ; 'OM' ERROR IF FREE MEM < 0
1139 c61d 93 1b                        SUBD VARTAB         ; SUBTRACT OUT START OF VARIABLES
1140 c61f 25 07                        BCS  LAE72          ; 'OM' ERROR IF FREE MEM < 0
1141 c621 df 21                        STU  FRETOP         ; SAVE NEW BOTTOM OF CLEARED SPACE
1142 c623 9f 27                        STX  MEMSIZ         ; SAVE NEW TOP OF CLEARED SPACE
1143 c625 7e c4 ca           LAE6F     JMP  LAD26          ; ERASE ALL VARIABLES, INITIALIZE POINTERS, ETC
1144 c628 7e c4 04           LAE72     JMP  LAC44          ; 'OM' ERROR
1145                         *
1146                         * RUN
1147 c62b 9d 82              RUN       JSR  GETCCH         ; * GET CURRENT INPUT CHARACTER
1148 c62d 10 27 fe 94                  LBEQ LAD21          ; * IF NO LINE NUMBER
1149 c631 bd c4 ca                     JSR  LAD26          ; ERASE ALL VARIABLES
1150 c634 20 19                        BRA  LAE9F          ; 'GOTO' THE RUN ADDRESS
1151                         *
1152                         * GO
1153 c636 1f 89              GO        TFR  A,B            ; SAVE INPUT CHARACTER IN ACCB
1154 c638 9d 7c              LAE88     JSR  GETNCH         ; GET A CHARACTER FROM BASIC
1155 c63a c1 a0                        CMPB #TOK_TO        ; 'TO' TOKEN
1156 c63c 27 16                        BEQ  LAEA4          ; BRANCH IF GOTO
1157 c63e c1 a1                        CMPB #TOK_SUB       ; 'SUB' TOKEN
1158 c640 26 45                        BNE  LAED7          ; 'SYNTAX ERROR' IF NEITHER
1159 c642 c6 03                        LDB  #3             ; =ROOM FOR 6
1160 c644 bd c3 f3                     JSR  LAC33          ; =BYTES ON STACK?
1161 c647 de 83                        LDU  CHARAD         ; * SAVE CURRENT BASIC INPUT POINTER, LINE
1162 c649 9e 68                        LDX  CURLIN         ; * NUMBER AND SUB TOKEN ON STACK
1163 c64b 86 a1                        LDA  #TOK_SUB       ; *
1164 c64d 34 52                        PSHS U,X,A          ; *
1165 c64f 8d 03              LAE9F     BSR  LAEA4          ; GO DO A 'GOTO'
1166 c651 7e c5 42                     JMP  LAD9E          ; JUMP BACK TO BASIC'S MAIN LOOP
1167                         * GOTO
1168 c654 9d 82              LAEA4     JSR  GETCCH         ; GET CURRENT INPUT CHAR
1169 c656 bd c7 17                     JSR  LAF67          ; GET LINE NUMBER TO BINARY IN BINVAL
1170 c659 8d 40                        BSR  LAEEB          ; ADVANCE BASIC'S POINTER TO END OF LINE
1171 c65b 30 01                        LEAX $01,X          ; POINT TO START OF NEXT LINE
1172 c65d dc 2b                        LDD  BINVAL         ; GET THE LINE NUMBER TO RUN
1173 c65f 10 93 68                     CMPD CURLIN         ; COMPARE TO CURRENT LINE NUMBER
1174 c662 22 02                        BHI  LAEB6          ; IF REO'D LINE NUMBER IS > CURRENT LINE NUMBER,
1175                         *              ; DON'T START LOOKING FROM
1176                         *              ; START OF PROGRAM
1177 c664 9e 19                        LDX  TXTTAB         ; BEGINNING OF PROGRAM
1178 c666 bd c4 a9           LAEB6     JSR  LAD05          ; GO FIND A LINE NUMBER
1179 c669 25 17                        BCS  LAED2          ; 'UNDEFINED LINE NUMBER'
1180 c66b 30 1f              LAEBB     LEAX -1,X           ; MOVE BACK TO JUST BEFORE START OF LINE
1181 c66d 9f 83                        STX  CHARAD         ; RESET BASIC'S INPUT POINTER
1182 c66f 39                 LAEBF     RTS
1183                         *
1184                         * RETURN
1185 c670 26 fd              RETURN    BNE  LAEBF          ; EXIT ROUTINE IF ARGUMENT GIVEN
1186 c672 86 ff                        LDA  #$FF           ; * PUT AN ILLEGAL VARIABLE NAME IN FIRST BYTE OF
1187 c674 97 3b                        STA  VARDES         ; * VARDES WHICH WILL CAUSE 'FOR/NEXT' DATA ON THE
1188                         *              ; STACK TO BE IGNORED
1189 c676 bd c3 b9                     JSR  LABF9          ; CHECK FOR RETURN DATA ON THE STACK
1190 c679 1f 14                        TFR  X,S            ; RESET STACK POINTER - PURGE TWO RETURN ADDRESSES
1191                         *              ; FROM THE STACK
1192 c67b 81 21                        CMPA #TOK_SUB-$80   ; SUB TOKEN - $80
1193 c67d 27 0b                        BEQ  LAEDA          ; BRANCH IF 'RETURN' FROM SUBROUTINE
1194 c67f c6 04                        LDB  #2*2           ; ERROR #2 'RETURN WITHOUT GOSUB'
1195 c681 8c                           FCB  SKP2           ; SKIP TWO BYTES
1196 c682 c6 0e              LAED2     LDB  #7*2           ; ERROR #7 'UNDEFINED LINE NUMBER'
1197 c684 7e c4 06                     JMP  LAC46          ; JUMP TO ERROR HANDLER
1198 c687 7e ca 03           LAED7     JMP  LB277          ; 'SYNTAX ERROR'
1199 c68a 35 52              LAEDA     PULS A,X,U          ; * RESTORE VALUES OF CURRENT LINE NUMBER AND
1200 c68c 9f 68                        STX  CURLIN         ; * BASIC'S INPUT POINTER FOR THIS SUBROUTINE
1201 c68e df 83                        STU  CHARAD         ; * AND LOAD ACCA WITH SUB TOKEN ($A6)
1202                         *
1203                         * DATA
1204 c690 8d 06              DATA      BSR  LAEE8          ; MOVE INPUT POINTER TO END OF SUBLINE OR LINE
1205 c692 8c                           FCB  SKP2           ; SKIP 2 BYTES
1206                         
1207                         * REM, ELSE
1208                         ELSE
1209 c693 8d 06              REM       BSR  LAEEB          ; MOVE INPUT POINTER TO END OF LINE
1210 c695 9f 83                        STX  CHARAD         ; RESET BASIC'S INPUT POINTER
1211 c697 39                 LAEE7     RTS
1212                         * ADVANCE INPUT POINTER TO END OF SUBLINE OR LINE
1213 c698 c6 3a              LAEE8     LDB  #':            ; COLON = SUBLINE TERMINATOR CHARACTER
1214 c69a 86                 LAEEA     FCB  SKP1LD         ; SKPILD SKIP ONE BYTE; LDA #$5F
1215                         * ADVANCE BASIC'S INPUT POINTER TO END OF
1216                         * LINE - RETURN ADDRESS OF END OF LINE+1 IN X
1217 c69b 5f                 LAEEB     CLRB                ; 0 = LINE TERMINATOR CHARACTER
1218 c69c d7 01                        STB  CHARAC         ; TEMP STORE PRIMARY TERMINATOR CHARACTER
1219 c69e 5f                           CLRB                ; 0 (END OF LINE) = ALTERNATE TERM. CHAR.
1220 c69f 9e 83                        LDX  CHARAD         ; LOAD X W/BASIC'S INPUT POINTER
1221 c6a1 1f 98              LAEF1     TFR  B,A            ; * CHANGE TERMINATOR CHARACTER
1222 c6a3 d6 01                        LDB  CHARAC         ; * FROM ACCB TO CHARAC - SAVE OLD TERMINATOR
1223                         *         IN   CHARAC
1224 c6a5 97 01                        STA  CHARAC         ; SWAP PRIMARY AND SECONDARY TERMINATORS
1225 c6a7 a6 84              LAEF7     LDA  ,X             ; GET NEXT INPUT CHARACTER
1226 c6a9 27 ec                        BEQ  LAEE7          ; RETURN IF 0 (END OF LINE)
1227 c6ab 34 04                        PSHS B              ; SAVE TERMINATOR ON STACK
1228 c6ad a1 e0                        CMPA ,S+            ; COMPARE TO INPUT CHARACTER
1229 c6af 27 e6                        BEQ  LAEE7          ; RETURN IF EQUAL
1230 c6b1 30 01                        LEAX 1,X            ; MOVE POINTER UP ONE
1231 c6b3 81 22                        CMPA #'"            ; CHECK FOR DOUBLE QUOTES
1232 c6b5 27 ea                        BEQ  LAEF1          ; BRANCH IF " - TOGGLE TERMINATOR CHARACTERS
1233 c6b7 4c                           INCA                ; * CHECK FOR $FF AND BRANCH IF
1234 c6b8 26 02                        BNE  LAF0C          ; * NOT SECONDARY TOKEN
1235 c6ba 30 01                        LEAX 1,X            ; MOVE INPUT POINTER 1 MORE IF SECONDARY
1236 c6bc 81 86              LAF0C     CMPA #TOK_IF+1      ; TOKEN FOR IF?
1237 c6be 26 e7                        BNE  LAEF7          ; NO - GET ANOTHER INPUT CHARACTER
1238 c6c0 0c 04                        INC  IFCTR          ; INCREMENT IF COUNTER - KEEP TRACK OF HOW MANY
1239                         *                             ; 'IF' STATEMENTS ARE NESTED IN ONE LINE
1240 c6c2 20 e3                        BRA  LAEF7          ; GET ANOTHER INPUT CHARACTER
1241                         
1242                         * IF
1243 c6c4 bd c8 cd           IF        JSR  LB141          ; EVALUATE NUMERIC EXPRESSION
1244 c6c7 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
1245 c6c9 81 81                        CMPA #TOK_GO        ; TOKEN FOR GO
1246 c6cb 27 05                        BEQ  LAF22          ; TREAT 'GO' THE SAME AS 'THEN'
1247 c6cd c6 a2                        LDB  #TOK_THEN      ; TOKEN FOR THEN
1248 c6cf bd c9 fb                     JSR  LB26F          ; DO A SYNTAX CHECK ON ACCB
1249 c6d2 96 4f              LAF22     LDA  FP0EXP         ; CHECK FOR TRUE/FALSE - FALSE IF FPA0 EXPONENT = ZERO
1250 c6d4 26 13                        BNE  LAF39          ; BRANCH IF CONDITION TRUE
1251 c6d6 0f 04                        CLR  IFCTR          ; CLEAR FLAG - KEEP TRACK OF WHICH NESTED ELSE STATEMENT
1252                         *                             ; TO SEARCH FOR IN NESTED 'IF' LOOPS
1253 c6d8 8d b6              LAF28     BSR  DATA           ; MOVE BASIC'S POINTER TO END OF SUBLINE
1254 c6da 4d                           TSTA                ; * CHECK TO SEE IF END OF LINE OR SUBLINE
1255 c6db 27 ba                        BEQ  LAEE7          ; * AND RETURN IF END OF LINE
1256 c6dd 9d 7c                        JSR  GETNCH         ; GET AN INPUT CHARACTER FROM BASIC
1257 c6df 81 84                        CMPA #TOK_ELSE      ; TOKEN FOR ELSE
1258 c6e1 26 f5                        BNE  LAF28          ; IGNORE ALL DATA EXCEPT 'ELSE' UNTIL
1259                         *                             ; END OF LINE (ZERO BYTE)
1260 c6e3 0a 04                        DEC  IFCTR          ; CHECK TO SEE IF YOU MUST SEARCH ANOTHER SUBLINE
1261 c6e5 2a f1                        BPL  LAF28          ; BRANCH TO SEARCH ANOTHER SUBLINE FOR 'ELSE'
1262 c6e7 9d 7c                        JSR  GETNCH         ; GET AN INPUT CHARACTER FROM BASIC
1263 c6e9 9d 82              LAF39     JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
1264 c6eb 10 25 ff 65                  LBCS LAEA4          ; BRANCH TO 'GOTO' IF NUMERIC CHARACTER
1265 c6ef 7e c5 7a                     JMP  LADC6          ; RETURN TO MAIN INTERPRETATION LOOP
1266                         
1267                         * ON
1268 c6f2 bd ce 92           ON        JSR  LB70B          ; EVALUATE EXPRESSION
1269 c6f5 c6 81                        LDB  #TOK_GO        ; TOKEN FOR GO
1270 c6f7 bd c9 fb                     JSR  LB26F          ; SYNTAX CHECK FOR GO
1271 c6fa 34 02                        PSHS A              ; SAVE NEW TOKEN (TO,SUB)
1272 c6fc 81 a1                        CMPA #TOK_SUB       ; TOKEN FOR SUB?
1273 c6fe 27 04                        BEQ  LAF54          ; YES
1274 c700 81 a0                        CMPA #TOK_TO        ; TOKEN FOR TO?
1275 c702 26 83              LAF52     BNE  LAED7          ; 'SYNTAX' ERROR IF NOT 'SUB' OR 'TO'
1276 c704 0a 53              LAF54     DEC  FPA0+3         ; DECREMENT IS BYTE OF MANTISSA OF FPA0 - THIS
1277                         *                             ; IS THE ARGUMENT OF THE 'ON' STATEMENT
1278 c706 26 05                        BNE  LAF5D          ; BRANCH IF NOT AT THE PROPER GOTO OR GOSUB LINE NUMBER
1279 c708 35 04                        PULS B              ; GET BACK THE TOKEN FOLLOWING 'GO'
1280 c70a 7e c6 38                     JMP  LAE88          ; GO DO A 'GOTO' OR 'GOSUB'
1281 c70d 9d 7c              LAF5D     JSR  GETNCH         ; GET A CHARACTER FROM BASIC
1282 c70f 8d 06                        BSR  LAF67          ; CONVERT BASIC LINE NUMBER TO BINARY
1283 c711 81 2c                        CMPA #',            ; IS CHARACTER FOLLOWING LINE NUMBER A COMMA?
1284 c713 27 ef                        BEQ  LAF54          ; YES
1285 c715 35 84                        PULS B,PC           ; IF NOT, FALL THROUGH TO NEXT COMMAND
1286 c717 9e 74              LAF67     LDX  ZERO           ; DEFAULT LINE NUMBER OF ZERO
1287 c719 9f 2b                        STX  BINVAL         ; SAVE IT IN BINVAL
1288                         *
1289                         * CONVERT LINE NUMBER TO BINARY - RETURN VALUE IN BINVAL
1290                         *
1291 c71b 24 61              LAF6B     BCC  LAFCE          ; RETURN IF NOT NUMERIC CHARACTER
1292 c71d 80 30                        SUBA #'0            ; MASK OFF ASCII
1293 c71f 97 01                        STA  CHARAC         ; SAVE DIGIT IN VO1
1294 c721 dc 2b                        LDD  BINVAL         ; GET ACCUMULATED LINE NUMBER VALUE
1295 c723 81 18                        CMPA #24            ; LARGEST LINE NUMBER IS $F9FF (63999) -
1296                         *         (24*256+255)*10+9
1297 c725 22 db                        BHI  LAF52          ; 'SYNTAX' ERROR IF TOO BIG
1298                         * MULT ACCD X 10
1299 c727 58                           ASLB                ; *
1300 c728 49                           ROLA                ; * TIMES 2
1301 c729 58                           ASLB                ; =
1302 c72a 49                           ROLA                ; = TIMES 4
1303 c72b d3 2b                        ADDD BINVAL         ; ADD 1 = TIMES 5
1304 c72d 58                           ASLB                ; *
1305 c72e 49                           ROLA                ; * TIMES 10
1306 c72f db 01                        ADDB CHARAC         ; ADD NEXT DIGIT
1307 c731 89 00                        ADCA #0             ; PROPAGATE CARRY
1308 c733 dd 2b                        STD  BINVAL         ; SAVE NEW ACCUMULATED LINE NUMBER
1309 c735 9d 7c                        JSR  GETNCH         ; GET NEXT CHARACTER FROM BASIC
1310 c737 20 e2                        BRA  LAF6B          ; LOOP- PROCESS NEXT DIGIT
1311                         *
1312                         * LET (EXBAS)
1313                         * EVALUATE A NON-TOKEN EXPRESSION
1314                         * TARGET = REPLACEMENT
1315 c739 bd ca de           LET       JSR  LB357          ; FIND TARGET VARIABLE DESCRIPTOR
1316 c73c 9f 3b                        STX  VARDES         ; SAVE DESCRIPTOR ADDRESS OF 1ST EXPRESSION
1317 c73e c6 ae                        LDB  #TOK_EQUALS    ; TOKEN FOR "="
1318 c740 bd c9 fb                     JSR  LB26F          ; DO A SYNTAX CHECK FOR '='
1319 c743 96 06                        LDA  VALTYP         ; * GET VARIABLE TYPE AND
1320 c745 34 02                        PSHS A              ; * SAVE ON THE STACK
1321 c747 bd c8 e2                     JSR  LB156          ; EVALUATE EXPRESSION
1322 c74a 35 02                        PULS A              ; * REGET VARIABLE TYPE OF 1ST EXPRESSION AND
1323 c74c 46                           RORA                ; * SET CARRY IF STRING
1324 c74d bd c8 d4                     JSR  LB148          ; TYPE CHECK-TM ERROR IF VARIABLE TYPES ON
1325                         *                             ; BOTH SIDES OF EQUALS SIGN NOT THE SAME
1326 c750 10 27 0c 2b                  LBEQ LBC33          ; GO PUT FPA0 INTO VARIABLE DESCRIPTOR IF NUMERIC
1327                         * MOVE A STRING WHOSE DESCRIPTOR IS LOCATED AT
1328                         * FPA0+2 INTO THE STRING SPACE. TRANSFER THE
1329                         * DESCRIPTOR ADDRESS TO THE ADDRESS IN VARDES
1330                         * DON'T MOVE THE STRING IF IT IS ALREADY IN THE
1331                         * STRING SPACE. REMOVE DESCRIPTOR FROM STRING
1332                         * STACK IF IT IS LAST ONE ON THE STACK
1333 c754 9e 52              LAFA4     LDX  FPA0+2         ; POINT X TO DESCRIPTOR OF REPLACEMENT STRING
1334 c756 dc 21                        LDD  FRETOP         ; LOAD ACCD WITH START OF STRING SPACE
1335 c758 10 a3 02                     CMPD 2,X            ; IS THE STRING IN STRING SPACE?
1336 c75b 24 11                        BCC  LAFBE          ; BRANCH IF IT'S NOT IN THE STRING SPACE
1337 c75d 9c 1b                        CMPX VARTAB         ; COMPARE DESCRIPTOR ADDRESS TO START OF VARIABLES
1338 c75f 25 0d                        BCS  LAFBE          ; BRANCH IF DESCRIPTOR ADDRESS NOT IN VARIABLES
1339 c761 e6 84              LAFB1     LDB  ,X             ; GET LENGTH OF REPLACEMENT STRING
1340 c763 bd cc 94                     JSR  LB50D          ; RESERVE ACCB BYTES OF STRING SPACE
1341 c766 9e 4d                        LDX  V4D            ; GET DESCRIPTOR ADDRESS BACK
1342 c768 bd cd ca                     JSR  LB643          ; MOVE STRING INTO STRING SPACE
1343 c76b 8e 00 56                     LDX  #STRDES        ; POINT X TO TEMP STRING DESCRIPTOR ADDRESS
1344 c76e 9f 4d              LAFBE     STX  V4D            ; SAVE STRING DESCRIPTOR ADDRESS IN V4D
1345 c770 bd cd fc                     JSR  LB675          ; REMOVE STRING DESCRIPTOR IF LAST ONE
1346                         *              ; ON STRING STACK
1347 c773 de 4d                        LDU  V4D            ; POINT U TO REPLACEMENT DESCRIPTOR ADDRESS
1348 c775 9e 3b                        LDX  VARDES         ; GET TARGET DESCRIPTOR ADDRESS
1349 c777 37 26                        PULU A,B,Y          ; GET LENGTH AND START OF REPLACEMENT STRING
1350 c779 a7 84                        STA  ,X             ; * SAVE STRING LENGTH AND START IN
1351 c77b 10 af 02                     STY  2,X            ; * TARGET DESCRIPTOR LOCATION
1352 c77e 39                 LAFCE     RTS
1353                         
1354 c77f 3f 52 45 44 4f     LAFCF     FCC  "?REDO"        ; ?REDO MESSAGE
1355 c784 0d 00                        FCB  CR,$00
1356                         
1357                         LAFD6
1358 c786 7e c4 06           LAFDC     JMP  LAC46          ; JMP TO ERROR HANDLER
1359 c789 96 09              LAFDF     LDA  INPFLG         ; = GET THE INPUT FLAG AND BRANCH
1360 c78b 27 07                        BEQ  LAFEA          ; = IF 'INPUT'
1361 c78d 9e 31                        LDX  DATTXT         ; * GET LINE NUMBER WHERE THE ERROR OCCURRED
1362 c78f 9f 68                        STX  CURLIN         ; * AND USE IT AS THE CURRENT LINE NUMBER
1363 c791 7e ca 03                     JMP  LB277          ; 'SYNTAX ERROR'
1364 c794 8e c7 7e           LAFEA     LDX  #LAFCF-1       ; * POINT X TO '?REDO' AND PRINT
1365 c797 bd d0 e8                     JSR  LB99C          ; * IT ON THE SCREEN
1366 c79a 9e 2f                        LDX  TINPTR         ; = GET THE SAVED ABSOLUTE ADDRESS OF
1367 c79c 9f 83                        STX  CHARAD         ; = INPUT POINTER AND RESTORE IT
1368 c79e 39                           RTS
1369                         *
1370                         * INPUT
1371 c79f c6 16              INPUT     LDB  #11*2          ; 'ID' ERROR
1372 c7a1 9e 68                        LDX  CURLIN         ; GET CURRENT LINE NUMBER
1373 c7a3 30 01                        LEAX 1,X            ; ADD ONE
1374 c7a5 27 df                        BEQ  LAFDC          ; 'ID' ERROR BRANCH IF DIRECT MODE
1375 c7a7 8d 01                        BSR  LB00F          ; GET SOME INPUT DATA - WAS LB002
1376 c7a9 39                           RTS
1377 c7aa 81 22              LB00F     CMPA #'"            ; CHECK FOR PROMPT STRING DELIMITER
1378 c7ac 26 0b                        BNE  LB01E          ; BRANCH IF NO PROMPT STRING
1379 c7ae bd c9 d0                     JSR  LB244          ; PUT PROMPT STRING ON STRING STACK
1380 c7b1 c6 3b                        LDB  #';            ; *
1381 c7b3 bd c9 fb                     JSR  LB26F          ; * DO A SYNTAX CHECK FOR SEMICOLON
1382 c7b6 bd d0 eb                     JSR  LB99F          ; PRINT MESSAGE TO CONSOLE OUT
1383 c7b9 8e 00 f3           LB01E     LDX  #LINBUF        ; POINT TO BASIC'S LINE BUFFER
1384 c7bc 6f 84                        CLR  ,X             ; CLEAR 1ST BYTE - FLAG TO INDICATE NO DATA
1385                         *              ; IN LINE BUFFER
1386 c7be 8d 06                        BSR  LB02F          ; INPUT A STRING TO LINE BUFFER
1387 c7c0 c6 2c                        LDB  #',            ; * INSERT A COMMA AT THE END
1388 c7c2 e7 84                        STB  ,X             ; * OF THE LINE INPUT BUFFER
1389 c7c4 20 16                        BRA  LB049
1390                         * FILL BASIC'S LINE INPUT BUFFER CONSOLE IN
1391 c7c6 bd d0 fb           LB02F     JSR  LB9AF          ; SEND A "?" TO CONSOLE OUT
1392 c7c9 bd d0 f8                     JSR  LB9AC          ; SEND A 'SPACE' TO CONSOLE OUT
1393 c7cc bd c1 41           LB035     JSR  LA390          ; GO READ IN A BASIC LINE
1394 c7cf 24 05                        BCC  LB03F          ; BRANCH IF ENTER KEY ENDED ENTRY
1395 c7d1 32 64                        LEAS 4,S            ; PURGE TWO RETURN ADDRESSES OFF THE STACK
1396 c7d3 7e c5 c9                     JMP  LAE11          ; GO DO A 'STOP' IF BREAK KEY ENDED LINE ENTRY
1397 c7d6 c6 2e              LB03F     LDB  #2*23          ; 'INPUT PAST END OF FILE' ERROR
1398 c7d8 39                           RTS
1399                         *
1400                         * READ
1401 c7d9 9e 33              READ      LDX  DATPTR         ; GET 'READ' START ADDRESS
1402 c7db 86                           FCB  SKP1LD         ; SKIP ONE BYTE - LDA #*$4F
1403 c7dc 4f                 LB049     CLRA                ; 'INPUT' ENTRY POINT: INPUT FLAG = 0
1404 c7dd 97 09                        STA  INPFLG         ; SET INPUT FLAG; 0 = INPUT: <> 0 = READ
1405 c7df 9f 35                        STX  DATTMP         ; SAVE 'READ' START ADDRESS/'INPUT' BUFFER START
1406 c7e1 bd ca de           LB04E     JSR  LB357          ; EVALUATE A VARIABLE
1407 c7e4 9f 3b                        STX  VARDES         ; SAVE DESCRIPTOR ADDRESS
1408 c7e6 9e 83                        LDX  CHARAD         ; * GET BASIC'S INPUT POINTER
1409 c7e8 9f 2b                        STX  BINVAL         ; * AND SAVE IT
1410 c7ea 9e 35                        LDX  DATTMP         ; GET 'READ' ADDRESS START/'INPUT' BUFFER POINTER
1411 c7ec a6 84                        LDA  ,X             ; GET A CHARACTER FROM THE BASIC PROGRAM
1412 c7ee 26 09                        BNE  LB069          ; BRANCH IF NOT END OF LINE
1413 c7f0 96 09                        LDA  INPFLG         ; * CHECK INPUT FLAG AND BRANCH
1414 c7f2 26 51                        BNE  LB0B9          ; * IF LOOKING FOR DATA (READ)
1415                         * NO DATA IN 'INPUT' LINE BUFFER AND/OR INPUT
1416                         * NOT COMING FROM SCREEN
1417 c7f4 bd d0 fb                     JSR  LB9AF          ; SEND A '?' TO CONSOLE OUT
1418 c7f7 8d cd                        BSR  LB02F          ; FILL INPUT BUFFER FROM CONSOLE IN
1419 c7f9 9f 83              LB069     STX  CHARAD         ; RESET BASIC'S INPUT POINTER
1420 c7fb 9d 7c                        JSR  GETNCH         ; GET A CHARACTER FROM BASIC
1421 c7fd d6 06                        LDB  VALTYP         ; * CHECK VARIABLE TYPE AND
1422 c7ff 27 23                        BEQ  LB098          ; * BRANCH IF NUMERIC
1423                         * READ/INPUT A STRING VARIABLE
1424 c801 9e 83                        LDX  CHARAD         ; LOAD X WITH CURRENT BASIC INPUT POINTER
1425 c803 97 01                        STA  CHARAC         ; SAVE CURRENT INPUT CHARACTER
1426 c805 81 22                        CMPA #'"            ; CHECK FOR STRING DELIMITER
1427 c807 27 0e                        BEQ  LB08B          ; BRANCH IF STRING DELIMITER
1428 c809 30 1f                        LEAX -1,X           ; BACK UP POINTER
1429 c80b 4f                           CLRA                ; * ZERO = END OF LINE CHARACTER
1430 c80c 97 01                        STA  CHARAC         ; * SAVE AS TERMINATOR
1431 c80e bd c1 33                     JSR  LA35F          ; SET UP PRINT PARAMETERS
1432 c811 86 3a                        LDA  #':            ; END OF SUBLINE CHARACTER
1433 c813 97 01                        STA  CHARAC         ; SAVE AS TERMINATOR I
1434 c815 86 2c                        LDA  #',            ; COMMA
1435 c817 97 02              LB08B     STA  ENDCHR         ; SAVE AS TERMINATOR 2
1436 c819 bd cc a5                     JSR  LB51E          ; STRIP A STRING FROM THE INPUT BUFFER
1437 c81c bd c9 d5                     JSR  LB249          ; MOVE INPUT POINTER TO END OF STRING
1438 c81f bd c7 54                     JSR  LAFA4          ; PUT A STRING INTO THE STRING SPACE IF NECESSARY
1439 c822 20 06                        BRA  LB09E          ; CHECK FOR ANOTHER DATA ITEM
1440                         * SAVE A NUMERIC VALUE IN A READ OR INPUT DATA ITEM
1441 c824 bd d4 5e           LB098     JSR  LBD12          ; CONVERT AN ASCII STRING TO FP NUMBER
1442 c827 bd d3 7f                     JSR  LBC33          ; PACK FPA0 AND STORE IT IN ADDRESS IN VARDES -
1443                         *                             ; INPUT OR READ DATA ITEM
1444 c82a 9d 82              LB09E     JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
1445 c82c 27 06                        BEQ  LB0A8          ; BRANCH IF END OF LINE
1446 c82e 81 2c                        CMPA #',            ; CHECK FOR A COMMA
1447 c830 10 26 ff 52                  LBNE LAFD6          ; BAD FILE DATA' ERROR OR RETRY
1448 c834 9e 83              LB0A8     LDX  CHARAD         ; * GET CURRENT INPUT
1449 c836 9f 35                        STX  DATTMP         ; * POINTER (USED AS A DATA POINTER) AND SAVE IT
1450 c838 9e 2b                        LDX  BINVAL         ; * RESET INPUT POINTER TO INPUT OR
1451 c83a 9f 83                        STX  CHARAD         ; * READ STATEMENT
1452 c83c 9d 82                        JSR  GETCCH         ; GET CURRENT CHARACTER FROM BASIC
1453 c83e 27 21                        BEQ  LB0D5          ; BRANCH IF END OF LINE - EXIT COMMAND
1454 c840 bd c9 f9                     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
1455 c843 20 9c                        BRA  LB04E          ; GET ANOTHER INPUT OR READ ITEM
1456                         * SEARCH FROM ADDRESS IN X FOR
1457                         * 1ST OCCURENCE OF THE TOKEN FOR DATA
1458 c845 9f 83              LB0B9     STX  CHARAD         ; RESET BASIC'S INPUT POINTER
1459 c847 bd c6 98                     JSR  LAEE8          ; SEARCH FOR END OF CURRENT LINE OR SUBLINE
1460 c84a 30 01                        LEAX 1,X            ; MOVE X ONE PAST END OF LINE
1461 c84c 4d                           TSTA                ; CHECK FOR END OF LINE
1462 c84d 26 0a                        BNE  LB0CD          ; BRANCH IF END OF SUBLINE
1463 c84f c6 06                        LDB  #2*3           ; 'OUT OF DATA' ERROR
1464 c851 ee 81                        LDU  ,X++           ; GET NEXT 2 CHARACTERS
1465 c853 27 41                        BEQ  LB10A          ; 'OD' ERROR IF END OF PROGRAM
1466 c855 ec 81                        LDD  ,X++           ; GET BASIC LINE NUMBER AND
1467 c857 dd 31                        STD  DATTXT         ; SAVE IT IN DATTXT
1468 c859 a6 84              LB0CD     LDA  ,X             ; GET AN INPUT CHARACTER
1469 c85b 81 86                        CMPA #TOK_DATA      ; DATA TOKEN?
1470 c85d 26 e6                        BNE  LB0B9          ; NO - KEEP LOOKING
1471 c85f 20 98                        BRA  LB069          ; YES
1472                         * EXIT READ AND INPUT COMMANDS
1473 c861 9e 35              LB0D5     LDX  DATTMP         ; GET DATA POINTER
1474 c863 d6 09                        LDB  INPFLG         ; * CHECK INPUT FLAG
1475 c865 10 26 fd 3a                  LBNE LADE8          ; * SAVE NEW DATA POINTER IF READ
1476 c869 a6 84                        LDA  ,X             ; = CHECK NEXT CHARACTER IN 'INPUT' BUFFER
1477 c86b 27 06                        BEQ  LB0E7          ; =
1478 c86d 8e c8 73                     LDX  #LB0E8-1       ; POINT X TO '?EXTRA IGNORED'
1479 c870 7e d0 e8                     JMP  LB99C          ; PRINT THE MESSAGE
1480 c873 39                 LB0E7     RTS
1481                         
1482 c874 3f 45 58 54 52 41  LB0E8     FCC  "?EXTRA IGNORED" ; ?EXTRA IGNORED MESSAGE
     20 49 47 4e 4f 52
     45 44
1483                         
1484                         
1485 c882 0d 00                        FCB  CR,$00
1486                         
1487                         * NEXT
1488 c884 26 04              NEXT      BNE  LB0FE          ; BRANCH IF ARGUMENT GIVEN
1489 c886 9e 74                        LDX  ZERO           ; X = 0: DEFAULT FOR NO ARGUMENT
1490 c888 20 03                        BRA  LB101
1491 c88a bd ca de           LB0FE     JSR  LB357          ; EVALUATE AN ALPHA EXPRESSION
1492 c88d 9f 3b              LB101     STX  VARDES         ; SAVE VARIABLE DESCRIPTOR POINTER
1493 c88f bd c3 b9                     JSR  LABF9          ; GO SCAN FOR 'FOR/NEXT' DATA ON STACK
1494 c892 27 04                        BEQ  LB10C          ; BRANCH IF DATA FOUND
1495 c894 c6 00                        LDB  #0             ; 'NEXT WITHOUT FOR' ERROR (SHOULD BE CLRB)
1496 c896 20 47              LB10A     BRA  LB153          ; PROCESS ERROR
1497 c898 1f 14              LB10C     TFR  X,S            ; POINT S TO START OF 'FOR/NEXT' DATA
1498 c89a 30 03                        LEAX 3,X            ; POINT X TO FP VALUE OF STEP
1499 c89c bd d3 60                     JSR  LBC14          ; COPY A FP NUMBER FROM (X) TO FPA0
1500 c89f a6 68                        LDA  8,S            ; GET THE DIRECTION OF STEP
1501 c8a1 97 54                        STA  FP0SGN         ; SAVE IT AS THE SIGN OF FPA0
1502 c8a3 9e 3b                        LDX  VARDES         ; POINT (X) TO INDEX VARIABLE DESCRIPTOR
1503 c8a5 bd d1 0e                     JSR  LB9C2          ; ADD (X) TO FPA0 (STEP TO INDEX)
1504 c8a8 bd d3 7f                     JSR  LBC33          ; PACK FPA0 AND STORE IT IN ADDRESS
1505                         *                             ; CONTAINED IN VARDES
1506 c8ab 30 69                        LEAX 9,S            ; POINT (X) TO TERMINAL VALUE OF INDEX
1507 c8ad bd d3 e2                     JSR  LBC96          ; COMPARE CURRENT INDEX VALUE TO TERMINAL VALUE OF INDEX
1508 c8b0 e0 68                        SUBB 8,S            ; ACCB = 0 IF TERMINAL VALUE=CURRENT VALUE AND STEP=0 OR IF
1509                         *                             ; STEP IS POSITIVE AND CURRENT VALUE>TERMINAL VALUE OR
1510                         *                             ; STEP IS NEGATIVE AND CURRENT VALUE<TERMINAL VALUE
1511 c8b2 27 0c                        BEQ  LB134          ; BRANCH IF 'FOR/NEXT' LOOP DONE
1512 c8b4 ae 6e                        LDX  14,S           ; * GET LINE NUMBER AND
1513 c8b6 9f 68                        STX  CURLIN         ; * BASIC POINTER OF
1514 c8b8 ae e8 10                     LDX  16,S           ; * STATEMENT FOLLOWING THE
1515 c8bb 9f 83                        STX  CHARAD         ; * PROPER FOR STATEMENT
1516 c8bd 7e c5 42           LB131     JMP  LAD9E          ; JUMP BACK TO COMMAND INTEPR. LOOP
1517 c8c0 32 e8 12           LB134     LEAS 18,S           ; PULL THE 'FOR-NEXT' DATA OFF THE STACK
1518 c8c3 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
1519 c8c5 81 2c                        CMPA #',            ; CHECK FOR ANOTHER ARGUMENT
1520 c8c7 26 f4                        BNE  LB131          ; RETURN IF NONE
1521 c8c9 9d 7c                        JSR  GETNCH         ; GET NEXT CHARACTER FROM BASIC
1522 c8cb 8d bd                        BSR  LB0FE          ; BSR SIMULATES A CALL TO 'NEXT' FROM COMMAND LOOP
1523                         
1524                         
1525 c8cd 8d 13              LB141     BSR  LB156          ; EVALUATE EXPRESSION AND DO A TYPE CHECK FOR NUMERIC
1526 c8cf 1c fe              LB143     ANDCC #$FE          ; CLEAR CARRY FLAG
1527 c8d1 7d                 LB145     FCB  $7D            ; OP CODE OF TST $1A01 - SKIP TWO BYTES (DO
1528                         *              ; NOT CHANGE CARRY FLAG)
1529 c8d2 1a 01              LB146     ORCC #1             ; SET CARRY
1530                         
1531                         * STRING TYPE MODE CHECK - IF ENTERED AT LB146 THEN VALTYP PLUS IS 'TM' ERROR
1532                         * NUMERIC TYPE MODE CHECK - IF ENTERED AT LB143 THEN VALTYP MINUS IS 'TM' ERROR
1533                         * IF ENTERED AT LB148, A TYPE CHECK IS DONE ON VALTYP
1534                         * IF ENTERED WITH CARRY SET, THEN 'TM' ERROR IF NUMERIC
1535                         * IF ENTERED WITH CARRY CLEAR, THEN 'TM' ERROR IF STRING.
1536 c8d4 0d 06              LB148     TST  VALTYP         ; TEST TYPE FLAG; DO NOT CHANGE CARRY
1537 c8d6 25 03                        BCS  LB14F          ; BRANCH IF STRING
1538 c8d8 2a 99                        BPL  LB0E7          ; RETURN ON PLUS
1539 c8da 8c                           FCB  SKP2           ; SKIP 2 BYTES - 'TM' ERROR
1540 c8db 2b 96              LB14F     BMI  LB0E7          ; RETURN ON MINUS
1541 c8dd c6 18                        LDB  #12*2          ; 'TYPE M1SMATCH' ERROR
1542 c8df 7e c4 06           LB153     JMP  LAC46          ; PROCESS ERROR
1543                         * EVALUATE EXPRESSION
1544 c8e2 8d 6e              LB156     BSR  LB1C6          ; BACK UP INPUT POINTER
1545 c8e4 4f                 LB158     CLRA                ; END OF OPERATION PRECEDENCE FLAG
1546 c8e5 8c                           FCB  SKP2           ; SKIP TWO BYTES
1547 c8e6 34 04              LB15A     PSHS B              ; SAVE FLAG (RELATIONAL OPERATOR FLAG)
1548 c8e8 34 02                        PSHS A              ; SAVE FLAG (PRECEDENCE FLAG)
1549 c8ea c6 01                        LDB  #1             ; *
1550 c8ec bd c3 f3                     JSR  LAC33          ; * SEE IF ROOM IN FREE RAM FOR (B) WORDS
1551 c8ef bd c9 af                     JSR  LB223          ; GO EVALUATE AN EXPRESSION
1552 c8f2 0f 3f                        CLR  TRELFL         ; RESET RELATIONAL OPERATOR FLAG
1553 c8f4 9d 82              LB168     JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
1554                         * CHECK FOR RELATIONAL OPERATORS
1555 c8f6 80 ad              LB16A     SUBA #TOK_GREATER   ; TOKEN FOR >
1556 c8f8 25 13                        BCS  LB181          ; BRANCH IF LESS THAN RELATIONAL OPERATORS
1557 c8fa 81 03                        CMPA #3             ; *
1558 c8fc 24 0f                        BCC  LB181          ; * BRANCH IF GREATER THAN RELATIONAL OPERATORS
1559 c8fe 81 01                        CMPA #1             ; SET CARRY IF '>'
1560 c900 49                           ROLA                ; CARRY TO BIT 0
1561 c901 98 3f                        EORA TRELFL         ; * CARRY SET IF
1562 c903 91 3f                        CMPA TRELFL         ; * TRELFL = ACCA
1563 c905 25 64                        BCS  LB1DF          ; BRANCH IF SYNTAX ERROR : == << OR >>
1564 c907 97 3f                        STA  TRELFL         ; BIT 0: >, BIT 1 =, BIT 2: <
1565 c909 9d 7c                        JSR  GETNCH         ; GET AN INPUT CHARACTER
1566 c90b 20 e9                        BRA  LB16A          ; CHECK FOR ANOTHER RELATIONAL OPERATOR
1567                         *
1568 c90d d6 3f              LB181     LDB  TRELFL         ; GET RELATIONAL OPERATOR FLAG
1569 c90f 26 33                        BNE  LB1B8          ; BRANCH IF RELATIONAL COMPARISON
1570 c911 10 24 00 6b                  LBCC LB1F4          ; BRANCH IF > RELATIONAL OPERATOR
1571 c915 8b 07                        ADDA #7             ; SEVEN ARITHMETIC/LOGICAL OPERATORS
1572 c917 24 67                        BCC  LB1F4          ; BRANCH IF NOT ARITHMETIC/LOGICAL OPERATOR
1573 c919 99 06                        ADCA VALTYP         ; ADD CARRY, NUMERIC FLAG AND MODIFIED TOKEN NUMBER
1574 c91b 10 27 04 77                  LBEQ LB60F          ; BRANCH IF VALTYP = FF, AND ACCA = '+' TOKEN -
1575                         *                             ; CONCATENATE TWO STRINGS
1576 c91f 89 ff                        ADCA #-1            ; RESTORE ARITHMETIC/LOGICAL OPERATOR NUMBER
1577 c921 34 02                        PSHS A              ; * STORE OPERATOR NUMBER ON STACK; MULTIPLY IT BY 2
1578 c923 48                           ASLA                ; * THEN ADD THE STORED STACK DATA = MULTIPLY
1579 c924 ab e0                        ADDA ,S+            ; * X 3; 3 BYTE/TABLE ENTRY
1580 c926 8e c2 0b                     LDX  #LAA51         ; JUMP TABLE FOR ARITHMETIC & LOGICAL OPERATORS
1581 c929 30 86                        LEAX A,X            ; POINT X TO PROPER TABLE
1582 c92b 35 02              LB19F     PULS A              ; GET PRECEDENCE FLAG FROM STACK
1583 c92d a1 84                        CMPA ,X             ; COMPARE TO CURRENT OPERATOR
1584 c92f 24 55                        BCC  LB1FA          ; BRANCH IF STACK OPERATOR > CURRENT OPERATOR
1585 c931 8d 9c                        BSR  LB143          ; 'TM' ERROR IF VARIABLE TYPE = STRING
1586                         
1587                         * OPERATION BEING PROCESSED IS OF HIGHER PRECEDENCE THAN THE PREVIOUS OPERATION.
1588 c933 34 02              LB1A7     PSHS A              ; SAVE PRECEDENCE FLAG
1589 c935 8d 29                        BSR  LB1D4          ; PUSH OPERATOR ROUTINE ADDRESS AND FPA0 ONTO STACK
1590 c937 9e 3d                        LDX  RELPTR         ; GET POINTER TO ARITHMETIC/LOGICAL TABLE ENTRY FOR
1591                         *                             ; LAST CALCULATED OPERATION
1592 c939 35 02                        PULS A              ; GET PRECEDENCE FLAG OF PREVIOUS OPERATION
1593 c93b 26 1d                        BNE  LB1CE          ; BRANCH IF NOT END OF OPERATION
1594 c93d 4d                           TSTA                ; CHECK TYPE OF PRECEDENCE FLAG
1595 c93e 10 27 00 6a                  LBEQ LB220          ; BRANCH IF END OF EXPRESSION OR SUB-EXPRESSION
1596 c942 20 4b                        BRA  LB203          ; EVALUATE AN OPERATION
1597                         
1598 c944 08 06              LB1B8     ASL  VALTYP         ; BIT 7 OF TYPE FLAG TO CARRY
1599 c946 59                           ROLB                ; SHIFT RELATIONAL FLAG LEFT - VALTYP TO BIT 0
1600 c947 8d 09                        BSR  LB1C6          ; MOVE THE INPUT POINTER BACK ONE
1601 c949 8e c9 57                     LDX  #LB1CB         ; POINT X TO RELATIONAL COMPARISON JUMP TABLE
1602 c94c d7 3f                        STB  TRELFL         ; SAVE RELATIONAL COMPARISON DATA
1603 c94e 0f 06                        CLR  VALTYP         ; SET VARIABLE TYPE TO NUMERIC
1604 c950 20 d9                        BRA  LB19F          ; PERFORM OPERATION OR SAVE ON STACK
1605                         
1606 c952 9e 83              LB1C6     LDX  CHARAD         ; * GET BASIC'S INPUT POINTER AND
1607 c954 7e c6 6b                     JMP  LAEBB          ; * MOVE IT BACK ONE
1608                         * RELATIONAL COMPARISON JUMP TABLE
1609 c957 64                 LB1CB     FCB  $64            ; RELATIONAL COMPARISON FLAG
1610 c958 ca 7b              LB1CC     FDB  LB2F4          ; JUMP ADDRESS
1611                         
1612 c95a a1 84              LB1CE     CMPA ,X             ; COMPARE PRECEDENCE OF LAST DONE OPERATION TO
1613                         *         NEXT TO BE DONE OPERATION
1614 c95c 24 31                        BCC  LB203          ; EVALUATE OPERATION IF LOWER PRECEDENCE
1615 c95e 20 d3                        BRA  LB1A7          ; PUSH OPERATION DATA ON STACK IF HIGHER PRECEDENCE
1616                         
1617                         * PUSH OPERATOR EVALUATION ADDRESS AND FPA0 ONTO STACK AND EVALUATE ANOTHER EXPR
1618 c960 ec 01              LB1D4     LDD  1,X            ; GET ADDRESS OF OPERATOR ROUTINE
1619 c962 34 06                        PSHS B,A            ; SAVE IT ON THE STACK
1620 c964 8d 08                        BSR  LB1E2          ; PUSH FPA0 ONTO STACK
1621 c966 d6 3f                        LDB  TRELFL         ; GET BACK RELATIONAL OPERATOR FLAG
1622 c968 16 ff 7b                     LBRA LB15A          ; EVALUATE ANOTHER EXPRESSION
1623 c96b 7e ca 03           LB1DF     JMP  LB277          ; 'SYNTAX ERROR'
1624                         * PUSH FPA0 ONTO THE STACK. ,S   = EXPONENT
1625                         * 1-2,S =HIGH ORDER MANTISSA 3-4,S = LOW ORDER MANTISSA
1626                         * 5,S = SIGN RETURN WITH PRECEDENCE CODE IN ACCA
1627 c96e d6 54              LB1E2     LDB  FP0SGN         ; GET SIGN OF FPA0 MANTISSA
1628 c970 a6 84                        LDA  ,X             ; GET PRECEDENCE CODE TO ACCA
1629 c972 35 20              LB1E6     PULS Y              ; GET RETURN ADDRESS FROM STACK & PUT IT IN Y
1630 c974 34 04                        PSHS B              ; SAVE ACCB ON STACK
1631 c976 d6 4f              LB1EA     LDB  FP0EXP         ; * PUSH FPA0 ONTO THE STACK
1632 c978 9e 50                        LDX  FPA0           ; *
1633 c97a de 52                        LDU  FPA0+2         ; *
1634 c97c 34 54                        PSHS U,X,B          ; *
1635 c97e 6e a4                        JMP  ,Y             ; JUMP TO ADDRESS IN Y
1636                         
1637                         * BRANCH HERE IF NON-OPERATOR CHARACTER FOUND - USUALLY ')' OR END OF LINE
1638 c980 9e 74              LB1F4     LDX  ZERO           ; POINT X TO DUMMY VALUE (ZERO)
1639 c982 a6 e0                        LDA  ,S+            ; GET PRECEDENCE FLAG FROM STACK
1640 c984 27 26                        BEQ  LB220          ; BRANCH IF END OF EXPRESSION
1641 c986 81 64              LB1FA     CMPA #$64           ; * CHECK FOR RELATIONAL COMPARISON FLAG
1642 c988 27 03                        BEQ  LB201          ; * AND BRANCH IF RELATIONAL COMPARISON
1643 c98a bd c8 cf                     JSR  LB143          ; 'TM' ERROR IF VARIABLE TYPE = STRING
1644 c98d 9f 3d              LB201     STX  RELPTR         ; SAVE POINTER TO OPERATOR ROUTINE
1645 c98f 35 04              LB203     PULS B              ; GET RELATIONAL OPERATOR FLAG FROM STACK
1646 c991 81 5a                        CMPA #$5A           ; CHECK FOR 'NOT' OPERATOR
1647 c993 27 19                        BEQ  LB222          ; RETURN IF 'NOT' - NO RELATIONAL COMPARISON
1648 c995 81 7d                        CMPA #$7D           ; CHECK FOR NEGATION (UNARY) FLAG
1649 c997 27 15                        BEQ  LB222          ; RETURN IF NEGATION - NO RELATIONAL COMPARISON
1650                         
1651                         * EVALUATE AN OPERATION. EIGHT BYTES WILL BE STORED ON STACK, FIRST SIX BYTES
1652                         * ARE A TEMPORARY FLOATING POINT RESULT THEN THE ADDRESS OF ROUTINE WHICH
1653                         * WILL EVALUATE THE OPERATION. THE RTS AT END OF ROUTINE WILL VECTOR
1654                         * TO EVALUATING ROUTINE.
1655 c999 54                           LSRB                ; = ROTATE VALTYP BIT INTO CARRY
1656 c99a d7 0a                        STB  RELFLG         ; = FLAG AND SAVE NEW RELFLG
1657 c99c 35 52                        PULS A,X,U          ; * PULL A FP VALUE OFF OF THE STACK
1658 c99e 97 5c                        STA  FP1EXP         ; * AND SAVE IT IN FPA1
1659 c9a0 9f 5d                        STX  FPA1           ; *
1660 c9a2 df 5f                        STU  FPA1+2         ; *
1661 c9a4 35 04                        PULS B              ; = GET MANTISSA SIGN AND
1662 c9a6 d7 61                        STB  FP1SGN         ; = SAVE IT IN FPA1
1663 c9a8 d8 54                        EORB FP0SGN         ; EOR IT WITH FPA1 MANTISSA SIGN
1664 c9aa d7 62                        STB  RESSGN         ; SAVE IT IN RESULT SIGN BYTE
1665 c9ac d6 4f              LB220     LDB  FP0EXP         ; GET EXPONENT OF FPA0
1666 c9ae 39                 LB222     RTS
1667                         
1668 c9af bd db fc           LB223     JSR  XVEC15         ; CALL EXTENDED BASIC ADD-IN
1669 c9b2 0f 06                        CLR  VALTYP         ; INITIALIZE TYPE FLAG TO NUMERIC
1670 c9b4 9d 7c                        JSR  GETNCH         ; GET AN INPUT CHAR
1671 c9b6 24 03                        BCC  LB22F          ; BRANCH IF NOT NUMERIC
1672 c9b8 7e d4 5e           LB22C     JMP  LBD12          ; CONVERT ASCII STRING TO FLOATING POINT -
1673                         *         RETURN RESULT IN FPA0
1674                         * PROCESS A NON NUMERIC FIRST CHARACTER
1675 c9bb bd cb 29           LB22F     JSR  LB3A2          ; SET CARRY IF NOT ALPHA
1676 c9be 24 50                        BCC  LB284          ; BRANCH IF ALPHA CHARACTER
1677 c9c0 81 2e                        CMPA #'.            ; IS IT '.' (DECIMAL POINT)?
1678 c9c2 27 f4                        BEQ  LB22C          ; CONVERT ASCII STRING TO FLOATING POINT
1679 c9c4 81 a7                        CMPA #TOK_MINUS     ; MINUS TOKEN
1680 c9c6 27 40                        BEQ  LB27C          ; YES - GO PROCESS THE MINUS OPERATOR
1681 c9c8 81 a6                        CMPA #TOK_PLUS      ; PLUS TOKEN
1682 c9ca 27 e3                        BEQ  LB223          ; YES - GET ANOTHER CHARACTER
1683 c9cc 81 22                        CMPA #'"            ; STRING DELIMITER?
1684 c9ce 26 0a                        BNE  LB24E          ; NO
1685 c9d0 9e 83              LB244     LDX  CHARAD         ; CURRENT BASIC POINTER TO X
1686 c9d2 bd cc 9f                     JSR  LB518          ; SAVE STRING ON STRING STACK
1687 c9d5 9e 64              LB249     LDX  COEFPT         ; * GET ADDRESS OF END OF STRING AND
1688 c9d7 9f 83                        STX  CHARAD         ; * PUT BASIC'S INPUT POINTER THERE
1689 c9d9 39                           RTS
1690 c9da 81 a3              LB24E     CMPA #TOK_NOT       ; NOT TOKEN?
1691 c9dc 26 0d                        BNE  LB25F          ; NO
1692                         * PROCESS THE NOT OPERATOR
1693 c9de 86 5a                        LDA  #$5A           ; 'NOT' PRECEDENCE FLAG
1694 c9e0 bd c8 e6                     JSR  LB15A          ; PROCESS OPERATION FOLLOWING 'NOT'
1695 c9e3 bd cb 74                     JSR  INTCNV         ; CONVERT FPA0 TO INTEGER IN ACCD
1696 c9e6 43                           COMA                ; * 'NOT' THE INTEGER
1697 c9e7 53                           COMB                ; *
1698 c9e8 7e cc 7b                     JMP  GIVABF         ; CONVERT ACCD TO FLOATING POINT (FPA0)
1699 c9eb 4c                 LB25F     INCA                ; CHECK FOR TOKENS PRECEEDED BY $FF
1700 c9ec 27 2e                        BEQ  LB290          ; IT WAS PRECEEDED BY $FF
1701 c9ee 8d 06              LB262     BSR  LB26A          ; SYNTAX CHECK FOR A '('
1702 c9f0 bd c8 e2                     JSR  LB156          ; EVALUATE EXPRESSIONS WITHIN PARENTHESES AT
1703                         *         HIGHEST PRECEDENCE
1704 c9f3 c6 29              LB267     LDB  #')            ; SYNTAX CHECK FOR ')'
1705 c9f5 8c                           FCB  SKP2           ; SKIP 2 BYTES
1706 c9f6 c6 28              LB26A     LDB  #'(            ; SYNTAX CHECK FOR '('
1707 c9f8 8c                           FCB  SKP2           ; SKIP 2 BYTES
1708 c9f9 c6 2c              LB26D     LDB  #',            ; SYNTAX CHECK FOR COMMA
1709 c9fb e1 9f 00 83        LB26F     CMPB [CHARAD]       ; * COMPARE ACCB TO CURRENT INPUT
1710 c9ff 26 02                        BNE  LB277          ; * CHARACTER - SYNTAX ERROR IF NO MATCH
1711 ca01 0e 7c                        JMP  GETNCH         ; GET A CHARACTER FROM BASIC
1712 ca03 c6 02              LB277     LDB  #2*1           ; SYNTAX ERROR
1713 ca05 7e c4 06                     JMP  LAC46          ; JUMP TO ERROR HANDLER
1714                         
1715                         * PROCESS THE MINUS (UNARY) OPERATOR
1716 ca08 86 7d              LB27C     LDA  #$7D           ; MINUS (UNARY) PRECEDENCE FLAG
1717 ca0a bd c8 e6                     JSR  LB15A          ; PROCESS OPERATION FOLLOWING 'UNARY' NEGATION
1718 ca0d 7e d6 35                     JMP  LBEE9          ; CHANGE SIGN OF FPA0 MANTISSA
1719                         
1720                         * EVALUATE ALPHA EXPRESSION
1721 ca10 bd ca de           LB284     JSR  LB357          ; FIND THE DESCRIPTOR ADDRESS OF A VARIABLE
1722 ca13 9f 52              LB287     STX  FPA0+2         ; SAVE DESCRIPTOR ADDRESS IN FPA0
1723 ca15 96 06                        LDA  VALTYP         ; TEST VARIABLE TYPE
1724 ca17 26 95                        BNE  LB222          ; RETURN IF STRING
1725 ca19 7e d3 60                     JMP  LBC14          ; COPY A FP NUMBER FROM (X) TO FPA0
1726                         
1727                         * EVALUATING A SECONDARY TOKEN
1728 ca1c 9d 7c              LB290     JSR  GETNCH         ; GET AN INPUT CHARACTER (SECONDARY TOKEN)
1729 ca1e 1f 89                        TFR  A,B            ; SAVE IT IN ACCB
1730 ca20 58                           ASLB                ; X2 & BET RID OF BIT 7
1731 ca21 9d 7c                        JSR  GETNCH         ; GET ANOTHER INPUT CHARACTER
1732 ca23 c1 38                        CMPB #NUM_SEC_FNS-1*2 ; 29 SECONDARY FUNCTIONS - 1
1733 ca25 23 03                        BLS  LB29F          ; BRANCH IF COLOR BASIC TOKEN
1734 ca27 7e ca 03                     JMP  LB277          ; SYNTAX ERROR
1735 ca2a 34 04              LB29F     PSHS B              ; SAVE TOKEN OFFSET ON STACK
1736 ca2c c1 2a                        CMPB #TOK_LEFT-$80*2 ; CHECK FOR TOKEN WITH AN ARGUMENT
1737 ca2e 25 1e                        BCS  LB2C7          ; DO SECONDARIES STRING$ OR LESS
1738 ca30 c1 30                        CMPB #TOK_INKEY-$80*2 ; *
1739 ca32 24 1c                        BCC  LB2C9          ; * DO SECONDARIES $92 (INKEY$) OR >
1740 ca34 8d c0                        BSR  LB26A          ; SYNTAX CHECK FOR A '('
1741 ca36 a6 e4                        LDA  ,S             ; GET TOKEN NUMBER
1742                         * DO SECONDARIES (LEFT$, RIGHT$, MID$)
1743 ca38 bd c8 e2                     JSR  LB156          ; EVALUATE FIRST STRING IN ARGUMENT
1744 ca3b 8d bc                        BSR  LB26D          ; SYNTAX CHECK FOR A COMMA
1745 ca3d bd c8 d2                     JSR  LB146          ; 'TM' ERROR IF NUMERIC VARiABLE
1746 ca40 35 02                        PULS A              ; GET TOKEN OFFSET FROM STACK
1747 ca42 de 52                        LDU  FPA0+2         ; POINT U TO STRING DESCRIPTOR
1748 ca44 34 42                        PSHS U,A            ; SAVE TOKEN OFFSET AND DESCRIPTOR ADDRESS
1749 ca46 bd ce 92                     JSR  LB70B          ; EVALUATE FIRST NUMERIC ARGUMENT
1750 ca49 35 02                        PULS A              ; GET TOKEN OFFSET FROM STACK
1751 ca4b 34 06                        PSHS B,A            ; SAVE TOKEN OFFSET AND NUMERIC ARGUMENT
1752 ca4d 8e                           FCB  $8E            ; OP CODE OF LDX# - SKlP 2 BYTES
1753 ca4e 8d 9e              LB2C7     BSR  LB262          ; SYNTAX CHECK FOR A '('
1754 ca50 35 04              LB2C9     PULS B              ; GET TOKEN OFFSET
1755 ca52 be c0 f9                     LDX  COMVEC+8       ; GET SECONDARY FUNCTION JUMP TABLE ADDRESS
1756 ca55 3a                 LB2CE     ABX                 ; ADD IN COMMAND OFFSET
1757                         *
1758                         * HERE IS WHERE WE BRANCH TO A SECONDARY FUNCTION
1759 ca56 ad 94                        JSR  [,X]           ; GO DO AN SECONDARY FUNCTION
1760 ca58 7e c8 cf                     JMP  LB143          ; 'TM' ERROR IF VARIABLE TYPE = STRING
1761                         
1762                         * LOGICAL OPERATOR 'OR' JUMPS HERE
1763 ca5b 86                 LB2D4     FCB  SKP1LD         ; SKIP ONE BYTE - 'OR' FLAG = $4F
1764                         
1765                         * LOGICAL OPERATOR 'AND' JUMPS HERE
1766 ca5c 4f                 LB2D5     CLRA                ; AND FLAG = 0
1767 ca5d 97 03                        STA  TMPLOC         ; AND/OR FLAG
1768 ca5f bd cb 74                     JSR  INTCNV         ; CONVERT FPA0 INTO AN INTEGER IN ACCD
1769 ca62 dd 01                        STD  CHARAC         ; TEMP SAVE ACCD
1770 ca64 bd d3 96                     JSR  LBC4A          ; MOVE FPA1 TO FPA0
1771 ca67 bd cb 74                     JSR  INTCNV         ; CONVERT FPA0 INTO AN INTEGER IN ACCD
1772 ca6a 0d 03                        TST  TMPLOC         ; CHECK AND/OR FLAG
1773 ca6c 26 06                        BNE  LB2ED          ; BRANCH IF OR
1774 ca6e 94 01                        ANDA CHARAC         ; * 'AND' ACCD WITH FPA0 INTEGER
1775 ca70 d4 02                        ANDB ENDCHR         ; * STORED IN ENDCHR
1776 ca72 20 04                        BRA  LB2F1          ; CONVERT TO FP
1777 ca74 9a 01              LB2ED     ORA  CHARAC         ; * 'OR' ACCD WITH FPA0 INTEGER
1778 ca76 da 02                        ORB  ENDCHR         ; * STORED IN CHARAC
1779 ca78 7e cc 7b           LB2F1     JMP  GIVABF         ; CONVERT THE VALUE IN ACCD INTO A FP NUMBER
1780                         
1781                         * RELATIONAL COMPARISON PROCESS HANDLER
1782 ca7b bd c8 d4           LB2F4     JSR  LB148          ; 'TM' ERROR IF TYPE MISMATCH
1783 ca7e 26 10                        BNE  LB309          ; BRANCH IF STRING VARIABLE
1784 ca80 96 61                        LDA  FP1SGN         ; * 'PACK' THE MANTISSA
1785 ca82 8a 7f                        ORA  #$7F           ; * SIGN OF FPA1 INTO
1786 ca84 94 5d                        ANDA FPA1           ; * BIT 7 OF THE
1787 ca86 97 5d                        STA  FPA1           ; * MANTISSA MS BYTE
1788 ca88 8e 00 5c                     LDX  #FP1EXP        ; POINT X TO FPA1
1789 ca8b bd d3 e2                     JSR  LBC96          ; COMPARE FPA0 TO FPA1
1790 ca8e 20 36                        BRA  LB33F          ; CHECK TRUTH OF RELATIONAL COMPARISON
1791                         
1792                         * RELATIONAL COMPARISON OF STRINGS
1793 ca90 0f 06              LB309     CLR  VALTYP         ; SET VARIABLE TYPE TO NUMERIC
1794 ca92 0a 3f                        DEC  TRELFL         ; REMOVE STRING TYPE FLAG (BIT0=1 FOR STRINGS) FROM THE
1795                         *                             ; DESIRED RELATIONAL COMPARISON DATA
1796 ca94 bd cd de                     JSR  LB657          ; GET LENGTH AND ADDRESS OF STRING WHOSE
1797                         *                             ; DESCRIPTOR ADDRESS IS IN THE BOTTOM OF FPA0
1798 ca97 d7 56                        STB  STRDES         ; * SAVE LENGTH AND ADDRESS IN TEMPORARY
1799 ca99 9f 58                        STX  STRDES+2       ; * DESCRIPTOR (STRING B)
1800 ca9b 9e 5f                        LDX  FPA1+2         ; = RETURN LENGTH AND ADDRESS OF STRING
1801 ca9d bd cd e0                     JSR  LB659          ; = WHOSE DESCRIPTOR ADDRESS IS STORED IN FPA1+2
1802 caa0 96 56                        LDA  STRDES         ; LOAD ACCA WITH LENGTH OF STRING B
1803 caa2 34 04                        PSHS B              ; SAVE LENGTH A ON STACK
1804 caa4 a0 e0                        SUBA ,S+            ; SUBTRACT LENGTH A FROM LENGTH B
1805 caa6 27 07                        BEQ  LB328          ; BRANCH IF STRINGS OF EQUAL LENGTH
1806 caa8 86 01                        LDA  #1             ; ; TRUE FLAG
1807 caaa 24 03                        BCC  LB328          ; TRUE IF LENGTH B > LENGTH A
1808 caac d6 56                        LDB  STRDES         ; LOAD ACCB WITH LENGTH B
1809 caae 40                           NEGA                ; SET FLAG = FALSE (1FF)
1810 caaf 97 54              LB328     STA  FP0SGN         ; SAVE TRUE/FALSE FLAG
1811 cab1 de 58                        LDU  STRDES+2       ; POINT U TO START OF STRING
1812 cab3 5c                           INCB                ; COMPENSATE FOR THE DECB BELOW
1813                         * ENTER WITH ACCB CONTAINING LENGTH OF SHORTER STRING
1814 cab4 5a                 LB32D     DECB                ; DECREMENT SHORTER STRING LENGTH
1815 cab5 26 04                        BNE  LB334          ; BRANCH IF ALL OF STRING NOT COMPARED
1816 cab7 d6 54                        LDB  FP0SGN         ; GET TRUE/FALSE FLAB
1817 cab9 20 0b                        BRA  LB33F          ; CHECK TRUTH OF RELATIONAL COMPARISON
1818 cabb a6 80              LB334     LDA  ,X+            ; GET A BYTE FROM STRING A
1819 cabd a1 c0                        CMPA ,U+            ; COMPARE TO STRING B
1820 cabf 27 f3                        BEQ  LB32D          ; CHECK ANOTHER CHARACTER IF =
1821 cac1 c6 ff                        LDB  #$FF           ; FALSE FLAG IF STRING A > B
1822 cac3 24 01                        BCC  LB33F          ; BRANCH IF STRING A > STRING B
1823 cac5 50                           NEGB                ; SET FLAG = TRUE
1824                         
1825                         * DETERMINE TRUTH OF COMPARISON - RETURN RESULT IN FPA0
1826 cac6 cb 01              LB33F     ADDB #1             ; CONVERT $FF,0,1 TO 0,1,2
1827 cac8 59                           ROLB                ; NOW IT'S 1,2,4 FOR > = <
1828 cac9 d4 0a                        ANDB RELFLG         ; 'AND' THE ACTUAL COMPARISON WITH THE DESIRED -
1829                         COMPARISON
1830 cacb 27 02                        BEQ  LB348          ; BRANCH IF FALSE (NO MATCHING BITS)
1831 cacd c6 ff                        LDB  #$FF           ; TRUE FLAG
1832 cacf 7e d3 c8           LB348     JMP  LBC7C          ; CONVERT ACCB INTO FP NUMBER IN FPA0
1833                         
1834                         * DIM
1835 cad2 bd c9 f9           LB34B     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
1836 cad5 c6 01              DIM       LDB  #1             ; DIMENSION FLAG
1837 cad7 8d 08                        BSR  LB35A          ; SAVE ARRAY SPACE FOR THIS VARIABLE
1838 cad9 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
1839 cadb 26 f5                        BNE  LB34B          ; KEEP DIMENSIONING IF NOT END OF LINE
1840 cadd 39                           RTS
1841                         * EVALUATE A VARIABLE - RETURN X AND
1842                         * VARPTR POINTING TO VARIABLE DESCRIPTOR
1843                         * EACH VARIABLE REQUIRES 7 BYTES - THE FIRST TWO
1844                         * BYTES ARE THE VARIABLE NAME AND THE NEXT 5
1845                         * BYTES ARE THE DESCRIPTOR. IF BIT 7 OF THE
1846                         * FIRST BYTE OF VARlABLE NAME IS SET, THE
1847                         * VARIABLE IS A DEF FN VARIABLE. IF BIT 7 OF
1848                         * THE SECOND BYTE OF VARIABLE NAME IS SET, THE
1849                         * VARIABLE IS A STRING, OTHERWISE THE VARIABLE
1850                         * IS NUMERIC.
1851                         * IF THE VARIABLE IS NOT FOUND, A ZERO VARIABLE IS
1852                         * INSERTED INTO THE VARIABLE SPACE
1853 cade 5f                 LB357     CLRB                ; DIMENSION FLAG = 0; DO NOT SET UP AN ARRAY
1854 cadf 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
1855 cae1 d7 05              LB35A     STB  DIMFLG         ; SAVE ARRAY FLAG
1856                         * ENTRY POINT FOR DEF FN VARIABLE SEARCH
1857 cae3 97 37              LB35C     STA  VARNAM         ; SAVE INPUT CHARACTER
1858 cae5 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
1859 cae7 8d 40                        BSR  LB3A2          ; SET CARRY IF NOT ALPHA
1860 cae9 10 25 ff 16                  LBCS LB277          ; SYNTAX ERROR IF NOT ALPHA
1861 caed 5f                           CLRB                ; DEFAULT 2ND VARIABLE CHARACTER TO ZERO
1862 caee d7 06                        STB  VALTYP         ; SET VARIABLE TYPE TO NUMERIC
1863 caf0 9d 7c                        JSR  GETNCH         ; GET ANOTHER CHARACTER FROM BASIC
1864 caf2 25 04                        BCS  LB371          ; BRANCH IF NUMERIC (2ND CHARACTER IN
1865                         *                             ; VARIABLE MAY BE NUMERIC)
1866 caf4 8d 33                        BSR  LB3A2          ; SET CARRY IF NOT ALPHA
1867 caf6 25 0a                        BCS  LB37B          ; BRANCH IF NOT ALPHA
1868 caf8 1f 89              LB371     TFR  A,B            ; SAVE 2ND CHARACTER IN ACCB
1869                         * READ INPUT CHARACTERS UNTIL A NON ALPHA OR
1870                         * NON NUMERIC IS FOUND - IGNORE ALL CHARACTERS
1871                         * IN VARIABLE NAME AFTER THE 1ST TWO
1872 cafa 9d 7c              LB373     JSR  GETNCH         ; GET AN INPUT CHARACTER
1873 cafc 25 fc                        BCS  LB373          ; BRANCH IF NUMERIC
1874 cafe 8d 29                        BSR  LB3A2          ; SET CARRY IF NOT ALPHA
1875 cb00 24 f8                        BCC  LB373          ; BRANCH IF ALPHA
1876 cb02 81 24              LB37B     CMPA #'$            ; CHECK FOR A STRING VARIABLE
1877 cb04 26 06                        BNE  LB385          ; BRANCH IF IT IS NOT A STRING
1878 cb06 03 06                        COM  VALTYP         ; SET VARIABLE TYPE TO STRING
1879 cb08 cb 80                        ADDB #$80           ; SET BIT 7 OF 2ND CHARACTER (STRING)
1880 cb0a 9d 7c                        JSR  GETNCH         ; GET AN INPUT CHARACTER
1881 cb0c d7 38              LB385     STB  VARNAM+1       ; SAVE 2ND CHARACTER IN VARNAM+1
1882 cb0e 9a 08                        ORA  ARYDIS         ; OR IN THE ARRAY DISABLE FLAG - IF = $80,
1883                         *              ; DON'T SEARCH FOR VARIABLES IN THE ARRAYS
1884 cb10 80 28                        SUBA #'(            ; IS THIS AN ARRAY VARIABLE?
1885 cb12 10 27 00 75                  LBEQ LB404          ; BRANCH IF IT IS
1886 cb16 0f 08                        CLR  ARYDIS         ; RESET THE ARRAY DISABLE FLAG
1887 cb18 9e 1b                        LDX  VARTAB         ; POINT X TO THE START OF VARIABLES
1888 cb1a dc 37                        LDD  VARNAM         ; GET VARIABLE IN QUESTION
1889 cb1c 9c 1d              LB395     CMPX ARYTAB         ; COMPARE X TO THE END OF VARIABLES
1890 cb1e 27 12                        BEQ  LB3AB          ; BRANCH IF END OF VARIABLES
1891 cb20 10 a3 81                     CMPD ,X++           ; * COMPARE VARIABLE IN QUESTION TO CURRENT
1892 cb23 27 3e                        BEQ  LB3DC          ; * VARIABLE AND BRANCH IF MATCH
1893 cb25 30 05                        LEAX 5,X            ; = MOVE POINTER TO NEXT VARIABLE AND
1894 cb27 20 f3                        BRA  LB395          ; = KEEP LOOKING
1895                         
1896                         * SET CARRY IF NOT UPPER CASE ALPHA
1897 cb29 81 41              LB3A2     CMPA #'A            ; * CARRY SET IF < 'A'
1898 cb2b 25 04                        BCS  LB3AA          ; *
1899 cb2d 80 5b                        SUBA #'Z+1          ; =
1900                         *         SUBA #-('Z+1)       ; = CARRY CLEAR IF <= 'Z'
1901 cb2f 80 a5                        FCB  $80,$A5
1902 cb31 39                 LB3AA     RTS
1903                         * PUT A NEW VARIABLE IN TABLE OF VARIABLES
1904 cb32 8e 00 74           LB3AB     LDX  #ZERO          ; POINT X TO ZERO LOCATION
1905 cb35 ee e4                        LDU  ,S             ; GET CURRENT RETURN ADDRESS
1906 cb37 11 83 ca 13                  CMPU #LB287         ; DID WE COME FROM 'EVALUATE ALPHA EXPR'?
1907 cb3b 27 28                        BEQ  LB3DE          ; YES - RETURN A ZERO VALUE
1908 cb3d dc 1f                        LDD  ARYEND         ; * GET END OF ARRAYS ADDRESS AND
1909 cb3f dd 43                        STD  V43            ; * SAVE IT AT V43
1910 cb41 c3 00 07                     ADDD #7             ; = ADD 7 TO END OF ARRAYS (EACH
1911 cb44 dd 41                        STD  V41            ; = VARIABLE = 7 BYTES) AND SAVE AT V41
1912 cb46 9e 1d                        LDX  ARYTAB         ; * GET END OF VARIABLES AND SAVE AT V47
1913 cb48 9f 47                        STX  V47            ; *
1914 cb4a bd c3 de                     JSR  LAC1E          ; MAKE A SEVEN BYTE SLOT FOR NEW VARIABLE AT
1915                         *         TOP  OF VARIABLES
1916 cb4d 9e 41                        LDX  V41            ; = GET NEW END OF ARRAYS AND SAVE IT
1917 cb4f 9f 1f                        STX  ARYEND         ; =
1918 cb51 9e 45                        LDX  V45            ; * GET NEW END OF VARIABLES AND SAVE IT
1919 cb53 9f 1d                        STX  ARYTAB         ; *
1920 cb55 9e 47                        LDX  V47            ; GET OLD END OF VARIABLES
1921 cb57 dc 37                        LDD  VARNAM         ; GET NEW VARIABLE NAME
1922 cb59 ed 81                        STD  ,X++           ; SAVE VARIABLE NAME
1923 cb5b 4f                           CLRA                ; * ZERO OUT THE FP VALUE OF THE NUMERIC
1924 cb5c 5f                           CLRB                ; * VARIABLE OR THE LENGTH AND ADDRESS
1925 cb5d ed 84                        STD  ,X             ; * OF A STRING VARIABLE
1926 cb5f ed 02                        STD  2,X            ; *
1927 cb61 a7 04                        STA  4,X            ; *
1928 cb63 9f 39              LB3DC     STX  VARPTR         ; STORE ADDRESS OF VARIABLE VALUE
1929 cb65 39                 LB3DE     RTS
1930                         *
1931 cb66 90 80 00 00 00     LB3DF     FCB  $90,$80,$00,$00,$00 ; * FLOATING POINT -32768
1932                         *                             ; SMALLEST SIGNED TWO BYTE INTEGER
1933                         *
1934 cb6b 9d 7c              LB3E4     JSR  GETNCH         ; GET AN INPUT CHARACTER FROM BASIC
1935 cb6d bd c8 cd           LB3E6     JSR  LB141          ; GO EVALUATE NUMERIC EXPRESSION
1936 cb70 96 54              LB3E9     LDA  FP0SGN         ; GET FPA0 MANTISSA SIGN
1937 cb72 2b 5d                        BMI  LB44A          ; 'FC' ERROR IF NEGATIVE NUMBER
1938                         
1939                         
1940 cb74 bd c8 cf           INTCNV    JSR  LB143          ; 'TM' ERROR IF STRING VARIABLE
1941 cb77 96 4f                        LDA  FP0EXP         ; GET FPA0 EXPONENT
1942 cb79 81 90                        CMPA #$90           ; * COMPARE TO 32768 - LARGEST INTEGER EXPONENT AND
1943 cb7b 25 08                        BCS  LB3FE          ; * BRANCH IF FPA0 < 32768
1944 cb7d 8e cb 66                     LDX  #LB3DF         ; POINT X TO FP VALUE OF -32768
1945 cb80 bd d3 e2                     JSR  LBC96          ; COMPARE -32768 TO FPA0
1946 cb83 26 4c                        BNE  LB44A          ; 'FC' ERROR IF NOT =
1947 cb85 bd d4 14           LB3FE     JSR  LBCC8          ; CONVERT FPA0 TO A TWO BYTE INTEGER
1948 cb88 dc 52                        LDD  FPA0+2         ; GET THE INTEGER
1949 cb8a 39                           RTS
1950                         * EVALUATE AN ARRAY VARIABLE
1951 cb8b dc 05              LB404     LDD  DIMFLG         ; GET ARRAY FLAG AND VARIABLE TYPE
1952 cb8d 34 06                        PSHS B,A            ; SAVE THEM ON STACK
1953 cb8f 12                           NOP                 ; DEAD SPACE CAUSED BY 1.2 REVISION
1954 cb90 5f                           CLRB                ; RESET DIMENSION COUNTER
1955 cb91 9e 37              LB40A     LDX  VARNAM         ; GET VARIABLE NAME
1956 cb93 34 14                        PSHS X,B            ; SAVE VARIABLE NAME AND DIMENSION COUNTER
1957 cb95 8d d4                        BSR  LB3E4          ; EVALUATE EXPRESSION (DIMENSlON LENGTH)
1958 cb97 35 34                        PULS B,X,Y          ; PULL OFF VARIABLE NAME, DIMENSlON COUNTER,
1959                         *                             ; ARRAY FLAG
1960 cb99 9f 37                        STX  VARNAM         ; SAVE VARIABLE NAME AND VARIABLE TYPE
1961 cb9b de 52                        LDU  FPA0+2         ; GET DIMENSION LENGTH
1962 cb9d 34 60                        PSHS U,Y            ; SAVE DIMENSION LENGTH, ARRAY FLAG, VARIABLE TYPE
1963 cb9f 5c                           INCB                ; INCREASE DIMENSION COUNTER
1964 cba0 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
1965 cba2 81 2c                        CMPA #',            ; CHECK FOR ANOTHER DIMENSION
1966 cba4 27 eb                        BEQ  LB40A          ; BRANCH IF MORE
1967 cba6 d7 03                        STB  TMPLOC         ; SAVE DIMENSION COUNTER
1968 cba8 bd c9 f3                     JSR  LB267          ; SYNTAX CHECK FOR A ')'
1969 cbab 35 06                        PULS A,B            ; * RESTORE VARIABLE TYPE AND ARRAY
1970 cbad dd 05                        STD  DIMFLG         ; * FLAG - LEAVE DIMENSION LENGTH ON STACK
1971 cbaf 9e 1d                        LDX  ARYTAB         ; GET START OF ARRAYS
1972 cbb1 9c 1f              LB42A     CMPX ARYEND         ; COMPARE TO END OF ARRAYS
1973 cbb3 27 21                        BEQ  LB44F          ; BRANCH IF NO MATCH FOUND
1974 cbb5 dc 37                        LDD  VARNAM         ; GET VARIABLE IN QUESTION
1975 cbb7 10 a3 84                     CMPD ,X             ; COMPARE TO CURRENT VARIABLE
1976 cbba 27 06                        BEQ  LB43B          ; BRANCH IF =
1977 cbbc ec 02                        LDD  2,X            ; GET OFFSET TO NEXT ARRAY VARIABLE
1978 cbbe 30 8b                        LEAX D,X            ; ADD TO CURRENT POINTER
1979 cbc0 20 ef                        BRA  LB42A          ; KEEP SEARCHING
1980 cbc2 c6 12              LB43B     LDB  #2*9           ; 'REDIMENSIONED ARRAY' ERROR
1981 cbc4 96 05                        LDA  DIMFLG         ; * TEST ARRAY FLAG - IF <>0 YOU ARE TRYING
1982 cbc6 26 0b                        BNE  LB44C          ; * TO REDIMENSION AN ARRAY
1983 cbc8 d6 03                        LDB  TMPLOC         ; GET NUMBER OF DIMENSIONS IN ARRAY
1984 cbca e1 04                        CMPB 4,X            ; COMPARE TO THIS ARRAYS DIMENSIONS
1985 cbcc 27 59                        BEQ  LB4A0          ; BRANCH IF =
1986 cbce c6 10              LB447     LDB  #8*2           ; 'BAD SUBSCRIPT'
1987 cbd0 8c                           FCB  SKP2           ; SKIP TWO BYTES
1988 cbd1 c6 08              LB44A     LDB  #4*2           ; 'ILLEGAL FUNCTION CALL'
1989 cbd3 7e c4 06           LB44C     JMP  LAC46          ; JUMP TO ERROR SERVICING ROUTINE
1990                         
1991                         * INSERT A NEW ARRAY INTO ARRAY VARIABLES
1992                         * EACH SET OF ARRAY VARIABLES IS PRECEEDED BY A DE-
1993                         * SCRIPTOR BLOCK COMPOSED OF 5+2*N BYTES WHERE N IS THE
1994                         * NUMBER OF DIMENSIONS IN THE ARRAY. THE BLOCK IS DEFINED
1995                         * AS FOLLOWS: BYTES 0,1:VARIABLE'S NAME; 2,3:TOTAL LENGTH
1996                         * OF ARRAY ITEMS AND DESCRIPTOR BLOCK; 4:NUMBER OF DIMEN-
1997                         * ISIONS; 5,6:LENGTH OF DIMENSION 1; 7,8:LENGTH OF DIMEN-
1998                         * SION 2;... 4+N,5+N:LENGTH OF DIMENSION N.
1999                         
2000 cbd6 cc 00 05           LB44F     LDD  #5             ; * 5 BYTES/ARRAY ENTRY SAVE AT COEFPT
2001 cbd9 dd 64                        STD  COEFPT         ; *
2002 cbdb dc 37                        LDD  VARNAM         ; = GET NAME OF ARRAY AND SAVE IN
2003 cbdd ed 84                        STD  ,X             ; = FIRST 2 BYTES OF DESCRIPTOR
2004 cbdf d6 03                        LDB  TMPLOC         ; GET NUMBER OF DIMENSIONS AND SAVE IN
2005 cbe1 e7 04                        STB  4,X            ; * 5TH BYTE OF DESCRIPTOR
2006 cbe3 bd c3 f3                     JSR  LAC33          ; CHECK FOR ROOM FOR DESCRIPTOR IN FREE RAM
2007 cbe6 9f 41                        STX  V41            ; TEMPORARILY SAVE DESCRIPTOR ADDRESS
2008 cbe8 c6 0b              LB461     LDB  #11            ; * DEFAULT DIMENSION VALUE:X(10)
2009 cbea 4f                           CLRA                ; *
2010 cbeb 0d 05                        TST  DIMFLG         ; = CHECK ARRAY FLAG AND BRANCH IF
2011 cbed 27 05                        BEQ  LB46D          ; = NOT DIMENSIONING AN ARRAY
2012 cbef 35 06                        PULS A,B            ; GET DIMENSION LENGTH
2013 cbf1 c3 00 01                     ADDD #1             ; ADD ONE (X(0) HAS A LENGTH OF ONE)
2014 cbf4 ed 05              LB46D     STD  5,X            ; SAVE LENGTH OF ARRAY DIMENSION
2015 cbf6 8d 5d                        BSR  LB4CE          ; MULTIPLY ACCUM ARRAY SIZE NUMBER LENGTH
2016                         *                             ; OF NEW DIMENSION
2017 cbf8 dd 64                        STD  COEFPT         ; TEMP STORE NEW CURRENT ACCUMULATED ARRAY SIZE
2018 cbfa 30 02                        LEAX 2,X            ; BUMP POINTER UP TWO
2019 cbfc 0a 03                        DEC  TMPLOC         ; * DECREMENT DIMENSION COUNTER AND BRANCH IF
2020 cbfe 26 e8                        BNE  LB461          ; * NOT DONE WITH ALL DIMENSIONS
2021 cc00 9f 0f                        STX  TEMPTR         ; SAVE ADDRESS OF (END OF ARRAY DESCRIPTOR - 5)
2022 cc02 d3 0f                        ADDD TEMPTR         ; ADD TOTAL SIZE OF NEW ARRAY
2023 cc04 10 25 f7 fc                  LBCS LAC44          ; 'OM' ERROR IF > $FFFF
2024 cc08 1f 01                        TFR  D,X            ; SAVE END OF ARRAY IN X
2025 cc0a bd c3 f7                     JSR  LAC37          ; MAKE SURE THERE IS ENOUGH FREE RAM FOR ARRAY
2026 cc0d 83 00 35                     SUBD #STKBUF-5      ; SUBTRACT OUT THE (STACK BUFFER - 5)
2027 cc10 dd 1f                        STD  ARYEND         ; SAVE NEW END OF ARRAYS
2028 cc12 4f                           CLRA                ; ZERO = TERMINATOR BYTE
2029 cc13 30 1f              LB48C     LEAX -1,X           ; * STORE TWO TERMINATOR BYTES AT
2030 cc15 a7 05                        STA  5,X            ; * THE END OF THE ARRAY DESCRIPTOR
2031 cc17 9c 0f                        CMPX TEMPTR         ; *
2032 cc19 26 f8                        BNE  LB48C          ; *
2033 cc1b 9e 41                        LDX  V41            ; GET ADDRESS OF START OF DESCRIPTOR
2034 cc1d 96 1f                        LDA  ARYEND         ; GET MSB OF END OF ARRAYS; LSB ALREADY THERE
2035 cc1f 93 41                        SUBD V41            ; SUBTRACT OUT ADDRESS OF START OF DESCRIPTOR
2036 cc21 ed 02                        STD  2,X            ; SAVE LENGTH OF (ARRAY AND DESCRIPTOR)
2037 cc23 96 05                        LDA  DIMFLG         ; * GET ARRAY FLAG AND BRANCH
2038 cc25 26 2d                        BNE  LB4CD          ; * BACK IF DIMENSIONING
2039                         * CALCULATE POINTER TO CORRECT ELEMENT
2040 cc27 e6 04              LB4A0     LDB  4,X            ; GET THE NUMBER OF DIMENSIONS
2041 cc29 d7 03                        STB  TMPLOC         ; TEMPORARILY SAVE
2042 cc2b 4f                           CLRA                ; * INITIALIZE POINTER
2043 cc2c 5f                           CLRB                ; * TO ZERO
2044 cc2d dd 64              LB4A6     STD  COEFPT         ; SAVE ACCUMULATED POINTER
2045 cc2f 35 06                        PULS A,B            ; * PULL DIMENSION ARGUMENT OFF THE
2046 cc31 dd 52                        STD  FPA0+2         ; * STACK AND SAVE IT
2047 cc33 10 a3 05                     CMPD 5,X            ; COMPARE TO STORED 'DIM' ARGUMENT
2048 cc36 24 3a                        BCC  LB4EB          ; 'BS' ERROR IF > = "DIM" ARGUMENT
2049 cc38 de 64                        LDU  COEFPT         ; * GET ACCUMULATED POINTER AND
2050 cc3a 27 04                        BEQ  LB4B9          ; * BRANCH IF 1ST DIMENSION
2051 cc3c 8d 17                        BSR  LB4CE          ; = MULTIPLY ACCUMULATED POINTER AND DIMENSION
2052 cc3e d3 52                        ADDD FPA0+2         ; = LENGTH AND ADD TO CURRENT ARGUMENT
2053 cc40 30 02              LB4B9     LEAX 2,X            ; MOVE POINTER TO NEXT DIMENSION
2054 cc42 0a 03                        DEC  TMPLOC         ; * DECREMENT DIMENSION COUNTER AND
2055 cc44 26 e7                        BNE  LB4A6          ; * BRANCH IF ANY DIMENSIONS LEFT
2056                         * MULTIPLY ACCD BY 5 - 5 BYTES/ARRAY VALUE
2057 cc46 ed e3                        STD  ,--S
2058 cc48 58                           ASLB
2059 cc49 49                           ROLA                ; TIMES 2
2060 cc4a 58                           ASLB
2061 cc4b 49                           ROLA                ; TIMES 4
2062 cc4c e3 e1                        ADDD ,S++           ; TIMES 5
2063 cc4e 30 8b                        LEAX D,X            ; ADD OFFSET TO START OF ARRAY
2064 cc50 30 05                        LEAX 5,X            ; ADJUST POINTER FOR SIZE OF DESCRIPTOR
2065 cc52 9f 39                        STX  VARPTR         ; SAVE POINTER TO ARRAY VALUE
2066 cc54 39                 LB4CD     RTS
2067                         * MULTIPLY 2 BYTE NUMBER IN 5,X BY THE 2 BYTE NUMBER
2068                         * IN COEFPT. RETURN RESULT IN ACCD, BS ERROR IF > $FFFF
2069 cc55 86 10              LB4CE     LDA  #16            ; 16 SHIFTS TO DO A MULTIPLY
2070 cc57 97 45                        STA  V45            ; SHIFT COUNTER
2071 cc59 ec 05                        LDD  5,X            ; * GET SIZE OF DIMENSION
2072 cc5b dd 17                        STD  BOTSTK         ; * AND SAVE IT
2073 cc5d 4f                           CLRA                ; * ZERO
2074 cc5e 5f                           CLRB                ; * ACCD
2075 cc5f 58                 LB4D8     ASLB                ; = SHIFT ACCB LEFT
2076 cc60 49                           ROLA                ; = ONE BIT
2077 cc61 25 0f                        BCS  LB4EB          ; 'BS' ERROR IF CARRY
2078 cc63 08 65                        ASL  COEFPT+1       ; * SHIFT MULTIPLICAND LEFT ONE
2079 cc65 09 64                        ROL  COEFPT         ; * BIT - ADD MULTIPLIER TO ACCUMULATOR
2080 cc67 24 04                        BCC  LB4E6          ; * IF CARRY <> 0
2081 cc69 d3 17                        ADDD BOTSTK         ; ADD MULTIPLIER TO ACCD
2082 cc6b 25 05                        BCS  LB4EB          ; 'BS' ERROR IF CARRY (>$FFFF)
2083 cc6d 0a 45              LB4E6     DEC  V45            ; * DECREMENT SHIFT COUNTER
2084 cc6f 26 ee                        BNE  LB4D8          ; * IF NOT DONE
2085 cc71 39                           RTS
2086 cc72 7e cb ce           LB4EB     JMP  LB447          ; 'BS' ERROR
2087                         *
2088                         * MEM
2089                         * THIS IS NOT A TRUE INDICATOR OF FREE MEMORY BECAUSE
2090                         * BASIC REQUIRES A STKBUF SIZE BUFFER FOR THE STACK
2091                         * FOR WHICH MEM DOES NOT ALLOW.
2092                         *
2093 cc75 1f 40              MEM       TFR  S,D            ; PUT STACK POINTER INTO ACCD
2094 cc77 93 1f                        SUBD ARYEND         ; SUBTRACT END OF ARRAYS
2095 cc79 21                           FCB  SKP1           ; SKIP ONE BYTE
2096                         *CONVERT THE VALUE IN ACCB INTO A FP NUMBER IN FPA0
2097 cc7a 4f                 LB4F3     CLRA                ; CLEAR MS BYTE OF ACCD
2098                         * CONVERT THE VALUE IN ACCD INTO A FLOATING POINT NUMBER IN FPA0
2099 cc7b 0f 06              GIVABF    CLR  VALTYP         ; SET VARIABLE TYPE TO NUMERIC
2100 cc7d dd 50                        STD  FPA0           ; SAVE ACCD IN TOP OF FACA
2101 cc7f c6 90                        LDB  #$90           ; EXPONENT REQUIRED IF THE TOP TWO BYTES
2102                         *         OF   FPA0 ARE TO BE TREATED AS AN INTEGER IN FPA0
2103 cc81 7e d3 ce                     JMP  LBC82          ; CONVERT THE REST OF FPA0 TO AN INTEGER
2104                         
2105                         * STR$
2106 cc84 bd c8 cf           STR       JSR  LB143          ; 'TM' ERROR IF STRING VARIABLE
2107 cc87 ce 01 f0                     LDU  #STRBUF+2      ; *CONVERT FP NUMBER TO ASCII STRING IN
2108 cc8a bd d5 28                     JSR  LBDDC          ; *THE STRING BUFFER
2109 cc8d 32 62                        LEAS 2,S            ; PURGE THE RETURN ADDRESS FROM THE STACK
2110 cc8f 8e 01 ef                     LDX  #STRBUF+1      ; *POINT X TO STRING BUFFER AND SAVE
2111 cc92 20 0b                        BRA  LB518          ; *THE STRING IN THE STRING SPACE
2112                         * RESERVE ACCB BYTES OF STRING SPACE. RETURN START
2113                         * ADDRESS IN (X) AND FRESPC
2114 cc94 9f 4d              LB50D     STX  V4D            ; SAVE X IN V4D
2115 cc96 8d 5c              LB50F     BSR  LB56D          ; RESERVE ACCB BYTES IN STRING SPACE
2116 cc98 9f 58              LB511     STX  STRDES+2       ; SAVE NEW STRING ADDRESS
2117 cc9a d7 56                        STB  STRDES         ; SAVE LENGTH OF RESERVED BLOCK
2118 cc9c 39                           RTS
2119 cc9d 30 1f              LB516     LEAX -1,X           ; MOVE POINTER BACK ONE
2120                         * SCAN A LINE FROM (X) UNTIL AN END OF LINE FLAG (ZERO) OR
2121                         * EITHER OF THE TWO TERMINATORS STORED IN CHARAC OR ENDCHR IS MATCHED.
2122                         * THE RESULTING STRING IS STORED IN THE STRING SPACE
2123                         * ONLY IF THE START OF THE STRING IS <= STRBUF+2
2124 cc9f 86 22              LB518     LDA  #'"            ; * INITIALIZE
2125 cca1 97 01                        STA  CHARAC         ; * TERMINATORS
2126 cca3 97 02              LB51A     STA  ENDCHR         ; * TO "
2127 cca5 30 01              LB51E     LEAX 1,X            ; MOVE POINTER UP ONE
2128 cca7 9f 62                        STX  RESSGN         ; TEMPORARILY SAVE START OF STRING
2129 cca9 9f 58                        STX  STRDES+2       ; SAVE START OF STRING IN TEMP DESCRIPTOR
2130 ccab c6 ff                        LDB  #-1            ; INITIALIZE CHARACTER COUNTER TO - 1
2131 ccad 5c                 LB526     INCB                ; INCREMENT CHARACTER COUNTER
2132 ccae a6 80                        LDA  ,X+            ; GET CHARACTER
2133 ccb0 27 0c                        BEQ  LB537          ; BRANCH IF END OF LINE
2134 ccb2 91 01                        CMPA CHARAC         ; * CHECK FOR TERMINATORS
2135 ccb4 27 04                        BEQ  LB533          ; * IN CHARAC AND ENDCHR
2136 ccb6 91 02                        CMPA ENDCHR         ; * DON'T MOVE POINTER BACK
2137 ccb8 26 f3                        BNE  LB526          ; * ONE IF TERMINATOR IS "MATCHED"
2138 ccba 81 22              LB533     CMPA #'"            ; = COMPARE CHARACTER TO STRING DELIMITER
2139 ccbc 27 02                        BEQ  LB539          ; = & DON'T MOVE POINTER BACK IF SO
2140 ccbe 30 1f              LB537     LEAX -1,X           ; MOVE POINTER BACK ONE
2141 ccc0 9f 64              LB539     STX  COEFPT         ; SAVE END OF STRING ADDRESS
2142 ccc2 d7 56                        STB  STRDES         ; SAVE STRING LENGTH IN TEMP DESCRIPTOR
2143 ccc4 de 62                        LDU  RESSGN         ; GET INITlAL STRING START
2144 ccc6 11 83 01 f0                  CMPU #STRBUF+2      ; COMPARE TO START OF STRING BUFFER
2145 ccca 22 07              LB543     BHI  LB54C          ; BRANCH IF > START OF STRING BUFFER
2146 cccc 8d c6                        BSR  LB50D          ; GO RESERVE SPACE FOR THE STRING
2147 ccce 9e 62                        LDX  RESSGN         ; POINT X TO THE BEGINNING OF THE STRING
2148 ccd0 bd cd cc                     JSR  LB645          ; MOVE (B) BYTES FROM (X) TO
2149                         *                             [FRESPC] - MOVE STRING DATA
2150                         * PUT DIRECT PAGE STRING DESCRIPTOR BUFFER DATA
2151                         * ON THE STRING STACK. SET VARIABLE TYPE TO STRING
2152 ccd3 9e 0b              LB54C     LDX  TEMPPT         ; GET NEXT AVAILABLE STRING STACK DESCRIPTOR
2153 ccd5 8c 00 f1                     CMPX #LINHDR        ; COMPARE TO TOP OF STRING DESCRIPTOR STACK - WAS #CFNBUF
2154 ccd8 26 05                        BNE  LB558          ; FORMULA O.K.
2155 ccda c6 1e                        LDB  #15*2          ; STRING FORMULA TOO COMPLEX' ERROR
2156 ccdc 7e c4 06           LB555     JMP  LAC46          ; JUMP TO ERROR SERVICING ROUTINE
2157 ccdf 96 56              LB558     LDA  STRDES         ; * GET LENGTH OF STRING AND SAVE IT
2158                         *         STA  ,X             ; * IN BYTE 0 OF DESCRIPTOR
2159 cce1 a7 00                        FCB  $A7,$00
2160 cce3 dc 58                        LDD  STRDES+2       ; = GET START ADDRESS OF ACTUAL STRING
2161 cce5 ed 02                        STD  2,X            ; = AND SAVE IN BYTES 2,3 OF DESCRIPTOR
2162 cce7 86 ff                        LDA  #$FF           ; * VARIABLE TYPE = STRING
2163 cce9 97 06                        STA  VALTYP         ; * SAVE IN VARIABLE TYPE FLAG
2164 cceb 9f 0d                        STX  LASTPT         ; = SAVE START OF DESCRIPTOR
2165 cced 9f 52                        STX  FPA0+2         ; = ADDRESS IN LASTPT AND FPA0
2166 ccef 30 05                        LEAX 5,X            ; 5 BYTES/STRING DESCRIPTOR
2167 ccf1 9f 0b                        STX  TEMPPT         ; NEXT AVAILABLE STRING VARIABLE DESCRIPTOR
2168 ccf3 39                           RTS
2169                         * RESERVE ACCB BYTES IN STRING STORAGE SPACE
2170                         * RETURN WITH THE STARTING ADDRESS OF THE
2171                         * RESERVED STRING SPACE IN (X) AND FRESPC
2172 ccf4 0f 07              LB56D     CLR  GARBFL         ; CLEAR STRING REORGANIZATION FLAG
2173 ccf6 4f                 LB56F     CLRA                ; * PUSH THE LENGTH OF THE
2174 ccf7 34 06                        PSHS B,A            ; * STRING ONTO THE STACK
2175 ccf9 dc 23                        LDD  STRTAB         ; GET START OF STRING VARIABLES
2176 ccfb a3 e0                        SUBD ,S+            ; SUBTRACT STRING LENGTH
2177 ccfd 10 93 21                     CMPD FRETOP         ; COMPARE TO START OF STRING STORAGE
2178 cd00 25 0a                        BCS  LB585          ; IF BELOW START, THEN REORGANIZE
2179 cd02 dd 23                        STD  STRTAB         ; SAVE NEW START OF STRING VARIABLES
2180 cd04 9e 23                        LDX  STRTAB         ; GET START OF STRING VARIABLES
2181 cd06 30 01                        LEAX 1,X            ; ADD ONE
2182 cd08 9f 25                        STX  FRESPC         ; SAVE START ADDRESS OF NEWLY RESERVED SPACE
2183 cd0a 35 84                        PULS B,PC           ; RESTORE NUMBER OF BYTES RESERVED AND RETURN
2184 cd0c c6 1a              LB585     LDB  #2*13          ; OUT OF STRING SPACE' ERROR
2185 cd0e 03 07                        COM  GARBFL         ; TOGGLE REORGANIZATiON FLAG
2186 cd10 27 ca                        BEQ  LB555          ; ERROR IF FRESHLY REORGANIZED
2187 cd12 8d 04                        BSR  LB591          ; GO REORGANIZE STRING SPACE
2188 cd14 35 04                        PULS B              ; GET BACK THE NUMBER OF BYTES TO RESERVE
2189 cd16 20 de                        BRA  LB56F          ; TRY TO RESERVE ACCB BYTES AGAIN
2190                         * REORGANIZE THE STRING SPACE
2191 cd18 9e 27              LB591     LDX  MEMSIZ         ; GET THE TOP OF STRING SPACE
2192 cd1a 9f 23              LB593     STX  STRTAB         ; SAVE TOP OF UNORGANIZED STRING SPACE
2193 cd1c 4f                           CLRA                ; * ZERO OUT ACCD
2194 cd1d 5f                           CLRB                ; * AND RESET VARIABLE
2195 cd1e dd 4b                        STD  V4B            ; * POINTER TO 0
2196 cd20 9e 21                        LDX  FRETOP         ; POINT X TO START OF STRING SPACE
2197 cd22 9f 47                        STX  V47            ; SAVE POINTER IN V47
2198 cd24 8e 00 c9                     LDX  #STRSTK        ; POINT X TO START OF STRING DESCRIPTOR STACK
2199 cd27 9c 0b              LB5A0     CMPX TEMPPT         ; COMPARE TO ADDRESS OF NEXT AVAILABLE DESCRIPTOR
2200 cd29 27 04                        BEQ  LB5A8          ; BRANCH IF TOP OF STRING STACK
2201 cd2b 8d 32                        BSR  LB5D8          ; CHECK FOR STRING IN UNORGANIZED STRING SPACE
2202 cd2d 20 f8                        BRA  LB5A0          ; KEEP CHECKING
2203 cd2f 9e 1b              LB5A8     LDX  VARTAB         ; GET THE END OF BASIC PROGRAM
2204 cd31 9c 1d              LB5AA     CMPX ARYTAB         ; COMPARE TO END OF VARIABLES
2205 cd33 27 04                        BEQ  LB5B2          ; BRANCH IF AT TOP OF VARIABLES
2206 cd35 8d 22                        BSR  LB5D2          ; CHECK FOR STRING IN UNORGANIZED STRING SPACE
2207 cd37 20 f8                        BRA  LB5AA          ; KEEP CHECKING VARIABLES
2208 cd39 9f 41              LB5B2     STX  V41            ; SAVE ADDRESS OF THE END OF VARIABLES
2209 cd3b 9e 41              LB5B4     LDX  V41            ; GET CURRENT ARRAY POINTER
2210 cd3d 9c 1f              LB5B6     CMPX ARYEND         ; COMPARE TO THE END OF ARRAYS
2211 cd3f 27 35                        BEQ  LB5EF          ; BRANCH IF AT END OF ARRAYS
2212 cd41 ec 02                        LDD  2,X            ; GET LENGTH OF ARRAY AND DESCRIPTOR
2213 cd43 d3 41                        ADDD V41            ; * ADD TO CURRENT ARRAY POINTER
2214 cd45 dd 41                        STD  V41            ; * AND SAVE IT
2215 cd47 a6 01                        LDA  1,X            ; GET 1ST CHARACTER OF VARIABLE NAME
2216 cd49 2a f0                        BPL  LB5B4          ; BRANCH IF NUMERIC ARRAY
2217 cd4b e6 04                        LDB  4,X            ; GET THE NUMBER OF DIMENSIONS IN THIS ARRAY
2218 cd4d 58                           ASLB                ; MULTIPLY BY 2
2219 cd4e cb 05                        ADDB #5             ; ADD FIVE BYTES (VARIABLE NAME, ARRAY
2220                         *                             ; LENGTH, NUMBER DIMENSIONS)
2221 cd50 3a                           ABX                 ; X NOW POINTS TO START OF ARRAY ELEMENTS
2222 cd51 9c 41              LB5CA     CMPX V41            ; AT END OF THIS ARRAY?
2223 cd53 27 e8                        BEQ  LB5B6          ; YES - CHECK FOR ANOTHER
2224 cd55 8d 08                        BSR  LB5D8          ; CHECK FOR STRING LOCATED IN
2225                         *                             ; UNORGANIZED STRING SPACE
2226 cd57 20 f8                        BRA  LB5CA          ; KEEP CHECKING ELEMENTS IN THIS ARRAY
2227 cd59 a6 01              LB5D2     LDA  1,X            ; GET F1RST BYTE OF VARIABLE NAME
2228 cd5b 30 02                        LEAX 2,X            ; MOVE POINTER TO DESCRIPTOR
2229 cd5d 2a 14                        BPL  LB5EC          ; BRANCH IF VARIABLE IS NUMERIC
2230                         * SEARCH FOR STRING - ENTER WITH X POINTING TO
2231                         * THE STRING DESCRIPTOR. IF STRING IS STORED
2232                         * BETWEEN V47 AND STRTAB, SAVE DESCRIPTOR POINTER
2233                         * IN V4B AND RESET V47 TO STRING ADDRESS
2234 cd5f e6 84              LB5D8     LDB  ,X             ; GET THE LENGTH OF THE STRING
2235 cd61 27 10                        BEQ  LB5EC          ; BRANCH IF NULL - NO STRING
2236 cd63 ec 02                        LDD  2,X            ; GET STARTING ADDRESS OF THE STRING
2237 cd65 10 93 23                     CMPD STRTAB         ; COMPARE TO THE START OF STRING VARIABLES
2238 cd68 22 09                        BHI  LB5EC          ; BRANCH IF THIS STRING IS STORED IN
2239                         *              ; THE STRING VARIABLES
2240 cd6a 10 93 47                     CMPD V47            ; COMPARE TO START OF STRING SPACE
2241 cd6d 23 04                        BLS  LB5EC          ; BRANCH IF NOT STORED IN THE STRING SPACE
2242 cd6f 9f 4b                        STX  V4B            ; SAVE VARIABLE POINTER IF STORED IN STRING SPACE
2243 cd71 dd 47                        STD  V47            ; SAVE STRING STARTING ADDRESS
2244 cd73 30 05              LB5EC     LEAX 5,X            ; MOVE TO NEXT VARIABLE DESCRIPTOR
2245 cd75 39                 LB5EE     RTS
2246 cd76 9e 4b              LB5EF     LDX  V4B            ; GET ADDRESS OF THE DESCRIPTOR FOR THE
2247                         *              ; STRING WHICH IS STORED IN THE HIGHEST RAM ADDRESS IN
2248                         *              ; THE UNORGANIZED STRING SPACE
2249 cd78 27 fb                        BEQ  LB5EE          ; BRANCH IF NONE FOUND AND REORGANIZATION DONE
2250 cd7a 4f                           CLRA                ; CLEAR MS BYTE OF LENGTH
2251 cd7b e6 84                        LDB  ,X             ; GET LENGTH OF STRING
2252 cd7d 5a                           DECB                ; SUBTRACT ONE
2253 cd7e d3 47                        ADDD V47            ; ADD LENGTH OF STRING TO ITS STARTING ADDRESS
2254 cd80 dd 43                        STD  V43            ; SAVE AS MOVE STARTING ADDRESS
2255 cd82 9e 23                        LDX  STRTAB         ; POINT X TO THE START OF ORGANIZED STRING VARIABLES
2256 cd84 9f 41                        STX  V41            ; SAVE AS MOVE ENDING ADDRESS
2257 cd86 bd c3 e0                     JSR  LAC20          ; MOVE STRING FROM CURRENT POSITION TO THE
2258                         *              ; TOP OF UNORGANIZED STRING SPACE
2259 cd89 9e 4b                        LDX  V4B            ; POINT X TO STRING DESCRIPTOR
2260 cd8b dc 45                        LDD  V45            ; * GET NEW STARTING ADDRESS OF STRING AND
2261 cd8d ed 02                        STD  2,X            ; * SAVE IT IN DESCRIPTOR
2262 cd8f 9e 45                        LDX  V45            ; GET NEW TOP OF UNORGANIZED STRING SPACE
2263 cd91 30 1f                        LEAX -1,X           ; MOVE POINTER BACK ONE
2264 cd93 7e cd 1a                     JMP  LB593          ; JUMP BACK AND REORGANIZE SOME MORE
2265                         
2266                         
2267 cd96 dc 52              LB60F     LDD  FPA0+2         ; * GET DESCRIPTOR ADDRESS OF STRING A
2268 cd98 34 06                        PSHS B,A            ; * AND SAVE IT ON THE STACK
2269 cd9a bd c9 af                     JSR  LB223          ; GET DESCRIPTOR ADDRESS OF STRING B
2270 cd9d bd c8 d2                     JSR  LB146          ; 'TM' ERROR IF NUMERIC VARIABLE
2271 cda0 35 10                        PULS X              ; * POINT X TO STRING A DESCRIPTOR
2272 cda2 9f 62                        STX  RESSGN         ; * ADDRESS AND SAVE IT IN RESSGN
2273 cda4 e6 84                        LDB  ,X             ; GET LENGTH OF STRING A
2274 cda6 9e 52                        LDX  FPA0+2         ; POINT X TO DESCRIPTOR OF STRING B
2275 cda8 eb 84                        ADDB ,X             ; ADD LENGTH OF STRING B TO STR1NG A
2276 cdaa 24 05                        BCC  LB62A          ; BRANCH IF LENGTH < 256
2277 cdac c6 1c                        LDB  #2*14          ; 'STRING TOO LONG' ERROR IF LENGTH > 255
2278 cdae 7e c4 06                     JMP  LAC46          ; JUMP TO ERROR SERVICING ROUTINE
2279 cdb1 bd cc 94           LB62A     JSR  LB50D          ; RESERVE ROOM IN STRING SPACE FOR NEW STRING
2280 cdb4 9e 62                        LDX  RESSGN         ; GET DESCRIPTOR ADDRESS OF STRING A
2281 cdb6 e6 84                        LDB  ,X             ; GET LENGTH OF STRING A
2282 cdb8 8d 10                        BSR  LB643          ; MOVE STRING A INTO RESERVED BUFFER IN STRING SPACE
2283 cdba 9e 4d                        LDX  V4D            ; GET DESCRIPTOR ADDRESS OF STRING B
2284 cdbc 8d 22                        BSR  LB659          ; GET LENGTH AND ADDRESS OF STRING B
2285 cdbe 8d 0c                        BSR  LB645          ; MOVE STRING B INTO REST OF RESERVED BUFFER
2286 cdc0 9e 62                        LDX  RESSGN         ; POINT X TO DESCRIPTOR OF STRING A
2287 cdc2 8d 1c                        BSR  LB659          ; DELETE STRING A IF LAST STRING ON STRING STACK
2288 cdc4 bd cc d3                     JSR  LB54C          ; PUT STRING DESCRIPTOR ON THE STRING STACK
2289 cdc7 7e c8 f4                     JMP  LB168          ; BRANCH BACK TO EXPRESSION EVALUATION
2290                         
2291                         * MOVE (B) BYTES FROM 2,X TO FRESPC
2292 cdca ae 02              LB643     LDX  2,X            ; POINT X TO SOURCE ADDRESS
2293 cdcc de 25              LB645     LDU  FRESPC         ; POINT U TO DESTINATION ADDRESS
2294 cdce 5c                           INCB                ; COMPENSATION FOR THE DECB BELOW
2295 cdcf 20 04                        BRA  LB64E          ; GO MOVE THE BYTES
2296                         * MOVE B BYTES FROM (X) TO (U)
2297 cdd1 a6 80              LB64A     LDA  ,X+            ; * GET A SOURCE BYTE AND MOVE IT
2298 cdd3 a7 c0                        STA  ,U+            ; * TO THE DESTINATION
2299 cdd5 5a                 LB64E     DECB                ; DECREMENT BYTE COUNTER
2300 cdd6 26 f9                        BNE  LB64A          ; BRANCH IF ALL BYTES NOT MOVED
2301 cdd8 df 25                        STU  FRESPC         ; SAVE ENDING ADDRESS IN FRESPC
2302 cdda 39                           RTS
2303                         * RETURN LENGTH (ACCB) AND ADDRESS (X) OF
2304                         * STRING WHOSE DESCRIPTOR IS IN FPA0+2
2305                         * DELETE THE STRING IF IT IS THE LAST ONE
2306                         * PUT ON THE STRING STACK. REMOVE STRING FROM STRING
2307                         * SPACE IF IT IS AT THE BOTTOM OF STRING VARIABLES.
2308 cddb bd c8 d2           LB654     JSR  LB146          ; 'TM' ERROR IF VARIABLE TYPE = NUMERIC
2309 cdde 9e 52              LB657     LDX  FPA0+2         ; GET ADDRESS OF SELECTED STRING DESCRIPTOR
2310 cde0 e6 84              LB659     LDB  ,X             ; GET LENGTH OF STRING
2311 cde2 8d 18                        BSR  LB675          ; * CHECK TO SEE IF THIS STRING DESCRIPTOR WAS
2312 cde4 26 13                        BNE  LB672          ; * THE LAST ONE PUT ON THE STRING STACK AND
2313                         *                             ; * BRANCH IF NOT
2314 cde6 ae 07                        LDX  5+2,X          ; GET START ADDRESS OF STRING JUST REMOVED
2315 cde8 30 1f                        LEAX -1,X           ; MOVE POINTER DOWN ONE
2316 cdea 9c 23                        CMPX STRTAB         ; COMPARE TO START OF STRING VARIABLES
2317 cdec 26 08                        BNE  LB66F          ; BRANCH IF THIS STRING IS NOT AT THE BOTTOM
2318                         *                             ; OF STRING VARIABLES
2319 cdee 34 04                        PSHS B              ; SAVE LENGTH; ACCA WAS CLEARED
2320 cdf0 d3 23                        ADDD STRTAB         ; * ADD THE LENGTH OF THE JUST REMOVED STRING
2321 cdf2 dd 23                        STD  STRTAB         ; * TO THE START OF STRING VARIABLES - THIS WILL
2322                         *                             ; * REMOVE THE STRING FROM THE STRING SPACE
2323 cdf4 35 04                        PULS B              ; RESTORE LENGTH
2324 cdf6 30 01              LB66F     LEAX 1,X            ; ADD ONE TO POINTER
2325 cdf8 39                           RTS
2326 cdf9 ae 02              LB672     LDX  2,X            ; *POINT X TO ADDRESS OF STRING NOT
2327 cdfb 39                           RTS                 ; *ON THE STRING STACK
2328                         * REMOVE STRING FROM STRING STACK. ENTER WITH X
2329                         * POINTING TO A STRING DESCRIPTOR - DELETE THE
2330                         * STRING FROM STACK IF IT IS ON TOP OF THE
2331                         * STACK. IF THE STRING IS DELETED, SET THE ZERO FLAG
2332 cdfc 9c 0d              LB675     CMPX LASTPT         ; *COMPARE TO LAST USED DESCRIPTOR ADDRESS
2333 cdfe 26 07                        BNE  LB680          ; *ON THE STRING STACK, RETURN IF DESCRIPTOR
2334                         *                             ; *ADDRESS NOT ON THE STRING STACK
2335 ce00 9f 0b                        STX  TEMPPT         ; SAVE LAST USED DESCRIPTOR AS NEXT AVAILABLE
2336 ce02 30 1b                        LEAX -5,X           ; * MOVE LAST USED DESCRIPTOR BACK 5 BYTES
2337 ce04 9f 0d                        STX  LASTPT         ; * AND SAVE AS THE LAST USED DESCRIPTOR ADDR
2338 ce06 4f                           CLRA                ; SET ZERO FLAG
2339 ce07 39                 LB680     RTS
2340                         
2341                         * LEN
2342 ce08 8d 03              LEN       BSR  LB686          ; POINT X TO PROPER STRING AND GET LENGTH
2343 ce0a 7e cc 7a           LB683     JMP  LB4F3          ; CONVERT ACCB TO FP NUMBER IN FPA0
2344                         * POINT X TO STRING ADDRESS LOAD LENGTH INTO
2345                         * ACCB. ENTER WITH THE STRING DESCRIPTOR IN
2346                         * BOTTOM TWO BYTES OF FPA0
2347 ce0d 8d cc              LB686     BSR  LB654          ; GET LENGTH AND ADDRESS OF STRING
2348 ce0f 0f 06                        CLR  VALTYP         ; SET VARIABLE TYPE TO NUMERIC
2349 ce11 5d                           TSTB                ; SET FLAGS ACCORDING TO LENGTH
2350 ce12 39                           RTS
2351                         
2352                         * CHR$
2353 ce13 bd ce 95           CHR       JSR  LB70E          ; CONVERT FPA0 TO AN INTEGER IN ACCD
2354 ce16 c6 01              LB68F     LDB  #1             ; * RESERVE ONE BYTE IN
2355 ce18 bd cc f4                     JSR  LB56D          ; * THE STRING SPACE
2356 ce1b 96 53                        LDA  FPA0+3         ; GET ASCII STRING VALUE
2357 ce1d bd cc 98                     JSR  LB511          ; SAVE RESERVED STRING DESCRIPTOR IN TEMP DESCRIPTOR
2358 ce20 a7 84                        STA  ,X             ; SAVE THE STRING (IT'S ONLY ONE BYTE)
2359 ce22 32 62              LB69B     LEAS 2,S            ; PURGE THE RETURN ADDRESS OFF OF THE STACK
2360 ce24 7e cc d3           LB69D     JMP  LB54C          ; PUT TEMP DESCRIPTOR DATA ONTO STRING STACK
2361                         
2362                         
2363 ce27 8d 02              ASC       BSR  LB6A4          ; PUT 1ST CHARACTER OF STRING INTO ACCB
2364 ce29 20 df                        BRA  LB683          ; CONVERT ACCB INTO FP NUMBER IN FPA0
2365 ce2b 8d e0              LB6A4     BSR  LB686          ; POINT X TO STRING DESCRIPTOR
2366 ce2d 27 5e                        BEQ  LB706          ; 'FC' ERROR IF NULL STRING
2367 ce2f e6 84                        LDB  ,X             ; GET FIRST BYTE OF STRING
2368 ce31 39                           RTS
2369                         
2370                         
2371 ce32 8d 48              LEFT      BSR  LB6F5          ; GET ARGUMENTS FROM STACK
2372 ce34 4f                 LB6AD     CLRA                ; CLEAR STRING POINTER OFFSET - OFFSET = 0 FOR LEFT$
2373 ce35 e1 84              LB6AE     CMPB ,X             ; * COMPARE LENGTH PARAMETER TO LENGTH OF
2374 ce37 23 03                        BLS  LB6B5          ; * STRING AND BRANCH IF LENGTH OF STRING
2375                         *                             ; >= LENGTH PARAMETER
2376 ce39 e6 84                        LDB  ,X             ; USE LENGTH OF STRING OTHERWISE
2377 ce3b 4f                           CLRA                ; CLEAR STRING POINTER OFFSET (0 FOR LEFT$)
2378 ce3c 34 06              LB6B5     PSHS B,A            ; PUSH PARAMETERS ONTO STACK
2379 ce3e bd cc 96                     JSR  LB50F          ; RESERVE ACCB BYTES IN THE STRING SPACE
2380 ce41 9e 4d                        LDX  V4D            ; POINT X TO STRING DESCRIPTOR
2381 ce43 8d 9b                        BSR  LB659          ; GET ADDRESS OF OLD STRING (X=ADDRESS)
2382 ce45 35 04                        PULS B              ; * PULL STRING POINTER OFFSET OFF OF THE STACK
2383 ce47 3a                           ABX                 ; * AND ADD IT TO STRING ADDRESS
2384 ce48 35 04                        PULS B              ; PULL LENGTH PARAMETER OFF OF THE STACK
2385 ce4a bd cd cc                     JSR  LB645          ; MOVE ACCB BYTES FROM (X) TO [FRESPC]
2386 ce4d 20 d5                        BRA  LB69D          ; PUT TEMP STRING DESCRIPTOR ONTO THE STRING STACK
2387                         
2388                         * RIGHT$
2389 ce4f 8d 2b              RIGHT     BSR  LB6F5          ; GET ARGUMENTS FROM STACK
2390 ce51 a0 84                        SUBA ,X             ; ACCA=LENGTH PARAMETER - LENGTH OF OLD STRING
2391 ce53 40                           NEGA                ; NOW ACCA = LENGTH OF OLD STRING
2392 ce54 20 df                        BRA  LB6AE          ; PUT NEW STRING IN THE STRING SPACE
2393                         
2394                         * MID$
2395 ce56 c6 ff              MID       LDB  #$FF           ; * GET DEFAULT VALUE OF LENGTH AND
2396 ce58 d7 53                        STB  FPA0+3         ; * SAVE IT IN FPA0
2397 ce5a 9d 82                        JSR  GETCCH         ; GET CURRENT CHARACTER FROM BASIC
2398 ce5c 81 29                        CMPA #')            ; ARGUMENT DELIMITER?
2399 ce5e 27 05                        BEQ  LB6DE          ; YES - NO LENGTH PARAMETER GIVEN
2400 ce60 bd c9 f9                     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
2401 ce63 8d 2d                        BSR  LB70B          ; EVALUATE NUMERIC EXPRESSION (LENGTH)
2402 ce65 8d 15              LB6DE     BSR  LB6F5          ; GET ARGUMENTS FROM STACK
2403 ce67 27 24                        BEQ  LB706          ; 'FC' ERROR IF NULL STRING
2404 ce69 5f                           CLRB                ; CLEAR LENGTH COUNTER (DEFAULT VALUE)
2405 ce6a 4a                           DECA                ; *SUOTRACT ONE FROM POSITION PARAMETER (THESE
2406 ce6b a1 84                        CMPA ,X             ; *ROUTINES EXPECT 1ST POSITION TO BE ZERO, NOT ONE)
2407                         *                             ; *AND COMPARE IT TO LENGTH OF OLD STRING
2408 ce6d 24 cd                        BCC  LB6B5          ; IF POSITION > LENGTH OF OLD STRING, THEN NEW
2409                         *                             ; STRING WILL BE A NULL STRING
2410 ce6f 1f 89                        TFR  A,B            ; SAVE ABSOLUTE POSITION PARAMETER IN ACCB
2411 ce71 e0 84                        SUBB ,X             ; ACCB=POSITION-LENGTH OF OLD STRING
2412 ce73 50                           NEGB                ; NOW ACCB=LENGTH OF OLDSTRING-POSITION
2413 ce74 d1 53                        CMPB FPA0+3         ; *IF THE AMOUNT OF OLD STRING TO THE RIGHT OF
2414 ce76 23 c4                        BLS  LB6B5          ; *POSITION IS <= THE LENGTH PARAMETER, BRANCH AND
2415                         * USE ALL OF THE STRING TO THE RIGHT OF THE POSITION
2416                         * INSTEAD OF THE LENGTH PARAMETER
2417 ce78 d6 53                        LDB  FPA0+3         ; GET LENGTH OF NEW STRING
2418 ce7a 20 c0                        BRA  LB6B5          ; PUT NEW STRING IN STRING SPACE
2419                         * DO A SYNTAX CHECK FOR ")", THEN PULL THE PREVIOUSLY CALCULATED NUMERIC
2420                         * ARGUMENT (ACCD) AND STRING ARGUMENT DESCRIPTOR ADDR OFF OF THE STACK
2421 ce7c bd c9 f3           LB6F5     JSR  LB267          ; SYNTAX CHECK FOR A ")"
2422 ce7f ee e4                        LDU  ,S             ; LOAD THE RETURN ADDRESS INTO U REGISTER
2423 ce81 ae 65                        LDX  5,S            ; * GET ADDRESS OF STRING AND
2424 ce83 9f 4d                        STX  V4D            ; * SAVE IT IN V4D
2425 ce85 a6 64                        LDA  4,S            ; = PUT LENGTH OF STRING IN
2426 ce87 e6 64                        LDB  4,S            ; = BOTH ACCA AND ACCB
2427 ce89 32 67                        LEAS 7,S            ; REMOVE DESCRIPTOR AND RETURN ADDRESS FROM STACK
2428 ce8b 1f 35                        TFR  U,PC           ; JUMP TO ADDRESS IN U REGISTER
2429 ce8d 7e cb d1           LB706     JMP  LB44A          ; 'ILLEGAL FUNCTION CALL'
2430                         * EVALUATE AN EXPRESSION - RETURN AN INTEGER IN
2431                         * ACCB - 'FC' ERROR IF EXPRESSION > 255
2432 ce90 9d 7c              LB709     JSR  GETNCH         ; GET NEXT BASIC INPUT CHARACTER
2433 ce92 bd c8 cd           LB70B     JSR  LB141          ; EVALUATE A NUMERIC EXPRESSION
2434 ce95 bd cb 70           LB70E     JSR  LB3E9          ; CONVERT FPA0 TO INTEGER IN ACCD
2435 ce98 4d                           TSTA                ; TEST MS BYTE OF INTEGER
2436 ce99 26 f2                        BNE  LB706          ; 'FC' ERROR IF EXPRESSION > 255
2437 ce9b 0e 82                        JMP  GETCCH         ; GET CURRENT INPUT CHARACTER FROM BASIC
2438                         
2439                         * VAL
2440 ce9d bd ce 0d           VAL       JSR  LB686          ; POINT X TO STRING ADDRESS
2441 cea0 10 27 02 e1                  LBEQ LBA39          ; IF NULL STRING SET FPA0
2442 cea4 de 83                        LDU  CHARAD         ; SAVE INPUT POINTER IN REGISTER U
2443 cea6 9f 83                        STX  CHARAD         ; POINT INPUT POINTER TO ADDRESS OF STRING
2444 cea8 3a                           ABX                 ; MOVE POINTER TO END OF STRING TERMINATOR
2445 cea9 a6 84                        LDA  ,X             ; GET LAST BYTE OF STRING
2446 ceab 34 52                        PSHS U,X,A          ; SAVE INPUT POINTER, STRING TERMINATOR
2447                         *         ADDRESS AND CHARACTER
2448 cead 6f 84                        CLR  ,X             ; CLEAR STRING TERMINATOR : FOR ASCII - FP CONVERSION
2449 ceaf 9d 82                        JSR  GETCCH         ; GET CURRENT CHARACTER FROM BASIC
2450 ceb1 bd d4 5e                     JSR  LBD12          ; CONVERT AN ASCII STRING TO FLOATING POINT
2451 ceb4 35 52                        PULS A,X,U          ; RESTORE CHARACTERS AND POINTERS
2452 ceb6 a7 84                        STA  ,X             ; REPLACE STRING TERMINATOR
2453 ceb8 df 83                        STU  CHARAD         ; RESTORE INPUT CHARACTER
2454 ceba 39                           RTS
2455                         
2456 cebb 8d 07              LB734     BSR  LB73D          ; * EVALUATE AN EXPRESSION, RETURN
2457 cebd 9f 2b                        STX  BINVAL         ; * THE VALUE IN X; STORE IT IN BINVAL
2458 cebf bd c9 f9           LB738     JSR  LB26D          ; SYNTAX CHECK FOR A COMMA
2459 cec2 20 ce                        BRA  LB70B          ; EVALUATE EXPRESSION IN RANGE 0 <= X < 256
2460                         * EVALUATE EXPRESSION : RETURN INTEGER PORTION IN X - 'FC' ERROR IF
2461                         
2462 cec4 bd c8 cd           LB73D     JSR  LB141          ; EVALUATE NUMERIC EXPRESSION
2463 cec7 96 54              LB740     LDA  FP0SGN         ; GET SIGN OF FPA0 MANTISSA
2464 cec9 2b c2                        BMI  LB706          ; ILLEGAL FUNCTION CALL' IF NEGATIVE
2465 cecb 96 4f                        LDA  FP0EXP         ; GET EXPONENT OF FPA0
2466 cecd 81 90                        CMPA #$90           ; COMPARE TO LARGEST POSITIVE INTEGER
2467 cecf 22 bc                        BHI  LB706          ; ILLEGAL FUNCTION CALL' IF TOO LARGE
2468 ced1 bd d4 14                     JSR  LBCC8          ; SHIFT BINARY POINT TO EXTREME RIGHT OF FPA0
2469 ced4 9e 52                        LDX  FPA0+2         ; LOAD X WITH LOWER TWO BYTES OF FPA0
2470 ced6 39                           RTS
2471                         
2472                         * PEEK
2473 ced7 8d ee              PEEK      BSR  LB740          ; CONVERT FPA0 TO INTEGER IN REGISTER X
2474 ced9 e6 84                        LDB  ,X             ; GET THE VALUE BEING 'PEEK'ED
2475 cedb 7e cc 7a                     JMP  LB4F3          ; CONVERT ACCB INTO A FP NUMBER
2476                         
2477                         * POKE
2478 cede 8d db              POKE      BSR  LB734          ; EVALUATE 2 EXPRESSIONS
2479 cee0 9e 2b                        LDX  BINVAL         ; GET THE ADDRESS TO BE 'POKE'ED
2480 cee2 e7 84                        STB  ,X             ; STORE THE DATA IN THAT ADDRESS
2481 cee4 39                           RTS
2482                         
2483                         
2484                         * LIST
2485 cee5 34 01              LIST      PSHS CC             ; SAVE ZERO FLAG ON STACK
2486 cee7 bd c7 17                     JSR  LAF67          ; CONVERT DECIMAL LINE NUMBER TO BINARY
2487 ceea bd c4 a5                     JSR  LAD01          ; * FIND RAM ADDRESS OF THAT LINE NUMBER AND
2488 ceed 9f 66                        STX  LSTTXT         ; * SAVE IT IN LSTTXT
2489 ceef 35 01                        PULS CC             ; GET ZERO FLAG FROM STACK
2490 cef1 27 12                        BEQ  LB784          ; BRANCH IF END OF LINE
2491 cef3 9d 82                        JSR  GETCCH         ; GET CURRENT CHARACTER FROM BASIC
2492 cef5 27 13                        BEQ  LB789          ; BRANCH IF END OF LINE
2493 cef7 81 a7                        CMPA #TOK_MINUS     ; MINUS TOKEN (IS IT A RANGE OF LINE NUMBERS?)
2494 cef9 26 09                        BNE  LB783          ; NO - RETURN
2495 cefb 9d 7c                        JSR  GETNCH         ; GET NEXT CHARACTER FROM BASIC
2496 cefd 27 06                        BEQ  LB784          ; BRANCH IF END OF LINE
2497 ceff bd c7 17                     JSR  LAF67          ; GET ENDING LINE NUMBER
2498 cf02 27 06                        BEQ  LB789          ; BRANCH IF LEGAL LINE NUMBER
2499 cf04 39                 LB783 RTS
2500                         * LIST THE ENTIRE PROGRAM
2501 cf05 ce ff ff           LB784     LDU  #$FFFF         ; * SET THE DEFAULT ENDING LINE NUMBER
2502 cf08 df 2b                        STU  BINVAL         ; * TO $FFFF
2503 cf0a 32 62              LB789     LEAS 2,S            ; PURGE RETURN ADDRESS FROM THE STACK
2504 cf0c 9e 66                        LDX  LSTTXT         ; POINT X TO STARTING LINE ADDRESS
2505 cf0e bd d0 ac           LB78D     JSR  LB95C          ; MOVE CURSOR TO START OF A NEW LINE
2506 cf11 bd c1 9a                     JSR  LA549          ; CHECK FOR A BREAK OR PAUSE
2507 cf14 ec 84                        LDD  ,X             ; GET ADDRESS OF NEXT BASIC LINE
2508 cf16 26 03                        BNE  LB79F          ; BRANCH IF NOT END OF PROGRAM
2509                         LB797
2510 cf18 7e c4 25                     JMP  LAC73          ; RETURN TO BASIC'S MAIN INPUT LOOP
2511 cf1b 9f 66              LB79F     STX  LSTTXT         ; SAVE NEW STARTING LINE ADDRESS
2512 cf1d ec 02                        LDD  2,X            ; * GET THE LINE NUMBER OF THIS LINE AND
2513 cf1f 10 93 2b                     CMPD BINVAL         ; * COMPARE IT TO ENDING LINE NUMBER
2514 cf22 22 f4                        BHI  LB797          ; EXIT IF LINE NUMBER > ENDING LINE NUMBER
2515 cf24 bd d5 18                     JSR  LBDCC          ; PRINT THE NUMBER IN ACCD ON SCREEN IN DECIMAL
2516 cf27 bd d0 f8                     JSR  LB9AC          ; SEND A SPACE TO CONSOLE OUT
2517 cf2a 9e 66                        LDX  LSTTXT         ; GET RAM ADDRESS OF THIS LINE
2518 cf2c 8d 10                        BSR  LB7C2          ; UNCRUNCH A LINE
2519 cf2e ae 9f 00 66                  LDX  [LSTTXT]       ; POINT X TO START OF NEXT LINE
2520 cf32 ce 00 f4                     LDU  #LINBUF+1      ; POINT U TO BUFFER FULL OF UNCRUNCHED LINE
2521 cf35 a6 c0              LB7B9     LDA  ,U+            ; GET A BYTE FROM THE BUFFER
2522 cf37 27 d5                        BEQ  LB78D          ; BRANCH IF END OF BUFFER
2523 cf39 bd d0 fd                     JSR  LB9B1          ; SEND CHARACTER TO CONSOLE OUT
2524 cf3c 20 f7                        BRA  LB7B9          ; GET ANOTHER CHARACTER
2525                         
2526                         * UNCRUNCH A LINE INTO BASIC'S LINE INPUT BUFFER
2527 cf3e 30 04              LB7C2     LEAX 4,X            ; MOVE POINTER PAST ADDRESS OF NEXT LINE AND LINE NUMBER
2528 cf40 10 8e 00 f4                  LDY  #LINBUF+1      ; UNCRUNCH LINE INTO LINE INPUT BUFFER
2529 cf44 a6 80              LB7CB     LDA  ,X+            ; GET A CHARACTER
2530 cf46 27 51                        BEQ  LB820          ; BRANCH IF END OF LINE
2531 cf48 2b 15                        BMI  LB7E6          ; BRANCH IF IT'S A TOKEN
2532 cf4a 81 3a                        CMPA #':            ; CHECK FOR END OF SUB LINE
2533 cf4c 26 0d                        BNE  LB7E2          ; BRNCH IF NOT END OF SUB LINE
2534 cf4e e6 84                        LDB  ,X             ; GET CHARACTER FOLLOWING COLON
2535 cf50 c1 84                        CMPB #TOK_ELSE      ; TOKEN FOR ELSE?
2536 cf52 27 f0                        BEQ  LB7CB          ; YES - DON'T PUT IT IN BUFFER
2537 cf54 c1 83                        CMPB #TOK_SNGL_Q    ; TOKEN FOR REMARK?
2538 cf56 27 ec                        BEQ  LB7CB          ; YES - DON'T PUT IT IN BUFFER
2539 cf58 8c                           FCB  SKP2           ; SKIP TWO BYTES
2540 cf59 86 21              LB7E0     LDA  #'!            ; EXCLAMATION POINT
2541 cf5b 8d 30              LB7E2     BSR  LB814          ; PUT CHARACTER IN BUFFER
2542 cf5d 20 e5                        BRA  LB7CB          ; GET ANOTHER CHARACTER
2543                         
2544 cf5f ce c0 e7           LB7E6     LDU  #COMVEC-10     ; FIRST DO COMMANDS
2545 cf62 81 ff                        CMPA #$FF           ; CHECK FOR SECONDARY TOKEN
2546 cf64 26 04                        BNE  LB7F1          ; BRANCH IF NON SECONDARY TOKEN
2547 cf66 a6 80                        LDA  ,X+            ; GET SECONDARY TOKEN
2548 cf68 33 45                        LEAU 5,U            ; BUMP IT UP TO SECONDARY FUNCTIONS
2549 cf6a 84 7f              LB7F1     ANDA #$7F           ; MASK OFF BIT 7 OF TOKEN
2550 cf6c 33 4a              LB7F3     LEAU 10,U           ; MOVE TO NEXT COMMAND TABLE
2551 cf6e 6d c4                        TST  ,U             ; IS THIS TABLE ENABLED?
2552 cf70 27 e7                        BEQ  LB7E0          ; NO - ILLEGAL TOKEN
2553 cf72 a0 c4                        SUBA ,U             ; SUBTRACT THE NUMBER OF TOKENS FROM THE CURRENT TOKEN NUMBER
2554 cf74 2a f6                        BPL  LB7F3          ; BRANCH IF TOKEN NOT IN THIS TABLE
2555 cf76 ab c4                        ADDA ,U             ; RESTORE TOKEN NUMBER RELATIVE TO THIS TABLE
2556 cf78 ee 41                        LDU  1,U            ; POINT U TO COMMAND DICTIONARY TABLE
2557 cf7a 4a                 LB801     DECA                ; DECREMENT TOKEN NUMBER
2558 cf7b 2b 06                        BMI  LB80A          ; BRANCH IF THIS IS THE CORRECT TOKEN
2559                         * SKIP THROUGH DICTIONARY TABLE TO START OF NEXT TOKEN
2560 cf7d 6d c0              LB804     TST  ,U+            ; GRAB A BYTE
2561 cf7f 2a fc                        BPL  LB804          ; BRANCH IF BIT 7 NOT SET
2562 cf81 20 f7                        BRA  LB801          ; GO SEE IF THIS IS THE CORRECT TOKEN
2563 cf83 a6 c4              LB80A     LDA  ,U             ; GET A CHARACTER FROM DICTIONARY TABLE
2564 cf85 8d 06                        BSR  LB814          ; PUT CHARACTER IN BUFFER
2565 cf87 6d c0                        TST  ,U+            ; CHECK FOR START OF NEXT TOKEN
2566 cf89 2a f8                        BPL  LB80A          ; BRANCH IF NOT DONE WITH THIS TOKEN
2567 cf8b 20 b7                        BRA  LB7CB          ; GO GET ANOTHER CHARACTER
2568 cf8d 10 8c 01 ed        LB814     CMPY #LINBUF+LBUFMX ; TEST FOR END OF LINE INPUT BUFFER
2569 cf91 24 06                        BCC  LB820          ; BRANCH IF AT END OF BUFFER
2570 cf93 84 7f                        ANDA #$7F           ; MASK OFF BIT 7
2571 cf95 a7 a0                        STA  ,Y+            ; * SAVE CHARACTER IN BUFFER AND
2572 cf97 6f a4                        CLR  ,Y             ; * CLEAR NEXT CHARACTER SLOT IN BUFFER
2573 cf99 39                 LB820     RTS
2574                         *
2575                         * CRUNCH THE LINE THAT THE INPUT POINTER IS
2576                         * POINTING TO INTO THE LINE INPUT BUFFER
2577                         * RETURN LENGTH OF CRUNCHED LINE IN ACCD
2578                         *
2579 cf9a 9e 83              LB821     LDX  CHARAD         ; GET BASIC'S INPUT POINTER ADDRESS
2580 cf9c ce 00 f3                     LDU  #LINBUF        ; POINT X TO LINE INPUT BUFFER
2581 cf9f 0f 43              LB829     CLR  V43            ; CLEAR ILLEGAL TOKEN FLAG
2582 cfa1 0f 44                        CLR  V44            ; CLEAR DATA FLAG
2583 cfa3 a6 80              LB82D     LDA  ,X+            ; GET INPUT CHAR
2584 cfa5 27 21                        BEQ  LB852          ; BRANCH IF END OF LINE
2585 cfa7 0d 43                        TST  V43            ; * CHECK ILLEGAL TOKEN FLAG & BRANCH IF NOT
2586 cfa9 27 0f                        BEQ  LB844          ; * PROCESSING AN ILLEGAL TOKEN
2587 cfab bd cb 29                     JSR  LB3A2          ; SET CARRY IF NOT UPPER CASE ALPHA
2588 cfae 24 18                        BCC  LB852          ; BRANCH IF UPPER CASE ALPHA
2589 cfb0 81 30                        CMPA #'0            ; * DON'T CRUNCH ASCII NUMERIC CHARACTERS
2590 cfb2 25 04                        BLO  LB842          ; * BRANCH IF NOT NUMERIC
2591 cfb4 81 39                        CMPA #'9            ; *
2592 cfb6 23 10                        BLS  LB852          ; * BRANCH IF NUMERIC
2593                         * END UP HERE IF NOT UPPER CASE ALPHA OR NUMERIC
2594 cfb8 0f 43              LB842     CLR  V43            ; CLEAR ILLEGAL TOKEN FLAG
2595 cfba 81 20              LB844     CMPA #SPACE         ; SPACE?
2596 cfbc 27 0a                        BEQ  LB852          ; DO NOT REMOVE SPACES
2597 cfbe 97 42                        STA  V42            ; SAVE INPUT CHARACTER AS SCAN DELIMITER
2598 cfc0 81 22                        CMPA #'"            ; CHECK FOR STRING DELIMITER
2599 cfc2 27 38                        BEQ  LB886          ; BRANCH IF STRING
2600 cfc4 0d 44                        TST  V44            ; * CHECK DATA FLAG AND BRANCH IF CLEAR
2601 cfc6 27 19                        BEQ  LB86B          ; * DO NOT CRUNCH DATA
2602 cfc8 a7 c0              LB852     STA  ,U+            ; SAVE CHARACTER IN BUFFER
2603 cfca 27 06                        BEQ  LB85C          ; BRANCH IF END OF LINE
2604 cfcc 81 3a                        CMPA #':            ; * CHECK FOR END OF SUBLINE
2605 cfce 27 cf                        BEQ  LB829          ; * AND RESET FLAGS IF END OF SUBLINE
2606 cfd0 20 d1              LB85A     BRA  LB82D          ; GO GET ANOTHER CHARACTER
2607 cfd2 6f c0              LB85C     CLR  ,U+            ; * DOUBLE ZERO AT END OF LINE
2608 cfd4 6f c0                        CLR  ,U+            ; *
2609 cfd6 1f 30                        TFR  U,D            ; SAVE ADDRESS OF END OF LINE IN ACCD
2610 cfd8 83 00 f1                     SUBD #LINHDR        ; LENGTH OF LINE IN ACCD
2611 cfdb 8e 00 f2                     LDX  #LINBUF-1      ; * SET THE INPUT POINTER TO ONE BEFORE
2612 cfde 9f 83                        STX  CHARAD         ; * THE START OF THE CRUNCHED LINE
2613 cfe0 39                           RTS                 ; EXIT 'CRUNCH'
2614 cfe1 81 3f              LB86B     CMPA #'?            ; CHECK FOR "?" - PRINT ABBREVIATION
2615 cfe3 26 04                        BNE  LB873          ; BRANCH IF NOT PRINT ABBREVIATION
2616 cfe5 86 87                        LDA  #TOK_PRINT     ; * GET THE PRINT TOKEN AND SAVE IT
2617 cfe7 20 df                        BRA  LB852          ; * IN BUFFER
2618 cfe9 81 27              LB873     CMPA #''            ; APOSTROPHE IS SAME AS REM
2619 cfeb 26 13                        BNE  LB88A          ; BRANCH IF NOT REMARK
2620 cfed cc 3a 83                     LDD  #$3A00+TOK_SNGL_Q ; COLON, REM TOKEN
2621 cff0 ed c1                        STD  ,U++           ; SAVE IN BUFFER
2622 cff2 0f 42              LB87C     CLR  V42            ; SET DELIMITER = 0 (END OF LINE)
2623 cff4 a6 80              LB87E     LDA  ,X+            ; SCAN TILL WE MATCH [V42]
2624 cff6 27 d0                        BEQ  LB852          ; BRANCH IF END OF LINE
2625 cff8 91 42                        CMPA V42            ; DELIMITER?
2626 cffa 27 cc                        BEQ  LB852          ; BRANCH OUT IF SO
2627 cffc a7 c0              LB886     STA  ,U+            ; DON'T CRUNCH REMARKS OR STRINGS
2628 cffe 20 f4                        BRA  LB87E          ; GO GET MORE STRING OR REMARK
2629 d000 81 30              LB88A     CMPA #'0            ; * LESS THAN ASCII ZERO?
2630 d002 25 04                        BCS  LB892          ; * BRANCH IF SO
2631 d004 81 3c                        CMPA #';+1          ; = CHECK FOR NUMERIC VALUE, COLON OR SEMICOLON
2632 d006 25 c0                        BCS  LB852          ; = AND INSERT IN BUFFER IF SO
2633 d008 30 1f              LB892     LEAX -1,X           ; MOVE INPUT POINTER BACK ONE
2634 d00a 34 50                        PSHS U,X            ; SAVE POINTERS TO INPUT STRING, OUTPUT STRING
2635 d00c 0f 41                        CLR  V41            ; TOKEN FLAG 0 = COMMAND, FF = SECONDARY
2636 d00e ce c0 e7                     LDU  #COMVEC-10     ; POINT U TO COMMAND INTERPRETATION
2637                         *                             ; TABLE FOR BASIC - 10
2638 d011 0f 42              LB89B     CLR  V42            ; INITIALIZE V42 AS TOKEN COUNTER
2639 d013 33 4a              LB89D     LEAU 10,U           ; MOVE TO NEXT COMMAND INTERPRETATION TABLE
2640 d015 a6 c4                        LDA  ,U             ; GET NUMBER OF COMMANDS
2641 d017 27 31                        BEQ  LB8D4          ; GO DO SECONDARY FUNCTIONS IF NO COMMAND TABLE
2642 d019 10 ae 41                     LDY  1,U            ; POINT Y TO COMMAND DICTIONARY TABLE
2643 d01c ae e4              LB8A6     LDX  ,S             ; GET POINTER TO INPUT STRING
2644 d01e e6 a0              LB8A8     LDB  ,Y+            ; GET A BYTE FROM DICTIONARY TABLE
2645 d020 e0 80                        SUBB ,X+            ; SUBTRACT INPUT CHARACTER
2646 d022 27 fa                        BEQ  LB8A8          ; LOOP IF SAME
2647 d024 c1 80                        CMPB #$80           ; LAST CHAR IN RESERVED WORD TABLE HAD
2648                         *                             ; BIT 7 SET, SO IF WE HAVE $80 HERE
2649                         *                             ; THEN IT IS A GOOD COMPARE
2650 d026 26 38                        BNE  LB8EA          ; BRANCH IF NO MATCH - CHECK ANOTHER COMMAND
2651 d028 32 62                        LEAS 2,S            ; DELETE OLD INPUT POINTER FROM STACK
2652 d02a 35 40                        PULS U              ; GET POINTER TO OUTPUT STRING
2653 d02c da 42                        ORB  V42            ; OR IN THE TABLE POSITION TO MAKE THE TOKEN
2654                         *                             ; - NOTE THAT B ALREADY HAD $80 IN IT -
2655 d02e 96 41                        LDA  V41            ; * CHECK TOKEN FLAG AND BRANCH
2656 d030 26 06                        BNE  LB8C2          ; * IF SECONDARY
2657 d032 c1 84                        CMPB #TOK_ELSE      ; IS IT ELSE TOKEN?
2658 d034 26 06                        BNE  LB8C6          ; NO
2659 d036 86 3a                        LDA  #':            ; PUT A COLON (SUBLINE) BEFORE ELSE TOKEN
2660 d038 ed c1              LB8C2     STD  ,U++           ; SECONDARY TOKENS PRECEEDED BY $FF
2661 d03a 20 94                        BRA  LB85A          ; GO PROCESS MORE INPUT CHARACTERS
2662 d03c e7 c0              LB8C6     STB  ,U+            ; SAVE THIS TOKEN
2663 d03e c1 86                        CMPB #TOK_DATA      ; DATA TOKEN?
2664 d040 26 02                        BNE  LB8CE          ; NO
2665 d042 0c 44                        INC  V44            ; SET DATA FLAG
2666 d044 c1 82              LB8CE     CMPB #TOK_REM       ; REM TOKEN?
2667 d046 27 aa                        BEQ  LB87C          ; YES
2668 d048 20 86              LB8D2     BRA  LB85A          ; GO PROCESS MORE INPUT CHARACTERS
2669                         * CHECK FOR A SECONDARY TOKEN
2670 d04a ce c0 ec           LB8D4     LDU  #COMVEC-5      ; NOW DO SECONDARY FUNCTIONS
2671 d04d 03 41                        COM  V41            ; TOGGLE THE TOKEN FLAG
2672 d04f 26 c0                        BNE  LB89B          ; BRANCH IF NOW CHECKING SECONDARY COMMANDS
2673                         
2674                         * THIS CODE WILL PROCESS INPUT DATA WHICH CANNOT BE CRUNCHED AND SO
2675                         * IS ASSUMED TO BE ILLEGAL DATA OR AN ILLEGAL TOKEN
2676 d051 35 50                        PULS X,U            ; RESTORE INPUT AND OUTPUT POINTERS
2677 d053 a6 80                        LDA  ,X+            ; * MOVE THE FIRST CHARACTER OF AN
2678 d055 a7 c0                        STA  ,U+            ; * ILLEGAL TOKEN
2679 d057 bd cb 29                     JSR  LB3A2          ; SET CARRY IF NOT ALPHA
2680 d05a 25 ec                        BCS  LB8D2          ; BRANCH IF NOT ALPHA
2681 d05c 03 43                        COM  V43            ; SET ILLEGAL TOKEN FLAG IF UPPER CASE ALPHA
2682 d05e 20 e8                        BRA  LB8D2          ; PROCESS MORE INPUT CHARACTERS
2683 d060 0c 42              LB8EA     INC  V42            ; INCREMENT TOKEN COUNTER
2684 d062 4a                           DECA                ; DECR COMMAND COUNTER
2685 d063 27 ae                        BEQ  LB89D          ; GET ANOTHER COMMAND TABLE IF DONE W/THIS ONE
2686 d065 31 3f                        LEAY -1,Y           ; MOVE POINTER BACK ONE
2687 d067 e6 a0              LB8F1     LDB  ,Y+            ; * GET TO NEXT
2688 d069 2a fc                        BPL  LB8F1          ; * RESERVED WORD
2689 d06b 20 af                        BRA  LB8A6          ; GO SEE IF THIS WORD IS A MATCH
2690                         
2691                         * PRINT
2692 d06d 27 39              PRINT     BEQ  LB958          ; BRANCH IF NO ARGUMENT
2693 d06f 8d 01                        BSR  LB8FE          ; CHECK FOR ALL PRINT OPTIONS
2694 d071 39                           RTS
2695                         LB8FE
2696 d072 bd df d2           LB918     JSR  XVEC9          ; CALL EXTENDED BASIC ADD-IN
2697 d075 27 3e              LB91B     BEQ  LB965          ; RETURN IF END OF LINE
2698 d077 81 9f              LB91D     CMPA #TOK_TAB       ; TOKEN FOR TAB( ?
2699 d079 27 53                        BEQ  LB97E          ; YES
2700 d07b 81 2c                        CMPA #',            ; COMMA?
2701 d07d 27 37                        BEQ  LB966          ; YES - ADVANCE TO NEXT TAB FIELD
2702 d07f 81 3b                        CMPA #';            ; SEMICOLON?
2703 d081 27 60                        BEQ  LB997          ; YES - DO NOT ADVANCE CURSOR
2704 d083 bd c8 e2                     JSR  LB156          ; EVALUATE EXPRESSION
2705 d086 96 06                        LDA  VALTYP         ; * GET VARIABLE TYPE AND
2706 d088 34 02                        PSHS A              ; * SAVE IT ON THE STACK
2707 d08a 26 06                        BNE  LB938          ; BRANCH IF STRING VARIABLE
2708 d08c bd d5 25                     JSR  LBDD9          ; CONVERT FP NUMBER TO AN ASCII STRING
2709 d08f bd cc 9d                     JSR  LB516          ; PARSE A STRING FROM (X-1) AND PUT
2710                         *                             ; DESCRIPTOR ON STRING STACK
2711 d092 8d 57              LB938     BSR  LB99F          ; PRINT STRING POINTED TO BY X
2712 d094 35 04                        PULS B              ; GET VARIABLE TYPE BACK
2713 d096 bd c1 33                     JSR  LA35F          ; SET UP TAB WIDTH ZONE, ETC
2714 d099 5d                 LB949     TSTB                ; CHECK CURRENT PRINT POSITION
2715 d09a 26 08                        BNE  LB954          ; BRANCH IF NOT AT START OF LINE
2716 d09c 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
2717 d09e 81 2c                        CMPA #',            ; COMMA?
2718 d0a0 27 14                        BEQ  LB966          ; SKIP TO NEXT TAB FIELD
2719 d0a2 8d 54                        BSR  LB9AC          ; SEND A SPACE TO CONSOLE OUT
2720 d0a4 9d 82              LB954     JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
2721 d0a6 26 cf                        BNE  LB91D          ; BRANCH IF NOT END OF LINE
2722 d0a8 86 0d              LB958     LDA  #CR            ; * SEND A CR TO
2723 d0aa 20 51                        BRA  LB9B1          ; * CONSOLE OUT
2724 d0ac bd c1 33           LB95C     JSR  LA35F          ; SET UP TAB WIDTH, ZONE ETC
2725 d0af 27 f7                        BEQ  LB958          ; BRANCH IF WIDTH = ZERO
2726 d0b1 96 6c                        LDA  DEVPOS         ; GET PRINT POSITION
2727 d0b3 26 f3                        BNE  LB958          ; BRANCH IF NOT AT START OF LINE
2728 d0b5 39                 LB965     RTS
2729                         * SKIP TO NEXT TAB FIELD
2730 d0b6 bd c1 33           LB966     JSR  LA35F          ; SET UP TAB WIDTH, ZONE ETC
2731 d0b9 27 0a                        BEQ  LB975          ; BRANCH IF LINE WIDTH = 0 (CASSETTE)
2732 d0bb d6 6c                        LDB  DEVPOS         ; GET CURRENT POSITION
2733 d0bd d1 6b                        CMPB DEVLCF         ; COMPARE TO LAST TAB ZONE
2734 d0bf 25 06                        BCS  LB977          ; BRANCH IF < LAST TAB ZONE
2735 d0c1 8d e5                        BSR  LB958          ; SEND A CARRIAGE RETURN TO CONSOLE OUT
2736 d0c3 20 1e                        BRA  LB997          ; GET MORE DATA
2737 d0c5 d6 6c              LB975     LDB  DEVPOS         ; *
2738 d0c7 d0 6a              LB977     SUBB DEVCFW         ; * SUBTRACT TAB FIELD WIDTH FROM CURRENT
2739 d0c9 24 fc                        BCC  LB977          ; * POSITION UNTIL CARRY SET - NEGATING THE
2740 d0cb 50                           NEGB                ; * REMAINDER LEAVES THE NUMBER OF SPACES TO NEXT
2741                         *              ; * TAB ZONE IN ACCB
2742 d0cc 20 10                        BRA  LB98E          ; GO ADVANCE TO NEXT TAB ZONE
2743                         
2744                         * PRINT TAB(
2745 d0ce bd ce 90           LB97E     JSR  LB709          ; EVALUATE EXPRESSION - RETURN VALUE IN B
2746 d0d1 81 29                        CMPA #')            ; * 'SYNTAX' ERROR IF NOT ')'
2747 d0d3 10 26 f9 2c                  LBNE LB277          ; *
2748 d0d7 bd c1 33                     JSR  LA35F          ; SET UP TAB WIDTH, ZONE ETC
2749 d0da d0 6c                        SUBB DEVPOS         ; GET DIFFERENCE OF PRINT POSITION & TAB POSITION
2750 d0dc 23 05                        BLS  LB997          ; BRANCH IF TAB POSITION < CURRENT POSITION
2751                         LB98E
2752 d0de 8d 18              LB992     BSR  LB9AC          ; SEND A SPACE TO CONSOLE OUT
2753 d0e0 5a                           DECB                ; DECREMENT DIFFERENCE COUNT
2754 d0e1 26 fb                        BNE  LB992          ; BRANCH UNTIL CURRENT POSITION = TAB POSITION
2755 d0e3 9d 7c              LB997     JSR  GETNCH         ; GET NEXT CHARACTER FROM BASIC
2756 d0e5 7e d0 75                     JMP  LB91B          ; LOOK FOR MORE PRINT DATA
2757                         * COPY A STRING FROM (X) TO CONSOLE OUT
2758 d0e8 bd cc 9f           LB99C     JSR  LB518          ; PARSE A STRING FROM X AND PUT
2759                         *         DESCRIPTOR ON STRING STACK
2760 d0eb bd cd de           LB99F     JSR  LB657          ; GET LENGTH OF STRING AND REMOVE
2761                         *         DESCRIPTOR FROM STRING STACK
2762 d0ee 5c                           INCB                ; COMPENSATE FOR DECB BELOW
2763 d0ef 5a                 LB9A3     DECB                ; DECREMENT COUNTER
2764 d0f0 27 c3                        BEQ  LB965          ; EXIT ROUTINE
2765 d0f2 a6 80                        LDA  ,X+            ; GET A CHARACTER FROM X
2766 d0f4 8d 07                        BSR  LB9B1          ; SEND TO CONSOLE OUT
2767 d0f6 20 f7                        BRA  LB9A3          ; KEEP LOOPING
2768 d0f8 86 20              LB9AC     LDA  #SPACE         ; SPACE TO CONSOLE OUT
2769 d0fa 8c                           FCB  SKP2           ; SKIP NEXT TWO BYTES
2770 d0fb 86 3f              LB9AF     LDA  #'?            ; QUESTION MARK TO CONSOLE OUT
2771 d0fd 7e c0 17           LB9B1     JMP  PUTCHR         ; JUMP TO CONSOLE OUT
2772                         
2773                         * FLOATING POINT MATH PACKAGE
2774                         
2775                         * ADD .5 TO FPA0
2776 d100 8e d6 0c           LB9B4     LDX  #LBEC0         ; FLOATING POINT CONSTANT (.5)
2777 d103 20 09                        BRA  LB9C2          ; ADD .5 TO FPA0
2778                         * SUBTRACT FPA0 FROM FP NUMBER POINTED
2779                         * TO BY (X), LEAVE RESULT IN FPA0
2780 d105 bd d2 7b           LB9B9     JSR  LBB2F          ; COPY PACKED FP DATA FROM (X) TO FPA1
2781                         
2782                         * ARITHMETIC OPERATION (-) JUMPS HERE - SUBTRACT FPA0 FROM FPA1 (ENTER
2783                         * WITH EXPONENT OF FPA0 IN ACCB AND EXPONENT OF FPA1 IN ACCA)
2784 d108 03 54              LB9BC     COM  FP0SGN         ; CHANGE MANTISSA SIGN OF FPA0
2785 d10a 03 62                        COM  RESSGN         ; REVERSE RESULT SIGN FLAG
2786 d10c 20 03                        BRA  LB9C5          ; GO ADD FPA1 AND FPA0
2787                         * ADD FP NUMBER POINTED TO BY
2788                         * (X) TO FPA0 - LEAVE RESULT IN FPA0
2789 d10e bd d2 7b           LB9C2     JSR  LBB2F          ; UNPACK PACKED FP DATA FROM (X) TO
2790                         *         FPA1; RETURN EXPONENT OF FPA1 IN ACCA
2791                         
2792                         * ARITHMETIC OPERATION (+) JUMPS HERE - ADD FPA0 TO
2793                         
2794 d111 5d                 LB9C5     TSTB                ; CHECK EXPONENT OF FPA0
2795 d112 10 27 02 80                  LBEQ LBC4A          ; COPY FPA1 TO FPA0 IF FPA0 =
2796 d116 8e 00 5c                     LDX  #FP1EXP        ; POINT X TO FPA1
2797 d119 1f 89              LB9CD     TFR  A,B            ; PUT EXPONENT OF FPA1 INTO ACCB
2798 d11b 5d                           TSTB                ; CHECK EXPONENT
2799 d11c 27 6c                        BEQ  LBA3E          ; RETURN IF EXPONENT = 0 (ADDING 0 TO FPA0)
2800 d11e d0 4f                        SUBB FP0EXP         ; SUBTRACT EXPONENT OF FPA0 FROM EXPONENT OF FPA1
2801 d120 27 69                        BEQ  LBA3F          ; BRANCH IF EXPONENTS ARE EQUAL
2802 d122 25 0a                        BCS  LB9E2          ; BRANCH IF EXPONENT FPA0 > FPA1
2803 d124 97 4f                        STA  FP0EXP         ; REPLACE FPA0 EXPONENT WITH FPA1 EXPONENT
2804 d126 96 61                        LDA  FP1SGN         ; * REPLACE FPA0 MANTISSA SIGN
2805 d128 97 54                        STA  FP0SGN         ; * WITH FPA1 MANTISSA SIGN
2806 d12a 8e 00 4f                     LDX  #FP0EXP        ; POINT X TO FPA0
2807 d12d 50                           NEGB                ; NEGATE DIFFERENCE OF EXPONENTS
2808 d12e c1 f8              LB9E2     CMPB #-8            ; TEST DIFFERENCE OF EXPONENTS
2809 d130 2f 59                        BLE  LBA3F          ; BRANCH IF DIFFERENCE OF EXPONENTS <= 8
2810 d132 4f                           CLRA                ; CLEAR OVERFLOW BYTE
2811 d133 64 01                        LSR  1,X            ; SHIFT MS BYTE OF MANTISSA; BIT 7 = 0
2812 d135 bd d2 06                     JSR  LBABA          ; GO SHIFT MANTISSA OF (X) TO THE RIGHT (B) TIMES
2813 d138 d6 62              LB9EC     LDB  RESSGN         ; GET SIGN FLAG
2814 d13a 2a 0b                        BPL  LB9FB          ; BRANCH IF FPA0 AND FPA1 SIGNS ARE THE SAME
2815 d13c 63 01                        COM  1,X            ; * COMPLEMENT MANTISSA POINTED
2816 d13e 63 02                        COM  2,X            ; * TO BY (X) THE
2817 d140 63 03                        COM  3,X            ; * ADCA BELOW WILL
2818 d142 63 04                        COM  4,X            ; * CONVERT THIS OPERATION
2819 d144 43                           COMA                ; * INTO A NEG (MANTISSA)
2820 d145 89 00                        ADCA #0             ; ADD ONE TO ACCA - COMA ALWAYS SETS THE CARRY FLAG
2821                         * THE PREVIOUS TWO BYTES MAY BE REPLACED BY A NEGA
2822                         *
2823                         * ADD MANTISSAS OF FPA0 AND FPA1, PUT RESULT IN FPA0
2824 d147 97 63              LB9FB     STA  FPSBYT         ; SAVE FPA SUB BYTE
2825 d149 96 53                        LDA  FPA0+3         ; * ADD LS BYTE
2826 d14b 99 60                        ADCA FPA1+3         ; * OF MANTISSA
2827 d14d 97 53                        STA  FPA0+3         ; SAVE IN FPA0 LSB
2828 d14f 96 52                        LDA  FPA0+2         ; * ADD NEXT BYTE
2829 d151 99 5f                        ADCA FPA1+2         ; * OF MANTISSA
2830 d153 97 52                        STA  FPA0+2         ; SAVE IN FPA0
2831 d155 96 51                        LDA  FPA0+1         ; * ADD NEXT BYTE
2832 d157 99 5e                        ADCA FPA1+1         ; * OF MANTISSA
2833 d159 97 51                        STA  FPA0+1         ; SAVE IN FPA0
2834 d15b 96 50                        LDA  FPA0           ; * ADD MS BYTE
2835 d15d 99 5d                        ADCA FPA1           ; * OF MANTISSA
2836 d15f 97 50                        STA  FPA0           ; SAVE IN FPA0
2837 d161 5d                           TSTB                ; TEST SIGN FLAG
2838 d162 2a 44                        BPL  LBA5C          ; BRANCH IF FPA0 & FPA1 SIGNS WERE ALIKE
2839 d164 25 02              LBA18     BCS  LBA1C          ; BRANCH IF POSITIVE MANTISSA
2840 d166 8d 5d                        BSR  LBA79          ; NEGATE FPA0 MANTISSA
2841                         
2842                         * NORMALIZE FPA0
2843 d168 5f                 LBA1C     CLRB                ; CLEAR TEMPORARY EXPONENT ACCUMULATOR
2844 d169 96 50              LBA1D     LDA  FPA0           ; TEST MSB OF MANTISSA
2845 d16b 26 2e                        BNE  LBA4F          ; BRANCH IF <> 0
2846 d16d 96 51                        LDA  FPA0+1         ; * IF THE MSB IS
2847 d16f 97 50                        STA  FPA0           ; * 0, THEN SHIFT THE
2848 d171 96 52                        LDA  FPA0+2         ; * MANTISSA A WHOLE BYTE
2849 d173 97 51                        STA  FPA0+1         ; * AT A TIME. THIS
2850 d175 96 53                        LDA  FPA0+3         ; * IS FASTER THAN ONE
2851 d177 97 52                        STA  FPA0+2         ; * BIT AT A TIME
2852 d179 96 63                        LDA  FPSBYT         ; * BUT USES MORE MEMORY.
2853 d17b 97 53                        STA  FPA0+3         ; * FPSBYT, THE CARRY IN
2854 d17d 0f 63                        CLR  FPSBYT         ; * BYTE, REPLACES THE MATISSA LSB.
2855 d17f cb 08                        ADDB #8             ; SHIFTING ONE BYTE = 8 BIT SHIFTS; ADD 8 TO EXPONENT
2856 d181 c1 28                        CMPB #5*8           ; CHECK FOR 5 SHIFTS
2857 d183 2d e4                        BLT  LBA1D          ; BRANCH IF < 5 SHIFTS, IF > 5, THEN MANTISSA = 0
2858 d185 4f                 LBA39     CLRA                ; A ZERO EXPONENT = 0 FLOATING POINT
2859 d186 97 4f              LBA3A     STA  FP0EXP         ; ZERO OUT THE EXPONENT
2860 d188 97 54                        STA  FP0SGN         ; ZERO OUT THE MANTISSA SIGN
2861 d18a 39                 LBA3E     RTS
2862 d18b 8d 6d              LBA3F     BSR  LBAAE          ; SHIFT FPA0 MANTISSA TO RIGHT
2863 d18d 5f                           CLRB                ; CLEAR CARRY FLAG
2864 d18e 20 a8                        BRA  LB9EC
2865                         * SHIFT FPA0 LEFT ONE BIT UNTIL BIT 7
2866                         * OF MATISSA MS BYTE = 1
2867 d190 5c                 LBA44     INCB                ; ADD ONE TO EXPONENT ACCUMULATOR
2868 d191 08 63                        ASL  FPSBYT         ; SHIFT SUB BYTE ONE LEFT
2869 d193 09 53                        ROL  FPA0+3         ; SHIFT LS BYTE
2870 d195 09 52                        ROL  FPA0+2         ; SHIFT NS BYTE
2871 d197 09 51                        ROL  FPA0+1         ; SHIFT NS BYTE
2872 d199 09 50                        ROL  FPA0           ; SHIFT MS BYTE
2873 d19b 2a f3              LBA4F     BPL  LBA44          ; BRANCH IF NOT YET NORMALIZED
2874 d19d 96 4f                        LDA  FP0EXP         ; GET CURRENT EXPONENT
2875 d19f 34 04                        PSHS B              ; SAVE EXPONENT MODIFIER CAUSED BY NORMALIZATION
2876 d1a1 a0 e0                        SUBA ,S+            ; SUBTRACT ACCUMULATED EXPONENT MODIFIER
2877 d1a3 97 4f                        STA  FP0EXP         ; SAVE AS NEW EXPONENT
2878 d1a5 23 de                        BLS  LBA39          ; SET FPA0 = 0 IF THE NORMALIZATION CAUSED
2879                         *         MORE OR EQUAL NUMBER OF LEFT SHIFTS THAN THE
2880                         *         SIZE OF THE EXPONENT
2881 d1a7 8c                           FCB  SKP2           ; SKIP 2 BYTES
2882 d1a8 25 08              LBA5C     BCS  LBA66          ; BRANCH IF MANTISSA OVERFLOW
2883 d1aa 08 63                        ASL  FPSBYT         ; SUB BYTE BIT 7 TO CARRY - USE AS ROUND-OFF
2884                         *                             ; FLAG (TRUNCATE THE REST OF SUB BYTE)
2885 d1ac 86 00                        LDA  #0             ; CLRA, BUT DO NOT CHANGE CARRY FLAG
2886 d1ae 97 63                        STA  FPSBYT         ; CLEAR THE SUB BYTE
2887 d1b0 20 0c                        BRA  LBA72          ; GO ROUND-OFF RESULT
2888 d1b2 0c 4f              LBA66     INC  FP0EXP         ; INCREMENT EXPONENT - MULTIPLY BY 2
2889 d1b4 27 28                        BEQ  LBA92          ; OVERFLOW ERROR IF CARRY PAST $FF
2890 d1b6 06 50                        ROR  FPA0           ; * SHIFT MANTISSA
2891 d1b8 06 51                        ROR  FPA0+1         ; * ONE TO
2892 d1ba 06 52                        ROR  FPA0+2         ; * THE RIGHT -
2893 d1bc 06 53                        ROR  FPA0+3         ; * DIVIDE BY TWO
2894 d1be 24 04              LBA72     BCC  LBA78          ; BRANCH IF NO ROUND-OFF NEEDED
2895 d1c0 8d 0d                        BSR  LBA83          ; ADD ONE TO MANTISSA - ROUND OFF
2896 d1c2 27 ee                        BEQ  LBA66          ; BRANCH iF OVERFLOW - MANTISSA = 0
2897 d1c4 39                 LBA78     RTS
2898                         * NEGATE FPA0 MANTISSA
2899 d1c5 03 54              LBA79     COM  FP0SGN         ; TOGGLE SIGN OF MANTISSA
2900 d1c7 03 50              LBA7B     COM  FPA0           ; * COMPLEMENT ALL 4 MANTISSA BYTES
2901 d1c9 03 51                        COM  FPA0+1         ; *
2902 d1cb 03 52                        COM  FPA0+2         ; *
2903 d1cd 03 53                        COM  FPA0+3         ; *
2904                         * ADD ONE TO FPA0 MANTISSA
2905 d1cf 9e 52              LBA83     LDX  FPA0+2         ; * GET BOTTOM 2 MANTISSA
2906 d1d1 30 01                        LEAX 1,X            ; * BYTES, ADD ONE TO
2907 d1d3 9f 52                        STX  FPA0+2         ; * THEM AND SAVE THEM
2908 d1d5 26 06                        BNE  LBA91          ; BRANCH IF NO OVERFLOW
2909 d1d7 9e 50                        LDX  FPA0           ; * IF OVERFLOW ADD ONE
2910 d1d9 30 01                        LEAX 1,X            ; * TO TOP 2 MANTISSA
2911 d1db 9f 50                        STX  FPA0           ; * BYTES AND SAVE THEM
2912 d1dd 39                 LBA91     RTS
2913 d1de c6 0a              LBA92     LDB  #2*5           ; OV' OVERFLOW ERROR
2914 d1e0 7e c4 06                     JMP  LAC46          ; PROCESS AN ERROR
2915 d1e3 8e 00 12           LBA97     LDX  #FPA2-1        ; POINT X TO FPA2
2916                         * SHIFT FPA POINTED TO BY (X) TO
2917                         * THE RIGHT -(B) TIMES. EXIT WITH
2918                         * ACCA CONTAINING DATA SHIFTED OUT
2919                         * TO THE RIGHT (SUB BYTE) AND THE DATA
2920                         * SHIFTED IN FROM THE LEFT WILL COME FROM FPCARY
2921 d1e6 a6 04              LBA9A     LDA  4,X            ; GET LS BYTE OF MANTISSA (X)
2922 d1e8 97 63                        STA  FPSBYT         ; SAVE IN FPA SUB BYTE
2923 d1ea a6 03                        LDA  3,X            ; * SHIFT THE NEXT THREE BYTES OF THE
2924 d1ec a7 04                        STA  4,X            ; * MANTISSA RIGHT ONE COMPLETE BYTE.
2925 d1ee a6 02                        LDA  2,X            ; *
2926 d1f0 a7 03                        STA  3,X            ; *
2927 d1f2 a6 01                        LDA  1,X            ; *
2928 d1f4 a7 02                        STA  2,X            ; *
2929 d1f6 96 5b                        LDA  FPCARY         ; GET THE CARRY IN BYTE
2930 d1f8 a7 01                        STA  1,X            ; STORE AS THE MS MANTISSA BYTE OF (X)
2931 d1fa cb 08              LBAAE     ADDB #8             ; ADD 8 TO DIFFERENCE OF EXPONENTS
2932 d1fc 2f e8                        BLE  LBA9A          ; BRANCH IF EXPONENT DIFFERENCE < -8
2933 d1fe 96 63                        LDA  FPSBYT         ; GET FPA SUB BYTE
2934 d200 c0 08                        SUBB #8             ; CAST OUT THE 8 ADDED IN ABOVE
2935 d202 27 0c                        BEQ  LBAC4          ; BRANCH IF EXPONENT DIFFERENCE = 0
2936                         
2937                         
2938 d204 67 01              LBAB8     ASR  1,X            ; * SHIFT MANTISSA AND SUB BYTE ONE BIT TO THE RIGHT
2939 d206 66 02              LBABA     ROR  2,X            ; *
2940 d208 66 03                        ROR  3,X            ; *
2941 d20a 66 04                        ROR  4,X            ; *
2942 d20c 46                           RORA                ; *
2943 d20d 5c                           INCB                ; ADD ONE TO EXPONENT DIFFERENCE
2944 d20e 26 f4                        BNE  LBAB8          ; BRANCH IF EXPONENTS NOT =
2945 d210 39                 LBAC4     RTS
2946 d211 81 00 00 00 00     LBAC5     FCB  $81,$00,$00,$00,$00 ; FLOATING POINT CONSTANT 1.0
2947                         
2948                         * ARITHMETIC OPERATION (*) JUMPS HERE - MULTIPLY
2949                         * FPA0 BY (X) - RETURN PRODUCT IN FPA0
2950 d216 8d 63              LBACA     BSR  LBB2F          ; MOVE PACKED FPA FROM (X) TO FPA1
2951 d218 27 60              LBACC     BEQ  LBB2E          ; BRANCH IF EXPONENT OF FPA0 = 0
2952 d21a 8d 78                        BSR  LBB48          ; CALCULATE EXPONENT OF PRODUCT
2953                         * MULTIPLY FPA0 MANTISSA BY FPA1. NORMALIZE
2954                         * HIGH ORDER BYTES OF PRODUCT IN FPA0. THE
2955                         * LOW ORDER FOUR BYTES OF THE PRODUCT WILL
2956                         * BE STORED IN VAB-VAE.
2957 d21c 86 00              LBAD0     LDA  #0             ; * ZERO OUT MANTISSA OF FPA2
2958 d21e 97 13                        STA  FPA2           ; *
2959 d220 97 14                        STA  FPA2+1         ; *
2960 d222 97 15                        STA  FPA2+2         ; *
2961 d224 97 16                        STA  FPA2+3         ; *
2962 d226 d6 53                        LDB  FPA0+3         ; GET LS BYTE OF FPA0
2963 d228 8d 22                        BSR  LBB00          ; MULTIPLY BY FPA1
2964 d22a d6 63                        LDB  FPSBYT         ; * TEMPORARILY SAVE SUB BYTE 4
2965 d22c d7 8b                        STB  VAE            ; *
2966 d22e d6 52                        LDB  FPA0+2         ; GET NUMBER 3 MANTISSA BYTE OF FPA0
2967 d230 8d 1a                        BSR  LBB00          ; MULTIPLY BY FPA1
2968 d232 d6 63                        LDB  FPSBYT         ; * TEMPORARILY SAVE SUB BYTE 3
2969 d234 d7 8a                        STB  VAD            ; *
2970 d236 d6 51                        LDB  FPA0+1         ; GET NUMBER 2 MANTISSA BYTE OF FPA0
2971 d238 8d 12                        BSR  LBB00          ; MULTIPLY BY FPA1
2972 d23a d6 63                        LDB  FPSBYT         ; * TEMPORARILY SAVE SUB BYTE 2
2973 d23c d7 89                        STB  VAC            ; *
2974 d23e d6 50                        LDB  FPA0           ; GET MS BYTE OF FPA0 MANTISSA
2975 d240 8d 0c                        BSR  LBB02          ; MULTIPLY BY FPA1
2976 d242 d6 63                        LDB  FPSBYT         ; * TEMPORARILY SAVE SUB BYTE 1
2977 d244 d7 88                        STB  VAB            ; *
2978 d246 bd d3 57                     JSR  LBC0B          ; COPY MANTISSA FROM FPA2 TO FPA0
2979 d249 7e d1 68                     JMP  LBA1C          ; NORMALIZE FPA0
2980 d24c 27 95              LBB00     BEQ  LBA97          ; SHIFT FPA2 ONE BYTE TO RIGHT
2981 d24e 43                 LBB02     COMA                ; SET CARRY FLAG
2982                         * MULTIPLY FPA1 MANTISSA BY ACCB AND
2983                         * ADD PRODUCT TO FPA2 MANTISSA
2984 d24f 96 13              LBB03     LDA  FPA2           ; GET FPA2 MS BYTE
2985 d251 56                           RORB                ; ROTATE CARRY FLAG INTO SHIFT COUNTER;
2986                         *         DATA BIT INTO CARRY
2987 d252 27 26                        BEQ  LBB2E          ; BRANCH WHEN 8 SHIFTS DONE
2988 d254 24 16                        BCC  LBB20          ; DO NOT ADD FPA1 IF DATA BIT = 0
2989 d256 96 16                        LDA  FPA2+3         ; * ADD MANTISSA LS BYTE
2990 d258 9b 60                        ADDA FPA1+3         ; *
2991 d25a 97 16                        STA  FPA2+3         ; *
2992 d25c 96 15                        LDA  FPA2+2         ; = ADD MANTISSA NUMBER 3 BYTE
2993 d25e 99 5f                        ADCA FPA1+2         ; =
2994 d260 97 15                        STA  FPA2+2         ; =
2995 d262 96 14                        LDA  FPA2+1         ; * ADD MANTISSA NUMBER 2 BYTE
2996 d264 99 5e                        ADCA FPA1+1         ; *
2997 d266 97 14                        STA  FPA2+1         ; *
2998 d268 96 13                        LDA  FPA2           ; = ADD MANTISSA MS BYTE
2999 d26a 99 5d                        ADCA FPA1           ; =
3000 d26c 46                 LBB20     RORA                ; * ROTATE CARRY INTO MS BYTE
3001 d26d 97 13                        STA  FPA2           ; *
3002 d26f 06 14                        ROR  FPA2+1         ; = ROTATE FPA2 ONE BIT TO THE RIGHT
3003 d271 06 15                        ROR  FPA2+2         ; =
3004 d273 06 16                        ROR  FPA2+3         ; =
3005 d275 06 63                        ROR  FPSBYT         ; =
3006 d277 4f                           CLRA                ; CLEAR CARRY FLAG
3007 d278 20 d5                        BRA  LBB03          ; KEEP LOOPING
3008 d27a 39                 LBB2E     RTS
3009                         * UNPACK A FP NUMBER FROM (X) TO FPA1
3010 d27b ec 01              LBB2F     LDD  1,X            ; GET TWO MSB BYTES OF MANTISSA FROM
3011                         *         FPA  POINTED TO BY X
3012 d27d 97 61                        STA  FP1SGN         ; SAVE PACKED MANTISSA SIGN BYTE
3013 d27f 8a 80                        ORA  #$80           ; FORCE BIT 7 OF MSB MANTISSA = 1
3014 d281 dd 5d                        STD  FPA1           ; SAVE 2 MSB BYTES IN FPA1
3015 d283 d6 61                        LDB  FP1SGN         ; * GET PACKED MANTISSA SIGN BYTE. EOR W/FPA0
3016 d285 d8 54                        EORB FP0SGN         ; * SIGN - NEW SIGN POSITION IF BOTH OLD SIGNS ALIKE,
3017 d287 d7 62                        STB  RESSGN         ; * NEG IF BOTH OLD SIGNS DIFF. SAVE ADJUSTED
3018                         *                             ; * MANTISSA SIGN BYTE
3019 d289 ec 03                        LDD  3,X            ; = GET 2 LSB BYTES OF MANTISSA
3020 d28b dd 5f                        STD  FPA1+2         ; = AND PUT IN FPA1
3021 d28d a6 84                        LDA  ,X             ; * GET EXPONENT FROM (X) AND
3022 d28f 97 5c                        STA  FP1EXP         ; * PUT IN EXPONENT OF FPA1
3023 d291 d6 4f                        LDB  FP0EXP         ; GET EXPONENT OF FPA0
3024 d293 39                           RTS
3025                         * CALCULATE EXPONENT FOR PRODUCT OF FPA0 & FPA1
3026                         * ENTER WITH EXPONENT OF FPA1 IN ACCA
3027 d294 4d                 LBB48     TSTA                ; TEST EXPONENT OF FPA1
3028 d295 27 16                        BEQ  LBB61          ; PURGE RETURN ADDRESS & SET FPA0 = 0
3029 d297 9b 4f                        ADDA FP0EXP         ; ADD FPA1 EXPONENT TO FPA0 EXPONENT
3030 d299 46                           RORA                ; ROTATE CARRY INTO BIT 7; BIT 0 INTO CARRY
3031 d29a 49                           ROLA                ; SET OVERFLOW FLAG
3032 d29b 28 10                        BVC  LBB61          ; BRANCH IF EXPONENT TOO LARGE OR SMALL
3033 d29d 8b 80                        ADDA #$80           ; ADD $80 BIAS TO EXPONENT
3034 d29f 97 4f                        STA  FP0EXP         ; SAVE NEW EXPONENT
3035 d2a1 27 0c                        BEQ  LBB63          ; SET FPA0
3036 d2a3 96 62                        LDA  RESSGN         ; GET MANTISSA SIGN
3037 d2a5 97 54                        STA  FP0SGN         ; SAVE AS MANTISSA SIGN OF FPA0
3038 d2a7 39                           RTS
3039                         * IF FPA0 = POSITIVE THEN 'OV' ERROR IF FPA0
3040                         * = IS NEGATIVE THEN FPA0 = 0
3041 d2a8 96 54              LBB5C     LDA  FP0SGN         ; GET MANTISSA SIGN OF FPA0
3042 d2aa 43                           COMA                ; CHANGE SIGN OF FPA0 MANTISSA
3043 d2ab 20 02                        BRA  LBB63
3044 d2ad 32 62              LBB61     LEAS 2,S            ; PURGE RETURN ADDRESS FROM STACK
3045 d2af 10 2a fe d2        LBB63     LBPL LBA39          ; ZERO FPA0 MANTISSA SIGN & EXPONENT
3046 d2b3 7e d1 de           LBB67     JMP  LBA92          ; 'OV' OVERFLOW ERROR
3047                         * FAST MULTIPLY BY 10 AND LEAVE RESULT IN FPA0
3048 d2b6 bd d3 ab           LBB6A     JSR  LBC5F          ; TRANSFER FPA0 TO FPA1
3049 d2b9 27 0d                        BEQ  LBB7C          ; BRANCH IF EXPONENT = 0
3050 d2bb 8b 02                        ADDA #2             ; ADD 2 TO EXPONENT (TIMES 4)
3051 d2bd 25 f4                        BCS  LBB67          ; 'OV' ERROR IF EXPONENT > $FF
3052 d2bf 0f 62                        CLR  RESSGN         ; CLEAR RESULT SIGN BYTE
3053 d2c1 bd d1 19                     JSR  LB9CD          ; ADD FPA1 TO FPA0 (TIMES 5)
3054 d2c4 0c 4f                        INC  FP0EXP         ; ADD ONE TO EXPONENT (TIMES 10)
3055 d2c6 27 eb                        BEQ  LBB67          ; 'OV' ERROR IF EXPONENT > $FF
3056 d2c8 39                 LBB7C     RTS
3057 d2c9 84 20 00 00 00     LBB7D     FCB  $84,$20,$00,$00,$00 ; FLOATING POINT CONSTANT 10
3058                         * DIVIDE FPA0 BY 10
3059 d2ce bd d3 ab           LBB82     JSR  LBC5F          ; MOVE FPA0 TO FPA1
3060 d2d1 8e d2 c9                     LDX  #LBB7D         ; POINT TO FLOATING POINT CONSTANT 10
3061 d2d4 5f                           CLRB                ; ZERO MANTISSA SIGN BYTE
3062 d2d5 d7 62              LBB89     STB  RESSGN         ; STORE THE QUOTIENT MANTISSA SIGN BYTE
3063 d2d7 bd d3 60                     JSR  LBC14          ; UNPACK AN FP NUMBER FROM (X) INTO FPA0
3064 d2da 8c                           FCB  SKP2           ; SKIP TWO BYTES
3065                         * DIVIDE (X) BY FPA0-LEAVE NORMALIZED QUOTIENT IN FPA0
3066 d2db 8d 9e              LBB8F     BSR  LBB2F          ; GET FP NUMBER FROM (X) TO FPA1
3067                         
3068                         * ARITHMETIC OPERATION (/) JUMPS HERE. DIVIDE FPA1 BY FPA0 (ENTER WITH
3069                         * EXPONENT OF FPA1 IN ACCA AND FLAGS SET BY TSTA)
3070                         
3071                         * DIVIDE FPA1 BY FPA0
3072 d2dd 27 73              LBB91     BEQ  LBC06          ; '/0' DIVIDE BY ZERO ERROR
3073 d2df 00 4f                        NEG  FP0EXP         ; GET EXPONENT OF RECIPROCAL OF DIVISOR
3074 d2e1 8d b1                        BSR  LBB48          ; CALCULATE EXPONENT OF QUOTIENT
3075 d2e3 0c 4f                        INC  FP0EXP         ; INCREMENT EXPONENT
3076 d2e5 27 cc                        BEQ  LBB67          ; 'OV' OVERFLOW ERROR
3077 d2e7 8e 00 13                     LDX  #FPA2          ; POINT X TO MANTISSA OF FPA2 - HOLD
3078                         *                             ; TEMPORARY QUOTIENT IN FPA2
3079 d2ea c6 04                        LDB  #4             ; 5 BYTE DIVIDE
3080 d2ec d7 03                        STB  TMPLOC         ; SAVE BYTE COUNTER
3081 d2ee c6 01                        LDB  #1             ; SHIFT COUNTER-AND TEMPORARY QUOTIENT BYTE
3082                         * COMPARE FPA0 MANTISSA TO FPA1 MANTISSA -
3083                         * SET CARRY FLAG IF FPA1 >= FPA0
3084 d2f0 96 50              LBBA4     LDA  FPA0           ; * COMPARE THE TWO MS BYTES
3085 d2f2 91 5d                        CMPA FPA1           ; * OF FPA0 AND FPA1 AND
3086 d2f4 26 13                        BNE  LBBBD          ; * BRANCH IF <>
3087 d2f6 96 51                        LDA  FPA0+1         ; = COMPARE THE NUMBER 2
3088 d2f8 91 5e                        CMPA FPA1+1         ; = BYTES AND
3089 d2fa 26 0d                        BNE  LBBBD          ; = BRANCH IF <>
3090 d2fc 96 52                        LDA  FPA0+2         ; * COMPARE THE NUMBER 3
3091 d2fe 91 5f                        CMPA FPA1+2         ; * BYTES AND
3092 d300 26 07                        BNE  LBBBD          ; * BRANCH IF <>
3093 d302 96 53                        LDA  FPA0+3         ; = COMPARE THE LS BYTES
3094 d304 91 60                        CMPA FPA1+3         ; = AND BRANCH
3095 d306 26 01                        BNE  LBBBD          ; = IF <>
3096 d308 43                           COMA                ; SET CARRY FLAG IF FPA0 = FPA1
3097 d309 1f a8              LBBBD     TFR  CC,A           ; SAVE CARRY FLAG STATUS IN ACCA; CARRY
3098                         *         CLEAR IF FPA0 > FPA1
3099 d30b 59                           ROLB                ; ROTATE CARRY INTO TEMPORARY QUOTIENT BYTE
3100 d30c 24 0a                        BCC  LBBCC          ; CARRY WILL BE SET AFTER 8 SHIFTS
3101 d30e e7 80                        STB  ,X+            ; SAVE TEMPORARY QUOTIENT
3102 d310 0a 03                        DEC  TMPLOC         ; DECREMENT BYTE COUNTER
3103 d312 2b 34                        BMI  LBBFC          ; BRANCH IF DONE
3104 d314 27 2e                        BEQ  LBBF8          ; BRANCH IF LAST BYTE
3105 d316 c6 01                        LDB  #1             ; RESET SHIFT COUNTER AND TEMPORARY QUOTIENT BYTE
3106 d318 1f 8a              LBBCC     TFR  A,CC           ; RESTORE CARRY FLAG AND
3107 d31a 25 0e                        BCS  LBBDE          ; BRANCH IF FPA0 =< FPA1
3108 d31c 08 60              LBBD0     ASL  FPA1+3         ; * SHIFT FPA1 MANTISSA 1 BIT TO LEFT
3109 d31e 09 5f                        ROL  FPA1+2         ; *
3110 d320 09 5e                        ROL  FPA1+1         ; *
3111 d322 09 5d                        ROL  FPA1           ; *
3112 d324 25 e3                        BCS  LBBBD          ; BRANCH IF CARRY - ADD ONE TO PARTIAL QUOTIENT
3113 d326 2b c8                        BMI  LBBA4          ; IF MSB OF HIGH ORDER MANTISSA BYTE IS
3114                         *         SET, CHECK THE MAGNITUDES OF FPA0, FPA1
3115 d328 20 df                        BRA  LBBBD          ; CARRY IS CLEAR, CHECK ANOTHER BIT
3116                         * SUBTRACT FPA0 FROM FPA1 - LEAVE RESULT IN FPA1
3117 d32a 96 60              LBBDE     LDA  FPA1+3         ; * SUBTRACT THE LS BYTES OF MANTISSA
3118 d32c 90 53                        SUBA FPA0+3         ; *
3119 d32e 97 60                        STA  FPA1+3         ; *
3120 d330 96 5f                        LDA  FPA1+2         ; = THEN THE NEXT BYTE
3121 d332 92 52                        SBCA FPA0+2         ; =
3122 d334 97 5f                        STA  FPA1+2         ; =
3123 d336 96 5e                        LDA  FPA1+1         ; * AND THE NEXT
3124 d338 92 51                        SBCA FPA0+1         ; *
3125 d33a 97 5e                        STA  FPA1+1         ; *
3126 d33c 96 5d                        LDA  FPA1           ; = AND FINALLY, THE MS BYTE OF MANTISSA
3127 d33e 92 50                        SBCA FPA0           ; =
3128 d340 97 5d                        STA  FPA1           ; =
3129 d342 20 d8                        BRA  LBBD0          ; GO SHIFT FPA1
3130 d344 c6 40              LBBF8     LDB  #$40           ; USE ONLY TWO BITS OF THE LAST BYTE (FIFTH)
3131 d346 20 d0                        BRA  LBBCC          ; GO SHIFT THE LAST BYTE
3132 d348 56                 LBBFC     RORB                ; * SHIFT CARRY (ALWAYS SET HERE) INTO
3133 d349 56                           RORB                ; * BIT 5 AND MOVE
3134 d34a 56                           RORB                ; * BITS 1,0 TO BITS 7,6
3135 d34b d7 63                        STB  FPSBYT         ; SAVE SUB BYTE
3136 d34d 8d 08                        BSR  LBC0B          ; MOVE MANTISSA OF FPA2 TO FPA0
3137 d34f 7e d1 68                     JMP  LBA1C          ; NORMALIZE FPA0
3138 d352 c6 14              LBC06     LDB  #2*10          ; /0' ERROR
3139 d354 7e c4 06                     JMP  LAC46          ; PROCESS THE ERROR
3140                         * COPY MANTISSA FROM FPA2 TO FPA0
3141 d357 9e 13              LBC0B     LDX  FPA2           ; * MOVE TOP 2 BYTES
3142 d359 9f 50                        STX  FPA0           ; *
3143 d35b 9e 15                        LDX  FPA2+2         ; = MOVE BOTTOM 2 BYTES
3144 d35d 9f 52                        STX  FPA0+2         ; =
3145 d35f 39                           RTS
3146                         * COPY A PACKED FP NUMBER FROM (X) TO FPA0
3147 d360 34 02              LBC14     PSHS A              ; SAVE ACCA
3148 d362 ec 01                        LDD  1,X            ; GET TOP TWO MANTISSA BYTES
3149 d364 97 54                        STA  FP0SGN         ; SAVE MS BYTE OF MANTISSA AS MANTISSA SIGN
3150 d366 8a 80                        ORA  #$80           ; UNPACK MS BYTE
3151 d368 dd 50                        STD  FPA0           ; SAVE UNPACKED TOP 2 MANTISSA BYTES
3152 d36a 0f 63                        CLR  FPSBYT         ; CLEAR MANTISSA SUB BYTE
3153 d36c e6 84                        LDB  ,X             ; GET EXPONENT TO ACCB
3154 d36e ae 03                        LDX  3,X            ; * MOVE LAST 2
3155 d370 9f 52                        STX  FPA0+2         ; * MANTISSA BYTES
3156 d372 d7 4f                        STB  FP0EXP         ; SAVE EXPONENT
3157 d374 35 82                        PULS A,PC           ; RESTORE ACCA AND RETURN
3158                         
3159 d376 8e 00 45           LBC2A     LDX  #V45           ; POINT X TO MANTISSA OF FPA4
3160 d379 20 06                        BRA  LBC35          ; MOVE FPA0 TO FPA4
3161 d37b 8e 00 40           LBC2F     LDX  #V40           ; POINT X TO MANTISSA OF FPA3
3162 d37e 8c                           FCB  SKP2           ; SKIP TWO BYTES
3163 d37f 9e 3b              LBC33     LDX  VARDES         ; POINT X TO VARIABLE DESCRIPTOR IN VARDES
3164                         * PACK FPA0 AND MOVE IT TO ADDRESS IN X
3165 d381 96 4f              LBC35     LDA  FP0EXP         ; * COPY EXPONENT
3166 d383 a7 84                        STA  ,X             ; *
3167 d385 96 54                        LDA  FP0SGN         ; GET MANTISSA SIGN BIT
3168 d387 8a 7f                        ORA  #$7F           ; MASK THE BOTTOM 7 BITS
3169 d389 94 50                        ANDA FPA0           ; AND BIT 7 OF MANTISSA SIGN INTO BIT 7 OF MS BYTE
3170 d38b a7 01                        STA  1,X            ; SAVE MS BYTE
3171 d38d 96 51                        LDA  FPA0+1         ; * MOVE 2ND MANTISSA BYTE
3172 d38f a7 02                        STA  2,X            ; *
3173 d391 de 52                        LDU  FPA0+2         ; = MOVE BOTTOM 2 MANTISSA BYTES
3174 d393 ef 03                        STU  3,X            ; =
3175 d395 39                           RTS
3176                         * MOVE FPA1 TO FPA0 RETURN W/MANTISSA SIGN IN ACCA
3177 d396 96 61              LBC4A     LDA  FP1SGN         ; * COPY MANTISSA SIGN FROM
3178 d398 97 54              LBC4C     STA  FP0SGN         ; * FPA1 TO FPA0
3179 d39a 9e 5c                        LDX  FP1EXP         ; = COPY EXPONENT + MS BYTE FROM
3180 d39c 9f 4f                        STX  FP0EXP         ; = FPA1 TO FPA0
3181 d39e 0f 63                        CLR  FPSBYT         ; CLEAR MANTISSA SUB BYTE
3182 d3a0 96 5e                        LDA  FPA1+1         ; * COPY 2ND MANTISSA BYTE
3183 d3a2 97 51                        STA  FPA0+1         ; * FROM FPA1 TO FPA0
3184 d3a4 96 54                        LDA  FP0SGN         ; GET MANTISSA SIGN
3185 d3a6 9e 5f                        LDX  FPA1+2         ; * COPY 3RD AND 4TH MANTISSA BYTE
3186 d3a8 9f 52                        STX  FPA0+2         ; * FROM FPA1 TO FPA0
3187 d3aa 39                           RTS
3188                         * TRANSFER FPA0 TO FPA1
3189 d3ab dc 4f              LBC5F     LDD  FP0EXP         ; * TRANSFER EXPONENT & MS BYTE
3190 d3ad dd 5c                        STD  FP1EXP         ; *
3191 d3af 9e 51                        LDX  FPA0+1         ; = TRANSFER MIDDLE TWO BYTES
3192 d3b1 9f 5e                        STX  FPA1+1         ; =
3193 d3b3 9e 53                        LDX  FPA0+3         ; * TRANSFER BOTTOM TWO BYTES
3194 d3b5 9f 60                        STX  FPA1+3         ; *
3195 d3b7 4d                           TSTA                ; SET FLAGS ACCORDING TO EXPONENT
3196 d3b8 39                           RTS
3197                         * CHECK FPA0; RETURN ACCB = 0 IF FPA0 = 0,
3198                         * ACCB = $FF IF FPA0 = NEGATIVE, ACCB = 1 IF FPA0 = POSITIVE
3199 d3b9 d6 4f              LBC6D     LDB  FP0EXP         ; GET EXPONENT
3200 d3bb 27 08                        BEQ  LBC79          ; BRANCH IF FPA0 = 0
3201 d3bd d6 54              LBC71     LDB  FP0SGN         ; GET SIGN OF MANTISSA
3202 d3bf 59                 LBC73     ROLB                ; BIT 7 TO CARRY
3203 d3c0 c6 ff                        LDB  #$FF           ; NEGATIVE FLAG
3204 d3c2 25 01                        BCS  LBC79          ; BRANCH IF NEGATIVE MANTISSA
3205 d3c4 50                           NEGB                ; ACCB = 1 IF POSITIVE MANTISSA
3206 d3c5 39                 LBC79     RTS
3207                         
3208                         * SGN
3209 d3c6 8d f1              SGN       BSR  LBC6D          ; SET ACCB ACCORDING TO SIGN OF FPA0
3210                         * CONVERT A SIGNED NUMBER IN ACCB INTO A FLOATING POINT NUMBER
3211 d3c8 d7 50              LBC7C     STB  FPA0           ; SAVE ACCB IN FPA0
3212 d3ca 0f 51                        CLR  FPA0+1         ; CLEAR NUMBER 2 MANTISSA BYTE OF FPA0
3213 d3cc c6 88                        LDB  #$88           ; EXPONENT REQUIRED IF FPA0 IS TO BE AN INTEGER
3214 d3ce 96 50              LBC82     LDA  FPA0           ; GET MS BYTE OF MANTISSA
3215 d3d0 80 80                        SUBA #$80           ; SET CARRY IF POSITIVE MANTISSA
3216 d3d2 d7 4f              LBC86     STB  FP0EXP         ; SAVE EXPONENT
3217 d3d4 dc 74                        LDD  ZERO           ; * ZERO OUT ACCD AND
3218 d3d6 dd 52                        STD  FPA0+2         ; * BOTTOM HALF OF FPA0
3219 d3d8 97 63                        STA  FPSBYT         ; CLEAR SUB BYTE
3220 d3da 97 54                        STA  FP0SGN         ; CLEAR SIGN OF FPA0 MANTISSA
3221 d3dc 7e d1 64                     JMP  LBA18          ; GO NORMALIZE FPA0
3222                         
3223                         * ABS
3224 d3df 0f 54              ABS       CLR  FP0SGN         ; FORCE MANTISSA SIGN OF FPA0 POSITIVE
3225 d3e1 39                           RTS
3226                         * COMPARE A PACKED FLOATING POINT NUMBER POINTED TO
3227                         * BY (X) TO AN UNPACKED FP NUMBER IN FPA0. RETURN
3228                         * ZERO FLAG SET AND ACCB = 0, IF EQUAL; ACCB = 1 IF
3229                         * FPA0 > (X); ACCB = $FF IF FPA0 < (X)
3230 d3e2 e6 84              LBC96     LDB  ,X             ; CHECK EXPONENT OF (X)
3231 d3e4 27 d3                        BEQ  LBC6D          ; BRANCH IF FPA = 0
3232 d3e6 e6 01                        LDB  1,X            ; GET MS BYTE OF MANTISSA OF (X)
3233 d3e8 d8 54                        EORB FP0SGN         ; EOR WITH SIGN OF FPA0
3234 d3ea 2b d1                        BMI  LBC71          ; BRANCH IF SIGNS NOT =
3235                         * COMPARE FPA0 WITH FP NUMBER POINTED TO BY (X).
3236                         * FPA0 IS NORMALIZED, (X) IS PACKED.
3237 d3ec d6 4f              LBCA0     LDB  FP0EXP         ; * GET EXPONENT OF
3238 d3ee e1 84                        CMPB ,X             ; * FPA0, COMPARE TO EXPONENT OF
3239 d3f0 26 1d                        BNE  LBCC3          ; * (X) AND BRANCH IF <>.
3240 d3f2 e6 01                        LDB  1,X            ; * GET MS BYTE OF (X), KEEP ONLY
3241 d3f4 ca 7f                        ORB  #$7F           ; * THE SIGN BIT - 'AND' THE BOTTOM 7
3242 d3f6 d4 50                        ANDB FPA0           ; * BITS OF FPA0 INTO ACCB
3243 d3f8 e1 01                        CMPB 1,X            ; = COMPARE THE BOTTOM 7 BITS OF THE MANTISSA
3244 d3fa 26 13                        BNE  LBCC3          ; = MS BYTE AND BRANCH IF <>
3245 d3fc d6 51                        LDB  FPA0+1         ; * COMPARE 2ND BYTE
3246 d3fe e1 02                        CMPB 2,X            ; * OF MANTISSA,
3247 d400 26 0d                        BNE  LBCC3          ; * BRANCH IF <>
3248 d402 d6 52                        LDB  FPA0+2         ; = COMPARE 3RD BYTE
3249 d404 e1 03                        CMPB 3,X            ; = OF MANTISSA,
3250 d406 26 07                        BNE  LBCC3          ; = BRANCH IF <>
3251 d408 d6 53                        LDB  FPA0+3         ; * SUBTRACT LS BYTE
3252 d40a e0 04                        SUBB 4,X            ; * OF (X) FROM LS BYTE OF
3253 d40c 26 01                        BNE  LBCC3          ; * FPA0, BRANCH IF <>
3254 d40e 39                           RTS                 ; RETURN IF FP (X) = FPA0
3255 d40f 56                 LBCC3     RORB                ; SHIFT CARRY TO BIT 7; CARRY SET IF FPA0 < (X)
3256 d410 d8 54                        EORB FP0SGN         ; TOGGLE SIZE COMPARISON BIT IF FPA0 IS NEGATIVE
3257 d412 20 ab                        BRA  LBC73          ; GO SET ACCB ACCORDING TO COMPARISON
3258                         * DE-NORMALIZE FPA0 : SHIFT THE MANTISSA UNTIL THE BINARY POINT IS TO THE RIGHT
3259                         * OF THE LEAST SIGNIFICANT BYTE OF THE MANTISSA
3260 d414 d6 4f              LBCC8     LDB  FP0EXP         ; GET EXPONENT OF FPA0
3261 d416 27 3d                        BEQ  LBD09          ; ZERO MANTISSA IF FPA0 = 0
3262 d418 c0 a0                        SUBB #$A0           ; SUBTRACT $A0 FROM FPA0 EXPONENT T THIS WILL YIELD
3263                         *                             ; THE NUMBER OF SHIFTS REQUIRED TO DENORMALIZE FPA0. WHEN
3264                         *                             ; THE EXPONENT OF FPA0 IS = ZERO, THEN THE BINARY POINT
3265                         *                             ; WILL BE TO THE RIGHT OF THE MANTISSA
3266 d41a 96 54                        LDA  FP0SGN         ; TEST SIGN OF FPA0 MANTISSA
3267 d41c 2a 05                        BPL  LBCD7          ; BRANCH IF POSITIVE
3268 d41e 03 5b                        COM  FPCARY         ; COMPLEMENT CARRY IN BYTE
3269 d420 bd d1 c7                     JSR  LBA7B          ; NEGATE MANTISSA OF FPA0
3270 d423 8e 00 4f           LBCD7     LDX  #FP0EXP        ; POINT X TO FPA0
3271 d426 c1 f8                        CMPB #-8            ; EXPONENT DIFFERENCE < -8?
3272 d428 2e 06                        BGT  LBCE4          ; YES
3273 d42a bd d1 fa                     JSR  LBAAE          ; SHIFT FPA0 RIGHT UNTIL FPA0 EXPONENT = $A0
3274 d42d 0f 5b                        CLR  FPCARY         ; CLEAR CARRY IN BYTE
3275 d42f 39                           RTS
3276 d430 0f 5b              LBCE4     CLR  FPCARY         ; CLEAR CARRY IN BYTE
3277 d432 96 54                        LDA  FP0SGN         ; * GET SIGN OF FPA0 MANTISSA
3278 d434 49                           ROLA                ; * ROTATE IT INTO THE CARRY FLAG
3279 d435 06 50                        ROR  FPA0           ; ROTATE CARRY (MANTISSA SIGN) INTO BIT 7
3280                         *                             ; OF LS BYTE OF MANTISSA
3281 d437 7e d2 06                     JMP  LBABA          ; DE-NORMALIZE FPA0
3282                         
3283                         * INT
3284                         * THE INT STATEMENT WILL "DENORMALIZE" FPA0 - THAT IS IT WILL SHIFT THE BINARY POINT
3285                         * TO THE EXTREME RIGHT OF THE MANTISSA TO FORCE ITS EXPONENT TO BE $AO. ONCE
3286                         * THIS IS DONE THE MANTISSA OF FPA0 WILL CONTAIN THE FOUR LEAST SIGNIFICANT
3287                         * BYTES OF THE INTEGER PORTION OF FPA0. AT THE CONCLUSION OF THE DE-NORMALIZATION
3288                         * ONLY THE INTEGER PORTION OF FPA0 WILL REMAIN.
3289                         *
3290 d43a d6 4f              INT       LDB  FP0EXP         ; GET EXPONENT OF FPA0
3291 d43c c1 a0                        CMPB #$A0           ; LARGEST POSSIBLE INTEGER EXPONENT
3292 d43e 24 1d                        BCC  LBD11          ; RETURN IF FPA0 >= 32768
3293 d440 8d d2                        BSR  LBCC8          ; SHIFT THE BINARY POINT ONE TO THE RIGHT OF THE
3294                         *                             ; LS BYTE OF THE FPA0 MANTISSA
3295 d442 d7 63                        STB  FPSBYT         ; ACCB = 0: ZERO OUT THE SUB BYTE
3296 d444 96 54                        LDA  FP0SGN         ; GET MANTISSA SIGN
3297 d446 d7 54                        STB  FP0SGN         ; FORCE MANTISSA SIGN TO BE POSITIVE
3298 d448 80 80                        SUBA #$80           ; SET CARRY IF MANTISSA
3299 d44a 86 a0                        LDA  #$A0           ; * GET DENORMALIZED EXPONENT AND
3300 d44c 97 4f                        STA  FP0EXP         ; * SAVE IT IN FPA0 EXPONENT
3301 d44e 96 53                        LDA  FPA0+3         ; = GET LS BYTE OF FPA0 AND
3302 d450 97 01                        STA  CHARAC         ; = SAVE IT IN CHARAC
3303 d452 7e d1 64                     JMP  LBA18          ; NORMALIZE FPA0
3304                         
3305 d455 d7 50              LBD09     STB  FPA0           ; * LOAD MANTISSA OF FPA0 WITH CONTENTS OF ACCB
3306 d457 d7 51                        STB  FPA0+1         ; *
3307 d459 d7 52                        STB  FPA0+2         ; *
3308 d45b d7 53                        STB  FPA0+3         ; *
3309 d45d 39                 LBD11     RTS                 ; *
3310                         
3311                         * CONVERT ASCII STRING TO FLOATING POINT
3312 d45e 9e 74              LBD12     LDX  ZERO           ; (X) = 0
3313 d460 9f 54                        STX  FP0SGN         ; * ZERO OUT FPA0 & THE SIGN FLAG (COEFCT)
3314 d462 9f 4f                        STX  FP0EXP         ; *
3315 d464 9f 51                        STX  FPA0+1         ; *
3316 d466 9f 52                        STX  FPA0+2         ; *
3317 d468 9f 47                        STX  V47            ; INITIALIZE EXPONENT & EXPONENT SIGN FLAG TO ZERO
3318 d46a 9f 45                        STX  V45            ; INITIALIZE RIGHT DECIMAL CTR & DECIMAL PT FLAG TO 0
3319 d46c 25 64                        BCS  LBD86          ; IF CARRY SET (NUMERIC CHARACTER), ASSUME ACCA CONTAINS FIRST
3320                         *         NUMERIC CHAR, SIGN IS POSITIVE AND SKIP THE RAM HOOK
3321 d46e bd db 9b                     JSR  XVEC19         ; CALL EXTENDED BASIC ADD-IN
3322 d471 81 2d              LBD25     CMPA #'-            ; * CHECK FOR A LEADING MINUS SIGN AND BRANCH
3323 d473 26 04                        BNE  LBD2D          ; * IF NO MINUS SIGN
3324 d475 03 55                        COM  COEFCT         ; TOGGLE SIGN; 0 = +; FF = -
3325 d477 20 04                        BRA  LBD31          ; INTERPRET THE REST OF THE STRING
3326 d479 81 2b              LBD2D     CMPA #'+            ; * CHECK FOR LEADING PLUS SlGN AND BRANCH
3327 d47b 26 04                        BNE  LBD35          ; * IF NOT A PLUS SIGN
3328 d47d 9d 7c              LBD31     JSR  GETNCH         ; GET NEXT INPUT CHARACTER FROM BASIC
3329 d47f 25 51                        BCS  LBD86          ; BRANCH IF NUMERIC CHARACTER
3330 d481 81 2e              LBD35     CMPA #'.            ; DECIMAL POlNT?
3331 d483 27 28                        BEQ  LBD61          ; YES
3332 d485 81 45                        CMPA #'E            ; "E" SHORTHAND FORM (SCIENTIFIC NOTATION)?
3333 d487 26 28                        BNE  LBD65          ; NO
3334                         * EVALUATE EXPONENT OF EXPONENTIAL FORMAT
3335 d489 9d 7c                        JSR  GETNCH         ; GET NEXT INPUT CHARACTER FROM BASIC
3336 d48b 25 64                        BCS  LBDA5          ; BRANCH IF NUMERIC
3337 d48d 81 a7                        CMPA #TOK_MINUS     ; MINUS TOKEN?
3338 d48f 27 0e                        BEQ  LBD53          ; YES
3339 d491 81 2d                        CMPA #'-            ; ASCII MINUS?
3340 d493 27 0a                        BEQ  LBD53          ; YES
3341 d495 81 a6                        CMPA #TOK_PLUS      ; PLUS TOKEN?
3342 d497 27 08                        BEQ  LBD55          ; YES
3343 d499 81 2b                        CMPA #'+            ; ASCII PLUS?
3344 d49b 27 04                        BEQ  LBD55          ; YES
3345 d49d 20 06                        BRA  LBD59          ; BRANCH IF NO SIGN FOUND
3346 d49f 03 48              LBD53     COM  V48            ; SET EXPONENT SIGN FLAG TO NEGATIVE
3347                         * STRIP A DECIMAL NUMBER FROM BASIC LINE, CONVERT IT TO BINARY IN V47
3348 d4a1 9d 7c              LBD55     JSR  GETNCH         ; GET NEXT INPUT CHARACTER FROM BASIC
3349 d4a3 25 4c                        BCS  LBDA5          ; IF NUMERIC CHARACTER, CONVERT TO BINARY
3350 d4a5 0d 48              LBD59     TST  V48            ; * CHECK EXPONENT SIGN FLAG
3351 d4a7 27 08                        BEQ  LBD65          ; * AND BRANCH IF POSITIVE
3352 d4a9 00 47                        NEG  V47            ; NEGATE VALUE OF EXPONENT
3353 d4ab 20 04                        BRA  LBD65
3354 d4ad 03 46              LBD61     COM  V46            ; *TOGGLE DECIMAL PT FLAG AND INTERPRET ANOTHER
3355 d4af 26 cc                        BNE  LBD31          ; *CHARACTER IF <> 0 - TERMINATE INTERPRETATION
3356                         *         IF   SECOND DECIMAL POINT
3357                         * ADJUST FPA0 FOR THE DECIMAL EXPONENT IN V47
3358 d4b1 96 47              LBD65     LDA  V47            ; * GET EXPONENT, SUBTRACT THE NUMBER OF
3359 d4b3 90 45                        SUBA V45            ; * PLACES TO THE RIGHT OF DECIMAL POINT
3360 d4b5 97 47                        STA  V47            ; * AND RESAVE IT.
3361 d4b7 27 12                        BEQ  LBD7F          ; EXIT ROUTINE IF ADJUSTED EXPONENT = ZERO
3362 d4b9 2a 09                        BPL  LBD78          ; BRANCH IF POSITIVE EXPONENT
3363 d4bb bd d2 ce           LBD6F     JSR  LBB82          ; DIVIDE FPA0 BY 10
3364 d4be 0c 47                        INC  V47            ; INCREMENT EXPONENT COUNTER (MULTIPLY BY 10)
3365 d4c0 26 f9                        BNE  LBD6F          ; KEEP MULTIPLYING
3366 d4c2 20 07                        BRA  LBD7F          ; EXIT ROUTINE
3367 d4c4 bd d2 b6           LBD78     JSR  LBB6A          ; MULTIPLY FPA0 BY 10
3368 d4c7 0a 47                        DEC  V47            ; DECREMENT EXPONENT COUNTER (DIVIDE BY 10)
3369 d4c9 26 f9                        BNE  LBD78          ; KEEP MULTIPLYING
3370 d4cb 96 55              LBD7F     LDA  COEFCT         ; GET THE SIGN FLAG
3371 d4cd 2a 8e                        BPL  LBD11          ; RETURN IF POSITIVE
3372 d4cf 7e d6 35                     JMP  LBEE9          ; TOGGLE MANTISSA SIGN OF FPA0, IF NEGATIVE
3373                         *MULTIPLY FPA0 BY TEN AND ADD ACCA TO THE RESULT
3374 d4d2 d6 45              LBD86     LDB  V45            ; *GET THE RIGHT DECIMAL COUNTER AND SUBTRACT
3375 d4d4 d0 46                        SUBB V46            ; *THE DECIMAL POINT FLAG FROM IT. IF DECIMAL POINT
3376 d4d6 d7 45                        STB  V45            ; *FLAG=0, NOTHING HAPPENS. IF DECIMAL POINT FLAG IS
3377                         *                             -1, THEN RIGHT DECIMAL COUNTER IS INCREMENTED BY ONE
3378 d4d8 34 02                        PSHS A              ; SAVE NEW DIGIT ON STACK
3379 d4da bd d2 b6                     JSR  LBB6A          ; MULTIPLY FPA0 BY 10
3380 d4dd 35 04                        PULS B              ; GET NEW DIGIT BACK
3381 d4df c0 30                        SUBB #'0            ; MASK OFF ASCII
3382 d4e1 8d 02                        BSR  LBD99          ; ADD ACCB TO FPA0
3383 d4e3 20 98                        BRA  LBD31          ; GET ANOTHER CHARACTER FROM BASIC
3384 d4e5 bd d3 7b           LBD99     JSR  LBC2F          ; PACK FPA0 AND SAVE IT IN FPA3
3385 d4e8 bd d3 c8                     JSR  LBC7C          ; CONVERT ACCB TO FP NUMBER IN FPA0
3386 d4eb 8e 00 40                     LDX  #V40           ; * ADD FPA0 TO
3387 d4ee 7e d1 0e                     JMP  LB9C2          ; * FPA3
3388                         
3389                         
3390 d4f1 d6 47              LBDA5     LDB  V47
3391 d4f3 58                           ASLB                ; TIMES 2
3392 d4f4 58                           ASLB                ; TIMES 4
3393 d4f5 db 47                        ADDB V47            ; ADD 1 = TIMES 5
3394 d4f7 58                           ASLB                ; TIMES 10
3395 d4f8 80 30                        SUBA #'0            ; *MASK OFF ASCII FROM ACCA, PUSH
3396 d4fa 34 04                        PSHS B              ; *RESULT ONTO THE STACK AND
3397 d4fc ab e0                        ADDA ,S+            ; ADD lT TO ACCB
3398 d4fe 97 47                        STA  V47            ; SAVE IN V47
3399 d500 20 9f                        BRA  LBD55          ; INTERPRET ANOTHER CHARACTER
3400                         *
3401 d502 9b 3e bc 1f fd     LBDB6     FCB  $9B,$3E,$BC,$1F,$FD ; * 99999999.9
3402 d507 9e 6e 6b 27 fd     LBDBB     FCB  $9E,$6E,$6B,$27,$FD ; * 999999999
3403 d50c 9e 6e 6b 28 00     LBDC0     FCB  $9E,$6E,$6B,$28,$00 ; * 1E + 09
3404                         *
3405 d511 8e c3 a7           LBDC5     LDX  #LABE8-1       ; POINT X TO " IN " MESSAGE
3406 d514 8d 0c                        BSR  LBDD6          ; COPY A STRING FROM (X) TO CONSOLE OUT
3407 d516 dc 68                        LDD  CURLIN         ; GET CURRENT BASIC LINE NUMBER TO ACCD
3408                         * CONVERT VALUE IN ACCD INTO A DECIMAL NUMBER
3409                         * AND PRINT IT TO CONSOLE OUT
3410 d518 dd 50              LBDCC     STD  FPA0           ; SAVE ACCD IN TOP HALF OF FPA0
3411 d51a c6 90                        LDB  #$90           ; REQ'D EXPONENT IF TOP HALF OF ACCD = INTEGER
3412 d51c 43                           COMA                ; SET CARRY FLAG - FORCE POSITIVE MANTISSA
3413 d51d bd d3 d2                     JSR  LBC86          ; ZERO BOTTOM HALF AND SIGN OF FPA0, THEN
3414                         *         SAVE EXPONENT AND NORMALIZE IT
3415 d520 8d 03                        BSR  LBDD9          ; CONVERT FP NUMBER TO ASCII STRING
3416 d522 7e d0 e8           LBDD6     JMP  LB99C          ; COPY A STRING FROM (X) TO CONSOLE OUT
3417                         
3418                         * CONVERT FP NUMBER TO ASCII STRING
3419 d525 ce 01 f1           LBDD9     LDU  #STRBUF+3      ; POINT U TO BUFFER WHICH WILL NOT CAUSE
3420                         *                             ; THE STRING TO BE STORED IN STRING SPACE
3421 d528 86 20              LBDDC     LDA  #SPACE         ; SPACE = DEFAULT SIGN FOR POSITIVE #
3422 d52a d6 54                        LDB  FP0SGN         ; GET SIGN OF FPA0
3423 d52c 2a 02                        BPL  LBDE4          ; BRANCH IF POSITIVE
3424 d52e 86 2d                        LDA  #'-            ; ASCII MINUS SIGN
3425 d530 a7 c0              LBDE4     STA  ,U+            ; STORE SIGN OF NUMBER
3426 d532 df 64                        STU  COEFPT         ; SAVE BUFFER POINTER
3427 d534 97 54                        STA  FP0SGN         ; SAVE SIGN (IN ASCII)
3428 d536 86 30                        LDA  #'0            ; ASCII ZERO IF EXPONENT = 0
3429 d538 d6 4f                        LDB  FP0EXP         ; GET FPA0 EXPONENT
3430 d53a 10 27 00 c6                  LBEQ LBEB8          ; BRANCH IF FPA0 = 0
3431 d53e 4f                           CLRA                ; BASE 10 EXPONENT=0 FOR FP NUMBER > 1
3432 d53f c1 80                        CMPB #$80           ; CHECK EXPONENT
3433 d541 22 08                        BHI  LBDFF          ; BRANCH IF FP NUMBER > 1
3434                         * IF FPA0 < 1.0, MULTIPLY IT BY 1E+09 TO SPEED UP THE CONVERSION PROCESS
3435 d543 8e d5 0c                     LDX  #LBDC0         ; POINT X TO FP 1E+09
3436 d546 bd d2 16                     JSR  LBACA          ; MULTIPLY FPA0 BY (X)
3437 d549 86 f7                        LDA  #-9            ; BASE 10 EXPONENT = -9
3438 d54b 97 45              LBDFF     STA  V45            ; BASE 10 EXPONENT
3439                         * PSEUDO - NORMALIZE THE FP NUMBER TO A VALUE IN THE RANGE
3440                         * OF 999,999,999 RO 99,999,999.9 - THIS IS THE LARGEST
3441                         * NUMBER RANGE IN WHICH ALL OF THE DIGITS ARE
3442                         * SIGNIFICANT WHICH CAN BE DISPLAYED WITHOUT USING
3443                         * SCIENTIFIC NOTATION
3444 d54d 8e d5 07           LBE01     LDX  #LBDBB         ; POINT X TO FP 999,999,999
3445 d550 bd d3 ec                     JSR  LBCA0          ; COMPARE FPA0 TO 999,999,999
3446 d553 2e 0f                        BGT  LBE18          ; BRANCH IF > 999,999,999
3447 d555 8e d5 02           LBE09     LDX  #LBDB6         ; POINT X TO FP 99,999,999.9
3448 d558 bd d3 ec                     JSR  LBCA0          ; COMPARE FPA0 TO 99,999,999.9
3449 d55b 2e 0e                        BGT  LBE1F          ; BRANCH IF > 99,999,999.9 (IN RANGE)
3450 d55d bd d2 b6                     JSR  LBB6A          ; MULTIPLY FPA0 BY 10
3451 d560 0a 45                        DEC  V45            ; SUBTRACT ONE FROM DECIMAL OFFSET
3452 d562 20 f1                        BRA  LBE09          ; PSEUDO - NORMALIZE SOME MORE
3453 d564 bd d2 ce           LBE18     JSR  LBB82          ; DIVIDE FPA0 BY 10
3454 d567 0c 45                        INC  V45            ; ADD ONE TO BASE 10 EXPONENT
3455 d569 20 e2                        BRA  LBE01          ; PSEUDO - NORMALIZE SOME MORE
3456 d56b bd d1 00           LBE1F     JSR  LB9B4          ; ADD .5 TO FPA0 (ROUND OFF)
3457 d56e bd d4 14                     JSR  LBCC8          ; CONVERT FPA0 TO AN INTEGER
3458 d571 c6 01                        LDB  #1             ; DEFAULT DECIMAL POINT FLAG (FORCE IMMED DECIMAL PT)
3459 d573 96 45                        LDA  V45            ; * GET BASE 10 EXPONENT AND ADD TEN TO IT
3460 d575 8b 0a                        ADDA #9+1           ; * (NUMBER 'NORMALIZED' TO 9 PLACES & DECIMAL PT)
3461 d577 2b 09                        BMI  LBE36          ; BRANCH IF NUMBER < 1.0
3462 d579 81 0b                        CMPA #9+2           ; NINE PLACES MAY BE DISPLAYED WITHOUT
3463                         *         USING SCIENTIFIC NOTATION
3464 d57b 24 05                        BCC  LBE36          ; BRANCH IF SCIENTIFIC NOTATION REQUIRED
3465 d57d 4a                           DECA                ; * SUBTRACT 1 FROM MODIFIED BASE 10 EXPONENT CTR
3466 d57e 1f 89                        TFR  A,B            ; * AND SAVE IT IN ACCB (DECiMAL POINT FLAG)
3467 d580 86 02                        LDA  #2             ; FORCE EXPONENT = 0 - DON'T USE SCIENTIFIC NOTATION
3468 d582 4a                 LBE36     DECA                ; * SUBTRACT TWO (WITHOUT AFFECTING CARRY)
3469 d583 4a                           DECA                ; * FROM BASE 10 EXPONENT
3470 d584 97 47                        STA  V47            ; SAVE EXPONENT - ZERO EXPONENT = DO NOT DISPLAY
3471                         *         IN   SCIENTIFIC NOTATION
3472 d586 d7 45                        STB  V45            ; DECIMAL POINT FLAG - NUMBER OF PLACES TO
3473                         *         LEFT OF DECIMAL POINT
3474 d588 2e 0d                        BGT  LBE4B          ; BRANCH IF >= 1
3475 d58a de 64                        LDU  COEFPT         ; POINT U TO THE STRING BUFFER
3476 d58c 86 2e                        LDA  #'.            ; * STORE A PERIOD
3477 d58e a7 c0                        STA  ,U+            ; * IN THE BUFFER
3478 d590 5d                           TSTB                ; CHECK DECIMAL POINT FLAG
3479 d591 27 04                        BEQ  LBE4B          ; BRANCH IF NOTHING TO LEFT OF DECIMAL POINT
3480 d593 86 30                        LDA  #'0            ; * STORE A ZERO
3481 d595 a7 c0                        STA  ,U+            ; * IN THE BUFFER
3482                         
3483                         * CONVERT FPA0 INTO A STRING OF ASCII DIGITS
3484 d597 8e d6 11           LBE4B     LDX  #LBEC5         ; POINT X TO FP POWER OF 10 MANTISSA
3485 d59a c6 80                        LDB  #0+$80         ; INITIALIZE DIGIT COUNTER TO 0+$80
3486                         * BIT 7 SET IS USED TO INDICATE THAT THE POWER OF 10 MANTISSA
3487                         * IS NEGATIVE. WHEN YOU 'ADD' A NEGATIVE MANTISSA, IT IS
3488                         * THE SAME AS SUBTRACTING A POSITIVE ONE AND BIT 7 OF ACCB IS HOW
3489                         * THE ROUTINE KNOWS THAT A 'SUBTRACTION' IS OCCURING.
3490 d59c 96 53              LBE50     LDA  FPA0+3         ; * ADD MANTISSA LS
3491 d59e ab 03                        ADDA 3,X            ; * BYTE OF FPA0
3492 d5a0 97 53                        STA  FPA0+3         ; * AND (X)
3493 d5a2 96 52                        LDA  FPA0+2         ; = ADD MANTISSA
3494 d5a4 a9 02                        ADCA 2,X            ; = NUMBER 3 BYTE OF
3495 d5a6 97 52                        STA  FPA0+2         ; = FPA0 AND (X)
3496 d5a8 96 51                        LDA  FPA0+1         ; * ADD MANTISSA
3497 d5aa a9 01                        ADCA 1,X            ; * NUMBER 2 BYTE OF
3498 d5ac 97 51                        STA  FPA0+1         ; * FPA0 AND (X)
3499 d5ae 96 50                        LDA  FPA0           ; = ADD MANTISSA
3500 d5b0 a9 84                        ADCA ,X             ; = MS BYTE OF
3501 d5b2 97 50                        STA  FPA0           ; = FPA0 AND (X)
3502 d5b4 5c                           INCB                ; ADD ONE TO DIGIT COUNTER
3503 d5b5 56                           RORB                ; ROTATE CARRY INTO BIT 7
3504 d5b6 59                           ROLB                ; *SET OVERFLOW FLAG AND BRANCH IF CARRY = 1 AND
3505 d5b7 28 e3                        BVC  LBE50          ; *POSITIVE MANTISSA OR CARRY = 0 AND NEG MANTISSA
3506 d5b9 24 03                        BCC  LBE72          ; BRANCH IF NEGATIVE MANTISSA
3507 d5bb c0 0b                        SUBB #10+1          ; * TAKE THE 9'S COMPLEMENT IF
3508 d5bd 50                           NEGB                ; * ADDING MANTISSA
3509 d5be cb 2f              LBE72     ADDB #'0-1          ; ADD ASCII OFFSET TO DIGIT
3510 d5c0 30 04                        LEAX 4,X            ; MOVE TO NEXT POWER OF 10 MANTISSA
3511 d5c2 1f 98                        TFR  B,A            ; SAVE DIGIT IN ACCA
3512 d5c4 84 7f                        ANDA #$7F           ; MASK OFF BIT 7 (ADD/SUBTRACT FLAG)
3513 d5c6 a7 c0                        STA  ,U+            ; STORE DIGIT IN STRING BUFFER
3514 d5c8 0a 45                        DEC  V45            ; DECREMENT DECIMAL POINT FLAG
3515 d5ca 26 04                        BNE  LBE84          ; BRANCH IF NOT TIME FOR DECIMAL POINT
3516 d5cc 86 2e                        LDA  #'.            ; * STORE DECIMAL POINT IN
3517 d5ce a7 c0                        STA  ,U+            ; * STRING BUFFER
3518 d5d0 53                 LBE84     COMB                ; TOGGLE BIT 7 (ADD/SUBTRACT FLAG)
3519 d5d1 c4 80                        ANDB #$80           ; MASK OFF ALL BUT ADD/SUBTRACT FLAG
3520 d5d3 8c d6 35                     CMPX #LBEC5+36      ; COMPARE X TO END OF MANTISSA TABLE
3521 d5d6 26 c4                        BNE  LBE50          ; BRANCH IF NOT AT END OF TABLE
3522                         * BLANK TRAILING ZEROS AND STORE EXPONENT IF ANY
3523 d5d8 a6 c2              LBE8C     LDA  ,-U            ; GET THE LAST CHARACTER; MOVE POINTER BACK
3524 d5da 81 30                        CMPA #'0            ; WAS IT A ZERO?
3525 d5dc 27 fa                        BEQ  LBE8C          ; IGNORE TRAILING ZEROS IF SO
3526 d5de 81 2e                        CMPA #'.            ; CHECK FOR DECIMAL POINT
3527 d5e0 26 02                        BNE  LBE98          ; BRANCH IF NOT DECIMAL POINT
3528 d5e2 33 5f                        LEAU -1,U           ; STEP OVER THE DECIMAL POINT
3529 d5e4 86 2b              LBE98     LDA  #'+            ; ASCII PLUS SIGN
3530 d5e6 d6 47                        LDB  V47            ; GET SCIENTIFIC NOTATION EXPONENT
3531 d5e8 27 1c                        BEQ  LBEBA          ; BRANCH IF NOT SCIENTIFIC NOTATION
3532 d5ea 2a 03                        BPL  LBEA3          ; BRANCH IF POSITIVE EXPONENT
3533 d5ec 86 2d                        LDA  #'-            ; ASCII MINUS SIGN
3534 d5ee 50                           NEGB                ; NEGATE EXPONENT IF NEGATIVE
3535 d5ef a7 42              LBEA3     STA  2,U            ; STORE EXPONENT SIGN IN STRING
3536 d5f1 86 45                        LDA  #'E            ; * GET ASCII 'E' (SCIENTIFIC NOTATION
3537 d5f3 a7 41                        STA  1,U            ; * FLAG) AND SAVE IT IN THE STRING
3538 d5f5 86 2f                        LDA  #'0-1          ; INITIALIZE ACCA TO ASCII ZERO
3539                         
3540                         
3541 d5f7 4c                 LBEAB     INCA                ; ADD ONE TO 10'S DIGIT OF EXPONENT
3542 d5f8 c0 0a                        SUBB #10            ; SUBTRACT 10 FROM ACCB
3543 d5fa 24 fb                        BCC  LBEAB          ; ADD 1 TO 10'S DIGIT IF NO CARRY
3544 d5fc cb 3a                        ADDB #'9+1          ; CONVERT UNITS DIGIT TO ASCII
3545 d5fe ed 43                        STD  3,U            ; SAVE EXPONENT IN STRING
3546 d600 6f 45                        CLR  5,U            ; CLEAR LAST BYTE (TERMINATOR)
3547 d602 20 04                        BRA  LBEBC          ; GO RESET POINTER
3548 d604 a7 c4              LBEB8     STA  ,U             ; STORE LAST CHARACTER
3549 d606 6f 41              LBEBA     CLR  1,U            ; CLEAR LAST BYTE (TERMINATOR - REQUIRED BY
3550                         *         PRINT SUBROUTINES)
3551 d608 8e 01 f1           LBEBC     LDX  #STRBUF+3      ; RESET POINTER TO START OF BUFFER
3552 d60b 39                           RTS
3553                         *
3554 d60c 80 00 00 00 00     LBEC0     FCB  $80,$00,$00,$00,$00 ; FLOATING POINT .5
3555                         *
3556                         *** TABLE OF UNNORMALIZED POWERS OF 10
3557 d611 fa 0a 1f 00        LBEC5     FCB  $FA,$0A,$1F,$00 ; -100000000
3558 d615 00 98 96 80        LBEC9     FCB  $00,$98,$96,$80 ; 10000000
3559 d619 ff f0 bd c0        LBECD     FCB  $FF,$F0,$BD,$C0 ; -1000000
3560 d61d 00 01 86 a0        LBED1     FCB  $00,$01,$86,$A0 ; 100000
3561 d621 ff ff d8 f0        LBED5     FCB  $FF,$FF,$D8,$F0 ; -10000
3562 d625 00 00 03 e8        LBED9     FCB  $00,$00,$03,$E8 ; 1000
3563 d629 ff ff ff 9c        LBEDD     FCB  $FF,$FF,$FF,$9C ; -100
3564 d62d 00 00 00 0a        LBEE1     FCB  $00,$00,$00,$0A ; 10
3565 d631 ff ff ff ff        LBEE5     FCB  $FF,$FF,$FF,$FF ; -1
3566                         *
3567                         *
3568 d635 96 4f              LBEE9     LDA  FP0EXP         ; GET EXPONENT OF FPA0
3569 d637 27 02                        BEQ  LBEEF          ; BRANCH IF FPA0 = 0
3570 d639 03 54                        COM  FP0SGN         ; TOGGLE MANTISSA SIGN OF FPA0
3571 d63b 39                 LBEEF     RTS
3572                         * EXPAND A POLYNOMIAL OF THE FORM
3573                         * AQ+BQ**3+CQ**5+DQ**7.... WHERE Q = FPA0
3574                         * AND THE X REGISTER POINTS TO A TABLE OF
3575                         * COEFFICIENTS A,B,C,D....
3576 d63c 9f 64              LBEF0     STX  COEFPT         ; SAVE COEFFICIENT TABLE POINTER
3577 d63e bd d3 7b                     JSR  LBC2F          ; MOVE FPA0 TO FPA3
3578 d641 8d 05                        BSR  LBEFC          ; MULTIPLY FPA3 BY FPA0
3579 d643 8d 08                        BSR  LBF01          ; EXPAND POLYNOMIAL
3580 d645 8e 00 40                     LDX  #V40           ; POINT X TO FPA3
3581 d648 7e d2 16           LBEFC     JMP  LBACA          ; MULTIPLY (X) BY FPA0
3582                         
3583                         * CALCULATE THE VALUE OF AN EXPANDED POLYNOMIAL
3584                         * EXPRESSION. ENTER WITH (X) POINTING TO A TABLE
3585                         * OF COEFFICIENTS, THE FIRST BYTE OF WHICH IS THE
3586                         * NUMBER OF (COEFFICIENTS-1) FOLLOWED BY THAT NUMBER
3587                         * OF PACKED FLOATING POINT NUMBERS. THE
3588                         * POLYNOMIAL IS EVALUATED AS FOLLOWS: VALUE =
3589                         * (((FPA0*Y0+Y1)*FPA0+Y2)*FPA0...YN)
3590 d64b 9f 64              LBEFF     STX  COEFPT         ; SAVE COEFFICIENT TABLE POINTER
3591 d64d bd d3 76           LBF01     JSR  LBC2A          ; MOVE FPA0 TO FPA4
3592 d650 9e 64                        LDX  COEFPT         ; GET THE COEFFICIENT POINTER
3593 d652 e6 80                        LDB  ,X+            ; GET THE TOP OF COEFFICIENT TABLE TO
3594 d654 d7 55                        STB  COEFCT         ; * USE AND STORE IT IN TEMPORARY COUNTER
3595 d656 9f 64                        STX  COEFPT         ; SAVE NEW COEFFICIENT POINTER
3596 d658 8d ee              LBF0C     BSR  LBEFC          ; MULTIPLY (X) BY FPA0
3597 d65a 9e 64                        LDX  COEFPT         ; *GET COEFFICIENT POINTER
3598 d65c 30 05                        LEAX 5,X            ; *MOVE TO NEXT FP NUMBER
3599 d65e 9f 64                        STX  COEFPT         ; *SAVE NEW COEFFICIENT POINTER
3600 d660 bd d1 0e                     JSR  LB9C2          ; ADD (X) AND FPA0
3601 d663 8e 00 45                     LDX  #V45           ; POINT (X) TO FPA4
3602 d666 0a 55                        DEC  COEFCT         ; DECREMENT TEMP COUNTER
3603 d668 26 ee                        BNE  LBF0C          ; BRANCH IF MORE COEFFICIENTS LEFT
3604 d66a 39                           RTS
3605                         
3606                         * RND
3607 d66b bd d3 b9           RND       JSR  LBC6D          ; TEST FPA0
3608 d66e 2b 1f                        BMI  LBF45          ; BRANCH IF FPA0 = NEGATIVE
3609 d670 27 15                        BEQ  LBF3B          ; BRANCH IF FPA0 = 0
3610 d672 8d 10                        BSR  LBF38          ; CONVERT FPA0 TO AN INTEGER
3611 d674 bd d3 7b                     JSR  LBC2F          ; PACK FPA0 TO FPA3
3612 d677 8d 0e                        BSR  LBF3B          ; GET A RANDOM NUMBER: FPA0 < 1.0
3613 d679 8e 00 40                     LDX  #V40           ; POINT (X) TO FPA3
3614 d67c 8d ca                        BSR  LBEFC          ; MULTIPLY (X) BY FPA0
3615 d67e 8e d2 11                     LDX  #LBAC5         ; POINT (X) TO FP VALUE OF 1.0
3616 d681 bd d1 0e                     JSR  LB9C2          ; ADD 1.0 TO FPA0
3617 d684 7e d4 3a           LBF38     JMP  INT            ; CONVERT FPA0 TO AN INTEGER
3618                         * CALCULATE A RANDOM NUMBER IN THE RANGE 0.0 < X <= 1.0
3619 d687 9e b1              LBF3B     LDX  RVSEED+1       ; * MOVE VARIABLE
3620 d689 9f 50                        STX  FPA0           ; * RANDOM NUMBER
3621 d68b 9e b3                        LDX  RVSEED+3       ; * SEED TO
3622 d68d 9f 52                        STX  FPA0+2         ; * FPA0
3623 d68f be d6 bc           LBF45     LDX  RSEED          ; = MOVE FIXED
3624 d692 9f 5d                        STX  FPA1           ; = RANDOM NUMBER
3625 d694 be d6 be                     LDX  RSEED+2        ; = SEED TO
3626 d697 9f 5f                        STX  FPA1+2         ; = MANTISSA OF FPA0
3627 d699 bd d2 1c                     JSR  LBAD0          ; MULTIPLY FPA0 X FPA1
3628 d69c dc 8a                        LDD  VAD            ; GET THE TWO LOWEST ORDER PRODUCT BYTES
3629 d69e c3 65 8b                     ADDD #$658B         ; ADD A CONSTANT
3630 d6a1 dd b3                        STD  RVSEED+3       ; SAVE NEW LOW ORDER VARIABLE RANDOM # SEED
3631 d6a3 dd 52                        STD  FPA0+2         ; SAVE NEW LOW ORDER BYTES OF FPA0 MANTISSA
3632 d6a5 dc 88                        LDD  VAB            ; GET 2 MORE LOW ORDER PRODUCT BYTES
3633 d6a7 c9 b0                        ADCB #$B0           ; ADD A CONSTANT
3634 d6a9 89 05                        ADCA #5             ; ADD A CONSTANT
3635 d6ab dd b1                        STD  RVSEED+1       ; SAVE NEW HIGH ORDER VARIABLE RANDOM # SEED
3636 d6ad dd 50                        STD  FPA0           ; SAVE NEW HIGH ORDER FPA0 MANTISSA
3637 d6af 0f 54                        CLR  FP0SGN         ; FORCE FPA0 MANTISSA = POSITIVE
3638 d6b1 86 80                        LDA  #$80           ; * SET FPA0 BIASED EXPONENT
3639 d6b3 97 4f                        STA  FP0EXP         ; * TO 0 1 < FPA0 < 0
3640 d6b5 96 15                        LDA  FPA2+2         ; GET A BYTE FROM FPA2 (MORE RANDOMNESS)
3641 d6b7 97 63                        STA  FPSBYT         ; SAVE AS SUB BYTE
3642 d6b9 7e d1 68                     JMP  LBA1C          ; NORMALIZE FPA0
3643                         *
3644 d6bc 40 e6              RSEED     FDB  $40E6          ; *CONSTANT RANDOM NUMBER GENERATOR SEED
3645 d6be 4d ab                        FDB  $4DAB          ; *
3646                         
3647                         * SIN
3648                         * THE SIN FUNCTION REQUIRES AN ARGUMENT IN RADIANS AND WILL REPEAT ITSELF EVERY
3649                         * 2*PI RADIANS. THE ARGUMENT IS DIVIDED BY 2*PI AND ONLY THE FRACTIONAL PART IS
3650                         * RETAINED. SINCE THE ARGUMENT WAS DIVIDED BY 2*P1, THE COEFFICIENTS MUST BE
3651                         * MULTIPLIED BY THE APPROPRIATE POWER OF 2*PI.
3652                         
3653                         * SIN IS EVALUATED USING THE TRIGONOMETRIC IDENTITIES BELOW:
3654                         * SIN(X)=SIN(PI-X) & -SIN(PI/2-X)=SIN((3*PI)/2+X)
3655 d6c0 bd d3 ab           SIN       JSR  LBC5F          ; COPY FPA0 TO FPA1
3656 d6c3 8e d7 05                     LDX  #LBFBD         ; POINT (X) TO 2*PI
3657 d6c6 d6 61                        LDB  FP1SGN         ; *GET MANTISSA SIGN OF FPA1
3658 d6c8 bd d2 d5                     JSR  LBB89          ; *AND DIVIDE FPA0 BY 2*PI
3659 d6cb bd d3 ab                     JSR  LBC5F          ; COPY FPA0 TO FPA1
3660 d6ce 8d b4                        BSR  LBF38          ; CONVERT FPA0 TO AN INTEGER
3661 d6d0 0f 62                        CLR  RESSGN         ; SET RESULT SIGN = POSITIVE
3662 d6d2 96 5c                        LDA  FP1EXP         ; *GET EXPONENT OF FPA1
3663 d6d4 d6 4f                        LDB  FP0EXP         ; *GET EXPONENT OF FPA0
3664 d6d6 bd d1 08                     JSR  LB9BC          ; *SUBTRACT FPA0 FROM FPA1
3665                         * NOW FPA0 CONTAINS ONLY THE FRACTIONAL PART OF ARGUMENT/2*PI
3666 d6d9 8e d7 0a                     LDX  #LBFC2         ; POINT X TO FP (.25)
3667 d6dc bd d1 05                     JSR  LB9B9          ; SUBTRACT FPA0 FROM .25 (PI/2)
3668 d6df 96 54                        LDA  FP0SGN         ; GET MANTISSA SIGN OF FPA0
3669 d6e1 34 02                        PSHS A              ; SAVE IT ON STACK
3670 d6e3 2a 09                        BPL  LBFA6          ; BRANCH IF MANTISSA POSITIVE
3671 d6e5 bd d1 00                     JSR  LB9B4          ; ADD .5 (PI) TO FPA0
3672 d6e8 96 54                        LDA  FP0SGN         ; GET SIGN OF FPA0
3673 d6ea 2b 05                        BMI  LBFA9          ; BRANCH IF NEGATIVE
3674 d6ec 03 0a                        COM  RELFLG         ; COM IF +(3*PI)/2 >= ARGUMENT >+ PI/2 (QUADRANT FLAG)
3675 d6ee bd d6 35           LBFA6     JSR  LBEE9          ; TOGGLE MANTISSA SIGN OF FPA0
3676 d6f1 8e d7 0a           LBFA9     LDX  #LBFC2         ; POINT X TO FP (.25)
3677 d6f4 bd d1 0e                     JSR  LB9C2          ; ADD .25 (PI/2) TO FPA0
3678 d6f7 35 02                        PULS A              ; GET OLD MANTISSA SIGN
3679 d6f9 4d                           TSTA                ; * BRANCH IF OLD
3680 d6fa 2a 03                        BPL  LBFB7          ; * SIGN WAS POSITIVE
3681 d6fc bd d6 35                     JSR  LBEE9          ; TOGGLE MANTISSA SIGN
3682 d6ff 8e d7 0f           LBFB7     LDX  #LBFC7         ; POINT X TO TABLE OF COEFFICIENTS
3683 d702 7e d6 3c                     JMP  LBEF0          ; GO CALCULATE POLYNOMIAL VALUE
3684                         
3685 d705 83 49 0f da a2     LBFBD     FCB  $83,$49,$0F,$DA,$A2 ; 6.28318531 (2*PI)
3686 d70a 7f 00 00 00 00     LBFC2     FCB  $7F,$00,$00,$00,$00 ; .25
3687                         
3688                         
3689 d70f 05                 LBFC7     FCB  6-1            ; SIX COEFFICIENTS
3690 d710 84 e6 1a 2d 1b     LBFC8     FCB  $84,$E6,$1A,$2D,$1B ; * -((2*PI)**11)/11!
3691 d715 86 28 07 fb f8     LBFCD     FCB  $86,$28,$07,$FB,$F8 ; * ((2*PI)**9)/9!
3692 d71a 87 99 68 89 01     LBFD2     FCB  $87,$99,$68,$89,$01 ; * -((2*PI)**7)/7!
3693 d71f 87 23 35 df e1     LBFD7     FCB  $87,$23,$35,$DF,$E1 ; * ((2*PI)**5)/5!
3694 d724 86 a5 5d e7 28     LBFDC     FCB  $86,$A5,$5D,$E7,$28 ; * -((2*PI)**3)/3!
3695 d729 83 49 0f da a2     LBFE1     FCB  $83,$49,$0F,$DA,$A2 ; *
3696                         
3697 d72e a1 54 46 8f 13               FCB  $A1,$54,$46,$8F,$13 ; UNUSED GARBAGE BYTES
3698 d733 8f 52 43 89 cd               FCB  $8F,$52,$43,$89,$CD ; UNUSED GARBAGE BYTES
3699                         * EXTENDED BASIC
3700                         
3701                         * COS
3702                         * THE VALUE OF COS(X) IS DETERMINED BY THE TRIG IDENTITY COS(X)=SIN((PI/2)+X)
3703 d738 8e d7 6b           COS       LDX  #L83AB         ; POINT X TO FP CONSTANT (P1/2)
3704 d73b bd d1 0e                     JSR  LB9C2          ; ADD FPA0 TO (X)
3705 d73e 7e d6 c0           L837E     JMP  SIN            ; JUMP TO SIN ROUTINE
3706                         
3707                         * TAN
3708                         * THE VALUE OF TAN(X) IS DETERMINED BY THE TRIG IDENTITY TAN(X)=SIN(X)/COS(X)
3709 d741 bd d3 7b           TAN       JSR  LBC2F          ; PACK FPA0 AND MOVE IT TO FPA3
3710 d744 0f 0a                        CLR  RELFLG         ; RESET QUADRANT FLAG
3711 d746 8d f6                        BSR  L837E          ; CALCULATE SIN OF ARGUMENT
3712 d748 8e 00 4a                     LDX  #V4A           ; POINT X TO FPA5
3713 d74b bd d3 81                     JSR  LBC35          ; PACK FPA0 AND MOVE IT TO FPA5
3714 d74e 8e 00 40                     LDX  #V40           ; POINT X TO FPA3
3715 d751 bd d3 60                     JSR  LBC14          ; MOVE FPA3 TO FPA0
3716 d754 0f 54                        CLR  FP0SGN         ; FORCE FPA0 MANTISSA TO BE POSITIVE
3717 d756 96 0a                        LDA  RELFLG         ; GET THE QUADRANT FLAG - COS NEGATIVE IN QUADS 2,3
3718 d758 8d 0c                        BSR  L83A6          ; CALCULATE VALUE OF COS(FPA0)
3719 d75a 0d 4f                        TST  FP0EXP         ; CHECK EXPONENT OF FPA0
3720 d75c 10 27 fa 7e                  LBEQ LBA92          ; ''OV' ERROR IF COS(X)=0
3721 d760 8e 00 4a                     LDX  #V4A           ; POINT X TO FPA5
3722 d763 7e d2 db           L83A3     JMP  LBB8F          ; DIVIDE (X) BY FPA0 - SIN(X)/COS(X)
3723 d766 34 02              L83A6     PSHS A              ; SAVE SIGN FLAG ON STACK
3724 d768 7e d6 ee                     JMP  LBFA6          ; EXPAND POLYNOMIAL
3725                         
3726 d76b 81 49 0f da a2     L83AB     FCB  $81,$49,$0F,$DA,$A2 ; 1.57079633 (PI/2)
3727                         
3728                         * ATN
3729                         * A 12 TERM TAYLOR SERIES IS USED TO EVALUATE THE
3730                         * ARCTAN EXPRESSION. TWO  DIFFERENT FORMULI ARE USED
3731                         * TO EVALUATE THE EXPRESSION DEPENDING UPON
3732                         * WHETHER OR NOT THE ARGUMENT SQUARED IS > OR < 1.0
3733                         
3734                         * IF X**2<1 THEN ATN=X-(X**3)/3+(X**5)/5-(X**7)/7. . .
3735                         * IF X**2>=1 THEN ATN=PI/2-(1/X-1/((X**3)*3)+(1/((X**5)*5)-. . .)
3736                         
3737 d770 96 54              ATN       LDA  FP0SGN         ; * GET THE SIGN OF THE MANTISSA AND
3738 d772 34 02                        PSHS A              ; * SAVE IT ON THE STACK
3739 d774 2a 02                        BPL  L83B8          ; BRANCH IF POSITIVE MANTISSA
3740 d776 8d 24                        BSR  L83DC          ; CHANGE SIGN OF FPA0
3741 d778 96 4f              L83B8     LDA  FP0EXP         ; * GET EXPONENT OF FPA0 AND
3742 d77a 34 02                        PSHS A              ; * SAVE IT ON THE STACK
3743 d77c 81 81                        CMPA #$81           ; IS FPAO < 1.0?
3744 d77e 25 05                        BLO  L83C5          ; YES
3745 d780 8e d2 11                     LDX  #LBAC5         ; POINT X TO FP CONSTANT 1.0
3746 d783 8d de                        BSR  L83A3          ; GET RECIPROCAL OF FPA0
3747 d785 8e d7 a0           L83C5     LDX  #L83E0         ; POINT (X) TO TAYLOR SERIES COEFFICIENTS
3748 d788 bd d6 3c                     JSR  LBEF0          ; EXPAND POLYNOMIAL
3749 d78b 35 02                        PULS A              ; GET EXPONENT OF ARGUMENT
3750 d78d 81 81                        CMPA #$81           ; WAS ARGUMENT < 1.0?
3751 d78f 25 06                        BLO  L83D7          ; YES
3752 d791 8e d7 6b                     LDX  #L83AB         ; POINT (X) TO FP NUMBER (PI/2)
3753 d794 bd d1 05                     JSR  LB9B9          ; SUBTRACT FPA0 FROM (PI/2)
3754 d797 35 02              L83D7     PULS A              ; * GET SIGN OF INITIAL ARGUMENT MANTISSA
3755 d799 4d                           TSTA                ; * AND SET FLAGS ACCORDING TO IT
3756 d79a 2a 03                        BPL  L83DF          ; RETURN IF ARGUMENT WAS POSITIVE
3757 d79c 7e d6 35           L83DC     JMP  LBEE9          ; CHANGE MANTISSA SIGN OF FPA0
3758 d79f 39                 L83DF     RTS
3759                         *
3760                         * TCHEBYSHEV MODIFIED TAYLOR SERIES COEFFICIENTS FOR ARCTANGENT
3761 d7a0 0b                 L83E0     FCB  $0B            ; TWELVE COEFFICIENTS
3762 d7a1 76 b3 83 bd d3     L83E1     FCB  $76,$B3,$83,$BD,$D3 ; -6.84793912E-04 1/23
3763 d7a6 79 1e f4 a6 f5     L83E6     FCB  $79,$1E,$F4,$A6,$F5 ; +4.85094216E-03 1/21
3764 d7ab 7b 83 fc b0 10     L83EB     FCB  $7B,$83,$FC,$B0,$10 ; -0.0161117018
3765 d7b0 7c 0c 1f 67 ca     L83F0     FCB  $7C,$0C,$1F,$67,$CA ; 0.0342096381
3766 d7b5 7c de 53 cb c1     L83F5     FCB  $7C,$DE,$53,$CB,$C1 ; -0.0542791328
3767 d7ba 7d 14 64 70 4c     L83FA     FCB  $7D,$14,$64,$70,$4C ; 0.0724571965
3768 d7bf 7d b7 ea 51 7a     L83FF     FCB  $7D,$B7,$EA,$51,$7A ; -0.0898023954
3769 d7c4 7d 63 30 88 7e     L8404     FCB  $7D,$63,$30,$88,$7E ; 0.110932413
3770 d7c9 7e 92 44 99 3a     L8409     FCB  $7E,$92,$44,$99,$3A ; -0.142839808
3771 d7ce 7e 4c cc 91 c7     L840E     FCB  $7E,$4C,$CC,$91,$C7 ; 0.199999121
3772 d7d3 7f aa aa aa 13     L8413     FCB  $7F,$AA,$AA,$AA,$13 ; -0.333333316
3773 d7d8 81 00 00 00 00     L8418     FCB  $81,$00,$00,$00,$00 ; 1
3774                         *
3775                         *** TCHEBYSHEV MODIFIED TAYLOR SERIES COEFFICIENTS FOR LN(X)
3776                         *
3777 d7dd 03                 L841D     FCB  3              ; FOUR COEFFICIENTS
3778 d7de 7f 5e 56 cb 79     L841E     FCB  $7F,$5E,$56,$CB,$79 ; 0.434255942
3779 d7e3 80 13 9b 0b 64     L8423     FCB  $80,$13,$9B,$0B,$64 ; 0.576584541
3780 d7e8 80 76 38 93 16     L8428     FCB  $80,$76,$38,$93,$16 ; 0.961800759
3781 d7ed 82 38 aa 3b 20     L842D     FCB  $82,$38,$AA,$3B,$20 ; 2.88539007
3782                         
3783 d7f2 80 35 04 f3 34     L8432     FCB  $80,$35,$04,$F3,$34 ; 1/SQR(2)
3784                         
3785 d7f7 81 35 04 f3 34     L8437     FCB  $81,$35,$04,$F3,$34 ; SQR(2)
3786                         
3787 d7fc 80 80 00 00 00     L843C     FCB  $80,$80,$00,$00,$00 ; -0.5
3788                         
3789 d801 80 31 72 17 f8     L8441     FCB  $80,$31,$72,$17,$F8 ; LN(2)
3790                         *
3791                         * LOG - NATURAL LOGARITHM (LN)
3792                         
3793                         * THE NATURAL OR NAPERIAN LOGARITHM IS CALCULATED USING
3794                         * MATHEMATICAL IDENTITIES. FPA0 IS OF THE FORM FPA0=A*(2**B) (SCIENTIFIC
3795                         * NOTATION). THEREFORE, THE LOG ROUTINE DETERMINES THE VALUE OF
3796                         * LN(A*(2**B)). A SERIES OF MATHEMATICAL IDENTITIES WILL EXPAND THIS
3797                         * TERM: LN(A*(2**B))=(-1/2+(1/LN(2))*(LN(A*SQR(2)))+B)*LN(2). ALL OF
3798                         * THE TERMS OF THE LATTER EXPRESSION ARE CONSTANTS EXCEPT FOR THE
3799                         * LN(A*SQR(2)) TERM WHICH IS EVALUATED USING THE TAYLOR SERIES EXPANSION
3800 d806 bd d3 b9           LOG       JSR  LBC6D          ; CHECK STATUS OF FPA0
3801 d809 10 2f f3 c4                  LBLE LB44A          ; 'FC' ERROR IF NEGATIVE OR ZERO
3802 d80d 8e d7 f2                     LDX  #L8432         ; POINT (X) TO FP NUMBER (1/SQR(2))
3803 d810 96 4f                        LDA  FP0EXP         ; *GET EXPONENT OF ARGUMENT
3804 d812 80 80                        SUBA #$80           ; *SUBTRACT OFF THE BIAS AND
3805 d814 34 02                        PSHS A              ; *SAVE IT ON THE STACK
3806 d816 86 80                        LDA  #$80
3807 d818 97 4f                        STA  FP0EXP
3808 d81a bd d1 0e                     JSR  LB9C2          ; ADD FPA0 TO (X)
3809 d81d 8e d7 f7                     LDX  #L8437         ; POINT X TO SQR(2)
3810 d820 bd d2 db                     JSR  LBB8F          ; DIVIDE SQR(2) BY FPA0
3811 d823 8e d2 11                     LDX  #LBAC5         ; POINT X TO FP VALUE OF 1.00
3812 d826 bd d1 05                     JSR  LB9B9          ; SUBTRACT FPA0 FROM (X)
3813                         *         NOW  FPA0 = (1-SQR(2)*X)/(1+SQR(2)*X) WHERE X IS ARGUMENT
3814 d829 8e d7 dd                     LDX  #L841D         ; POINT X TO TABLE OF COEFFICIENTS
3815 d82c bd d6 3c                     JSR  LBEF0          ; EXPAND POLYNOMIAL
3816 d82f 8e d7 fc                     LDX  #L843C         ; POINT X TO FP VALUE OF (-.5)
3817 d832 bd d1 0e                     JSR  LB9C2          ; ADD FPA0 TO X
3818 d835 35 04                        PULS B              ; GET EXPONENT OF ARGUMENT BACK (WITHOUT BIAS)
3819 d837 bd d4 e5                     JSR  LBD99          ; ADD ACCB TO FPA0
3820 d83a 8e d8 01                     LDX  #L8441         ; POINT X TO LN(2)
3821 d83d 7e d2 16                     JMP  LBACA          ; MULTIPLY FPA0 * LN(2)
3822                         
3823                         * SQR
3824 d840 bd d3 ab           SQR       JSR  LBC5F          ; MOVE FPA0 TO FPA1
3825 d843 8e d6 0c                     LDX  #LBEC0         ; POINT (X) TO FP NUMBER (.5)
3826 d846 bd d3 60                     JSR  LBC14          ; COPY A PACKED NUMBER FROM (X) TO FPA0
3827                         
3828                         * ARITHMETIC OPERATOR FOR EXPONENTIATION JUMPS
3829                         * HERE. THE FORMULA USED TO EVALUATE EXPONENTIATION
3830                         * IS A**X=E**(X LN A) = E**(FPA0*LN(FPA1)), E=2.7182818
3831 d849 27 67              L8489     BEQ  EXP            ; DO A NATURAL EXPONENTIATION IF EXPONENT = 0
3832 d84b 4d                           TSTA                ; *CHECK VALUE BEING EXPONENTIATED
3833 d84c 26 03                        BNE  L8491          ; *AND BRANCH IF IT IS <> 0
3834 d84e 7e d1 86                     JMP  LBA3A          ; FPA0=0 IF RAISING ZERO TO A POWER
3835 d851 8e 00 4a           L8491     LDX  #V4A           ; * PACK FPA0 AND SAVE
3836 d854 bd d3 81                     JSR  LBC35          ; * IT IN FPA5 (ARGUMENT'S EXPONENT)
3837 d857 5f                           CLRB                ; ACCB=DEFAULT RESULT SIGN FLAG; 0=POSITIVE
3838 d858 96 61                        LDA  FP1SGN         ; *CHECK THE SIGN OF ARGUMENT
3839 d85a 2a 10                        BPL  L84AC          ; *BRANCH IF POSITIVE
3840 d85c bd d4 3a                     JSR  INT            ; CONVERT EXPONENT INTO AN INTEGER
3841 d85f 8e 00 4a                     LDX  #V4A           ; POINT X TO FPA5 (ORIGINAL EXPONENT)
3842 d862 96 61                        LDA  FP1SGN         ; GET MANTISSA SIGN OF FPA1 (ARGUMENT)
3843 d864 bd d3 ec                     JSR  LBCA0          ; *COMPARE FPA0 TO (X) AND
3844 d867 26 03                        BNE  L84AC          ; *BRANCH IF NOT EQUAL
3845 d869 43                           COMA                ; TOGGLE FPA1 MANTISSA SIGN - FORCE POSITIVE
3846 d86a d6 01                        LDB  CHARAC         ; GET LS BYTE OF INTEGER VALUE OF EXPONENT (RESULT SIGN FLAG)
3847 d86c bd d3 98           L84AC     JSR  LBC4C          ; COPY FPA1 TO FPA0; ACCA = MANTISSA SIGN
3848 d86f 34 04                        PSHS B              ; PUT RESULT SIGN FLAG ON THE STACK
3849 d871 bd d8 06                     JSR  LOG
3850 d874 8e 00 4a                     LDX  #V4A           ; POINT (X) TO FPA5
3851 d877 bd d2 16                     JSR  LBACA          ; MULTIPLY FPA0 BY FPA5
3852 d87a 8d 36                        BSR  EXP            ; CALCULATE E**(FPA0)
3853 d87c 35 02                        PULS A              ; * GET RESULT SIGN FLAG FROM THE STACK
3854 d87e 46                           RORA                ; * AND BRANCH IF NEGATIVE
3855 d87f 10 25 fd b2                  LBCS LBEE9          ; CHANGE SIGN OF FPA0 MANTISSA
3856 d883 39                           RTS
3857                         
3858                         * CORRECTION FACTOR FOR EXPONENTIAL FUNCTION
3859 d884 81 38 aa 3b 29     L84C4     FCB  $81,$38,$AA,$3B,$29 ; 1.44269504 ( CF )
3860                         *
3861                         * TCHEBYSHEV MODIFIED TAYLOR SERIES COEFFICIENTS FOR E**X
3862                         *
3863 d889 07                 L84C9     FCB  7              ; EIGHT COEFFICIENTS
3864 d88a 71 34 58 3e 56     L84CA     FCB  $71,$34,$58,$3E,$56 ; 2.14987637E-05: 1/(7!*(CF**7))
3865 d88f 74 16 7e b3 1b     L84CF     FCB  $74,$16,$7E,$B3,$1B ; 1.4352314E-04 : 1/(6!*(CF**6))
3866 d894 77 2f ee e3 85     L84D4     FCB  $77,$2F,$EE,$E3,$85 ; 1.34226348E-03: 1/(5!*(CF**5))
3867 d899 7a 1d 84 1c 2a     L84D9     FCB  $7A,$1D,$84,$1C,$2A ; 9.61401701E-03: 1/(4!*(CF**4))
3868 d89e 7c 63 59 58 0a     L84DE     FCB  $7C,$63,$59,$58,$0A ; 0.0555051269
3869 d8a3 7e 75 fd e7 c6     L84E3     FCB  $7E,$75,$FD,$E7,$C6 ; 0.240226385
3870 d8a8 80 31 72 18 10     L84E8     FCB  $80,$31,$72,$18,$10 ; 0.693147186
3871 d8ad 81 00 00 00 00     L84ED     FCB  $81,$00,$00,$00,$00 ; 1
3872                         *
3873                         * EXP ( E**X)
3874                         * THE EXPONENTIAL FUNCTION IS EVALUATED BY FIRST MULTIPLYING THE
3875                         * ARGUMENT BY A CORRECTION FACTOR (CF). AFTER THIS IS DONE, AN
3876                         * ARGUMENT >= 127 WILL YIELD A ZERO RESULT (NO UNDERFLOW) FOR A
3877                         * NEGATIVE ARGUMENT OR AN 'OV' (OVERFLOW) ERROR FOR A POSITIVE
3878                         * ARGUMENT. THE POLYNOMIAL COEFFICIENTS ARE MODIFIED TO REFLECT
3879                         * THE CF MULTIPLICATION AT THE START OF THE EVALUATION PROCESS.
3880                         
3881 d8b2 8e d8 84           EXP       LDX  #L84C4         ; POINT X TO THE CORRECTION FACTOR
3882 d8b5 bd d2 16                     JSR  LBACA          ; MULTIPLY FPA0 BY (X)
3883 d8b8 bd d3 7b                     JSR  LBC2F          ; PACK FPA0 AND STORE IT IN FPA3
3884 d8bb 96 4f                        LDA  FP0EXP         ; *GET EXPONENT OF FPA0 AND
3885 d8bd 81 88                        CMPA #$88           ; *COMPARE TO THE MAXIMUM VALUE
3886 d8bf 25 03                        BLO  L8504          ; BRANCH IF FPA0 < 128
3887 d8c1 7e d2 a8           L8501     JMP  LBB5C          ; SET FPA0 = 0 OR 'OV' ERROR
3888 d8c4 bd d4 3a           L8504     JSR  INT            ; CONVERT FPA0 TO INTEGER
3889 d8c7 96 01                        LDA  CHARAC         ; GET LS BYTE OF INTEGER
3890 d8c9 8b 81                        ADDA #$81           ; * WAS THE ARGUMENT =127, IF SO
3891 d8cb 27 f4                        BEQ  L8501          ; * THEN 'OV' ERROR; THIS WILL ALSO ADD THE $80 BIAS
3892                         *              ; * REQUIRED WHEN THE NEW EXPONENT IS CALCULATED BELOW
3893 d8cd 4a                           DECA                ; DECREMENT ONE FROM THE EXPONENT, BECAUSE $81, NOT $80 WAS USED ABOVE
3894 d8ce 34 02                        PSHS A              ; SAVE EXPONENT OF INTEGER PORTION ON STACK
3895 d8d0 8e 00 40                     LDX  #V40           ; POINT (X) TO FPA3
3896 d8d3 bd d1 05                     JSR  LB9B9          ; SUBTRACT FPA0 FROM (X) - GET FRACTIONAL PART OF ARGUMENT
3897 d8d6 8e d8 89                     LDX  #L84C9         ; POINT X TO COEFFICIENTS
3898 d8d9 bd d6 4b                     JSR  LBEFF          ; EVALUATE POLYNOMIAL FOR FRACTIONAL PART
3899 d8dc 0f 62                        CLR  RESSGN         ; FORCE THE MANTISSA TO BE POSITIVE
3900 d8de 35 02                        PULS A              ; GET INTEGER EXPONENT FROM STACK
3901 d8e0 bd d2 94                     JSR  LBB48          ; * CALCULATE EXPONENT OF NEW FPA0 BY ADDING THE EXPONENTS OF THE
3902                         *              ; * INTEGER AND FRACTIONAL PARTS
3903 d8e3 39                           RTS
3904                         
3905                         * FIX
3906 d8e4 bd d3 b9           FIX       JSR  LBC6D          ; CHECK STATUS OF FPA0
3907 d8e7 2b 03                        BMI  L852C          ; BRANCH IF FPA0 = NEGATIVE
3908 d8e9 7e d4 3a           L8529     JMP  INT            ; CONVERT FPA0 TO INTEGER
3909 d8ec 03 54              L852C     COM  FP0SGN         ; TOGGLE SIGN OF FPA0 MANTISSA
3910 d8ee 8d f9                        BSR  L8529          ; CONVERT FPA0 TO INTEGER
3911 d8f0 7e d6 35                     JMP  LBEE9          ; TOGGLE SIGN OF FPA0
3912                         
3913                         * EDIT
3914 d8f3 bd dd 21           EDIT      JSR  L89AE          ; GET LINE NUMBER FROM BASIC
3915 d8f6 32 62                        LEAS $02,S          ; PURGE RETURN ADDRESS OFF OF THE STACK
3916 d8f8 86 01              L8538     LDA  #$01           ; 'LIST' FLAG
3917 d8fa 97 98                        STA  VD8            ; SET FLAG TO LIST LINE
3918 d8fc bd c4 a5                     JSR  LAD01          ; GO FIND THE LINE NUMBER IN PROGRAM
3919 d8ff 10 25 ed 7f                  LBCS LAED2          ; ERROR #7 'UNDEFINED LINE #'
3920 d903 bd cf 3e                     JSR  LB7C2          ; GO UNCRUNCH LINE INTO BUFFER AT LINBUF+1
3921 d906 1f 20                        TFR  Y,D            ; PUT ABSOLUTE ADDRESS OF END OF LINE TO ACCD
3922 d908 83 00 f5                     SUBD #LINBUF+2      ; SUBTRACT OUT THE START OF LINE
3923 d90b d7 97                        STB  VD7            ; SAVE LENGTH OF LINE
3924 d90d dc 2b              L854D     LDD  BINVAL         ; GET THE HEX VALUE OF LINE NUMBER
3925 d90f bd d5 18                     JSR  LBDCC          ; LIST THE LINE NUMBER ON THE SCREEN
3926 d912 bd d0 f8                     JSR  LB9AC          ; PRINT A SPACE
3927 d915 8e 00 f4                     LDX  #LINBUF+1      ; POINT X TO BUFFER
3928 d918 d6 98                        LDB  VD8            ; * CHECK TO SEE IF LINE IS TO BE
3929 d91a 26 25                        BNE  L8581          ; * LISTED TO SCREEN - BRANCH IF IT IS
3930 d91c 5f                 L855C     CLRB                ; RESET DIGIT ACCUMULATOR - DEFAULT VALUE
3931 d91d bd da 47           L855D     JSR  L8687          ; GET KEY STROKE
3932 d920 bd e1 ec                     JSR  L90AA          ; SET CARRY IF NOT NUMERIC
3933 d923 25 0b                        BLO  L8570          ; BRANCH IF NOT NUMERIC
3934 d925 80 30                        SUBA #'0            ; MASK OFF ASCII
3935 d927 34 02                        PSHS A              ; SAVE IT ON STACK
3936 d929 86 0a                        LDA  #10            ; NUMBER BEING CONVERTED IS BASE 10
3937 d92b 3d                           MUL                 ; MULTIPLY ACCUMULATED VALUE BY BASE (10)
3938 d92c eb e0                        ADDB ,S+            ; ADD DIGIT TO ACCUMULATED VALUE
3939 d92e 20 ed                        BRA  L855D          ; CHECK FOR ANOTHER DIGIT
3940 d930 c0 01              L8570     SUBB #$01           ; * REPEAT PARAMETER IN ACCB; IF IT
3941 d932 c9 01                        ADCB #$01           ; *IS 0, THEN MAKE IT '1'
3942 d934 81 41                        CMPA #'A            ; ABORT?
3943 d936 26 05                        BNE  L857D          ; NO
3944 d938 bd d0 a8                     JSR  LB958          ; PRINT CARRIAGE RETURN TO SCREEN
3945 d93b 20 bb                        BRA  L8538          ; RESTART EDIT PROCESS - CANCEL ALL CHANGES
3946 d93d 81 4c              L857D     CMPA #'L            ; LIST?
3947 d93f 26 0b                        BNE  L858C          ; NO
3948 d941 8d 31              L8581     BSR  L85B4          ; LIST THE LINE
3949 d943 0f 98                        CLR  VD8            ; RESET THE LIST FLAG TO 'NO LIST'
3950 d945 bd d0 a8                     JSR  LB958          ; PRINT CARRIAGE RETURN
3951 d948 20 c3                        BRA  L854D          ; GO INTERPRET ANOTHER EDIT COMMAND
3952 d94a 32 62              L858A     LEAS $02,S          ; PURGE RETURN ADDRESS OFF OF THE STACK
3953 d94c 81 0d              L858C     CMPA #CR            ; ENTER KEY?
3954 d94e 26 0d                        BNE  L859D          ; NO
3955 d950 8d 22                        BSR  L85B4          ; ECHO THE LINE TO THE SCREEN
3956 d952 bd d0 a8           L8592     JSR  LB958          ; PRINT CARRIAGE RETURN
3957 d955 8e 00 f4                     LDX  #LINBUF+1      ; * RESET BASIC'S INPUT POINTER
3958 d958 9f 83                        STX  CHARAD         ; * TO THE LINE INPUT BUFFER
3959 d95a 7e c4 4e                     JMP  LACA8          ; GO PUT LINE BACK IN PROGRAM
3960 d95d 81 45              L859D     CMPA #'E            ; EXIT?
3961 d95f 27 f1                        BEQ  L8592          ; YES - SAME AS ENTER EXCEPT NO ECHO
3962 d961 81 51                        CMPA #'Q            ; QUIT?
3963 d963 26 06                        BNE  L85AB          ; NO
3964 d965 bd d0 a8                     JSR  LB958          ; PRINT CARRIAGE RETURN TO SCREEN
3965 d968 7e c4 25                     JMP  LAC73          ; GO TO COMMAND LEVEL - MAKE NO CHANGES
3966 d96b 8d 02              L85AB     BSR  L85AF          ; INTERPRET THE REMAINING COMMANDS AS SUBROUTINES
3967 d96d 20 ad                        BRA  L855C          ; GO INTERPRET ANOTHER EDIT COMMAND
3968 d96f 81 20              L85AF     CMPA #SPACE         ; SPACE BAR?
3969 d971 26 10                        BNE  L85C3          ; NO
3970 d973 8c                 L85B3     FCB  SKP2           ; SKIP TWO BYTES
3971                         * DISPLAY THE NEXT ACCB BYTES OF THE LINE IN THE BUFFER TO THE SCREEN
3972                         *
3973 d974 c6 f9              L85B4     LDB  #LBUFMX-1      ; 250 BYTES MAX IN BUFFER
3974 d976 a6 84              L85B6     LDA  ,X             ; GET A CHARACTER FROM BUFFER
3975 d978 27 08                        BEQ  L85C2          ; EXIT IF IT'S A 0
3976 d97a bd c0 17                     JSR  PUTCHR         ; SEND CHAR TO CONSOLE OUT
3977 d97d 30 01                        LEAX $01,X          ; MOVE POINTER UP ONE
3978 d97f 5a                           DECB                ; DECREMENT CHARACTER COUNTER
3979 d980 26 f4                        BNE  L85B6          ; LOOP IF NOT DONE
3980 d982 39                 L85C2     RTS
3981 d983 81 44              L85C3     CMPA #'D            ; DELETE?
3982 d985 26 48                        BNE  L860F          ; NO
3983 d987 6d 84              L85C7     TST  ,X             ; * CHECK FOR END OF LINE
3984 d989 27 f7                        BEQ  L85C2          ; * AND BRANCH IF SO
3985 d98b 8d 04                        BSR  L85D1          ; REMOVE A CHARACTER
3986 d98d 5a                           DECB                ; DECREMENT REPEAT PARAMETER
3987 d98e 26 f7                        BNE  L85C7          ; BRANCH IF NOT DONE
3988 d990 39                           RTS
3989                         * REMOVE ONE CHARACTER FROM BUFFER
3990 d991 0a 97              L85D1     DEC  VD7            ; DECREMENT LENGTH OF BUFFER
3991 d993 31 1f                        LEAY -1,X           ; POINT Y TO ONE BEFORE CURRENT BUFFER POINTER
3992 d995 31 21              L85D5     LEAY $01,Y          ; INCREMENT TEMPORARY BUFFER POINTER
3993 d997 a6 21                        LDA  $01,Y          ; GET NEXT CHARACTER
3994 d999 a7 a4                        STA  ,Y             ; PUT IT IN CURRENT POSITION
3995 d99b 26 f8                        BNE  L85D5          ; BRANCH IF NOT END OF LINE
3996 d99d 39                           RTS
3997 d99e 81 49              L85DE     CMPA #'I            ;  INSERT?
3998 d9a0 27 13                        BEQ  L85F5          ; YES
3999 d9a2 81 58                        CMPA #'X            ; EXTEND?
4000 d9a4 27 0d                        BEQ  L85F3          ; YES
4001 d9a6 81 48                        CMPA #'H            ; HACK?
4002 d9a8 26 5c                        BNE  L8646          ; NO
4003 d9aa 6f 84                        CLR  ,X             ; TURN CURRENT BUFFER POINTER INTO END OF LINE FLAG
4004 d9ac 1f 10                        TFR  X,D            ; PUT CURRENT BUFFER POINTER IN ACCD
4005 d9ae 83 00 f5                     SUBD #LINBUF+2      ; SUBTRACT INITIAL POINTER POSITION
4006 d9b1 d7 97                        STB  VD7            ; SAVE NEW BUFFER LENGTH
4007 d9b3 8d bf              L85F3     BSR  L85B4          ; DISPLAY THE LINE ON THE SCREEN
4008 d9b5 bd da 47           L85F5     JSR  L8687          ; GET A KEYSTROKE
4009 d9b8 81 0d                        CMPA #CR            ; ENTER KEY?
4010 d9ba 27 8e                        BEQ  L858A          ; YES - INTERPRET ANOTHER COMMAND - PRINT LINE
4011 d9bc 81 1b                        CMPA #ESC           ; ESCAPE?
4012 d9be 27 25                        BEQ  L8625          ; YES - RETURN TO COMMAND LEVEL - DON'T PRINT LINE
4013 d9c0 81 08                        CMPA #BS            ; BACK SPACE?
4014 d9c2 26 22                        BNE  L8626          ; NO
4015 d9c4 8c 00 f4                     CMPX #LINBUF+1      ; COMPARE POINTER TO START OF BUFFER
4016 d9c7 27 ec                        BEQ  L85F5          ; DO NOT ALLOW BS IF AT START
4017 d9c9 8d 45                        BSR  L8650          ; MOVE POINTER BACK ONE, BS TO SCREEN
4018 d9cb 8d c4                        BSR  L85D1          ; REMOVE ONE CHARACTER FROM BUFFER
4019 d9cd 20 e6                        BRA  L85F5          ; GET INSERT SUB COMMAND
4020 d9cf 81 43              L860F     CMPA #'C            ; CHANGE?
4021 d9d1 26 cb                        BNE  L85DE          ; NO
4022 d9d3 6d 84              L8613     TST  ,X             ; CHECK CURRENT BUFFER CHARACTER
4023 d9d5 27 0e                        BEQ  L8625          ; BRANCH IF END OF LINE
4024 d9d7 bd da 47                     JSR  L8687          ; GET A KEYSTROKE
4025 d9da 25 02                        BLO  L861E          ; BRANCH IF LEGITIMATE KEY
4026 d9dc 20 f5                        BRA  L8613          ; TRY AGAIN IF ILLEGAL KEY
4027 d9de a7 80              L861E     STA  ,X+            ; INSERT NEW CHARACTER INTO BUFFER
4028 d9e0 8d 37                        BSR  L8659          ; SEND NEW CHARACTER TO SCREEN
4029 d9e2 5a                           DECB                ; DECREMENT REPEAT PARAMETER
4030 d9e3 26 ee                        BNE  L8613          ; BRANCH IF NOT DONE
4031 d9e5 39                 L8625     RTS
4032 d9e6 d6 97              L8626     LDB  VD7            ; GET LENGTH OF LINE
4033 d9e8 c1 f9                        CMPB #LBUFMX-1      ; COMPARE TO MAXIMUM LENGTH
4034 d9ea 26 02                        BNE  L862E          ; BRANCH IF NOT AT MAXIMUM
4035 d9ec 20 c7                        BRA  L85F5          ; IGNORE INPUT IF LINE AT MAXIMUM LENGTH
4036 d9ee 34 10              L862E     PSHS X              ; SAVE CURRENT BUFFER POINTER
4037 d9f0 6d 80              L8630     TST  ,X+            ; * SCAN THE LINE UNTIL END OF
4038 d9f2 26 fc                        BNE  L8630          ; * LINE (0) IS FOUND
4039 d9f4 e6 82              L8634     LDB  ,-X            ; DECR TEMP LINE POINTER AND GET A CHARACTER
4040 d9f6 e7 01                        STB  $01,X          ; PUT CHARACTER BACK DOWN ONE SPOT
4041 d9f8 ac e4                        CMPX ,S             ; HAVE WE REACHED STARTING POINT?
4042 d9fa 26 f8                        BNE  L8634          ; NO - KEEP GOING
4043 d9fc 32 62                        LEAS $02,S          ; PURGE BUFFER POINTER FROM STACK
4044 d9fe a7 80                        STA  ,X+            ; INSERT NEW CHARACTER INTO THE LINE
4045 da00 8d 17                        BSR  L8659          ; SEND A CHARACTER TO CONSOLE OUT
4046 da02 0c 97                        INC  VD7            ; ADD ONE TO BUFFER LENGTH
4047 da04 20 af                        BRA  L85F5          ; GET INSERT SUB COMMAND
4048 da06 81 08              L8646     CMPA #BS            ; BACKSPACE?
4049 da08 26 12                        BNE  L865C          ; NO
4050 da0a 8d 04              L864A     BSR  L8650          ; MOVE POINTER BACK 1, SEND BS TO SCREEN
4051 da0c 5a                           DECB                ; DECREMENT REPEAT PARAMETER
4052 da0d 26 fb                        BNE  L864A          ; LOOP UNTIL DONE
4053 da0f 39                           RTS
4054 da10 8c 00 f4           L8650     CMPX #LINBUF+1      ; COMPARE POINTER TO START OF BUFFER
4055 da13 27 d0                        BEQ  L8625          ; DO NOT ALLOW BS IF AT START
4056 da15 30 1f                        LEAX -1,X           ; MOVE POINTER BACK ONE
4057 da17 86 08                        LDA  #BS            ; BACK SPACE
4058 da19 7e c0 17           L8659     JMP  PUTCHR         ; SEND TO CONSOLE OUT
4059 da1c 81 4b              L865C     CMPA #'K            ; KILL?
4060 da1e 27 05                        BEQ  L8665          ; YES
4061 da20 80 53                        SUBA #'S            ; SEARCH?
4062 da22 27 01                        BEQ  L8665          ; YES
4063 da24 39                           RTS
4064 da25 34 02              L8665     PSHS A              ; SAVE KILL/SEARCH FLAG ON STACK
4065 da27 8d 1e                        BSR  L8687          ; * GET A KEYSTROKE (TARGET CHARACTER)
4066 da29 34 02                        PSHS A              ; * AND SAVE IT ON STACK
4067 da2b a6 84              L866B     LDA  ,X             ; GET CURRENT BUFFER CHARACTER
4068 da2d 27 16                        BEQ  L8685          ; AND RETURN IF END OF LINE
4069 da2f 6d 61                        TST  $01,S          ; CHECK KILL/SEARCH FLAG
4070 da31 26 06                        BNE  L8679          ; BRANCH IF KILL
4071 da33 8d e4                        BSR  L8659          ; SEND A CHARACTER TO CONSOLE OUT
4072 da35 30 01                        LEAX $01,X          ; INCREMENT BUFFER POINTER
4073 da37 20 03                        BRA  L867C          ; CHECK NEXT INPUT CHARACTER
4074 da39 bd d9 91           L8679     JSR  L85D1          ; REMOVE ONE CHARACTER FROM BUFFER
4075 da3c a6 84              L867C     LDA  ,X             ; GET CURRENT INPUT CHARACTER
4076 da3e a1 e4                        CMPA ,S             ; COMPARE TO TARGET CHARACTER
4077 da40 26 e9                        BNE  L866B          ; BRANCH IF NO MATCH
4078 da42 5a                           DECB                ; DECREMENT REPEAT PARAMETER
4079 da43 26 e6                        BNE  L866B          ; BRANCH IF NOT DONE
4080 da45 35 a0              L8685     PULS Y,PC           ; THE Y PULL WILL CLEAN UP THE STACK FOR THE 2 PSHS A
4081                         *
4082                         * GET A KEYSTRKE
4083 da47 bd c0 03           L8687     JSR  LA171          ; CALL CONSOLE IN : DEV NBR=SCREEN
4084 da4a 81 7f                        CMPA #$7F           ; GRAPHIC CHARACTER?
4085 da4c 24 f9                        BCC  L8687          ; YES - GET ANOTHER CHAR
4086 da4e 81 5f                        CMPA #$5F           ; SHIFT UP ARROW (QUIT INSERT)
4087 da50 26 02                        BNE  L8694          ; NO
4088 da52 86 1b                        LDA  #ESC           ; REPLACE W/ESCAPE CODE
4089 da54 81 0d              L8694     CMPA #CR            ; ENTER KEY
4090 da56 27 0e                        BEQ  L86A6          ; YES
4091 da58 81 1b                        CMPA #ESC           ; ESCAPE?
4092 da5a 27 0a                        BEQ  L86A6          ; YES
4093 da5c 81 08                        CMPA #BS            ; BACKSPACE?
4094 da5e 27 06                        BEQ  L86A6          ; YES
4095 da60 81 20                        CMPA #SPACE         ; SPACE
4096 da62 25 e3                        BLO  L8687          ; GET ANOTHER CHAR IF CONTROL CHAR
4097 da64 1a 01                        ORCC #$01           ; SET CARRY
4098 da66 39                 L86A6     RTS
4099                         
4100                         * TRON
4101 da67 86                 TRON      FCB  SKP1LD         ; SKIP ONE BYTE AND LDA #$4F
4102                         
4103                         * TROFF
4104 da68 4f                 TROFF     CLRA                ; TROFF FLAG
4105 da69 97 8c                        STA  TRCFLG         ; TRON/TROFF FLAG:0=TROFF, <> 0=TRON
4106 da6b 39                           RTS
4107                         
4108                         * POS
4109                         
4110 da6c 86 00              POS       LDA  #0             ; GET DEVICE NUMBER
4111 da6e d6 79                        LDB  LPTPOS         ; GET PRINT POSITION
4112 da70 1d                 LA5E8     SEX                 ; CONVERT ACCB TO 2 DIGIT SIGNED INTEGER
4113 da71 7e cc 7b                     JMP  GIVABF         ; CONVERT ACCD TO FLOATING POINT
4114                         
4115                         
4116                         * VARPTR
4117 da74 bd c9 f6           VARPT     JSR  LB26A          ; SYNTAX CHECK FOR '('
4118 da77 dc 1f                        LDD  ARYEND         ; GET ADDR OF END OF ARRAYS
4119 da79 34 06                        PSHS B,A            ; SAVE IT ON STACK
4120 da7b bd ca de                     JSR  LB357          ; GET VARIABLE DESCRIPTOR
4121 da7e bd c9 f3                     JSR  LB267          ; SYNTAX CHECK FOR ')'
4122 da81 35 06                        PULS A,B            ; GET END OF ARRAYS ADDR BACK
4123 da83 1e 10                        EXG  X,D            ; SWAP END OF ARRAYS AND VARIABLE DESCRIPTOR
4124 da85 9c 1f                        CMPX ARYEND         ; COMPARE TO NEW END OF ARRAYS
4125 da87 26 51                        BNE  L8724          ; 'FC' ERROR IF VARIABLE WAS NOT DEFINED PRIOR TO CALLING VARPTR
4126 da89 7e cc 7b                     JMP  GIVABF         ; CONVERT VARIABLE DESCRIPTOR INTO A FP NUMBER
4127                         
4128                         * MID$(OLDSTRING,POSITION,LENGTH)=REPLACEMENT
4129 da8c 9d 7c              L86D6     JSR  GETNCH         ; GET INPUT CHAR FROM BASIC
4130 da8e bd c9 f6                     JSR  LB26A          ; SYNTAX CHECK FOR '('
4131 da91 bd ca de                     JSR  LB357          ; * GET VARIABLE DESCRIPTOR ADDRESS AND
4132 da94 34 10                        PSHS X              ; * SAVE IT ON THE STACK
4133 da96 ec 02                        LDD  $02,X          ; POINT ACCD TO START OF OLDSTRING
4134 da98 10 93 21                     CMPD FRETOP         ; COMPARE TO START OF CLEARED SPACE
4135 da9b 23 04                        BLS  L86EB          ; BRANCH IF <=
4136 da9d 93 27                        SUBD MEMSIZ         ; SUBTRACT OUT TOP OF CLEARED SPACE
4137 da9f 23 12                        BLS  L86FD          ; BRANCH IF STRING IN STRING SPACE
4138 daa1 e6 84              L86EB     LDB  ,X             ; GET LENGTH OF OLDSTRING
4139 daa3 bd cc f4                     JSR  LB56D          ; RESERVE ACCB BYTES IN STRING SPACE
4140 daa6 34 10                        PSHS X              ; SAVE RESERVED SPACE STRING ADDRESS ON STACK
4141 daa8 ae 62                        LDX  $02,S          ; POINT X TO OLDSTRING DESCRIPTOR
4142 daaa bd cd ca                     JSR  LB643          ; MOVE OLDSTRING INTO STRING SPACE
4143 daad 35 50                        PULS X,U            ; * GET OLDSTRING DESCRIPTOR ADDRESS AND RESERVED STRING
4144 daaf af 42                        STX  $02,U          ; * ADDRESS AND SAVE RESERVED ADDRESS AS OLDSTRING ADDRESS
4145 dab1 34 40                        PSHS U              ; SAVE OLDSTRING DESCRIPTOR ADDRESS
4146 dab3 bd ce bf           L86FD     JSR  LB738          ; SYNTAX CHECK FOR COMMA AND EVALUATE LENGTH EXPRESSION
4147 dab6 34 04                        PSHS B              ; SAVE POSITION PARAMETER ON STACK
4148 dab8 5d                           TSTB                ; * CHECK POSITION PARAMETER AND BRANCH
4149 dab9 27 1f                        BEQ  L8724          ; * IF START OF STRING
4150 dabb c6 ff                        LDB  #$FF           ; DEFAULT REPLACEMENT LENGTH = $FF
4151 dabd 81 29                        CMPA #')            ; * CHECK FOR END OF MID$ STATEMENT AND
4152 dabf 27 03                        BEQ  L870E          ; * BRANCH IF AT END OF STATEMENT
4153 dac1 bd ce bf                     JSR  LB738          ; SYNTAX CHECK FOR COMMA AND EVALUATE LENGTH EXPRESSION
4154 dac4 34 04              L870E     PSHS B              ; SAVE LENGTH PARAMETER ON STACK
4155 dac6 bd c9 f3                     JSR  LB267          ; SYNTAX CHECK FOR ')'
4156 dac9 c6 ae                        LDB  #TOK_EQUALS    ; TOKEN FOR =
4157 dacb bd c9 fb                     JSR  LB26F          ; SYNTAX CHECK FOR '='
4158 dace 8d 2e                        BSR  L8748          ; EVALUATE REPLACEMENT STRING
4159 dad0 1f 13                        TFR  X,U            ; SAVE REPLACEMENT STRING ADDRESS IN U
4160 dad2 ae 62                        LDX  $02,S          ; POINT X TO OLOSTRING DESCRIPTOR ADDRESS
4161 dad4 a6 84                        LDA  ,X             ; GET LENGTH OF OLDSTRING
4162 dad6 a0 61                        SUBA $01,S          ; SUBTRACT POSITION PARAMETER
4163 dad8 24 03                        BCC  L8727          ; INSERT REPLACEMENT STRING INTO OLDSTRING
4164 dada 7e cb d1           L8724     JMP  LB44A          ; 'FC' ERROR IF POSITION > LENGTH OF OLDSTRING
4165 dadd 4c                 L8727     INCA                ; * NOW ACCA = NUMBER OF CHARACTERS TO THE RIGHT
4166                         *                             ; * (INCLUSIVE) OF THE POSITION PARAMETER
4167 dade a1 e4                        CMPA ,S
4168 dae0 24 02                        BCC  L872E          ; BRANCH IF NEW STRING WILL FIT IN OLDSTRING
4169 dae2 a7 e4                        STA  ,S             ; IF NOT, USE AS MUCH OF LENGTH PARAMETER AS WILL FIT
4170 dae4 a6 61              L872E     LDA  $01,S          ; GET POSITION PARAMETER
4171 dae6 1e 89                        EXG  A,B            ; ACCA=LENGTH OF REPL STRING, ACCB=POSITION PARAMETER
4172 dae8 ae 02                        LDX  $02,X          ; POINT X TO OLDSTRING ADDRESS
4173 daea 5a                           DECB                ; * BASIC'S POSITION PARAMETER STARTS AT 1; THIS ROUTINE
4174                         *                             ; * WANTS IT TO START AT ZERO
4175 daeb 3a                           ABX                 ; POINT X TO POSITION IN OLDSTRING WHERE THE REPLACEMENT WILL GO
4176 daec 4d                           TSTA                ; * IF THE LENGTH OF THE REPLACEMENT STRING IS ZERO
4177 daed 27 0d                        BEQ  L8746          ; * THEN RETURN
4178 daef a1 e4                        CMPA ,S
4179 daf1 23 02                        BLS  L873F          ; ADJUSTED LENGTH PARAMETER, THEN BRANCH
4180 daf3 a6 e4                        LDA  ,S             ; OTHERWISE USE AS MUCH ROOM AS IS AVAILABLE
4181 daf5 1f 89              L873F     TFR  A,B            ; SAVE NUMBER OF BYTES TO MOVE IN ACCB
4182 daf7 1e 31                        EXG  U,X            ; SWAP SOURCE AND DESTINATION POINTERS
4183 daf9 bd c1 b1                     JSR  LA59A          ; MOVE (B) BYTES FROM (X) TO (U)
4184 dafc 35 96              L8746     PULS A,B,X,PC
4185 dafe bd c8 e2           L8748     JSR  LB156          ; EVALUATE EXPRESSION
4186 db01 7e cd db                     JMP  LB654          ; *'TM' ERROR IF NUMERIC; RETURN WITH X POINTING
4187                         *                             ; *TO STRING, ACCB = LENGTH
4188                         
4189                         * STRING
4190 db04 bd c9 f6           STRING    JSR  LB26A          ; SYNTAX CHECK FOR '('
4191 db07 bd ce 92                     JSR  LB70B          ; EVALUATE EXPRESSION; ERROR IF > 255
4192 db0a 34 04                        PSHS B              ; SAVE LENGTH OF STRING
4193 db0c bd c9 f9                     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
4194 db0f bd c8 e2                     JSR  LB156          ; EVALUATE EXPRESSION
4195 db12 bd c9 f3                     JSR  LB267          ; SYNTAX CHECK FOR ')'
4196 db15 96 06                        LDA  VALTYP         ; GET VARIABLE TYPE
4197 db17 26 05                        BNE  L8768          ; BRANCH IF STRING
4198 db19 bd ce 95                     JSR  LB70E          ; CONVERT FPA0 INTO AN INTEGER IN ACCB
4199 db1c 20 03                        BRA  L876B          ; SAVE THE STRING IN STRING SPACE
4200 db1e bd ce 2b           L8768     JSR  LB6A4          ; GET FIRST BYTE OF STRING
4201 db21 34 04              L876B     PSHS B              ; SAVE FIRST BYTE OF EXPRESSION
4202 db23 e6 61                        LDB  $01,S          ; GET LENGTH OF STRING
4203 db25 bd cc 96                     JSR  LB50F          ; RESERVE ACCB BYTES IN STRING SPACE
4204 db28 35 06                        PULS A,B            ; GET LENGTH OF STRING AND CHARACTER
4205 db2a 27 05                        BEQ  L877B          ; BRANCH IF NULL STRING
4206 db2c a7 80              L8776     STA  ,X+            ; SAVE A CHARACTER IN STRING SPACE
4207 db2e 5a                           DECB                ; DECREMENT LENGTH
4208 db2f 26 fb                        BNE  L8776          ; BRANCH IF NOT DONE
4209 db31 7e ce 22           L877B     JMP  LB69B          ; PUT STRING DESCRIPTOR ONTO STRING STACK
4210                         
4211                         * INSTR
4212 db34 bd c9 f6           INSTR     JSR  LB26A          ; SYNTAX CHECK FOR '('
4213 db37 bd c8 e2                     JSR  LB156          ; EVALUATE EXPRESSION
4214 db3a c6 01                        LDB  #$01           ; DEFAULT POSITION = 1 (SEARCH START)
4215 db3c 34 04                        PSHS B              ; SAVE START
4216 db3e 96 06                        LDA  VALTYP         ; GET VARIABLE TYPE
4217 db40 26 10                        BNE  L879C          ; BRANCH IF STRING
4218 db42 bd ce 95                     JSR  LB70E          ; CONVERT FPA0 TO INTEGER IN ACCB
4219 db45 e7 e4                        STB  ,S             ; SAVE START SEARCH VALUE
4220 db47 27 91                        BEQ  L8724          ; BRANCH IF START SEARCH AT ZERO
4221 db49 bd c9 f9                     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
4222 db4c bd c8 e2                     JSR  LB156          ; EVALUATE EXPRESSION - SEARCH STRING
4223 db4f bd c8 d2                     JSR  LB146          ; 'TM' ERROR IF NUMERIC
4224 db52 9e 52              L879C     LDX  FPA0+2         ; SEARCH STRING DESCRIPTOR ADDRESS
4225 db54 34 10                        PSHS X              ; SAVE ON THE STACK
4226 db56 bd c9 f9                     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
4227 db59 bd da fe                     JSR  L8748          ; EVALUATE TARGET STRING EXPRESSION
4228 db5c 34 14                        PSHS X,B            ; SAVE ADDRESS AND LENGTH ON STACK
4229 db5e bd c9 f3                     JSR  LB267          ; SYNTAX CHECK FOR ')'
4230 db61 ae 63                        LDX  $03,S          ; * LOAD X WITH SEARCH STRING DESCRIPTOR ADDRESS
4231 db63 bd cd e0                     JSR  LB659          ; * AND GET THE LENGTH ANDADDRESS OF SEARCH STRING
4232 db66 34 04                        PSHS B              ; SAVE LENGTH ON STACK
4233                         *
4234                         * AT THIS POINT THE STACK HAS THE FOLLOWING INFORMATION
4235                         * ON IT: 0,S-SEARCH LENGTH; 1,S-TARGET LENGTH; 2 3,S-TARGET
4236                         * ADDRESS; 4 5,S-SEARCH DESCRIPTOR ADDRESS; 6,S-SEARCH POSITION
4237 db68 e1 66                        CMPB $06,S          ; COMPARE LENGTH OF SEARCH STRING TO START
4238 db6a 25 23                        BLO  L87D9          ; POSITION; RETURN 0 IF LENGTH < START
4239 db6c a6 61                        LDA  $01,S          ; GET LENGTH OF TARGET STRING
4240 db6e 27 1c                        BEQ  L87D6          ; BRANCH IF TARGET STRING = NULL
4241 db70 e6 66                        LDB  $06,S          ; GET START POSITION
4242 db72 5a                           DECB                ; MOVE BACK ONE
4243 db73 3a                           ABX                 ; POINT X TO POSITION IN SEARCH STRING WHERE SEARCHING WILL START
4244 db74 31 84              L87BE     LEAY ,X             ; POINT Y TO SEARCH POSITION
4245 db76 ee 62                        LDU  $02,S          ; POINT U TO START OF TARGET
4246 db78 e6 61                        LDB  $01,S          ; LOAD ACCB WITH LENGTH OF TARGET
4247 db7a a6 e4                        LDA  ,S             ; LOAD ACCA WITH LENGTH OF SEARCH
4248 db7c a0 66                        SUBA $06,S          ; SUBTRACT SEARCH POSITION FROM SEARCH LENGTH
4249 db7e 4c                           INCA                ; ADD ONE
4250 db7f a1 61                        CMPA $01,S          ; COMPARE TO TARGET LENGTH
4251 db81 25 0c                        BLO  L87D9          ; RETURN 0 IF TARGET LENGTH > WHAT'S LEFT OF SEARCH STRING
4252 db83 a6 80              L87CD     LDA  ,X+            ; GET A CHARACTER FROM SEARCH STRING
4253 db85 a1 c0                        CMPA ,U+            ; COMPARE IT TO TARGET STRING
4254 db87 26 0c                        BNE  L87DF          ; BRANCH IF NO MATCH
4255 db89 5a                           DECB                ; DECREMENT TARGET LENGTH
4256 db8a 26 f7                        BNE  L87CD          ; CHECK ANOTHER CHARACTER
4257 db8c e6 66              L87D6     LDB  $06,S          ; GET MATCH POSITION
4258 db8e 21                 L87D8     FCB  SKP1           ; SKIP NEXT BYTE
4259 db8f 5f                 L87D9     CLRB                ; MATCH ADDRESS = 0
4260 db90 32 67                        LEAS $07,S          ; CLEAN UP THE STACK
4261 db92 7e cc 7a                     JMP  LB4F3          ; CONVERT ACCB TO FP NUMBER
4262 db95 6c 66              L87DF     INC  $06,S          ; INCREMENT SEARCH POSITION
4263 db97 30 21                        LEAX $01,Y          ; MOVE X TO NEXT SEARCH POSITION
4264 db99 20 d9                        BRA  L87BE          ; KEEP LOOKING FOR A MATCH
4265                         
4266                         * EXTENDED BASIC RVEC19 HOOK CODE
4267 db9b 81 26              XVEC19    CMPA #'&            ; *
4268 db9d 26 5c                        BNE  L8845          ; * RETURN IF NOT HEX OR OCTAL VARIABLE
4269 db9f 32 62                        LEAS $02,S          ; PURGE RETURN ADDRESS FROM STACK
4270                         * PROCESS A VARIABLE PRECEEDED BY A '&' (&H,&O)
4271 dba1 0f 52              L87EB     CLR  FPA0+2         ; * CLEAR BOTTOM TWO
4272 dba3 0f 53                        CLR  FPA0+3         ; * BYTES OF FPA0
4273 dba5 8e 00 52                     LDX  #FPA0+2        ; BYTES 2,3 OF FPA0 = (TEMPORARY ACCUMULATOR)
4274 dba8 9d 7c                        JSR  GETNCH         ; GET A CHARACTER FROM BASIC
4275 dbaa 81 4f                        CMPA #'O
4276 dbac 27 12                        BEQ  L880A          ; YES
4277 dbae 81 48                        CMPA #'H
4278 dbb0 27 23                        BEQ  L881F          ; YES
4279 dbb2 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
4280 dbb4 20 0c                        BRA  L880C          ; DEFAULT TO OCTAL (&O)
4281 dbb6 81 38              L8800     CMPA #'8
4282 dbb8 10 22 ee 47                  LBHI LB277
4283 dbbc c6 03                        LDB  #$03           ; BASE 8 MULTIPLIER
4284 dbbe 8d 2a                        BSR  L8834          ; ADD DIGIT TO TEMPORARY ACCUMULATOR
4285                         * EVALUATE AN &O VARIABLE
4286 dbc0 9d 7c              L880A     JSR  GETNCH         ; GET A CHARACTER FROM BASIC
4287 dbc2 25 f2              L880C     BLO  L8800          ; BRANCH IF NUMERIC
4288 dbc4 0f 50              L880E     CLR  FPA0           ; * CLEAR 2 HIGH ORDER
4289 dbc6 0f 51                        CLR  FPA0+1         ; * BYTES OF FPA0
4290 dbc8 0f 06                        CLR  VALTYP         ; SET VARXABLE TYPE TO NUMERIC
4291 dbca 0f 63                        CLR  FPSBYT         ; ZERO OUT SUB BYTE OF FPA0
4292 dbcc 0f 54                        CLR  FP0SGN         ; ZERO OUT MANTISSA SIGN OF FPA0
4293 dbce c6 a0                        LDB  #$A0           ; * SET EXPONENT OF FPA0
4294 dbd0 d7 4f                        STB  FP0EXP         ; *
4295 dbd2 7e d1 68                     JMP  LBA1C          ; GO NORMALIZE FPA0
4296                         * EVALUATE AN &H VARIABLE
4297 dbd5 9d 7c              L881F     JSR  GETNCH         ; GET A CHARACTER FROM BASIC
4298 dbd7 25 0b                        BLO  L882E          ; BRANCH IF NUMERIC
4299 dbd9 bd cb 29                     JSR  LB3A2          ; SET CARRY IF NOT ALPHA
4300 dbdc 25 e6                        BLO  L880E          ; BRANCH IF NOT ALPHA OR NUMERIC
4301 dbde 81 47                        CMPA #'G            ; CHECK FOR LETTERS A-F
4302 dbe0 24 e2                        BCC  L880E          ; BRANCH IF >= G (ILLEGAL HEX LETTER)
4303 dbe2 80 07                        SUBA #7             ; SUBTRACT ASCII DIFFERENCE BETWEEN A AND 9
4304 dbe4 c6 04              L882E     LDB  #$04           ; BASE 16 DIGIT MULTIPLIER = 2**4
4305 dbe6 8d 02                        BSR  L8834          ; ADD DIGIT TO TEMPORARY ACCUMULATOR
4306 dbe8 20 eb                        BRA  L881F          ; KEEP EVALUATING VARIABLE
4307 dbea 68 01              L8834     ASL  $01,X          ; * MULTIPLY TEMPORARY
4308 dbec 69 84                        ROL  ,X             ; * ACCUMULATOR BY TWO
4309 dbee 10 25 f5 ec                  LBCS LBA92          ; 'OV' OVERFLOW ERROR
4310 dbf2 5a                           DECB                ; DECREMENT SHIFT COUNTER
4311 dbf3 26 f5                        BNE  L8834          ; MULTIPLY TEMPORARY ACCUMULATOR AGAIN
4312 dbf5 80 30                        SUBA #'0            ; MASK OFF ASCII
4313 dbf7 ab 01                        ADDA $01,X          ; * ADD DIGIT TO TEMPORARY
4314 dbf9 a7 01                        STA  $01,X          ; * ACCUMULATOR AND SAVE IT
4315 dbfb 39                 L8845     RTS
4316                         
4317 dbfc 35 40              XVEC15    PULS U              ; PULL RETURN ADDRESS AND SAVE IN U REGISTER
4318 dbfe 0f 06                        CLR  VALTYP         ; SET VARIABLE TYPE TO NUMERIC
4319 dc00 9e 83                        LDX  CHARAD         ; CURRENT INPUT POINTER TO X
4320 dc02 9d 7c                        JSR  GETNCH         ; GET CHARACTER FROM BASIC
4321 dc04 81 26                        CMPA #'&            ; HEX AND OCTAL VARIABLES ARE PRECEEDED BY &
4322 dc06 27 99                        BEQ  L87EB          ; PROCESS A '&' VARIABLE
4323 dc08 81 b0                        CMPA #TOK_FN        ; TOKEN FOR FN
4324 dc0a 27 5e                        BEQ  L88B4          ; PROCESS FN CALL
4325 dc0c 81 ff                        CMPA #$FF           ; CHECK FOR SECONDARY TOKEN
4326 dc0e 26 08                        BNE  L8862          ; NOT SECONDARY
4327 dc10 9d 7c                        JSR  GETNCH         ; GET CHARACTER FROM BASIC
4328 dc12 81 83                        CMPA #TOK_USR       ; TOKEN FOR USR
4329 dc14 10 27 00 ab                  LBEQ L892C          ; PROCESS USR CALL
4330 dc18 9f 83              L8862     STX  CHARAD         ; RESTORE BASIC'S INPUT POINTER
4331 dc1a 6e c4                        JMP  ,U             ; RETURN TO CALLING ROUTINE
4332 dc1c 9e 68              L8866     LDX  CURLIN         ; GET CURRENT LINE NUMBER
4333 dc1e 30 01                        LEAX $01,X          ; IN DIRECT MODE?
4334 dc20 26 d9                        BNE  L8845          ; RETURN IF NOT IN DIRECT MODE
4335 dc22 c6 16                        LDB  #2*11          ; 'ILLEGAL DIRECT STATEMENT' ERROR
4336 dc24 7e c4 06           L886E     JMP  LAC46          ; PROCESS ERROR
4337                         
4338 dc27 ae 9f 00 83        DEF       LDX  [CHARAD]       ; GET TWO INPUT CHARS
4339 dc2b 8c ff 83                     CMPX #TOK_FF_USR    ; TOKEN FOR USR
4340 dc2e 10 27 00 74                  LBEQ L890F          ; BRANCH IF DEF USR
4341 dc32 8d 23                        BSR  L88A1          ; GET DESCRIPTOR ADDRESS FOR FN VARIABLE NAME
4342 dc34 8d e6                        BSR  L8866          ; DON'T ALLOW DEF FN IF IN DIRECT MODE
4343 dc36 bd c9 f6                     JSR  LB26A          ; SYNTAX CHECK FOR '('
4344 dc39 c6 80                        LDB  #$80           ; * GET THE FLAG TO INDICATE ARRAY VARIABLE SEARCH DISABLE
4345 dc3b d7 08                        STB  ARYDIS         ; * AND SAVE IT IN THE ARRAY DISABLE FLAG
4346 dc3d bd ca de                     JSR  LB357          ; GET VARIABLE DESCRIPTOR
4347 dc40 8d 25                        BSR  L88B1          ; 'TM' ERROR IF STRING
4348 dc42 bd c9 f3                     JSR  LB267          ; SYNTAX CHECK FOR ')'
4349 dc45 c6 ae                        LDB  #TOK_EQUALS    ; TOKEN FOR '='
4350 dc47 bd c9 fb                     JSR  LB26F          ; DO A SYNTAX CHECK FOR =
4351 dc4a 9e 4b                        LDX  V4B            ; GET THE ADDRESS OF THE FN NAME DESCRIPTOR
4352 dc4c dc 83                        LDD  CHARAD         ; * GET THE CURRENT INPUT POINTER ADDRESS AND
4353 dc4e ed 84                        STD  ,X             ; * SAVE IT IN FIRST 2 BYTES OF THE DESCRIPTOR
4354 dc50 dc 39                        LDD  VARPTR         ; = GET THE DESCRIPTOR ADDRESS OF THE ARGUMENT
4355 dc52 ed 02                        STD  $02,X          ; = VARIABLE AND SAVE IT IN THE DESCRIPTOR OF THE FN NAME
4356 dc54 7e c6 90                     JMP  DATA           ; MOVE INPUT POINTER TO END OF LINE OR SUBLINE
4357 dc57 c6 b0              L88A1     LDB  #TOK_FN        ; TOKEN FOR FN
4358 dc59 bd c9 fb                     JSR  LB26F          ; DO A SYNTAX CHECK FOR FN
4359 dc5c c6 80                        LDB  #$80           ; * GET THE FLAG TO INDICATE ARRAY VARIABLE SEARCH DISABLE FLAG
4360 dc5e d7 08                        STB  ARYDIS         ; * AND SAVE IT IN ARRAY VARIABLE FLAG
4361 dc60 8a 80                        ORA  #$80           ; SET BIT 7 OF CURRENT INPUT CHARACTER TO INDICATE AN FN VARIABLE
4362 dc62 bd ca e3                     JSR  LB35C          ; * GET THE DESCRIPTOR ADDRESS OF THIS
4363 dc65 9f 4b                        STX  V4B            ; * VARIABLE AND SAVE IT IN V4B
4364 dc67 7e c8 cf           L88B1     JMP  LB143          ; 'TM' ERROR IF STRING VARIABLE
4365                         * EVALUATE AN FN CALL
4366 dc6a 8d eb              L88B4     BSR  L88A1          ; * GET THE DESCRIPTOR OF THE FN NAME
4367 dc6c 34 10                        PSHS X              ; * VARIABLE AND SAVE IT ON THE STACK
4368 dc6e bd c9 ee                     JSR  LB262          ; SYNTAX CHECK FOR '(' & EVALUATE EXPR
4369 dc71 8d f4                        BSR  L88B1          ; 'TM' ERROR IF STRING VARIABLE
4370 dc73 35 40                        PULS U              ; POINT U TO FN NAME DESCRIPTOR
4371 dc75 c6 32                        LDB  #2*25          ; 'UNDEFINED FUNCTION CALL' ERROR
4372 dc77 ae 42                        LDX  $02,U          ; POINT X TO ARGUMENT VARIABLE DESCRIPTOR
4373 dc79 27 a9                        BEQ  L886E          ; BRANCH TO ERROR HANDLER
4374 dc7b 10 9e 83                     LDY  CHARAD         ; SAVE CURRENT INPUT POINTER IN Y
4375 dc7e ee c4                        LDU  ,U             ; * POINT U TO START OF FN FORMULA AND
4376 dc80 df 83                        STU  CHARAD         ; * SAVE IT IN INPUT POINTER
4377 dc82 a6 04                        LDA  $04,X          ; = GET FP VALUE OF
4378 dc84 34 02                        PSHS A              ; = ARGUMENT VARIABLE, CURRENT INPUT
4379 dc86 ec 84                        LDD  ,X             ; = POINTER, AND ADDRESS OF START
4380 dc88 ee 02                        LDU  $02,X          ; = OF FN FORMULA AND SAVE
4381 dc8a 34 76                        PSHS U,Y,X,B,A      ; = THEM ON THE STACK
4382 dc8c bd d3 81                     JSR  LBC35          ; PACK FPA0 AND SAVE IT IN (X)
4383 dc8f bd c8 cd           L88D9     JSR  LB141          ; EVALUATE FN EXPRESSION
4384 dc92 35 76                        PULS A,B,X,Y,U      ; RESTORE REGISTERS
4385 dc94 ed 84                        STD  ,X             ; * GET THE FP
4386 dc96 ef 02                        STU  $02,X          ; * VALUE OF THE ARGUMENT
4387 dc98 35 02                        PULS A              ; * VARIABLE OFF OF THE
4388 dc9a a7 04                        STA  $04,X          ; * STACK AND RE-SAVE IT
4389 dc9c 9d 82                        JSR  GETCCH         ; GET FINAL CHARACTER OF THE FN FORMULA
4390 dc9e 10 26 ed 61                  LBNE LB277          ; 'SYNTAX' ERROR IF NOT END OF LINE
4391 dca2 10 9f 83                     STY  CHARAD         ; RESTORE INPUT POINTER
4392 dca5 39                 L88EF     RTS
4393                         
4394                         
4395                         
4396                         * DEF USR
4397 dca6 9d 7c              L890F     JSR  GETNCH         ; SKIP PAST SECOND BYTE OF DEF USR TOKEN
4398 dca8 8d 09                        BSR  L891C          ; GET FN NUMBER
4399 dcaa 34 10                        PSHS X              ; SAVE FN EXEC ADDRESS STORAGE LOC
4400 dcac 8d 2d                        BSR  L8944          ; CALCULATE EXEC ADDRESS
4401 dcae 35 40                        PULS U              ; GET FN EXEC ADDRESS STORAGE LOC
4402 dcb0 af c4                        STX  ,U             ; SAVE EXEC ADDRESS
4403 dcb2 39                           RTS
4404 dcb3 5f                 L891C     CLRB                ; DEFAULT TO USR0 IF NO ARGUMENT
4405 dcb4 9d 7c                        JSR  GETNCH         ; GET A CHARACTER FROM BASIC
4406 dcb6 24 06                        BCC  L8927          ; BRANCH IF NOT NUMERIC
4407 dcb8 80 30                        SUBA #'0            ; MASK OFF ASCII
4408 dcba 1f 89                        TFR  A,B            ; SAVE USR NUMBER IN ACCB
4409 dcbc 9d 7c                        JSR  GETNCH         ; GET A CHARACTER FROM BASIC
4410 dcbe 9e 8d              L8927     LDX  USRADR         ; GET ADDRESS OF STORAGE LOCs FOR USR ADDRESS
4411 dcc0 58                           ASLB                ; X2 - 2 BYTES/USR ADDRESS
4412 dcc1 3a                           ABX                 ; ADD OFFSET TO START ADDRESS OF STORAGE LOCs
4413 dcc2 39                           RTS
4414                         * PROCESS A USR CALL
4415 dcc3 8d ee              L892C     BSR  L891C          ; GET STORAGE LOC OF EXEC ADDRESS FOR USR N
4416 dcc5 ae 84                        LDX  ,X             ; * GET EXEC ADDRESS AND
4417 dcc7 34 10                        PSHS X              ; * PUSH IT ONTO STACK
4418 dcc9 bd c9 ee                     JSR  LB262          ; SYNTAX CHECK FOR '(' & EVALUATE EXPR
4419 dccc 8e 00 4f                     LDX  #FP0EXP        ; POINT X TO FPA0
4420 dccf 96 06                        LDA  VALTYP         ; GET VARIABLE TYPE
4421 dcd1 27 07                        BEQ  L8943          ; BRANCH IF NUMERIC, STRING IF <> 0
4422 dcd3 bd cd de                     JSR  LB657          ; GET LENGTH & ADDRESS OF STRING VARIABLE
4423 dcd6 9e 52                        LDX  FPA0+2         ; GET POINTER TO STRING DESCRIPTOR
4424 dcd8 96 06                        LDA  VALTYP         ; GET VARIABLE TYPE
4425 dcda 39                 L8943     RTS                 ; JUMP TO USR ROUTINE (PSHS X ABOVE)
4426 dcdb c6 ae              L8944     LDB  #TOK_EQUALS    ; TOKEN FOR '='
4427 dcdd bd c9 fb                     JSR  LB26F          ; DO A SYNTAX CHECK FOR =
4428 dce0 7e ce c4                     JMP  LB73D          ; EVALUATE EXPRESSION, RETURN VALUE IN X
4429                         
4430                         
4431                         
4432                         * DEL
4433 dce3 10 27 ee ea        DEL       LBEQ LB44A          ; 'FC' ERROR IF NO ARGUMENT
4434 dce7 bd c7 17                     JSR  LAF67          ; CONVERT A DECIMAL BASiC NUMBER TO BINARY
4435 dcea bd c4 a5                     JSR  LAD01          ; FIND RAM ADDRESS OF START OF A BASIC LINE
4436 dced 9f 93                        STX  VD3            ; SAVE RAM ADDRESS OF STARTING LINE NUMBER
4437 dcef 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
4438 dcf1 27 10                        BEQ  L8990          ; BRANCH IF END OF LINE
4439 dcf3 81 a7                        CMPA #TOK_MINUS     ; TOKEN FOR '-'
4440 dcf5 26 3b                        BNE  L89BF          ; TERMINATE COMMAND IF LINE NUMBER NOT FOLLOWED BY '-'
4441 dcf7 9d 7c                        JSR  GETNCH         ; GET A CHARACTER FROM BASIC
4442 dcf9 27 04                        BEQ  L898C          ; IF END OF LINE, USE DEFAULT ENDING LINE NUMBER
4443 dcfb 8d 24                        BSR  L89AE          ; * CONVERT ENDING LINE NUMBER TO BINARY
4444 dcfd 20 04                        BRA  L8990          ; * AND SAVE IT IN BINVAL
4445 dcff 86 ff              L898C     LDA  #$FF           ; = USE $FFXX AS DEFAULT ENDING
4446 dd01 97 2b                        STA  BINVAL         ; = LINE NUMBER - SAVE IT IN BINVAL
4447 dd03 de 93              L8990     LDU  VD3            ; POINT U TO STARTING LINE NUMBER ADDRESS
4448 dd05 8c                 L8992     FCB  SKP2           ; SKIP TWO BYTES
4449 dd06 ee c4              L8993     LDU  ,U             ; POINT U TO START OF NEXT LINE
4450 dd08 ec c4                        LDD  ,U             ; CHECK FOR END OF PROGRAM
4451 dd0a 27 06                        BEQ  L899F          ; BRANCH IF END OF PROGRAM
4452 dd0c ec 42                        LDD  $02,U          ; LOAD ACCD WITH THIS LINE'S NUMBER
4453 dd0e 93 2b                        SUBD BINVAL         ; SUBTRACT ENDING LINE NUMBER ADDRESS
4454 dd10 23 f4                        BLS  L8993          ; BRANCH IF = < ENDING LINE NUMBER
4455 dd12 9e 93              L899F     LDX  VD3            ; GET STARTING LINE NUMBER
4456 dd14 8d 15                        BSR  L89B8          ; MOVE (U) TO (X) UNTIL END OF PROGRAM
4457 dd16 bd c4 c5                     JSR  LAD21          ; RESET BASIC'S INPUT POINTER AND ERASE VARIABLES
4458 dd19 9e 93                        LDX  VD3            ; GET STARTING LINE NUMBER ADDRESS
4459 dd1b bd c4 95                     JSR  LACF1          ; RECOMPUTE START OF NEXT LINE ADDRESSES
4460 dd1e 7e c4 25                     JMP  LAC73          ; JUMP TO BASIC'S MAIN COMMAND LOOP
4461 dd21 bd c7 17           L89AE     JSR  LAF67          ; GO GET LINE NUMBER CONVERTED TO BINARY
4462 dd24 7e c1 ba                     JMP  LA5C7          ; MAKE SURE THERE'S NO MORE ON THIS LINE
4463 dd27 a6 c0              L89B4     LDA  ,U+            ; GET A BYTE FROM (U)
4464 dd29 a7 80                        STA  ,X+            ; MOVE THE BYTE TO (X)
4465 dd2b 11 93 1b           L89B8     CMPU VARTAB         ; COMPARE TO END OF BASIC
4466 dd2e 26 f7                        BNE  L89B4          ; BRANCH IF NOT AT END
4467 dd30 9f 1b                        STX  VARTAB         ; SAVE (X) AS NEW END OF BASIC
4468 dd32 39                 L89BF     RTS
4469                         
4470                         
4471 dd33 bd dc 1c           L89C0     JSR  L8866          ; 'BS' ERROR IF IN DIRECT MODE
4472 dd36 9d 7c                        JSR  GETNCH         ; GET A CHAR FROM BASIC
4473 dd38 81 22              L89D2     CMPA #'"            ; CHECK FOR PROMPT STRING
4474 dd3a 26 0b                        BNE  L89E1          ; BRANCH IF NO PROMPT STRING
4475 dd3c bd c9 d0                     JSR  LB244          ; STRIP OFF PROMPT STRING & PUT IT ON STRING STACK
4476 dd3f c6 3b                        LDB  #';            ; *
4477 dd41 bd c9 fb                     JSR  LB26F          ; * DO A SYNTAX CHECK FOR;
4478 dd44 bd d0 eb                     JSR  LB99F          ; REMOVE PROMPT STRING FROM STRING STACK & SEND TO CONSOLE OUT
4479 dd47 32 7e              L89E1     LEAS -2,S           ; RESERVE TWO STORAGE SLOTS ON STACK
4480 dd49 bd c7 cc                     JSR  LB035          ; INPUT A LINE FROM CURRENT INPUT DEVICE
4481 dd4c 32 62                        LEAS $02,S          ; CLEAN UP THE STACK
4482 dd4e bd ca de                     JSR  LB357          ; SEARCH FOR A VARIABLE
4483 dd51 9f 3b                        STX  VARDES         ; SAVE POINTER TO VARIABLE DESCRIPTOR
4484 dd53 bd c8 d2                     JSR  LB146          ; ''TM' ERROR IF VARIABLE TYPE = NUMERIC
4485 dd56 8e 00 f3                     LDX  #LINBUF        ; POINT X TO THE STRING BUFFER WHERE THE INPUT STRING WAS STORED
4486 dd59 4f                           CLRA                ; TERMINATOR CHARACTER 0 (END OF LINE)
4487 dd5a bd cc a3                     JSR  LB51A          ; PARSE THE INPUT STRING AND STORE IT IN THE STRING SPACE
4488 dd5d 7e c7 54                     JMP  LAFA4          ; REMOVE DESCRIPTOR FROM STRING STACK
4489 dd60 bd c7 17           L89FC     JSR  LAF67          ; STRIP A DECIMAL NUMBER FROM BASIC INPUT LINE
4490 dd63 9e 2b                        LDX  BINVAL         ; GET BINARY VALUE
4491 dd65 39                           RTS
4492 dd66 9e 91              L8A02     LDX  VD1            ; GET CURRENT OLD NUMBER BEING RENUMBERED
4493 dd68 9f 2b              L8A04     STX  BINVAL         ; SAVE THE LINE NUMBER BEING SEARCHED FOR
4494 dd6a 7e c4 a5                     JMP  LAD01          ; GO FIND THE LINE NUMBER IN BASIC PROGRAM
4495                         
4496                         * RENUM
4497 dd6d bd c4 ca           RENUM     JSR  LAD26          ; ERASE VARIABLES
4498 dd70 cc 00 0a                     LDD  #10            ; DEFAULT LINE NUMBER INTERVAL
4499 dd73 dd 95                        STD  VD5            ; SAVE DEFAULT RENUMBER START LINE NUMBER
4500 dd75 dd 8f                        STD  VCF            ; SAVE DEFAULT INTERVAL
4501 dd77 5f                           CLRB                ; NOW ACCD = 0
4502 dd78 dd 91                        STD  VD1            ; DEFAULT LINE NUMBER OF WHERE TO START RENUMBERING
4503 dd7a 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
4504 dd7c 24 06                        BCC  L8A20          ; BRANCH IF NOT NUMERIC
4505 dd7e 8d e0                        BSR  L89FC          ; CONVERT DECIMAL NUMBER IN BASIC PROGRAM TO BINARY
4506 dd80 9f 95                        STX  VD5            ; SAVE LINE NUMBER WHERE RENUMBERING STARTS
4507 dd82 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
4508 dd84 27 1b              L8A20     BEQ  L8A3D          ; BRANCH IF END OF LINE
4509 dd86 bd c9 f9                     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
4510 dd89 24 06                        BCC  L8A2D          ; BRANCH IF NEXT CHARACTER NOT NUMERIC
4511 dd8b 8d d3                        BSR  L89FC          ; CONVERT DECIMAL NUMBER IN BASIC PROGRAM TO BINARY
4512 dd8d 9f 91                        STX  VD1            ; SAVE NEW RENUMBER LINE
4513 dd8f 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
4514 dd91 27 0e              L8A2D     BEQ  L8A3D          ; BRANCH IF END OF LINE
4515 dd93 bd c9 f9                     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
4516 dd96 24 06                        BCC  L8A3A          ; BRANCH IF NEXT CHARACTER NOT NUMERIC
4517 dd98 8d c6                        BSR  L89FC          ; CONVERT DECIMAL NUMBER IN BASIC PROGRAM TO BINARY
4518 dd9a 9f 8f                        STX  VCF            ; SAVE NEW INTERVAL
4519 dd9c 27 49                        BEQ  L8A83          ; 'FC' ERROR
4520 dd9e bd c1 ba           L8A3A     JSR  LA5C7          ; CHECK FOR MORE CHARACTERS ON LINE - 'SYNTAX' ERROR IF ANY
4521 dda1 8d c3              L8A3D     BSR  L8A02          ; GO GET ADDRESS OF OLD NUMBER BEING RENUMBERED
4522 dda3 9f 93                        STX  VD3            ; SAVE ADDRESS
4523 dda5 9e 95                        LDX  VD5            ; GET NEXT RENUMBERED LINE NUMBER TO USE
4524 dda7 8d bf                        BSR  L8A04          ; FIND THE LINE NUMBER IN THE BASIC PROGRAM
4525 dda9 9c 93                        CMPX VD3            ; COMPARE TO ADDRESS OF OLD LINE NUMBER
4526 ddab 25 3a                        BLO  L8A83          ; 'FC' ERROR IF NEW ADDRESS < OLD ADDRESS
4527 ddad 8d 1c                        BSR  L8A67          ; MAKE SURE RENUMBERED LINE NUMBERS WILL BE IN RANGE
4528 ddaf bd de 41                     JSR  L8ADD          ; CONVERT ASCII LINE NUMBERS TO 'EXPANDED' BINARY
4529 ddb2 bd c4 93                     JSR  LACEF          ; RECALCULATE NEXT LINE RAM ADDRESSES
4530 ddb5 8d af                        BSR  L8A02          ; GET RAM ADDRESS OF FIRST LINE TO BE RENUMBERED
4531 ddb7 9f 93                        STX  VD3            ; SAVE IT
4532 ddb9 8d 3a                        BSR  L8A91          ; MAKE SURE LINE NUMBERS EXIST
4533 ddbb 8d 0f                        BSR  L8A68          ; INSERT NEW LINE NUMBERS IN LINE HEADERS
4534 ddbd 8d 36                        BSR  L8A91          ; INSERT NEW LINE NUMBERS IN PROGRAM STATEMENTS
4535 ddbf bd de dc                     JSR  L8B7B          ; CONVERT PACKED BINARY LINE NUMBERS TO ASCII
4536 ddc2 bd c4 ca                     JSR  LAD26          ; ERASE VARIABLES
4537 ddc5 bd c4 93                     JSR  LACEF          ; RECALCULATE NEXT LINE RAM ADDRESS
4538 ddc8 7e c4 25                     JMP  LAC73          ; GO BACK TO BASIC'S MAIN LOOP
4539 ddcb 86                 L8A67     FCB  SKP1LD         ; SKIP ONE BYTE - LDA #$4F
4540 ddcc 4f                 L8A68     CLRA                ; NEW LINE NUMBER FLAG - 0; INSERT NEW LINE NUMBERS
4541 ddcd 97 98                        STA  VD8            ; SAVE NEW LINE NUMBER FLAG; 0 = INSERT NEW NUMBERS
4542 ddcf 9e 93                        LDX  VD3            ; GET ADDRESS OF OLD LINE NUMBER BEING RENUMBERED
4543 ddd1 dc 95                        LDD  VD5            ; GET THE CURRENT RENUMBERED LINE NUMBER
4544 ddd3 8d 15                        BSR  L8A86          ; RETURN IF END OF PROGRAM
4545 ddd5 0d 98              L8A71     TST  VD8            ; CHECK NEW LINE NUMBER FLAG
4546 ddd7 26 02                        BNE  L8A77          ; BRANCH IF NOT INSERTING NEW LINE NUMBERS
4547 ddd9 ed 02                        STD  $02,X          ; STORE THE NEW LINE NUMBER IN THE BASIC PROGRAM
4548 dddb ae 84              L8A77     LDX  ,X             ; POINT X TO THE NEXT LINE IN BASIC
4549 dddd 8d 0b                        BSR  L8A86          ; RETURN IF END OF PROGRAM
4550 dddf d3 8f                        ADDD VCF            ; ADD INTERVAL TO CURRENT RENUMBERED LINE NUMBER
4551 dde1 25 04                        BLO  L8A83          ; 'FC' ERROR IF LINE NUMBER > $FFFF
4552 dde3 81 fa                        CMPA #MAXLIN        ; LARGEST LINE NUMBER = $F9FF
4553 dde5 25 ee                        BLO  L8A71          ; BRANCH IF LEGAL LINE NUMBER
4554 dde7 7e cb d1           L8A83     JMP  LB44A          ; 'FC' ERROR IF LINE NUMBER MS BYTE > $F9
4555                         * TEST THE TWO BYTES POINTED TO BY (X).
4556                         * NORMAL RETURN IF <> 0. IF = 0 (END OF
4557                         * PROGRAM) RETURN IS PULLED OFF STACK AND
4558                         * YOU RETURN TO PREVIOUS SUBROUTINE CALL.
4559 ddea 34 06              L8A86     PSHS B,A            ; SAVE ACCD
4560 ddec ec 84                        LDD  ,X             ; TEST THE 2 BYTES POINTED TO BY X
4561 ddee 35 06                        PULS A,B            ; RESTORE ACCD
4562 ddf0 26 02                        BNE  L8A90          ; BRANCH IF NOT END OF PROGRAM
4563 ddf2 32 62                        LEAS $02,S          ; PURGE RETURN ADDRESS FROM STACK
4564 ddf4 39                 L8A90     RTS
4565 ddf5 9e 19              L8A91     LDX  TXTTAB         ; GET START OF BASIC PROGRAM
4566 ddf7 30 1f                        LEAX -1,X           ; MOVE POINTER BACK ONE
4567 ddf9 30 01              L8A95     LEAX $01,X          ; MOVE POINTER UP ONE
4568 ddfb 8d ed                        BSR  L8A86          ; RETURN IF END OF PROGRAM
4569 ddfd 30 03              L8A99     LEAX $03,X          ; SKIP OVER NEXT LINE ADDRESS AND LINE NUMBER
4570 ddff 30 01              L8A9B     LEAX $01,X          ; MOVE POINTER TO NEXT CHARACTER
4571 de01 a6 84                        LDA  ,X             ; CHECK CURRENT CHARACTER
4572 de03 27 f4                        BEQ  L8A95          ; BRANCH IF END OF LINE
4573 de05 9f 0f                        STX  TEMPTR         ; SAVE CURRENT POINTER
4574 de07 4a                           DECA                ; =
4575 de08 27 0c                        BEQ  L8AB2          ; =BRANCH IF START OF PACKED NUMERIC LINE
4576 de0a 4a                           DECA                ; *
4577 de0b 27 2a                        BEQ  L8AD3          ; *BRANCH IF LINE NUMBER EXISTS
4578 de0d 4a                           DECA                ; =
4579 de0e 26 ef                        BNE  L8A9B          ; =MOVE TO NEXT CHARACTER IF > 3
4580 de10 86 03              L8AAC     LDA  #$03           ; * SET 1ST BYTE = 3 TO INDICATE LINE
4581 de12 a7 80                        STA  ,X+            ; * NUMBER DOESN'T CURRENTLY EXIST
4582 de14 20 e7                        BRA  L8A99          ; GO GET ANOTHER CHARACTER
4583 de16 ec 01              L8AB2     LDD  $01,X          ; GET MS BYTE OF LINE NUMBER
4584 de18 6a 02                        DEC  $02,X          ; DECREMENT ZERO CHECK BYTE
4585 de1a 27 01                        BEQ  L8AB9          ; BRANCH IF MS BYTE <> 0
4586 de1c 4f                           CLRA                ; CLEAR MS BYTE
4587 de1d e6 03              L8AB9     LDB  $03,X          ; GET LS BYTE OF LINE NUMBER
4588 de1f 6a 04                        DEC  $04,X          ; DECREMENT ZERO CHECK FLAG
4589 de21 27 01                        BEQ  L8AC0          ; BRANCH IF IS BYTE <> 0
4590 de23 5f                           CLRB                ; CLEAR LS BYTE
4591 de24 ed 01              L8AC0     STD  $01,X          ; SAVE BINARY LINE NUMBER
4592 de26 dd 2b                        STD  BINVAL         ; SAVE TRIAL LINE NUMBER
4593 de28 bd c4 a5                     JSR  LAD01          ; FIND RAM ADDRESS OF A BASIC LINE NUMBER
4594 de2b 9e 0f              L8AC7     LDX  TEMPTR         ; GET BACK POINTER TO START OF PACKED LINE NUMBER
4595 de2d 25 e1                        BLO  L8AAC          ; BRANCH IF NO LINE NUMBER MATCH FOUND
4596 de2f dc 47                        LDD  V47            ; GET START ADDRESS OF LINE NUMBER
4597 de31 6c 80                        INC  ,X+            ; * SET 1ST BYTE = 2, TO INDICATE LINE NUMBER EXISTS IF CHECKING FOR
4598                         *              ; * EXISTENCE OF LINE NUMBER, SET IT = 1 IF INSERTING LINE NUMBERS
4599                         
4600 de33 ed 84                        STD  ,X             ; SAVE RAM ADDRESS OF CORRECT LINE NUMBER
4601 de35 20 c6                        BRA  L8A99          ; GO GET ANOTHER CHARACTER
4602 de37 6f 84              L8AD3     CLR  ,X             ; CLEAR CARRY FLAG AND 1ST BYTE
4603 de39 ae 01                        LDX  $01,X          ; POINT X TO RAM ADDRESS OF CORRECT LINE NUMBER
4604 de3b ae 02                        LDX  $02,X          ; PUT CORRECT LINE NUMBER INTO (X)
4605 de3d 9f 47                        STX  V47            ; SAVE IT TEMPORARILY
4606 de3f 20 ea                        BRA  L8AC7          ; GO INSERT IT INTO BASIC LINE
4607 de41 9e 19              L8ADD     LDX  TXTTAB         ; GET BEGINNING OF BASIC PROGRAM
4608 de43 20 04                        BRA  L8AE5
4609 de45 9e 83              L8AE1     LDX  CHARAD         ; *GET CURRENT INPUT POINTER
4610 de47 30 01                        LEAX $01,X          ; *AND BUMP IT ONE
4611 de49 8d 9f              L8AE5     BSR  L8A86          ; RETURN IF END OF PROGRAM
4612 de4b 30 02                        LEAX $02,X          ; SKIP PAST NEXT LINE ADDRESS
4613 de4d 30 01              L8AE9     LEAX $01,X          ; ADVANCE POINTER BY ONE
4614 de4f 9f 83              L8AEB     STX  CHARAD         ; SAVE NEW BASIC INPUT POINTER
4615 de51 9d 7c              L8AED     JSR  GETNCH         ; GET NEXT CHARACTER FROM BASIC
4616 de53 4d                 L8AEF     TSTA                ; CHECK THE CHARACTER
4617 de54 27 ef                        BEQ  L8AE1          ; BRANCH IF END OF LINE
4618 de56 2a f9                        BPL  L8AED          ; BRANCH IF NOT A TOKEN
4619 de58 9e 83                        LDX  CHARAD         ; GET CURRENT INPUT POINTER
4620 de5a 81 ff                        CMPA #$FF           ; IS THIS A SECONDARY TOKEN?
4621 de5c 27 ef                        BEQ  L8AE9          ; YES - IGNORE IT
4622 de5e 81 a2                        CMPA #TOK_THEN      ; TOKEN FOR THEN?
4623 de60 27 12                        BEQ  L8B13          ; YES
4624 de62 81 84                        CMPA #TOK_ELSE      ; TOKEN FOR ELSE?
4625 de64 27 0e                        BEQ  L8B13          ; YES
4626 de66 81 81                        CMPA #TOK_GO        ; TOKEN FOR GO?
4627 de68 26 e7                        BNE  L8AED          ; NO
4628 de6a 9d 7c                        JSR  GETNCH         ; GET A CHARACTER FROM BASIC
4629 de6c 81 a0                        CMPA #TOK_TO        ; TOKEN FOR TO?
4630 de6e 27 04                        BEQ  L8B13          ; YES
4631 de70 81 a1                        CMPA #TOK_SUB       ; TOKEN FOR SUB?
4632 de72 26 db                        BNE  L8AEB          ; NO
4633 de74 9d 7c              L8B13     JSR  GETNCH         ; GET A CHARACTER FROM BASIC
4634 de76 25 04                        BLO  L8B1B          ; BRANCH IF NUMERIC
4635 de78 9d 82              L8B17     JSR  GETCCH         ; GET CURRENT BASIC INPUT CHARRACTER
4636 de7a 20 d7                        BRA  L8AEF          ; KEEP CHECKING THE LINE
4637 de7c 9e 83              L8B1B     LDX  CHARAD         ; GET CURRENT INPUT ADDRESS
4638 de7e 34 10                        PSHS X              ; SAVE IT ON THE STACK
4639 de80 bd c7 17                     JSR  LAF67          ; CONVERT DECIMAL BASIC NUMBER TO BINARY
4640 de83 9e 83                        LDX  CHARAD         ; GET CURRENT INPUT POINTER
4641 de85 a6 82              L8B24     LDA  ,-X            ; GET PREVIOUS INPUT CHARACTER
4642 de87 bd e1 ec                     JSR  L90AA          ; CLEAR CARRY IF NUMERIC INPUT VALUE
4643 de8a 25 f9                        BLO  L8B24          ; BRANCH IF NON-NUMERIC
4644 de8c 30 01                        LEAX $01,X          ; MOVE POINTER UP ONE
4645 de8e 1f 10                        TFR  X,D            ; NOW ACCD POINTS TO ONE PAST END OF LINE NUMBER
4646 de90 e0 61                        SUBB $01,S          ; SUBTRACT PRE-NUMERIC POINTER LS BYTE
4647 de92 c0 05                        SUBB #$05           ; MAKE SURE THERE ARE AT LEAST 5 CHARACTERS IN THE NUMERIC LINE
4648                         *
4649 de94 27 20                        BEQ  L8B55          ; BRANCH IF EXACTLY 5
4650 de96 25 0a                        BLO  L8B41          ; BRANCH IF < 5
4651 de98 33 84                        LEAU ,X             ; TRANSFER X TO U
4652 de9a 50                           NEGB                ; NEGATE B
4653 de9b 30 85                        LEAX B,X            ; MOVE X BACK B BYTES
4654 de9d bd dd 2b                     JSR  L89B8          ; *MOVE BYTES FROM (U) TO (X) UNTIL
4655                         *         *U   = END OF BASIC; (I) = NEW END OF BASIC
4656 dea0 20 14                        BRA  L8B55
4657                         * FORCE FIVE BYTES OF SPACE FOR THE LINE NUMBER
4658 dea2 9f 47              L8B41     STX  V47            ; SAVE END OF NUMERIC VALUE
4659 dea4 9e 1b                        LDX  VARTAB         ; GET END OF BASIC PROGRAM
4660 dea6 9f 43                        STX  V43            ; SAVE IT
4661 dea8 50                           NEGB                ; NEGATE B
4662 dea9 30 85                        LEAX B,X            ; ADD IT TO END OF NUMERIC POiNTER
4663 deab 9f 41                        STX  V41            ; SAVE POINTER
4664 dead 9f 1b                        STX  VARTAB         ; STORE END OF BASIC PROGRAM
4665 deaf bd c3 de                     JSR  LAC1E          ; ACCD = TOP OF ARRAYS - CHECK FOR ENOUGH ROOM
4666 deb2 9e 45                        LDX  V45            ; * GET AND SAVE THE
4667 deb4 9f 83                        STX  CHARAD         ; * NEW CURRENT INPUT POINTER
4668 deb6 35 10              L8B55     PULS X              ; RESTORE POINTER TO START OF NUMERIC VALUE
4669 deb8 86 01                        LDA  #$01           ; NEW LINE NUMBER FLAG
4670 deba a7 84                        STA  ,X             ; * SAVE NEW LINE FLAG
4671 debc a7 02                        STA  $02,X          ; *
4672 debe a7 04                        STA  $04,X          ; *
4673 dec0 d6 2b                        LDB  BINVAL         ; GET MS BYTE OF BINARY LINE NUMBER
4674 dec2 26 04                        BNE  L8B67          ; BRANCH IF IT IS NOT ZERO
4675 dec4 c6 01                        LDB  #$01           ; ; SAVE A 1 IF BYTE IS 0; OTHERWISE, BASIC WILL
4676                         *              ; THINK IT IS THE END OF A LINE
4677 dec6 6c 02                        INC  $02,X          ; IF 2,X = 2, THEN PREVIOUS BYTE WAS A ZERO
4678 dec8 e7 01              L8B67     STB  $01,X          ; SAVE MS BYTE OF BINARY LINE NUMBER
4679 deca d6 2c                        LDB  BINVAL+1       ; GET IS BYTE OF BINARY LINE NUMBER
4680 decc 26 04                        BNE  L8B71          ; BRANCH IF NOT A ZERO BYTE
4681 dece c6 01                        LDB  #$01           ; SAVE A 1 IF BYTE IS A 0
4682 ded0 6c 04                        INC  $04,X          ; IF 4,X = 2, THEN PREVIOUS BYTE WAS A 0
4683 ded2 e7 03              L8B71     STB  $03,X          ; SAVE LS BYTE OF BINARY LINE NUMBER
4684 ded4 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
4685 ded6 81 2c                        CMPA #',            ; IS IT A COMMA?
4686 ded8 27 9a                        BEQ  L8B13          ; YES - PROCESS ANOTHER NUMERIC VALUE
4687 deda 20 9c                        BRA  L8B17          ; NO - GO GET AND PROCESS AN INPUT CHARACTER
4688 dedc 9e 19              L8B7B     LDX  TXTTAB         ; POINT X TO START OF BASIC PROGRAM
4689 dede 30 1f                        LEAX -1,X           ; MOVE POINTER BACK ONE
4690 dee0 30 01              L8B7F     LEAX $01,X          ; MOVE POINTER UP ONE
4691 dee2 ec 02                        LDD  $02,X          ; GET ADDRESS OF NEXT LINE
4692 dee4 dd 68                        STD  CURLIN         ; SAVE IT IN CURLIN
4693 dee6 bd dd ea                     JSR  L8A86          ; RETURN IF END OF PROGRAM
4694 dee9 30 03                        LEAX $03,X          ; SKIP OVER ADDRESS OF NEXT LINE AND 1ST BYTE OF LINE NUMBER
4695 deeb 30 01              L8B8A     LEAX $01,X          ; MOVE POINTER UP ONE
4696 deed a6 84              L8B8C     LDA  ,X             ; GET CURRENT CHARACTER
4697 deef 27 ef                        BEQ  L8B7F          ; BRANCH IF END OF LINE
4698 def1 4a                           DECA                ; INPUT CHARACTER = 1? - VALID LINE NUMBER
4699 def2 27 1b                        BEQ  L8BAE          ; YES
4700 def4 80 02                        SUBA #$02           ; INPUT CHARACTER 3? - UL LINE NUMBER
4701 def6 26 f3                        BNE  L8B8A          ; NO
4702 def8 34 10                        PSHS X              ; SAVE CURRENT POSITION OF INPUT POINTER
4703 defa 8e df 39                     LDX  #L8BD9-1       ; POINT X TO 'UL' MESSAGE
4704 defd bd d0 e8                     JSR  LB99C          ; PRINT STRING TO THE SCREEN
4705 df00 ae e4                        LDX  ,S             ; GET INPUT POINTER
4706 df02 ec 01                        LDD  $01,X          ; GET THE UNDEFINED LINE NUMBER
4707 df04 bd d5 18                     JSR  LBDCC          ; CONVERT NUMBER IN ACCD TO DECIMAL AND DISPLAY IT
4708 df07 bd d5 11                     JSR  LBDC5          ; PRINT 'IN XXXX' XXXX = CURRENT LINE NUMBER
4709 df0a bd d0 a8                     JSR  LB958          ; SEND A CR TO CONSOLE OUT
4710 df0d 35 10                        PULS X              ; GET INPUT POINTER BACK
4711 df0f 34 10              L8BAE     PSHS X              ; SAVE CURRENT POSITION OF INPUT POINTER
4712 df11 ec 01                        LDD  $01,X          ; LOAD ACCD WITH BINARY VALUE OF LINE NUMBER
4713 df13 dd 52                        STD  FPA0+2         ; SAVE IN BOTTOM 2 BYTES OF FPA0
4714 df15 bd db c4                     JSR  L880E          ; ADJUST REST OF FPA0 AS AN INTEGER
4715 df18 bd d5 25                     JSR  LBDD9          ; CONVERT FPA0 TO ASCII, STORE IN LINE NUMBER
4716 df1b 35 40                        PULS U              ; LOAD U WITH PREVIOUS ADDRESS OF INPUT POINTER
4717 df1d c6 05                        LDB  #$05           ; EACH EXPANDED LINE NUMBER USES 5 BYTES
4718 df1f 30 01              L8BBE     LEAX $01,X          ; MOVE POINTER FORWARD ONE
4719 df21 a6 84                        LDA  ,X             ; GET AN ASCII BYTE
4720 df23 27 05                        BEQ  L8BC9          ; BRANCH IF END OF NUMBER
4721 df25 5a                           DECB                ; DECREMENT BYTE COUNTER
4722 df26 a7 c0                        STA  ,U+            ; STORE ASCII NUMBER IN BASIC LINE
4723 df28 20 f5                        BRA  L8BBE          ; CHECK FOR ANOTHER DIGIT
4724 df2a 30 c4              L8BC9     LEAX ,U             ; TRANSFER NEW LINE POINTER TO (X)
4725 df2c 5d                           TSTB                ; DOES THE NEW LINE NUMBER REQUIRE 5 BYTES?
4726 df2d 27 be                        BEQ  L8B8C          ; YES - GO GET ANOTHER INPUT CHARACTER
4727 df2f 31 c4                        LEAY ,U             ; SAVE NEW LINE POINTER IN Y
4728 df31 33 c5                        LEAU B,U            ; POINT U TO END OF 5 BYTE PACKED LINE NUMBER BLOCK
4729 df33 bd dd 2b                     JSR  L89B8          ; MOVE BYTES FROM (U) TO (X) UNTIL END OF PROGRAM
4730 df36 30 a4                        LEAX ,Y             ; LOAD (X) WITH NEW LINE POINTER
4731 df38 20 b3                        BRA  L8B8C          ; GO GET ANOTHER INPUT CHARACTER
4732                         
4733 df3a 55 4c 20           L8BD9     FCC  "UL "          ; UNKNOWN LINE NUMBER MESSAGE
4734 df3d 00                           FCB  0
4735                         
4736                         
4737 df3e bd ce c7           HEXDOL    JSR  LB740          ; CONVERT FPA0 INTO A POSITIVE 2 BYTE INTEGER
4738 df41 8e 01 f0                     LDX  #STRBUF+2      ; POINT TO TEMPORARY BUFFER
4739 df44 c6 04                        LDB  #$04           ; CONVERT 4 NIBBLES
4740 df46 34 04              L8BE5     PSHS B              ; SAVE NIBBLE COUNTER
4741 df48 5f                           CLRB                ; CLEAR CARRY FLAG
4742 df49 86 04                        LDA  #$04           ; 4 SHIFTS
4743 df4b 08 53              L8BEA     ASL  FPA0+3         ; * SHIFT BOTTOM TWO BYTES OF
4744 df4d 09 52                        ROL  FPA0+2         ; * FPA0 LEFT ONE BIT (X2)
4745 df4f 59                           ROLB                ; IF OVERFLOW, ACCB <> 0
4746 df50 4a                           DECA                ; * DECREMENT SHIFT COUNTER AND
4747 df51 26 f8                        BNE  L8BEA          ; * BRANCH IF NOT DONE
4748 df53 5d                           TSTB                ; CHECK FOR OVERFLOW
4749 df54 26 0a                        BNE  L8BFF          ; BRANCH IF OVERFLOW
4750 df56 a6 e4                        LDA  ,S             ; * GET NIBBLE COUNTER,
4751 df58 4a                           DECA                ; * DECREMENT IT AND
4752 df59 27 05                        BEQ  L8BFF          ; * BRANCH IF DONE
4753 df5b 8c 01 f0                     CMPX #STRBUF+2      ; DO NOT DO A CONVERSION UNTIL A NON-ZERO
4754 df5e 27 0c                        BEQ  L8C0B          ; BYTE IS FOUND - LEADING ZERO SUPPRESSION
4755 df60 cb 30              L8BFF     ADDB #'0            ; ADD IN ASCII ZERO
4756 df62 c1 39                        CMPB #'9            ; COMPARE TO ASCII 9
4757 df64 23 02                        BLS  L8C07          ; BRANCH IF < 9
4758 df66 cb 07                        ADDB #7             ; ADD ASCII OFFSET IF HEX LETTER
4759 df68 e7 80              L8C07     STB  ,X+            ; STORE HEX VALUE AND ADVANCE POINTER
4760 df6a 6f 84                        CLR  ,X             ; CLEAR NEXT BYTE - END OF STRING FLAG
4761 df6c 35 04              L8C0B     PULS B              ; * GET NIBBLE COUNTER,
4762 df6e 5a                           DECB                ; * DECREMENT IT AND
4763 df6f 26 d5                        BNE  L8BE5          ; * BRANCH IF NOT DONE
4764 df71 32 62                        LEAS $02,S          ; PURGE RETURN ADDRESS OFF OF STACK
4765 df73 8e 01 ef                     LDX  #STRBUF+1      ; RESET POINTER
4766 df76 7e cc 9f                     JMP  LB518          ; SAVE STRING ON STRING STACK
4767                         * PROCESS EXCLAMATION POINT
4768 df79 86 01              L8E37     LDA  #$01           ; * SET SPACES
4769 df7b 97 99                        STA  VD9            ; * COUNTER = 1
4770                         * PROCESS STRING ITEM - LIST
4771 df7d 5a                 L8E3B     DECB                ; DECREMENT FORMAT STRING LENGTH COUNTER
4772 df7e bd e1 1a                     JSR  L8FD8          ; SEND A '+' TO CONSOLE OUT IF VDA <>0
4773 df81 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
4774 df83 10 27 00 93                  LBEQ L8ED8          ; EXIT PRINT USING IF END OF LINE
4775 df87 d7 93                        STB  VD3            ; SAVE REMAINDER FORMAT STRING LENGTH
4776 df89 bd c8 e2                     JSR  LB156          ; EVALUATE EXPRESSION
4777 df8c bd c8 d2                     JSR  LB146          ; 'TM' ERROR IF NUMERIC VARIABLE
4778 df8f 9e 52                        LDX  FPA0+2         ; * GET ITEM - LIST DESCRIPTOR ADDRESS
4779 df91 9f 4d                        STX  V4D            ; * AND SAVE IT IN V4D
4780 df93 d6 99                        LDB  VD9            ; GET SPACES COUNTER
4781 df95 bd ce 34                     JSR  LB6AD          ; PUT ACCB BYTES INTO STRING SPACE & PUT DESCRIPTOR ON STRING STACK
4782 df98 bd d0 eb                     JSR  LB99F          ; PRINT THE FORMATTED STRING TO CONSOLE OUT
4783                         * PAD FORMAT STRING WITH SPACES IF ITEM - LIST STRING < FORMAT STRING LENGTH
4784 df9b 9e 52                        LDX  FPA0+2         ; POINT X TO FORMATTED STRING DESCRIPTOR ADDRESS
4785 df9d d6 99                        LDB  VD9            ; GET SPACES COUNTER
4786 df9f e0 84                        SUBB ,X             ; SUBTRACT LENGTH OF FORMATTED STRING
4787 dfa1 5a                 L8E5F     DECB                ; DECREMENT DIFFERENCE
4788 dfa2 10 2b 01 4f                  LBMI L8FB3          ; GO INTERPRET ANOTHER ITEM - LIST
4789 dfa6 bd d0 f8                     JSR  LB9AC          ; PAD FORMAT STRING WITH A SPACE
4790 dfa9 20 f6                        BRA  L8E5F          ; KEEP PADDING
4791                         * PERCENT SIGN - PROCESS A %SPACES% COMMAND
4792 dfab d7 93              L8E69     STB  VD3            ; * SAVE THE CURRENT FORMAT STRING
4793 dfad 9f 0f                        STX  TEMPTR         ; * COUNTER AND POINTER
4794 dfaf 86 02                        LDA  #$02           ; INITIAL SPACES COUNTER = 2
4795 dfb1 97 99                        STA  VD9            ; SAVE IN SPACES COUNTER
4796 dfb3 a6 84              L8E71     LDA  ,X             ; GET A CHARACTER FROM FORMAT STRING
4797 dfb5 81 25                        CMPA #'%            ; COMPARE TO TERMINATOR CHARACTER
4798 dfb7 27 c4                        BEQ  L8E3B          ; BRANCH IF END OF SPACES COMMAND
4799 dfb9 81 20                        CMPA #'             ; BLANK
4800 dfbb 26 07                        BNE  L8E82          ; BRANCH IF ILLEGAL CHARACTER
4801 dfbd 0c 99                        INC  VD9            ; ADD ONE TO SPACES COUNTER
4802 dfbf 30 01                        LEAX $01,X          ; MOVE FORMAT POINTER UP ONE
4803 dfc1 5a                           DECB                ; DECREMENT LENGTH COUNTER
4804 dfc2 26 ef                        BNE  L8E71          ; BRANCH IF NOT END OF FORMAT STRING
4805 dfc4 9e 0f              L8E82     LDX  TEMPTR         ; * RESTORE CURRENT FORMAT STRING COUNTER
4806 dfc6 d6 93                        LDB  VD3            ; * AND POINTER TO POSITION BEFORE SPACES COMMAND
4807 dfc8 86 25                        LDA  #'%            ; SEND A '%' TO CONSOLE OUT AS A DEBUGGING AID
4808                         * ERROR PROCESSOR - ILLEGAL CHARACTER OR BAD SYNTAX IN FORMAT STRING
4809 dfca bd e1 1a           L8E88     JSR  L8FD8          ; SEND A '+' TO CONSOLE OUT IF VDA <> 0
4810 dfcd bd c0 17                     JSR  PUTCHR         ; SEND CHARACTER TO CONSOLE OUT
4811 dfd0 20 29                        BRA  L8EB9          ; GET NEXT CHARACTER IN FORMAT STRING
4812                         
4813                         * PRINT RAM HOOK
4814 dfd2 81 b1              XVEC9     CMPA #TOK_USING     ; USING TOKEN
4815 dfd4 27 01                        BEQ  L8E95          ; BRANCH IF PRINT USING
4816 dfd6 39                           RTS
4817                         
4818                         * PRINT USING
4819                         * VDA IS USED AS A STATUS BYTE: BIT 6 = COMMA FORCE
4820                         * BIT 5=LEADING ASTERISK FORCE; BIT 4 = FLOATING $ FORCE
4821                         * BIT 3 = PRE SIGN FORCE; BIT 2 = POST SIGN FORCE; BIT 0 = EXPONENTIAL FORCE
4822 dfd7 32 62              L8E95     LEAS $02,S          ; PURGE RETURN ADDRESS OFF THE STACK
4823 dfd9 bd c8 e4                     JSR  LB158          ; EVALUATE FORMAT STRING
4824 dfdc bd c8 d2                     JSR  LB146          ; 'TM' ERROR IF VARIABLE TYPE = NUMERIC
4825 dfdf c6 3b                        LDB  #';            ; CHECK FOR ITEM LIST SEPARATOR
4826 dfe1 bd c9 fb                     JSR  LB26F          ; SYNTAX CHECK FOR ;
4827 dfe4 9e 52                        LDX  FPA0+2         ; * GET FORMAT STRING DESCRIPTOR ADDRESS
4828 dfe6 9f 95                        STX  VD5            ; * AND SAVE IT IN VD5
4829 dfe8 20 06                        BRA  L8EAE          ; GO PROCESS FORMAT STRING
4830 dfea 96 97              L8EA8     LDA  VD7            ; *CHECK NEXT PRINT ITEM FLAG AND
4831 dfec 27 08                        BEQ  L8EB4          ; *'FC' ERROR IF NO FURTHER PRINT ITEMS
4832 dfee 9e 95                        LDX  VD5            ; RESET FORMAT STRING POINTER TO START OF STRING
4833 dff0 0f 97              L8EAE     CLR  VD7            ; RESET NEXT PRINT ITEM FLAG
4834 dff2 e6 84                        LDB  ,X             ; GET LENGTH OF FORMAT STRING
4835 dff4 26 03                        BNE  L8EB7          ; INTERPRET FORMAT STRING IF LENGTH > 0
4836 dff6 7e cb d1           L8EB4     JMP  LB44A          ; 'FC' ERROR IF FORMAT STRING = NULL
4837 dff9 ae 02              L8EB7     LDX  $02,X          ; POINT X TO START OF FORMAT STRING
4838                         * INTERPRET THE FORMAT STRING
4839 dffb 0f 9a              L8EB9     CLR  VDA            ; CLEAR THE STATUS BYTE
4840 dffd 0f 99              L8EBB     CLR  VD9            ; CLEAR LEFT DIGIT COUNTER
4841 dfff a6 80                        LDA  ,X+            ; GET A CHARACTER FROM FORMAT STRING
4842 e001 81 21                        CMPA #'!            ; EXCLAMATION POINT?
4843 e003 10 27 ff 72                  LBEQ L8E37          ; YES - STRING TYPE FORMAT
4844 e007 81 23                        CMPA #'#            ; NUMBER SIGN? (DIGIT LOCATOR)
4845 e009 27 5b                        BEQ  L8F24          ; YES - NUMERIC TYPE FORMAT
4846 e00b 5a                           DECB                ; DECREMENT FORMAT STRING LENGTH
4847 e00c 26 16                        BNE  L8EE2          ; BRANCH IF NOT DONE
4848 e00e bd e1 1a                     JSR  L8FD8          ; SEND A '+' TO CONSOLE OUT IF VDA <> 0
4849 e011 bd c0 17                     JSR  PUTCHR         ; SEND CHARACTER TO CONSOLE OUT
4850 e014 9d 82              L8ED2     JSR  GETCCH         ; GET CURRENT CHARACTER FROM BASIC
4851 e016 26 d2                        BNE  L8EA8          ; BRANCH IF NOT END OF LINE
4852 e018 96 97                        LDA  VD7            ; GET NEXT PRINT ITEM FLAG
4853 e01a 26 03              L8ED8     BNE  L8EDD          ; BRANCH IF MORE PRINT ITEMS
4854 e01c bd d0 a8                     JSR  LB958          ; SEND A CARRIAGE RETURN TO CONSOLE OUT
4855 e01f 9e 95              L8EDD     LDX  VD5            ; POINT X TO FORMAT STRING DESCRIPTOR
4856 e021 7e cd e0                     JMP  LB659          ; RETURN ADDRESS AND LENGTH OF FORMAT STRING - EXIT PRINT USING
4857 e024 81 2b              L8EE2     CMPA #'+            ; CHECK FOR '+' (PRE-SIGN FORCE)
4858 e026 26 09                        BNE  L8EEF          ; NO PLUS
4859 e028 bd e1 1a                     JSR  L8FD8          ; SEND A '+' TO CONSOLE OUT IF VDA <> 0
4860 e02b 86 08                        LDA  #$08           ; * LOAD THE STATUS BYTE WITH 8;
4861 e02d 97 9a                        STA  VDA            ; * PRE-SIGN FORCE FLAG
4862 e02f 20 cc                        BRA  L8EBB          ; INTERPRET THE REST OF THE FORMAT STRING
4863 e031 81 2e              L8EEF     CMPA #'.            ; DECIMAL POINT?
4864 e033 27 4e                        BEQ  L8F41          ; YES
4865 e035 81 25                        CMPA #'%            ; PERCENT SIGN?
4866 e037 10 27 ff 70                  LBEQ L8E69          ; YES
4867 e03b a1 84                        CMPA ,X             ; COMPARE THE PRESENT FORMAT STRING INPUT
4868                         *              ; CHARACTER TO THE NEXT ONE IN THE STRING
4869 e03d 26 8b              L8EFB     BNE  L8E88          ; NO MATCH - ILLEGAL CHARACTER
4870                         * TWO CONSECUTIVE EQUAL CHARACTERS IN FORMAT STRING
4871 e03f 81 24                        CMPA #'$            ; DOLLAR SIGN?
4872 e041 27 19                        BEQ  L8F1A          ; YES - MAKE THE DOLLAR SIGN FLOAT
4873 e043 81 2a                        CMPA #'*            ; ASTERISK?
4874 e045 26 f6                        BNE  L8EFB          ; NO - ILLEGAL CHARACTER
4875 e047 96 9a                        LDA  VDA            ; * GRAB THE STATUS BYTE AND BET BIT 5
4876 e049 8a 20                        ORA  #$20           ; * TO INDICATE THAT THE OUTPUT WILL
4877 e04b 97 9a                        STA  VDA            ; * BE LEFT PADDED WITH ASTERISKS
4878 e04d c1 02                        CMPB #2             ; * CHECK TO SEE IF THE $$ ARE THE LAST TWO
4879 e04f 25 11                        BLO  L8F20          ; * CHARACTERS IN THE FORMAT STRING AND BRANCH IF SO
4880 e051 a6 01                        LDA  $01,X          ; GET THE NEXT CHARACTER AFTER **
4881 e053 81 24                        CMPA #'$            ; CHECK FOR **$
4882 e055 26 0b                        BNE  L8F20          ; CHECK FOR MORE CHARACTERS
4883 e057 5a                           DECB                ; DECREMENT STRING LENGTH COUNTER
4884 e058 30 01                        LEAX $01,X          ; MOVE FORMAT STRING POINTER UP ONE
4885 e05a 0c 99                        INC  VD9            ; ADD ONE TO LEFT DIGIT COUNTER - FOR ASTERISK PAD AND
4886                         *              ; FLOATING DOLLAR SIGN COMBINATION
4887 e05c 96 9a              L8F1A     LDA  VDA            ; * GET THE STATUS BYTE AND SET
4888 e05e 8a 10                        ORA  #$10           ; * BIT 4 TO INDICATE A
4889 e060 97 9a                        STA  VDA            ; * FLOATING DOLLAR SIGN
4890 e062 30 01              L8F20     LEAX $01,X          ; MOVE FORMAT STRING POINTER UP ONE
4891 e064 0c 99                        INC  VD9            ; ADD ONE TO LEFT DIGIT (FLOATING $ OR ASTERISK PAD)
4892                         * PROCESS CHARACTERS TO THE LEFT OF THE DECIMAL POINT IN THE FORMAT STRING
4893 e066 0f 98              L8F24     CLR  VD8            ; CLEAR THE RIGHT DIGIT COUNTER
4894 e068 0c 99              L8F26     INC  VD9            ; ADD ONE TO LEFT DIGIT COUNTER
4895 e06a 5a                           DECB                ; DECREMENT FORMAT STRING LENGTH COUNTER
4896 e06b 27 49                        BEQ  L8F74          ; BRANCH IF END OF FORMAT STRING
4897 e06d a6 80                        LDA  ,X+            ; GET THE NEXT FORMAT CHARACTER
4898 e06f 81 2e                        CMPA #'.            ; DECIMAL POINT?
4899 e071 27 1e                        BEQ  L8F4F          ; YES
4900 e073 81 23                        CMPA #'#            ; NUMBER SIGN?
4901 e075 27 f1                        BEQ  L8F26          ; YES
4902 e077 81 2c                        CMPA #',            ; COMMA?
4903 e079 26 21                        BNE  L8F5A          ; NO
4904 e07b 96 9a                        LDA  VDA            ; * GET THE STATUS BYTE
4905 e07d 8a 40                        ORA  #$40           ; * AND SET BIT 6 WHICH IS THE
4906 e07f 97 9a                        STA  VDA            ; * COMMA SEPARATOR FLAG
4907 e081 20 e5                        BRA  L8F26          ; PROCESS MORE CHARACTERS TO LEFT OF DECIMAL POINT
4908                         * PROCESS DECIMAL POINT IF NO DIGITS TO LEFT OF IT
4909 e083 a6 84              L8F41     LDA  ,X             ; GET NEXT FORMAT CHARACTER
4910 e085 81 23                        CMPA #'#            ; IS IT A NUMBER SIGN?
4911 e087 10 26 ff 3f                  LBNE L8E88          ; NO
4912 e08b 86 01                        LDA  #1             ; * SET THE RIGHT DIGIT COUNTER TO 1 -
4913 e08d 97 98                        STA  VD8            ; * ALLOW ONE SPOT FOR DECIMAL POINT
4914 e08f 30 01                        LEAX $01,X          ; MOVE FORMAT POINTER UP ONE
4915                         * PROCESS DIGITS TO RIGHT OF DECIMAL POINT
4916 e091 0c 98              L8F4F     INC  VD8            ; ADD ONE TO RIGHT DIGIT COUNTER
4917 e093 5a                           DECB                ; DECREMENT FORMAT LENGTH COUNTER
4918 e094 27 20                        BEQ  L8F74          ; BRANCH IF END OF FORMAT STRING
4919 e096 a6 80                        LDA  ,X+            ; GET A CHARACTER FROM FORMAT STRING
4920 e098 81 23                        CMPA #'#            ; IS IT NUMBER SIGN?
4921 e09a 27 f5                        BEQ  L8F4F          ; YES - KEEP CHECKING
4922                         * CHECK FOR EXPONENTIAL FORCE
4923 e09c 81 5e              L8F5A     CMPA #$5E           ; CHECK FOR UP ARROW
4924 e09e 26 16                        BNE  L8F74          ; NO UP ARROW
4925 e0a0 a1 84                        CMPA ,X             ; IS THE NEXT CHARACTER AN UP ARROW?
4926 e0a2 26 12                        BNE  L8F74          ; NO
4927 e0a4 a1 01                        CMPA $01,X          ; AND THE NEXT CHARACTER?
4928 e0a6 26 0e                        BNE  L8F74          ; NO
4929 e0a8 a1 02                        CMPA $02,X          ; HOW ABOUT THE 4TH CHARACTER?
4930 e0aa 26 0a                        BNE  L8F74          ; NO, ALSO
4931 e0ac c1 04                        CMPB #4             ; * CHECK TO SEE IF THE 4 UP ARROWS ARE IN THE
4932 e0ae 25 06                        BLO  L8F74          ; * FORMAT STRING AND BRANCH IF NOT
4933 e0b0 c0 04                        SUBB #4             ; * MOVE POINTER UP 4 AND SUBTRACT
4934 e0b2 30 04                        LEAX $04,X          ; * FOUR FROM LENGTH
4935 e0b4 0c 9a                        INC  VDA            ; INCREMENT STATUS BYTE - EXPONENTIAL FORM
4936                         
4937                         * CHECK FOR A PRE OR POST - SIGN FORCE AT END OF FORMAT STRING
4938 e0b6 30 1f              L8F74     LEAX -1,X           ; MOVE POINTER BACK ONE
4939 e0b8 0c 99                        INC  VD9            ; ADD ONE TO LEFT DIGIT COUNTER FOR PRE-SIGN FORCE
4940 e0ba 96 9a                        LDA  VDA            ; * PRE-SIGN
4941 e0bc 85 08                        BITA #$08           ; * FORCE AND
4942 e0be 26 18                        BNE  L8F96          ; * BRANCH IF SET
4943 e0c0 0a 99                        DEC  VD9            ; DECREMENT LEFT DIGIT - NO PRE-SIGN FORCE
4944 e0c2 5d                           TSTB                ; * CHECK LENGTH COUNTER AND BRANCH
4945 e0c3 27 13                        BEQ  L8F96          ; * IF END OF FORMAT STRING
4946 e0c5 a6 84                        LDA  ,X             ; GET NEXT FORMAT STRING CHARACTER
4947 e0c7 80 2d                        SUBA #'-            ; CHECK FOR MINUS SIGN
4948 e0c9 27 06                        BEQ  L8F8F          ; BRANCH IF MINUS SIGN
4949 e0cb 81 fe                        CMPA #$FE           ; * WAS CMPA #('+')-('-')
4950 e0cd 26 09                        BNE  L8F96          ; BRANCH IF NO PLUS SIGN
4951 e0cf 86 08                        LDA  #$08           ; GET THE PRE-SIGN FORCE FLAG
4952 e0d1 8a 04              L8F8F     ORA  #$04           ; 'OR' IN POST-SIGN FORCE FLAG
4953 e0d3 9a 9a                        ORA  VDA            ; 'OR' IN THE STATUS BYTE
4954 e0d5 97 9a                        STA  VDA            ; SAVE THE STATUS BYTE
4955 e0d7 5a                           DECB                ; DECREMENT FORMAT STRING LENGTH
4956                         
4957                         * EVALUATE NUMERIC ITEM-LIST
4958 e0d8 9d 82              L8F96     JSR  GETCCH         ; GET CURRENT CHARACTER
4959 e0da 10 27 ff 3c                  LBEQ L8ED8          ; BRANCH IF END OF LINE
4960 e0de d7 93                        STB  VD3            ; SAVE FORMAT STRING LENGTH WHEN FORMAT EVALUATION ENDED
4961 e0e0 bd c8 cd                     JSR  LB141          ; EVALUATE EXPRESSION
4962 e0e3 96 99                        LDA  VD9            ; GET THE LEFT DIGIT COUNTER
4963 e0e5 9b 98                        ADDA VD8            ; ADD IT TO THE RIGHT DIGIT COUNTER
4964 e0e7 81 11                        CMPA #17            ; *
4965 e0e9 10 22 ea e4                  LBHI LB44A          ; *'FC' ERROR IF MORE THAN 16 DIGITS AND DECIMAL POiNT
4966 e0ed bd e1 27                     JSR  L8FE5          ; CONVERT ITEM-LIST TO FORMATTED ASCII STRING
4967 e0f0 30 1f                        LEAX -1,X           ; MOVE BUFFER POINTER BACK ONE
4968 e0f2 bd d0 e8                     JSR  LB99C          ; DISPLAY THE FORMATTED STRING TO CONSOLE OUT
4969 e0f5 0f 97              L8FB3     CLR  VD7            ; RESET NEXT PRINT ITEM FLAG
4970 e0f7 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
4971 e0f9 27 0d                        BEQ  L8FC6          ; BRANCH IF END OF LINE
4972 e0fb 97 97                        STA  VD7            ; SAVE CURRENT CHARACTER (<>0) IN NEXT PRINT ITEM FLAG
4973 e0fd 81 3b                        CMPA #';            ; * CHECK FOR ; - ITEM-LIST SEPARATOR AND
4974 e0ff 27 05                        BEQ  L8FC4          ; * BRANCH IF SEMICOLON
4975 e101 bd c9 f9                     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
4976 e104 20 02                        BRA  L8FC6          ; PROCESS NEXT PRINT ITEM
4977 e106 9d 7c              L8FC4     JSR  GETNCH         ; GET NEXT INPUT CHARACTER
4978 e108 9e 95              L8FC6     LDX  VD5            ; GET FORMAT STRING DESCRIPTOR ADDRESS
4979 e10a e6 84                        LDB  ,X             ; GET LENGTH OF FORMAT STRING
4980 e10c d0 93                        SUBB VD3            ; SUBTRACT AMOUNT OF FORMAT STRING LEFT AFTER LAST PRINT ITEM
4981 e10e ae 02                        LDX  $02,X          ; *GET FORMAT STRING START ADDRESS AND ADVANCE
4982 e110 3a                           ABX                 ; *POINTER TO START OF UNUSED FORMAT STRING
4983 e111 d6 93                        LDB  VD3            ; * GET AMOUNT OF UNUSED FORMAT STRING
4984 e113 10 26 fe e4                  LBNE L8EB9          ; * REINTERPRET FORMAT STRING FROM THAT POINT
4985 e117 7e e0 14                     JMP  L8ED2          ; REINTERPRET FORMAT STRING FROM THE START IF ENTIRELY
4986                         *         USED ON LAST PRINT ITEM
4987                         
4988                         * PRINT A '+' TO CONSOLE OUT IF THE STATUS BYTE <> 0
4989 e11a 34 02              L8FD8     PSHS A              ; RESTORE ACCA AND RETURN
4990 e11c 86 2b                        LDA  #'+            ; GET ASCII PLUS SIGN
4991 e11e 0d 9a                        TST  VDA            ; * CHECK THE STATUS BYTE AND
4992 e120 27 03                        BEQ  L8FE3          ; * RETURN IF = 0
4993 e122 bd c0 17                     JSR  PUTCHR         ; SEND A CHARACTER TO CONSOLE OUT
4994 e125 35 82              L8FE3     PULS A,PC           ; RETURN ACCA AND RETURN
4995                         
4996                         * CONVERT ITEM-LIST TO DECIMAL ASCII STRING
4997 e127 ce 01 f2           L8FE5     LDU  #STRBUF+4      ; POINT U TO STRING BUFFER
4998 e12a c6 20                        LDB  #SPACE         ; BLANK
4999 e12c 96 9a                        LDA  VDA            ; * GET THE STATUS FLAG AND
5000 e12e 85 08                        BITA #$08           ; * CHECK FOR A PRE-SIGN FORCE
5001 e130 27 02                        BEQ  L8FF2          ; * BRANCH IF NO PRE-SIGN FORCE
5002 e132 c6 2b                        LDB  #'+            ; PLUS SIGN
5003 e134 0d 54              L8FF2     TST  FP0SGN         ; CHECK THE SIGN OF FPA0
5004 e136 2a 04                        BPL  L8FFA          ; BRANCH IF POSITIVE
5005 e138 0f 54                        CLR  FP0SGN         ; FORCE FPA0 SIGN TO BE POSITIVE
5006 e13a c6 2d                        LDB  #'-            ; MINUS SIGN
5007 e13c e7 c0              L8FFA     STB  ,U+            ; SAVE THE SIGN IN BUFFER
5008 e13e c6 30                        LDB  #'0            ; * PUT A ZERO INTO THE BUFFER
5009 e140 e7 c0                        STB  ,U+            ; *
5010 e142 84 01                        ANDA #$01           ; * CHECK THE EXPONENTIAL FORCE FLAG IN
5011 e144 10 26 01 07                  LBNE L910D          ; * THE STATUS BYTE - BRANCH IF ACTIVE
5012 e148 8e d5 0c                     LDX  #LBDC0         ; POINT X TO FLOATING POINT 1E + 09
5013 e14b bd d3 ec                     JSR  LBCA0          ; COMPARE FPA0 TO (X)
5014 e14e 2b 15                        BMI  L9023          ; BRANCH IF FPA0 < 1E+09
5015 e150 bd d5 25                     JSR  LBDD9          ; CONVERT FP NUMBER TO ASCII STRING
5016 e153 a6 80              L9011     LDA  ,X+            ; * ADVANCE POINTER TO END OF
5017 e155 26 fc                        BNE  L9011          ; * ASCII STRING (ZERO BYTE)
5018 e157 a6 82              L9015     LDA  ,-X            ; MOVE THE
5019 e159 a7 01                        STA  $01,X          ; ENTIRE STRING
5020 e15b 8c 01 f1                     CMPX #STRBUF+3      ; UP ONE
5021 e15e 26 f7                        BNE  L9015          ; BYTE
5022 e160 86 25                        LDA  #'%            ; * INSERT A % SIGN AT START OF
5023 e162 a7 84                        STA  ,X             ; * STRING - OVERFLOW ERROR
5024 e164 39                           RTS
5025                         
5026 e165 96 4f              L9023     LDA  FP0EXP         ; GET EXPONENT OF FPA0
5027 e167 97 47                        STA  V47            ; AND SAVE IT IN V74
5028 e169 27 03                        BEQ  L902C          ; BRANCH IF FPA0 = 0
5029 e16b bd e3 0f                     JSR  L91CD          ; CONVERT FPA0 TO NUMBER WITH 9 SIGNIFICANT
5030                         *              ; PLACES TO LEFT OF DECIMAL POINT
5031 e16e 96 47              L902C     LDA  V47            ; GET BASE 10 EXPONENT OFFSET
5032 e170 10 2b 00 81                  LBMI L90B3          ; BRANCH IF FPA0 < 100,000,000
5033 e174 40                           NEGA                ; * CALCULATE THE NUMBER OF LEADING ZEROES TO INSERT -
5034 e175 9b 99                        ADDA VD9            ; * SUBTRACT BASE 10 EXPONENT OFFSET AND 9 (FPA0 HAS
5035 e177 80 09                        SUBA #$09           ; * 9 PLACES TO LEFT OF EXPONENT) FROM LEFT DIGIT COUNTER
5036 e179 bd e2 2c                     JSR  L90EA          ; PUT ACCA ZEROES IN STRING BUFFER
5037 e17c bd e3 a5                     JSR  L9263          ; INITIALIZE DECIMAL POINT AND COMMA COUNTERS
5038 e17f bd e3 44                     JSR  L9202          ; CONVERT FPA0 TO DECIMAL ASCII IN THE STRING BUFFER
5039 e182 96 47                        LDA  V47            ; * GET BASE 10 EXPONENT AND PUT THAT MANY
5040 e184 bd e3 c3                     JSR  L9281          ; * ZEROES IN STRING BUFFER - STOP AT DECIMAL POINT
5041 e187 96 47                        LDA  V47            ; WASTED INSTRUCTION - SERVES NO PURPOSE
5042 e189 bd e3 8b                     JSR  L9249          ; CHECK FOR DECIMAL POINT
5043 e18c 96 98                        LDA  VD8            ; GET THE RIGHT DIGIT COUNTER
5044 e18e 26 02                        BNE  L9050          ; BRANCH IF RIGHT DIGlT COUNTER <> 0
5045 e190 33 5f                        LEAU -1,U           ; * MOVE BUFFER POINTER BACK ONE - DELETE
5046                         *                             ; * DECIMAL POINT IF NO RIGHT DIGITS SPECiFIED
5047 e192 4a                 L9050     DECA                ; SUBTRACT ONE (DECIMAL POINT)
5048 e193 bd e2 2c                     JSR  L90EA          ; PUT ACCA ZEROES INTO BUFFER (TRAILING ZEROES)
5049 e196 bd e2 c7           L9054     JSR  L9185          ; INSERT ASTERISK PADDING, FLOATING $, AND POST-SIGN
5050 e199 4d                           TSTA                ; WAS THERE A POST-SIGN?
5051 e19a 27 06                        BEQ  L9060          ; NO
5052 e19c c1 2a                        CMPB #'*            ; IS THE FIRST CHARACTER AN $?
5053 e19e 27 02                        BEQ  L9060          ; YES
5054 e1a0 e7 c0                        STB  ,U+            ; STORE THE POST-SIGN
5055 e1a2 6f c4              L9060     CLR  ,U             ; CLEAR THE LAST CHARACTER IN THE BUFFER
5056                         *
5057                         * REMOVE ANY EXTRA BLANKS OR ASTERISKS FROM THE
5058                         * STRING BUFFER TO THE LEFT OF THE DECIMAL POINT
5059 e1a4 8e 01 f1                     LDX  #STRBUF+3      ; POINT X TO THE START OF THE BUFFER
5060 e1a7 30 01              L9065     LEAX $01,X          ; MOVE BUFFER POINTER UP ONE
5061 e1a9 9f 0f                        STX  TEMPTR         ; SAVE BUFFER POINTER IN TEMPTR
5062 e1ab 96 3a                        LDA  VARPTR+1       ; * GET ADDRESS OF DECIMAL POINT IN BUFFER, SUBTRACT
5063 e1ad 90 10                        SUBA TEMPTR+1       ; * CURRENT POSITION AND SUBTRACT LEFT DIGIT COUNTER -
5064 e1af 90 99                        SUBA VD9            ; * THE RESULT WILL BE ZERO WHEN TEMPTR+1 IS POINTING
5065                         *              ; * TO THE FIRST DIGIT OF THE FORMAT STRING
5066 e1b1 27 38                        BEQ  L90A9          ; RETURN IF NO DIGITS TO LEFT OF THE DECiMAL POINT
5067 e1b3 a6 84                        LDA  ,X             ; GET THE CURRENT BUFFER CHARACTER
5068 e1b5 81 20                        CMPA #SPACE         ; SPACE?
5069 e1b7 27 ee                        BEQ  L9065          ; YES - ADVANCE POINTER
5070 e1b9 81 2a                        CMPA #'*            ; ASTERISK?
5071 e1bb 27 ea                        BEQ  L9065          ; YES - ADVANCE POINTER
5072 e1bd 4f                           CLRA                ; A ZERO ON THE STACK IS END OF DATA POINTER
5073 e1be 34 02              L907C     PSHS A              ; PUSH A CHARACTER ONTO THE STACK
5074 e1c0 a6 80                        LDA  ,X+            ; GET NEXT CHARACTER FROM BUFFER
5075 e1c2 81 2d                        CMPA #'-            ; MINUS SIGN?
5076 e1c4 27 f8                        BEQ  L907C          ; YES
5077 e1c6 81 2b                        CMPA #'+            ; PLUS SIGN?
5078 e1c8 27 f4                        BEQ  L907C          ; YES
5079 e1ca 81 24                        CMPA #'$            ; DOLLAR SIGN?
5080 e1cc 27 f0                        BEQ  L907C          ; YES
5081 e1ce 81 30                        CMPA #'0            ; ZERO?
5082 e1d0 26 0e                        BNE  L909E          ; NO - ERROR
5083 e1d2 a6 01                        LDA  $01,X          ; GET CHARACTER FOLLOWING ZERO
5084 e1d4 8d 16                        BSR  L90AA          ; CLEAR CARRY IF NUMERIC
5085 e1d6 25 08                        BLO  L909E          ; BRANCH IF NOT A NUMERIC CHARACTER - ERROR
5086 e1d8 35 02              L9096     PULS A              ; * PULL A CHARACTER OFF OF THE STACK
5087 e1da a7 82                        STA  ,-X            ; * AND PUT IT BACK IN THE STRING BUFFER
5088 e1dc 26 fa                        BNE  L9096          ; * KEEP GOING UNTIL ZERO FLAG
5089 e1de 20 c7                        BRA  L9065          ; KEEP CLEANING UP THE INPUT BUFFER
5090 e1e0 35 02              L909E     PULS A              ;
5091 e1e2 4d                           TSTA                ; * THE STACK AND EXIT WHEN
5092 e1e3 26 fb                        BNE  L909E          ; * ZERO FLAG FOUND
5093 e1e5 9e 0f                        LDX  TEMPTR         ; GET THE STRING BUFFER START POINTER
5094 e1e7 86 25                        LDA  #'%            ; * PUT A % SIGN BEFORE THE ERROR POSITION TO
5095 e1e9 a7 82                        STA  ,-X            ; * INDICATE AN ERROR
5096 e1eb 39                 L90A9     RTS
5097                         *
5098                         * CLEAR CARRY IF NUMERIC
5099 e1ec 81 30              L90AA     CMPA #'0            ; ASCII ZERO
5100 e1ee 25 04                        BLO  L90B2          ; RETURN IF ACCA < ASCII 0
5101 e1f0 80 3a                        SUBA #$3A           ; *  #'9'+1
5102 e1f2 80 c6                        SUBA #$C6           ; * #-('9'+1)  CARRY CLEAR IF NUMERIC
5103 e1f4 39                 L90B2     RTS
5104                         *
5105                         * PROCESS AN ITEM-LIST WHICH IS < 100,000,000
5106 e1f5 96 98              L90B3     LDA  VD8            ; GET RIGHT DIGIT COUNTER
5107 e1f7 27 01                        BEQ  L90B8          ; BRANCH IF NO FORMATTED DIGITS TO THE RIGHT OF DECIMAL PT
5108 e1f9 4a                           DECA                ; SUBTRACT ONE FOR DECIMAL POINT
5109 e1fa 9b 47              L90B8     ADDA V47            ; *ADD THE BASE 10 EXPONENT OFFSET - ACCA CONTAINS THE
5110                         *         *NUMBER OF SHIFTS REQUIRED TO ADJUST FPA0 TO THE SPECIFIED
5111                         *         *NUMBER OF DlGITS TO THE RIGHT OF THE DECIMAL POINT
5112 e1fc 2b 01                        BMI  L90BD          ; IF ACCA >= 0 THEN NO SHIFTS ARE REQUIRED
5113 e1fe 4f                           CLRA                ; FORCE SHIFT COUNTER = 0
5114 e1ff 34 02              L90BD     PSHS A              ; SAVE INITIAL SHIFT COUNTER ON THE STACK
5115 e201 2a 0a              L90BF     BPL  L90CB          ; EXIT ROUTINE IF POSITIVE
5116 e203 34 02                        PSHS A              ; SAVE SHIFT COUNTER ON STACK
5117 e205 bd d2 ce                     JSR  LBB82          ; DIVIDE FPA0 BY 10 - SHIFT ONE DIGIT TO RIGHT
5118 e208 35 02                        PULS A              ; GET SHIFT COUNTER FROM THE STACK
5119 e20a 4c                           INCA                ; BUMP SHIFT COUNTER UP BY ONE
5120 e20b 20 f4                        BRA  L90BF          ; CHECK FOR FURTHER DIVISION
5121 e20d 96 47              L90CB     LDA  V47            ; * GET BASE 10 EXPONENT OFFSET, ADD INITIAL SHIFT COUNTER
5122 e20f a0 e0                        SUBA ,S+            ; * AND SAVE NEW BASE 10 EXPONENT OFFSET - BECAUSE
5123 e211 97 47                        STA  V47            ; * FPA0 WAS SHIFTED ABOVE
5124 e213 8b 09                        ADDA #$09           ; * ADD NINE (SIGNIFICANT PLACES) AND BRANCH IF THERE ARE NO
5125 e215 2b 19                        BMI  L90EE          ; * ZEROES TO THE LEFT OF THE DECIMAL POINT IN THIS PRINT ITEM
5126 e217 96 99                        LDA  VD9            ; *DETERMINE HOW MANY FILLER ZEROES TO THE LEFT OF THE DECIMAL
5127 e219 80 09                        SUBA #$09           ; *POINT. GET THE NUMBER OF FORMAT PLACES TO LEFT OF DECIMAL
5128 e21b 90 47                        SUBA V47            ; *POINT, SUBTRACT THE BASE 10 EXPONENT OFFSET AND THE CONSTANT 9
5129 e21d 8d 0d                        BSR  L90EA          ; *(UNNORMALIZATION)-THEN OUTPUT THAT MANY ZEROES TO THE BUFFER
5130 e21f bd e3 a5                     JSR  L9263          ; INITIALIZE DECIMAL POINT AND COMMA COUNTERS
5131 e222 20 1d                        BRA  L90FF          ; PROCESS THE REMAINDER OF THE PRINT ITEM
5132                         *
5133                         * PUT (ACCA+1) ASCII ZEROES IN BUFFER
5134 e224 34 02              L90E2     PSHS A              ; SAVE ZERO COUNTER
5135 e226 86 30                        LDA  #'0            ; * INSERT A ZERO INTO
5136 e228 a7 c0                        STA  ,U+            ; * THE BUFFER
5137 e22a 35 02                        PULS A              ; RESTORE ZERO COUNTER
5138                         
5139                         * PUT ACCA ASCII ZEROES INTO THE BUFFER
5140 e22c 4a                 L90EA     DECA                ; DECREMENT ZERO COUNTER
5141 e22d 2a f5                        BPL  L90E2          ; BRANCH IF NOT DONE
5142 e22f 39                           RTS
5143                         
5144 e230 96 99              L90EE     LDA  VD9            ; * GET THE LEFT DIGIT COUNTER AND PUT
5145 e232 8d f8                        BSR  L90EA          ; * THAT MANY ZEROES IN THE STRiNG BUFFER
5146 e234 bd e3 8f                     JSR  L924D          ; PUT THE DECIMAL POINT IN THE STRING BUFFER
5147 e237 86 f7                        LDA  #-9            ; *DETERMINE HOW MANY FILLER ZEROES BETWEEN THE DECIMAL POINT
5148 e239 90 47                        SUBA V47            ; *AND SIGNIFICANT DATA. SUBTRACT BASE 10 EXPONENT FROM -9
5149 e23b 8d ef                        BSR  L90EA          ; *(UNNORMALIZATION) AND OUTPUT THAT MANY ZEROES TO BUFFER
5150 e23d 0f 45                        CLR  V45            ; CLEAR THE DECIMAL POINT COUNTER - SUPPRESS THE DECIMAL POINT
5151 e23f 0f 97                        CLR  VD7            ; CLEAR THE COMMA COUNTER - SUPPRESS COMMAS
5152 e241 bd e3 44           L90FF     JSR  L9202          ; DECODE FPA0 INTO A DECIMAL ASCII STRING
5153 e244 96 98                        LDA  VD8            ; GET THE RIGHT DIGIT COUNTER
5154 e246 26 02                        BNE  L9108          ; BRANCH IF RIGHT DIGIT COUNTER <> 0
5155 e248 de 39                        LDU  VARPTR         ; RESET BUFFER PTR TO THE DECIMAL POINT IF NO DIGITS TO RIGHT
5156 e24a 9b 47              L9108     ADDA V47            ; *ADD BASE 10 EXPONENT - A POSITIVE ACCA WILL CAUSE THAT MANY
5157                         * *FILLER ZEROES TO BE OUTPUT ; TO THE RIGHT OF LAST SIGNIFICANT DATA
5158                         *         *SIGNIFICANT DATA
5159 e24c 16 ff 43                     LBRA L9050          ; INSERT LEADING ASTERISKS, FLOATING DOLLAR SIGN, ETC
5160                         *
5161                         * FORCE THE NUMERIC OUTPUT FORMAT TO BE EXPONENTIAL FORMAT
5162 e24f 96 4f              L910D     LDA  FP0EXP         ; * GET EXPONENT OF FPA0 AND
5163 e251 34 02                        PSHS A              ; * SAVE IT ON THE STACK
5164 e253 27 03                        BEQ  L9116          ; BRANCH IF FPA0 = 0
5165 e255 bd e3 0f                     JSR  L91CD          ; *CONVERT FPA0 INTO A NUMBER WITH 9 SIGNIFICANT
5166                         *         *DIGITS TO THE LEFT OF THE DECIMAL POINT
5167 e258 96 98              L9116     LDA  VD8            ; GET THE RIGHT DIGIT COUNTER
5168 e25a 27 01                        BEQ  L911B          ; BRANCH IF NO FORMATTED DIGITS TO THE RIGHT
5169 e25c 4a                           DECA                ; SUBTRACT ONE FOR THE DECIMAL POINT
5170 e25d 9b 99              L911B     ADDA VD9            ; ADD TO THE LEFT DIGIT COUNTER
5171 e25f 7f 01 f1                     CLR  STRBUF+3       ; CLEAR BUFFER BYTE AS TEMPORARY STORAGE LOCATION
5172 e262 d6 9a                        LDB  VDA            ; * GET THE STATUS BYTE FOR A
5173 e264 c4 04                        ANDB #$04           ; * POST-BYTE FORCE; BRANCH IF
5174 e266 26 03                        BNE  L9129          ; * A POST-BYTE FORCE
5175 e268 73 01 f1                     COM  STRBUF+3       ; TOGGLE BUFFER BYTE TO -1 IF NO POST-BYTE FORCE
5176 e26b bb 01 f1           L9129     ADDA STRBUF+3       ; SUBTRACT 1 IF NO POST BYTE FORCE
5177 e26e 80 09                        SUBA #$09           ; *SUBTRACT 9 (DUE TO THE CONVERSION TO 9
5178                         *         *SIGNIFICANT DIGITS TO LEFT OF DECIMAL POINT)
5179 e270 34 02                        PSHS A              ; * SAVE SHIFT COUNTER ON THE STACK - ACCA CONTAINS THE NUMBER
5180                         *         OF   SHIFTS REQUIRED TO ADJUST FPA0 FOR THE NUMBER OF
5181                         *         FORMATTED PLACES TO THE RIGHT OF THE DECIMAL POINT.
5182 e272 2a 0a              L9130     BPL  L913C          ; NO MORE SHIFTS WHEN ACCA >= 0
5183 e274 34 02                        PSHS A              ; SAVE SHIFT COUNTER
5184 e276 bd d2 ce                     JSR  LBB82          ; DIVIDE FPA0 BY 10 - SHIFT TO RIGHT ONE
5185 e279 35 02                        PULS A              ; RESTORE THE SHIFT COUNTER
5186 e27b 4c                           INCA                ; ADD 1 TO SHIFT COUNTER
5187 e27c 20 f4                        BRA  L9130          ; CHECK FOR FURTHER SHIFTING (DIVISION)
5188 e27e a6 e4              L913C     LDA  ,S             ; *GET THE INITIAL VALUE OF THE SHIFT COUNTER
5189 e280 2b 01                        BMI  L9141          ; *AND BRANCH IF SHIFTING HAS TAKEN PLACE
5190 e282 4f                           CLRA                ; RESET ACCA IF NO SHIFTING HAS TAKEN PLACE
5191 e283 40                 L9141     NEGA                ; *CALCULATE THE POSITION OF THE DECIMAL POINT BY
5192 e284 9b 99                        ADDA VD9            ; *NEGATING SHIFT COUNTER, ADDING THE LEFT DIGIT COUNTER
5193 e286 4c                           INCA                ; *PLUS ONE AND THE POST-BYTE POSlTION, IF USED
5194 e287 bb 01 f1                     ADDA STRBUF+3       ; *
5195 e28a 97 45                        STA  V45            ; SAVE DECIMAL POINT COUNTER
5196 e28c 0f 97                        CLR  VD7            ; CLEAR COMMA COUNTER - NO COMMAS INSERTED
5197 e28e bd e3 44                     JSR  L9202          ; CONVERT FPA0 INTO ASCII DECIMAL STRING
5198 e291 35 02                        PULS A              ; * GET THE INITIAL VALUE OF SHIFT COUNTER AND
5199 e293 bd e3 c3                     JSR  L9281          ; * INSERT THAT MANY ZEROES INTO THE BUFFER
5200 e296 96 98                        LDA  VD8            ; *GET THE RIGHT DIGIT COUNTER AND BRANCH
5201 e298 26 02                        BNE  L915A          ; *IF NOT ZERO
5202 e29a 33 5f                        LEAU -1,U           ; MOVE BUFFER POINTER BACK ONE
5203                         
5204                         * CALCULATE VALUE OF EXPONENT AND PUT IN STRING BUFFER
5205 e29c e6 e0              L915A     LDB  ,S+            ; GET ORIGINAL EXPONENT OF FPA0
5206 e29e 27 09                        BEQ  L9167          ; BRANCH IF EXPONENT = 0
5207 e2a0 d6 47                        LDB  V47            ; GET BASE 10 EXPONENT
5208 e2a2 cb 09                        ADDB #$09           ; ADD 9 FOR 9 SIGNIFICANT DIGIT CONVERSION
5209 e2a4 d0 99                        SUBB VD9            ; SUBTRACT LEFT DIGIT COUNTER
5210 e2a6 f0 01 f1                     SUBB STRBUF+3       ; ADD ONE TO EXPONENT IF POST-SIGN FORCE
5211 e2a9 86 2b              L9167     LDA  #'+            ; PLUS SIGN
5212 e2ab 5d                           TSTB                ; TEST EXPONENT
5213 e2ac 2a 03                        BPL  L916F          ; BRANCH IF POSITIVE EXPONENT
5214 e2ae 86 2d                        LDA  #'-            ; MINUS SIGN
5215 e2b0 50                           NEGB                ; CONVERT EXPONENT TO POSITIVE NUMBER
5216 e2b1 a7 41              L916F     STA  $01,U          ; PUT SIGN OF EXPONENT IN STRING BUFFER
5217 e2b3 86 45                        LDA  #'E            ; * PUT AN 'E' (EXPONENTIATION FLAG) IN
5218 e2b5 a7 c1                        STA  ,U++           ; * BUFFER AND SKIP OVER THE SIGN
5219 e2b7 86 2f                        LDA  #$2F           ; * WAS LDA #'0'-1
5220                         *CONVERT BINARY EXPONENT IN ACCB TO ASCII VALUE IN ACCA
5221 e2b9 4c                 L9177     INCA                ; ADD ONE TO TENS DIGIT COUNTER
5222 e2ba c0 0a                        SUBB #10            ; *SUBTRACT 10 FROM EXPONENT AND ADD ONE TO TENS
5223 e2bc 24 fb                        BCC  L9177          ; * DIGIT IF NO CARRY. TENS DIGIT DONE IF THERE IS A CARRY
5224 e2be cb 3a                        ADDB #$3A           ; WAS ADDB #'9'+1
5225 e2c0 ed c1                        STD  ,U++           ; SAVE EXPONENT IN BUFFER
5226 e2c2 6f c4                        CLR  ,U             ; CLEAR FINAL BYTE IN BUFFER - PRINT TERMINATOR
5227 e2c4 7e e1 96                     JMP  L9054          ; INSERT ASTERISK PADDING, FLOATING DOLLAR SIGN, ETC.
5228                         
5229                         * INSERT ASTERISK PADDING, FLOATING $ AND PRE-SIGN
5230 e2c7 8e 01 f2           L9185     LDX  #STRBUF+4      ; POINT X TO START OF PRINT ITEM BUFFER
5231 e2ca e6 84                        LDB  ,X             ; * GET SIGN BYTE OF ITEM-LIST BUFFER
5232 e2cc 34 04                        PSHS B              ; * AND SAVE IT ON THE STACK
5233 e2ce 86 20                        LDA  #SPACE         ; DEFAULT PAD WITH BLANKS
5234 e2d0 d6 9a                        LDB  VDA            ; * GET STATUS BYTE AND CHECK FOR
5235 e2d2 c5 20                        BITB #$20           ; * ASTERISK LEFT PADDING
5236 e2d4 35 04                        PULS B              ; GET SIGN BYTE AGAIN
5237 e2d6 27 08                        BEQ  L919E          ; BRANCH IF NO PADDING
5238 e2d8 86 2a                        LDA  #'*            ; PAD WITH ASTERISK
5239 e2da c1 20                        CMPB #SPACE         ; WAS THE FIRST BYTE A BLANK (POSITIVE)?
5240 e2dc 26 02                        BNE  L919E          ; NO
5241 e2de 1f 89                        TFR  A,B            ; TRANSFER PAD CHARACTER TO ACCB
5242 e2e0 34 04              L919E     PSHS B              ; SAVE FIRST CHARACTER ON STACK
5243 e2e2 a7 80              L91A0     STA  ,X+            ; STORE PAD CHARACTER IN BUFFER
5244 e2e4 e6 84                        LDB  ,X             ; GET NEXT CHARACTER IN BUFFER
5245 e2e6 27 10                        BEQ  L91B6          ; INSERT A ZERO IF END OF BUFFER
5246 e2e8 c1 45                        CMPB #'E            ; * CHECK FOR AN 'E' AND
5247 e2ea 27 0c                        BEQ  L91B6          ; * PUT A ZERO BEFORE IT
5248 e2ec c1 30                        CMPB #'0            ; * REPLACE LEADING ZEROES WITH
5249 e2ee 27 f2                        BEQ  L91A0          ; * PAD CHARACTERS
5250 e2f0 c1 2c                        CMPB #',            ; * REPLACE LEADING COMMAS
5251 e2f2 27 ee                        BEQ  L91A0          ; * WITH PAD CHARACTERS
5252 e2f4 c1 2e                        CMPB #'.            ; * CHECK FOR DECIMAL POINT
5253 e2f6 26 04                        BNE  L91BA          ; * AND DON'T PUT A ZERO BEFORE IT
5254 e2f8 86 30              L91B6     LDA  #'0            ; * REPLACE PREVIOUS CHARACTER
5255 e2fa a7 82                        STA  ,-X            ; * WITH A ZERO
5256 e2fc 96 9a              L91BA     LDA  VDA            ; * GET STATUS BYTE, CHECK
5257 e2fe 85 10                        BITA #$10           ; * FOR FLOATING $
5258 e300 27 04                        BEQ  L91C4          ; * BRANCH IF NO FLOATING $
5259 e302 c6 24                        LDB  #'$            ; * STORE A $ IN
5260 e304 e7 82                        STB  ,-X            ; * BUFFER
5261 e306 84 04              L91C4     ANDA #$04           ; CHECK PRE-SIGN FLAG
5262 e308 35 04                        PULS B              ; GET SIGN CHARACTER
5263 e30a 26 02                        BNE  L91CC          ; RETURN IF POST-SIGN REQUIRED
5264 e30c e7 82                        STB  ,-X            ; STORE FIRST CHARACTER
5265 e30e 39                 L91CC     RTS
5266                         *
5267                         * CONVERT FPA0 INTO A NUMBER OF THE FORM - NNN,NNN,NNN X 10**M.
5268                         * THE EXPONENT M WILL BE RETURNED IN V47 (BASE 10 EXPONENT).
5269 e30f 34 40              L91CD     PSHS U              ; SAVE BUFFER POINTER
5270 e311 4f                           CLRA                ; INITIAL EXPONENT OFFSET = 0
5271 e312 97 47              L91D0     STA  V47            ; SAVE EXPONENT OFFSET
5272 e314 d6 4f                        LDB  FP0EXP         ; GET EXPONENT OF FPA0
5273 e316 c1 80                        CMPB #$80           ; * COMPARE TO EXPONENT OF .5
5274 e318 22 11                        BHI  L91E9          ; * AND BRANCH IF FPA0 > = 1.0
5275                         
5276                         * IF FPA0 < 1.0, MULTIPLY IT BY 1E+09 UNTIL IT IS >= 1
5277 e31a 8e d5 0c                     LDX  #LBDC0         ; POINT X TO FP NUMBER (1E+09)
5278 e31d bd d2 16                     JSR  LBACA          ; MULTIPLY FPA0 BY 1E+09
5279 e320 96 47                        LDA  V47            ; GET EXPONENT OFFSET
5280 e322 80 09                        SUBA #$09           ; SUBTRACT 9 (BECAUSE WE MULTIPLIED BY 1E+09 ABOVE)
5281 e324 20 ec                        BRA  L91D0          ; CHECK TO SEE IF > 1.0
5282 e326 bd d2 ce           L91E4     JSR  LBB82          ; DIVIDE FPA0 BY 10
5283 e329 0c 47                        INC  V47            ; INCREMENT EXPONENT OFFSET
5284 e32b 8e d5 07           L91E9     LDX  #LBDBB         ; POINT X TO FP NUMBER (999,999,999)
5285 e32e bd d3 ec                     JSR  LBCA0          ; COMPARE FPA0 TO X
5286 e331 2e f3                        BGT  L91E4          ; BRANCH IF FPA0 > 999,999,999
5287 e333 8e d5 02           L91F1     LDX  #LBDB6         ; POINT X TO FP NUMBER (99,999,999.9)
5288 e336 bd d3 ec                     JSR  LBCA0          ; COMPARE FPA0 TO X
5289 e339 2e 07                        BGT  L9200          ; RETURN IF 999,999,999 > FPA0 > 99,999,999.9
5290 e33b bd d2 b6                     JSR  LBB6A          ; MULTIPLY FPA0 BY 10
5291 e33e 0a 47                        DEC  V47            ; DECREMENT EXPONENT OFFSET
5292 e340 20 f1                        BRA  L91F1          ; KEEP UNNORMALIZING
5293 e342 35 c0              L9200     PULS U,PC           ; RESTORE BUFFER POINTER AND RETURN
5294                         *
5295                         * CONVERT FPA0 INTO AN INTEGER, THEN DECODE IT
5296                         * INTO A DECIMAL ASCII STRING IN THE BUFFER
5297 e344 34 40              L9202     PSHS U              ; SAVE BUFFER POINTER
5298 e346 bd d1 00                     JSR  LB9B4          ; ADD .5 TO FPA0 (ROUND OFF)
5299 e349 bd d4 14                     JSR  LBCC8          ; CONVERT FPA0 TO INTEGER FORMAT
5300 e34c 35 40                        PULS U              ; RESTORE BUFFER POINTER
5301                         *
5302                         * CONVERT FPA0 INTO A DECIMAL ASCII STRING
5303 e34e 8e d6 11                     LDX  #LBEC5         ; POINT X TO UNNORMALIZED POWERS OF 10
5304 e351 c6 80                        LDB  #$80           ; INITIALIZE DIGIT COUNTER TO 0 + $80.
5305                         * BIT 7 SET IS USED TO INDICATE THAT THE POWER OF 10 MANTISSA
5306                         * IS NEGATIVE. WHEN YOU 'ADD' A NEGATIVE MANTISSA, IT IS
5307                         * THE SAME AS SUBTRACTING A POSITIVE ONE AND BIT 7 OF ACCB
5308                         * IS HOW THIS ROUTINE KNOWS THAT A 'SUBTRACTION' IS OCCURRING.
5309 e353 8d 36              L9211     BSR  L9249          ; CHECK FOR COMMA INSERTION
5310 e355 96 53              L9213     LDA  FPA0+3         ; * 'ADD' A POWER OF 10 MANTISSA TO FPA0.
5311 e357 ab 03                        ADDA $03,X          ; * IF THE MANTISSA IS NEGATIVE, A SUBTRACTION
5312 e359 97 53                        STA  FPA0+3         ; * WILL BE WHAT REALLY TAKES PLACE.
5313 e35b 96 52                        LDA  FPA0+2         ; *
5314 e35d a9 02                        ADCA $02,X          ; *
5315 e35f 97 52                        STA  FPA0+2         ; *
5316 e361 96 51                        LDA  FPA0+1         ; *
5317 e363 a9 01                        ADCA $01,X          ; *
5318 e365 97 51                        STA  FPA0+1         ; *
5319 e367 96 50                        LDA  FPA0           ; *
5320 e369 a9 84                        ADCA ,X             ; *
5321 e36b 97 50                        STA  FPA0           ; *
5322 e36d 5c                           INCB                ; ADD ONE TO DIGIT COUNTER
5323 e36e 56                           RORB                ; ROTATE CARRY INTO BIT 7
5324 e36f 59                           ROLB                ; * SET OVERFLOW FLAG - BRANCH IF CARRY SET AND
5325 e370 28 e3                        BVC  L9213          ; * ADDING MANTISSA OR CARRY CLEAR AND SUBTRACTING MANTISSA
5326 e372 24 03                        BCC  L9235          ; BRANCH IF SUBTRACTING MANTISSA
5327 e374 c0 0b                        SUBB #10+1          ; WAS SUBB #10+1
5328 e376 50                           NEGB                ; * IF ADDING MANTISSA
5329 e377 cb 2f              L9235     ADDB #$2F           ; WAS ADDB #'0'-1
5330 e379 30 04                        LEAX $04,X          ; MOVE TO NEXT POWER OF 10 MANTISSA
5331 e37b 1f 98                        TFR  B,A            ; SAVE DIGIT IN ACCA
5332 e37d 84 7f                        ANDA #$7F           ; MASK OFF ADD/SUBTRACT FLAG (BIT 7)
5333 e37f a7 c0                        STA  ,U+            ; STORE DIGIT IN BUFFER
5334 e381 53                           COMB                ; TOGGLE ADD/SUBTRACT FLAG
5335 e382 c4 80                        ANDB #$80           ; MASK OFF EVERYTHING BUT ADD/SUB FLAG
5336 e384 8c d6 35                     CMPX #LBEE9         ; COMPARE TO END OF UNNORMALIZED POWERS OF 10
5337 e387 26 ca                        BNE  L9211          ; BRANCH IF NOT DONE
5338 e389 6f c4                        CLR  ,U             ; PUT A ZERO AT END OF INTEGER
5339                         
5340                         * DECREMENT DECIMAL POINT COUNTER AND CHECK FOR COMMA INSERTION
5341 e38b 0a 45              L9249     DEC  V45            ; DECREMENT DECIMAL POINT COUNTER
5342 e38d 26 09                        BNE  L9256          ; NOT TIME FOR DECIMAL POINT
5343 e38f df 39              L924D     STU  VARPTR         ; SAVE BUFFER POINTER-POSITION OF THE DECIMAL POINT
5344 e391 86 2e                        LDA  #'.            ; * STORE A DECIMAL
5345 e393 a7 c0                        STA  ,U+            ; * POINT IN THE OUTPUT BUFFER
5346 e395 0f 97                        CLR  VD7            ; * CLEAR COMMA COUNTER - NOW IT WILL TAKE 255
5347                         *                             ; * DECREMENTS BEFORE ANOTHER COMMA WILL BE INSERTED
5348 e397 39                           RTS
5349 e398 0a 97              L9256     DEC  VD7            ; DECREMENT COMMA COUNTER
5350 e39a 26 08                        BNE  L9262          ; RETURN IF NOT TIME FOR COMMA
5351 e39c 86 03                        LDA  #$03           ; * RESET COMMA COUNTER TO 3; THREE
5352 e39e 97 97                        STA  VD7            ; * DIGITS BETWEEN COMMAS
5353 e3a0 86 2c                        LDA  #',            ; * PUT A COMMA INTO
5354 e3a2 a7 c0                        STA  ,U+            ; * THE BUFFER
5355 e3a4 39                 L9262     RTS
5356                         
5357                         * INITIALIZE DECIMAL POINT AND COMMA COUNTERS
5358 e3a5 96 47              L9263     LDA  V47            ; GET THE BASE 10 EXPONENT OFFSET
5359 e3a7 8b 0a                        ADDA #10            ; * ADD 10 (FPA0 WAS 'NORMALIZED' TO 9 PLACES LEFT
5360 e3a9 97 45                        STA  V45            ; * OF DECIMAL POINT) - SAVE IN DECIMAL POINT COUNTER
5361 e3ab 4c                           INCA                ; ADD ONE FOR THE DECIMAL POINT
5362 e3ac 80 03              L926A     SUBA #$03           ; * DIVIDE DECIMAL POINT COUNTER BY 3; LEAVE
5363 e3ae 24 fc                        BCC  L926A          ; * THE REMAINDER IN ACCA
5364 e3b0 8b 05                        ADDA #$05           ; CONVERT REMAINDER INTO A NUMBER FROM 1-3
5365 e3b2 97 97                        STA  VD7            ; SAVE COMMA COUNTER
5366 e3b4 96 9a                        LDA  VDA            ; GET STATUS BYTE
5367 e3b6 84 40                        ANDA #$40           ; CHECK FOR COMMA FLAG
5368 e3b8 26 02                        BNE  L927A          ; BRANCH IF COMMA FLAG ACTIVE
5369 e3ba 97 97                        STA  VD7            ; CLEAR COMMA COUNTER - 255 DIGITS OUTPUT BEFORE A COMMA
5370 e3bc 39                 L927A     RTS
5371                         *
5372                         * INSERT ACCA ZEROES INTO THE BUFFER
5373 e3bd 34 02              L927B     PSHS A              ; SAVE ZEROES COUNTER
5374 e3bf 8d ca                        BSR  L9249          ; CHECK FOR DECIMAL POINT
5375 e3c1 35 02                        PULS A              ; RESTORE ZEROES COUNTER
5376 e3c3 4a                 L9281     DECA                ; * DECREMENT ZEROES COUNTER AND
5377 e3c4 2b 0a                        BMI  L928E          ; * RETURN IF < 0
5378 e3c6 34 02                        PSHS A              ; SAVE ZEROES COUNTER
5379 e3c8 86 30                        LDA  #'0            ; * PUT A ZERO INTO
5380 e3ca a7 c0                        STA  ,U+            ; * THE BUFFER
5381 e3cc a6 e0                        LDA  ,S+            ; RESTORE THE ZEROES COUNTER
5382 e3ce 26 ed                        BNE  L927B          ; BRANCH IF NOT DONE
5383 e3d0 39                 L928E     RTS
5384                         
5385                         
5386                         * LINE
5387 e3d1 81 89              LINE      CMPA #TOK_INPUT     ; 'INPUT' TOKEN
5388 e3d3 10 27 f9 5c                  LBEQ L89C0          ; GO DO 'LINE INPUT' COMMAND
5389 e3d7 7e ca 03                     JMP  LB277          ; 'SYNTAX ERROR' IF NOT "LINE INPUT"
5390                         
5391                         * END OF EXTENDED BASIC
5392                         
5393                         ;************************************************************************
5394                         ;
5395                         ; 6809 Disassembler
5396                         ;
5397                         ; Copyright (C) 2019 by Jeff Tranter <tranter@pobox.com>
5398                         ;
5399                         ; Licensed under the Apache License, Version 2.0 (the "License");
5400                         ; you may not use this file except in compliance with the License.
5401                         ; You may obtain a copy of the License at
5402                         ;
5403                         ;   http://www.apache.org/licenses/LICENSE-2.0
5404                         ;
5405                         ; Unless required by applicable law or agreed to in writing, software
5406                         ; distributed under the License is distributed on an "AS IS" BASIS,
5407                         ; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
5408                         ; See the License for the specific language governing permissions and
5409                         ; limitations under the License.
5410                         ;
5411                         ; Revision History
5412                         ; Version Date         Comments
5413                         ; 0.0     29-Jan-2019  First version started, based on 6502 code.
5414                         ; 0.1     03-Feb-2019  All instructions now supported.
5415                         ; 0.2     05-Feb-2019  Integrated into ASSSIST09/BASIC ROM.
5416                         
5417                         ; Character defines
5418                         
5419 000d                    RET     EQU     $0D             ; Carriage return
5420 0020                    SP      EQU     $20             ; Space
5421                         
5422 0018                    PAGELEN EQU     24              ; Number of instructions to show before waiting for keypress
5423                         
5424                         ; Start address for RAM variables
5425 6fd0                            ORG     $6FD0
5426                         
5427                         ; Variables
5428                         
5429 6fd0                    ADRS    RMB     2               ; Current address to disassemble
5430 6fd2                    OPCODE  RMB     1               ; Opcode of instruction
5431 6fd3                    AM      RMB     1               ; Addressing mode of instruction
5432 6fd4                    OPTYPE  RMB     1               ; Instruction type
5433 6fd5                    POSTBYT RMB     1               ; Post byte (for indexed addressing)
5434 6fd6                    LENG    RMB     1               ; Length of instruction
5435 6fd7                    TEMP    RMB     2               ; Temp variable (used by print routines)
5436 6fd9                    TEMP1   RMB     2               ; Temp variable
5437 6fdb                    FIRST   RMB     1               ; Flag used to indicate first time an item printed
5438 6fdc                    PAGE23  RMB     1               ; Flag indicating page2/3 instruction when non-zero
5439                         
5440                         ; Instructions. Matches indexes into entries in table MNEMONICS.
5441                         
5442 0000                    OP_INV   EQU    $00
5443 0001                    OP_ABX   EQU    $01
5444 0002                    OP_ADCA  EQU    $02
5445 0003                    OP_ADCB  EQU    $03
5446 0004                    OP_ADDA  EQU    $04
5447 0005                    OP_ADDB  EQU    $05
5448 0006                    OP_ADDD  EQU    $06
5449 0007                    OP_ANDA  EQU    $07
5450 0008                    OP_ANDB  EQU    $08
5451 0009                    OP_ANDCC EQU    $09
5452 000a                    OP_ASL   EQU    $0A
5453 000b                    OP_ASLA  EQU    $0B
5454 000c                    OP_ASLB  EQU    $0C
5455 000d                    OP_ASR   EQU    $0D
5456 000e                    OP_ASRA  EQU    $0E
5457 000f                    OP_ASRB  EQU    $0F
5458 0010                    OP_BCC   EQU    $10
5459 0011                    OP_BCS   EQU    $11
5460 0012                    OP_BEQ   EQU    $12
5461 0013                    OP_BGE   EQU    $13
5462 0014                    OP_BGT   EQU    $14
5463 0015                    OP_BHI   EQU    $15
5464 0016                    OP_BITA  EQU    $16
5465 0017                    OP_BITB  EQU    $17
5466 0018                    OP_BLE   EQU    $18
5467 0019                    OP_BLS   EQU    $19
5468 001a                    OP_BLT   EQU    $1A
5469 001b                    OP_BMI   EQU    $1B
5470 001c                    OP_BNE   EQU    $1C
5471 001d                    OP_BPL   EQU    $1D
5472 001e                    OP_BRA   EQU    $1E
5473 001f                    OP_BRN   EQU    $1F
5474 0020                    OP_BSR   EQU    $20
5475 0021                    OP_BVC   EQU    $21
5476 0022                    OP_BVS   EQU    $22
5477 0023                    OP_CLR   EQU    $23
5478 0024                    OP_CLRA  EQU    $24
5479 0025                    OP_CLRB  EQU    $25
5480 0026                    OP_CMPA  EQU    $26
5481 0027                    OP_CMPB  EQU    $27
5482 0028                    OP_CMPD  EQU    $28
5483 0029                    OP_CMPS  EQU    $29
5484 002a                    OP_CMPU  EQU    $2A
5485 002b                    OP_CMPX  EQU    $2B
5486 002c                    OP_CMPY  EQU    $2C
5487 002d                    OP_COMA  EQU    $2D
5488 002e                    OP_COMB  EQU    $2E
5489 002f                    OP_COM   EQU    $2F
5490 0030                    OP_CWAI  EQU    $30
5491 0031                    OP_DAA   EQU    $31
5492 0032                    OP_DEC   EQU    $32
5493 0033                    OP_DECA  EQU    $33
5494 0034                    OP_DECB  EQU    $34
5495 0035                    OP_EORA  EQU    $35
5496 0036                    OP_EORB  EQU    $36
5497 0037                    OP_EXG   EQU    $37
5498 0038                    OP_INC   EQU    $38
5499 0039                    OP_INCA  EQU    $39
5500 003a                    OP_INCB  EQU    $3A
5501 003b                    OP_JMP   EQU    $3B
5502 003c                    OP_JSR   EQU    $3C
5503 003d                    OP_LBCC  EQU    $3D
5504 003e                    OP_LBCS  EQU    $3E
5505 003f                    OP_LBEQ  EQU    $3F
5506 0040                    OP_LBGE  EQU    $40
5507 0041                    OP_LBGT  EQU    $41
5508 0042                    OP_LBHI  EQU    $42
5509 0043                    OP_LBLE  EQU    $43
5510 0044                    OP_LBLS  EQU    $44
5511 0045                    OP_LBLT  EQU    $45
5512 0046                    OP_LBMI  EQU    $46
5513 0047                    OP_LBNE  EQU    $47
5514 0048                    OP_LBPL  EQU    $48
5515 0049                    OP_LBRA  EQU    $49
5516 004a                    OP_LBRN  EQU    $4A
5517 004b                    OP_LBSR  EQU    $4B
5518 004c                    OP_LBVC  EQU    $4C
5519 004d                    OP_LBVS  EQU    $4D
5520 004e                    OP_LDA   EQU    $4E
5521 004f                    OP_LDB   EQU    $4F
5522 0050                    OP_LDD   EQU    $50
5523 0051                    OP_LDS   EQU    $51
5524 0052                    OP_LDU   EQU    $52
5525 0053                    OP_LDX   EQU    $53
5526 0054                    OP_LDY   EQU    $54
5527 0055                    OP_LEAS  EQU    $55
5528 0056                    OP_LEAU  EQU    $56
5529 0057                    OP_LEAX  EQU    $57
5530 0058                    OP_LEAY  EQU    $58
5531 0059                    OP_LSR   EQU    $59
5532 005a                    OP_LSRA  EQU    $5A
5533 005b                    OP_LSRB  EQU    $5B
5534 005c                    OP_MUL   EQU    $5C
5535 005d                    OP_NEG   EQU    $5D
5536 005e                    OP_NEGA  EQU    $5E
5537 005f                    OP_NEGB  EQU    $5F
5538 0060                    OP_NOP   EQU    $60
5539 0061                    OP_ORA   EQU    $61
5540 0062                    OP_ORB   EQU    $62
5541 0063                    OP_ORCC  EQU    $63
5542 0064                    OP_PSHS  EQU    $64
5543 0065                    OP_PSHU  EQU    $65
5544 0066                    OP_PULS  EQU    $66
5545 0067                    OP_PULU  EQU    $67
5546 0068                    OP_ROL   EQU    $68
5547 0069                    OP_ROLA  EQU    $69
5548 006a                    OP_ROLB  EQU    $6A
5549 006b                    OP_ROR   EQU    $6B
5550 006c                    OP_RORA  EQU    $6C
5551 006d                    OP_RORB  EQU    $6D
5552 006e                    OP_RTI   EQU    $6E
5553 006f                    OP_RTS   EQU    $6F
5554 0070                    OP_SBCA  EQU    $70
5555 0071                    OP_SBCB  EQU    $71
5556 0072                    OP_SEX   EQU    $72
5557 0073                    OP_STA   EQU    $73
5558 0074                    OP_STB   EQU    $74
5559 0075                    OP_STD   EQU    $75
5560 0076                    OP_STS   EQU    $76
5561 0077                    OP_STU   EQU    $77
5562 0078                    OP_STX   EQU    $78
5563 0079                    OP_STY   EQU    $79
5564 007a                    OP_SUBA  EQU    $7A
5565 007b                    OP_SUBB  EQU    $7B
5566 007c                    OP_SUBD  EQU    $7C
5567 007d                    OP_SWI   EQU    $7D
5568 007e                    OP_SWI2  EQU    $7E
5569 007f                    OP_SWI3  EQU    $7F
5570 0080                    OP_SYNC  EQU    $80
5571 0081                    OP_TFR   EQU    $81
5572 0082                    OP_TST   EQU    $82
5573 0083                    OP_TSTA  EQU    $83
5574 0084                    OP_TSTB  EQU    $84
5575                         
5576                         ; Addressing Modes. OPCODES table lists these for each instruction.
5577                         ; LENGTHS lists the instruction length for each addressing mode.
5578                         ; Need to distinguish relative modes that are 2 and 3 (long) bytes.
5579                         ; Some immediate are 2 and some 3 bytes.
5580                         ; Indexed modes can be longer depending on postbyte.
5581                         ; Page 2 and 3 opcodes are one byte longer (prefixed by 10 or 11)
5582                         
5583 0000                    AM_INVALID      EQU     0       ; $01 (1)
5584 0001                    AM_INHERENT     EQU     1       ; RTS (1)
5585 0002                    AM_IMMEDIATE8   EQU     2       ; LDA #$12 (2)
5586 0003                    AM_IMMEDIATE16  EQU     3       ; LDD #$1234 (3)
5587 0004                    AM_DIRECT       EQU     4       ; LDA $12 (2)
5588 0005                    AM_EXTENDED     EQU     5       ; LDA $1234 (3)
5589 0006                    AM_RELATIVE8    EQU     6       ; BSR $1234 (2)
5590 0007                    AM_RELATIVE16   EQU     7       ; LBSR $1234 (3)
5591 0008                    AM_INDEXED      EQU     8       ; LDA 0,X (2+)
5592                         
5593                         ; *** CODE ***
5594                         
5595 e400                            ORG     $E400
5596                         
5597                         ; Unassemble command. Disassembles a page at a time. Can be run directly or
5598                         ; as an ASSIST09 monitor external command. Gets start address from
5599                         ; command line.
5600                         
5601 e400 17 1a 5d           CUNAS:  LBSR    CDNUM           ; Parse command line, return 16-bit number in D
5602 e403 fd 6f d0                   STD     ADRS            ; Store it
5603 e406 86 18              PAGE:   LDA     #PAGELEN        ; Number of instructions to disassemble per page
5604 e408 34 02              DIS:    PSHS    A               ; Save A
5605 e40a 17 01 97                   LBSR    DISASM          ; Do disassembly of one instruction
5606 e40d 35 02                      PULS    A               ; Restore A
5607 e40f 4a                         DECA                    ; Decrement count
5608 e410 26 f6                      BNE     DIS             ; Go back and repeat until a page has been done
5609 e412 30 8d 0b 8f                LEAX    MSG2,PCR        ; Display message to press a key
5610 e416 17 00 84                   LBSR    PrintString
5611 e419 8d 63              BADKEY: BSR     GetChar         ; Wait for keyboard input
5612 e41b 8d 11                      BSR     PrintCR
5613 e41d 81 20                      CMPA    #SP             ; Space key pressed?
5614 e41f 27 e5                      BEQ     PAGE            ; If so, display next page
5615 e421 81 51                      CMPA    #'Q             ; Q key pressed?
5616 e423 27 08                      BEQ     RETN            ; If so, return
5617 e425 81 71                      CMPA    #'q             ; q key pressed?
5618 e427 27 04                      BEQ     RETN            ; If so, return
5619 e429 8d 72                      BSR     PrintString     ; Bad key, prompt and try again
5620 e42b 20 ec                      BRA     BADKEY
5621 e42d 39                 RETN:   RTS                     ; Return to caller
5622                         
5623                         ; *** Utility Functions ***
5624                         ; Some of these call ASSIST09 ROM monitor routines.
5625                         
5626                         ; Print CR/LF to the console.
5627                         ; Registers changed: none
5628                         PrintCR:
5629 e42e 34 02                      PSHS    A               ; Save A
5630 e430 86 0d                      LDA     #RET
5631 e432 8d 47                      BSR     PrintChar
5632 e434 86 0a                      LDA     #LF
5633 e436 8d 43                      BSR     PrintChar
5634 e438 35 02                      PULS    A               ; Restore A
5635 e43a 39                         RTS
5636                         
5637                         ; Print dollar sign to the console.
5638                         ; Registers changed: none
5639                         PrintDollar:
5640 e43b 34 02                      PSHS    A               ; Save A
5641 e43d 86 24                      LDA     #'$
5642 e43f 8d 3a                      BSR     PrintChar
5643 e441 35 02                      PULS    A               ; Restore A
5644 e443 39                         RTS
5645                         
5646                         ; Print comma to the console.
5647                         ; Registers changed: none
5648                         PrintComma:
5649 e444 34 02                      PSHS    A               ; Save A
5650 e446 86 2c                      LDA     #',
5651 e448 8d 31                      BSR     PrintChar
5652 e44a 35 02                      PULS    A               ; Restore A
5653 e44c 39                         RTS
5654                         
5655                         ; Print left square bracket to the console.
5656                         ; Registers changed: none
5657                         PrintLBracket:
5658 e44d 34 02                      PSHS    A               ; Save A
5659 e44f 86 5b                      LDA     #'[
5660 e451 8d 28                      BSR     PrintChar
5661 e453 35 02                      PULS    A               ; Restore A
5662 e455 39                         RTS
5663                         
5664                         ; Print right square bracket to the console.
5665                         ; Registers changed: none
5666                         PrintRBracket:
5667 e456 34 02                      PSHS    A               ; Save A
5668 e458 86 5d                      LDA     #']
5669 e45a 8d 1f                      BSR     PrintChar
5670 e45c 35 02                      PULS    A               ; Restore A
5671 e45e 39                         RTS
5672                         
5673                         ; Print space sign to the console.
5674                         ; Registers changed: none
5675                         PrintSpace:
5676 e45f 3f                         SWI
5677 e460 07                         FCB     SPACEF
5678 e461 39                         RTS
5679                         
5680                         ; Print two spaces to the console.
5681                         ; Registers changed: none
5682                         Print2Spaces:
5683 e462 34 02                      PSHS    A               ; Save A
5684 e464 86 20                      LDA     #SP
5685 e466 8d 13                      BSR     PrintChar
5686 e468 8d 11                      BSR     PrintChar
5687 e46a 35 02                      PULS    A               ; Restore A
5688 e46c 39                         RTS
5689                         
5690                         ; Print several space characters.
5691                         ; A contains number of spaces to print.
5692                         ; Registers changed: none
5693                         PrintSpaces:
5694 e46d 34 02                      PSHS    A               ; Save registers used
5695 e46f 81 00              PS1:    CMPA    #0              ; Is count zero?
5696 e471 27 05                      BEQ     PS2             ; Is so, done
5697 e473 8d ea                      BSR     PrintSpace      ; Print a space
5698 e475 4a                         DECA                    ; Decrement count
5699 e476 20 f7                      BRA     PS1             ; Check again
5700 e478 35 02              PS2:    PULS    A               ; Restore registers used
5701 e47a 39                         RTS
5702                         
5703                         ; Print character to the console
5704                         ; A contains character to print.
5705                         ; Registers changed: none
5706                         PrintChar:
5707 e47b 3f                         SWI                     ; Call ASSIST09 monitor function
5708 e47c 01                         FCB     OUTCH           ; Service code byte
5709 e47d 39                         RTS
5710                         
5711                         ; Get character from the console
5712                         ; A contains character read. Blocks until key pressed. Character is
5713                         ; echoed. Ignores NULL ($00) and RUBOUT ($7F). CR ($OD) is converted
5714                         ; to LF ($0A).
5715                         ; Registers changed: none (flags may change). Returns char in A.
5716                         GetChar:
5717 e47e 3f                         SWI                     ; Call ASSIST09 monitor function
5718 e47f 00                         FCB     INCHNP          ; Service code byte
5719 e480 39                         RTS
5720                         
5721                         ; Print a byte as two hex digits followed by a space.
5722                         ; A contains byte to print.
5723                         ; Registers changed: none
5724                         PrintByte:
5725 e481 34 16                      PSHS    A,B,X           ; Save registers used
5726 e483 b7 6f d7                   STA     TEMP            ; Needs to be in memory so we can point to it
5727 e486 30 8d 8b 4d                LEAX    TEMP,PCR        ; Get pointer to it
5728 e48a 3f                         SWI                     ; Call ASSIST09 monitor function
5729 e48b 04                         FCB     OUT2HS          ; Service code byte
5730 e48c 35 16                      PULS    X,B,A           ; Restore registers used
5731 e48e 39                         RTS
5732                         
5733                         ; Print a word as four hex digits followed by a space.
5734                         ; X contains word to print.
5735                         ; Registers changed: none
5736                         PrintAddress:
5737 e48f 34 16                      PSHS    A,B,X           ; Save registers used
5738 e491 bf 6f d7                   STX     TEMP            ; Needs to be in memory so we can point to it
5739 e494 30 8d 8b 3f                LEAX    TEMP,PCR        ; Get pointer to it
5740 e498 3f                         SWI                     ; Call ASSIST09 monitor function
5741 e499 05                         FCB     OUT4HS          ; Service code byte
5742 e49a 35 16                      PULS    X,B,A           ; Restore registers used
5743 e49c 39                         RTS
5744                         
5745                         ; Print a string.
5746                         ; X points to start of string to display.
5747                         ; String must be terminated in EOT character.
5748                         ; Registers changed: none
5749                         PrintString:
5750 e49d 34 10                      PSHS    X               ; Save registers used
5751 e49f 3f                         SWI                     ; Call ASSIST09 monitor function
5752 e4a0 02                         FCB     PDATA1          ; Service code byte
5753 e4a1 35 10                      PULS    X               ; Restore registers used
5754 e4a3 39                         RTS
5755                         
5756                         ; Decode the instruction pointed to by ADRS. On return will have set
5757                         ; ADRS, OPCODE, OPTYPE, LENG, AM, PAGE23, and POSTBYT.
5758                         
5759 e4a4 7f 6f dc           Decode: CLR     PAGE23          ; Clear page2/3 flag
5760 e4a7 ae 8d 8b 25                LDX     ADRS,PCR        ; Get address of instruction
5761 e4ab e6 84                      LDB     ,X              ; Get instruction op code
5762 e4ad c1 10                      CMPB    #$10            ; Is it a page 2 16-bit opcode prefix with 10?
5763 e4af 27 07                      BEQ     handle10        ; If so, do special handling
5764 e4b1 c1 11                      CMPB    #$11            ; Is it a page 3 16-bit opcode prefix with 11?
5765 e4b3 27 53                      BEQ     handle11        ; If so, do special handling
5766 e4b5 16 00 a0                   LBRA    not1011         ; If not, handle as normal case
5767                         
5768                         handle10:                       ; Handle page 2 instruction
5769 e4b8 86 01                      LDA     #1              ; Set page2/3 flag
5770 e4ba b7 6f dc                   STA     PAGE23
5771 e4bd e6 01                      LDB     1,X             ; Get real opcode
5772 e4bf f7 6f d2                   STB     OPCODE          ; Save it.
5773 e4c2 30 8d 0a 46                LEAX    PAGE2,PCR       ; Pointer to start of table
5774 e4c6 4f                         CLRA                    ; Set index into table to zero
5775                         search10:
5776 e4c7 e1 86                      CMPB    A,X             ; Check for match of opcode in table
5777 e4c9 27 1f                      BEQ     found10         ; Branch if found
5778 e4cb 8b 03                      ADDA    #3              ; Advance to next entry in table (entries are 3 bytes long)
5779 e4cd 6d 86                      TST     A,X             ; Check entry
5780 e4cf 27 02                      BEQ     notfound10      ; If zero, then reached end of table
5781 e4d1 20 f4                      BRA     search10        ; If not, keep looking
5782                         
5783                         notfound10:                     ; Instruction not found, so is invalid.
5784 e4d3 86 10                      LDA     #$10            ; Set opcode to 10
5785 e4d5 b7 6f d2                   STA     OPCODE
5786 e4d8 86 00                      LDA     #OP_INV         ; Set as instruction type invalid
5787 e4da b7 6f d4                   STA     OPTYPE
5788 e4dd 86 00                      LDA     #AM_INVALID     ; Set as addressing mode invalid
5789 e4df b7 6f d3                   STA     AM
5790 e4e2 86 01                      LDA     #1              ; Set length to one
5791 e4e4 b7 6f d6                   STA     LENG
5792 e4e7 16 00 90                   LBRA    dism            ; Disassemble as normal
5793                         
5794                         found10:                        ; Found entry in table
5795 e4ea 8b 01                      ADDA    #1              ; Advance to instruction type entry in table
5796 e4ec e6 86                      LDB     A,X             ; Get instruction type
5797 e4ee f7 6f d4                   STB     OPTYPE          ; Save it
5798 e4f1 8b 01                      ADDA    #1              ; Advanced to address mode entry in table
5799 e4f3 e6 86                      LDB     A,X             ; Get address mode
5800 e4f5 f7 6f d3                   STB     AM              ; Save it
5801 e4f8 4f                         CLRA                    ; Clear MSB of D, addressing mode is now in A:B (D)
5802 e4f9 1f 01                      TFR     D,X             ; Put addressing mode in X
5803 e4fb e6 89 ec df                LDB     LENGTHS,X       ; Get instruction length from table
5804 e4ff f7 6f d6                   STB     LENG            ; Store it
5805 e502 7c 6f d6                   INC     LENG            ; Add one because it is a two byte op code
5806 e505 16 00 72                   LBRA    dism            ; Continue normal disassembly processing.
5807                         
5808                         handle11:                       ; Same logic as above, but use table for page 3 opcodes.
5809 e508 86 01                      LDA     #1              ; Set page2/3 flag
5810 e50a b7 6f dc                   STA     PAGE23
5811 e50d e6 01                      LDB     1,X             ; Get real opcode
5812 e50f f7 6f d2                   STB     OPCODE          ; Save it.
5813 e512 30 8d 0a 69                LEAX    PAGE3,PCR       ; Pointer to start of table
5814 e516 4f                         CLRA                    ; Set index into table to zero
5815                         search11:
5816 e517 e1 86                      CMPB    A,X             ; Check for match of opcode in table
5817 e519 27 1f                      BEQ     found11         ; Branch if found
5818 e51b 8b 03                      ADDA    #3              ; Advance to next entry in table (entries are 3 bytes long)
5819 e51d 6d 86                      TST     A,X             ; Check entry
5820 e51f 27 02                      BEQ     notfound11      ; If zero, then reached end of table
5821 e521 20 f4                      BRA     search11        ; If not, keep looking
5822                         
5823                         notfound11:                     ; Instruction not found, so is invalid.
5824 e523 86 11                      LDA     #$11            ; Set opcode to 10
5825 e525 b7 6f d2                   STA     OPCODE
5826 e528 86 00                      LDA     #OP_INV         ; Set as instruction type invalid
5827 e52a b7 6f d4                   STA     OPTYPE
5828 e52d 86 00                      LDA     #AM_INVALID     ; Set as addressing mode invalid
5829 e52f b7 6f d3                   STA     AM
5830 e532 86 01                      LDA     #1              ; Set length to one
5831 e534 b7 6f d6                   STA     LENG
5832 e537 16 00 40                   LBRA    dism            ; Disassemble as normal
5833                         
5834                         found11:                        ; Found entry in table
5835 e53a 8b 01                      ADDA    #1              ; Advance to instruction type entry in table
5836 e53c e6 86                      LDB     A,X             ; Get instruction type
5837 e53e f7 6f d4                   STB     OPTYPE          ; Save it
5838 e541 8b 01                      ADDA    #1              ; Advanced to address mode entry in table
5839 e543 e6 86                      LDB     A,X             ; Get address mode
5840 e545 f7 6f d3                   STB     AM              ; Save it
5841 e548 4f                         CLRA                    ; Clear MSB of D, addressing mode is now in A:B (D)
5842 e549 1f 01                      TFR     D,X             ; Put addressing mode in X
5843 e54b e6 89 ec df                LDB     LENGTHS,X       ; Get instruction length from table
5844 e54f f7 6f d6                   STB     LENG            ; Store it
5845 e552 7c 6f d6                   INC     LENG            ; Add one because it is a two byte op code
5846 e555 16 00 22                   LBRA    dism            ; Continue normal disassembly processing.
5847                         
5848                         not1011:
5849 e558 f7 6f d2                   STB     OPCODE          ; Save the op code
5850 e55b 4f                         CLRA                    ; Clear MSB of D
5851 e55c 1f 01                      TFR     D,X             ; Put op code in X
5852 e55e e6 89 ed 0c                LDB     OPCODES,X       ; Get opcode type from table
5853 e562 f7 6f d4                   STB     OPTYPE          ; Store it
5854 e565 f6 6f d2                   LDB     OPCODE          ; Get op code again
5855 e568 1f 01                      TFR     D,X             ; Put opcode in X
5856 e56a e6 89 ee 0c                LDB     MODES,X         ; Get addressing mode type from table
5857 e56e f7 6f d3                   STB     AM              ; Store it
5858 e571 1f 01                      TFR     D,X             ; Put addressing mode in X
5859 e573 e6 89 ec df                LDB     LENGTHS,X       ; Get instruction length from table
5860 e577 f7 6f d6                   STB     LENG            ; Store it
5861                         
5862                         ; If addressing mode is indexed, get and save the indexed addressing
5863                         ; post byte.
5864                         
5865 e57a b6 6f d3           dism:   LDA     AM              ; Get addressing mode
5866 e57d 81 08                      CMPA    #AM_INDEXED     ; Is it indexed mode?
5867 e57f 26 22                      BNE     NotIndexed      ; Branch if not
5868 e581 ae 8d 8a 4b                LDX     ADRS,PCR        ; Get address of op code
5869                                                         ; If it is a page2/3 instruction, op code is the next byte after ADRS
5870 e585 7d 6f dc                   TST     PAGE23          ; Page2/3 instruction?
5871 e588 27 04                      BEQ     norm            ; Branch if not
5872 e58a a6 02                      LDA     2,X             ; Post byte is two past ADRS
5873 e58c 20 02                      BRA     getpb
5874 e58e a6 01              norm:   LDA     1,X             ; Get next byte (the post byte)
5875 e590 b7 6f d5           getpb:  STA     POSTBYT         ; Save it
5876                         
5877                         ; Determine number of additional bytes for indexed addressing based on
5878                         ; postbyte. If most significant bit is 0, there are no additional
5879                         ; bytes and we can skip the rest of the check.
5880                         
5881 e593 2a 0e                      BPL     NotIndexed      ; Branch of MSB is zero
5882                         
5883                         ; Else if most significant bit is 1, mask off all but low order 5 bits
5884                         ; and look up length in table.
5885                         
5886 e595 84 1f                      ANDA    #%00011111      ; Mask off bits
5887 e597 30 8d 07 51                LEAX    POSTBYTES,PCR   ; Lookup table of lengths
5888 e59b a6 86                      LDA     A,X             ; Get table entry
5889 e59d bb 6f d6                   ADDA    LENG            ; Add to instruction length
5890 e5a0 b7 6f d6                   STA     LENG            ; Save new length
5891                         
5892                         NotIndexed:
5893 e5a3 39                         rts
5894                         
5895                         ; Disassemble instruction at address ADRS. On return, ADRS points to
5896                         ; next instruction so it can be called again.
5897                         
5898 e5a4 bd e4 a4           DISASM: JSR     Decode          ; Decode the instruction
5899                         
5900                         ; Print address followed by a space
5901 e5a7 ae 8d 8a 25                LDX     ADRS,PCR
5902 e5ab 17 fe e1                   LBSR    PrintAddress
5903                         
5904                         ; Print one more space
5905                         
5906 e5ae 17 fe ae                   LBSR    PrintSpace
5907                         
5908                         ; Print the op code bytes based on the instruction length
5909                         
5910 e5b1 f6 6f d6                   LDB     LENG            ; Number of bytes in instruction
5911 e5b4 ae 8d 8a 18                LDX     ADRS,PCR        ; Pointer to start of instruction
5912 e5b8 a6 80              opby:   LDA     ,X+             ; Get instruction byte and increment pointer
5913 e5ba 17 fe c4                   LBSR    PrintByte       ; Print it, followed by a space
5914 e5bd 5a                         DECB                    ; Decrement byte count
5915 e5be 26 f8                      BNE     opby            ; Repeat until done
5916                         
5917                         ; Print needed remaining spaces to pad out to correct column
5918                         
5919 e5c0 30 8d 07 24                LEAX    PADDING,PCR     ; Pointer to start of lookup table
5920 e5c4 b6 6f d6                   LDA     LENG            ; Number of bytes in instruction
5921 e5c7 4a                         DECA                    ; Subtract 1 since table starts at 1, not 0
5922 e5c8 a6 86                      LDA     A,X             ; Get number of spaces to print
5923 e5ca 17 fe a0                   LBSR    PrintSpaces
5924                         
5925                         ; If a page2/3 instruction, advance ADRS to the next byte which points
5926                         ; to the real op code.
5927                         
5928 e5cd 7d 6f dc                   TST     PAGE23          ; Flag set
5929 e5d0 27 09                      BEQ     noinc           ; Branch if not
5930 e5d2 fc 6f d0                   LDD     ADRS            ; Increment 16-bit address
5931 e5d5 c3 00 01                   ADDD    #1
5932 e5d8 fd 6f d0                   STD     ADRS
5933                         
5934                         ; Get and print mnemonic (4 chars)
5935                         
5936 e5db f6 6f d4           noinc   LDB     OPTYPE          ; Get instruction type to index into table
5937 e5de 4f                         CLRA                    ; Clear MSB of D
5938 e5df 58                         ASLB                    ; 16-bit shift of D: Rotate B, MSB into Carry
5939 e5e0 49                         ROLA                    ; Rotate A, Carry into LSB
5940 e5e1 58                         ASLB                    ; Do it twice to multiple by four
5941 e5e2 49                         ROLA                    ;
5942 e5e3 30 8d 04 e4                LEAX    MNEMONICS,PCR   ; Pointer to start of table
5943 e5e7 b7 6f d9                   STA     TEMP1           ; Save value of A
5944 e5ea a6 8b                      LDA     D,X             ; Get first char of mnemonic
5945 e5ec 17 fe 8c                   LBSR    PrintChar       ; Print it
5946 e5ef b6 6f d9                   LDA     TEMP1           ; Restore value of A
5947 e5f2 5c                         INCB                    ; Advance pointer
5948 e5f3 a6 8b                      LDA     D,X             ; Get second char of mnemonic
5949 e5f5 17 fe 83                   LBSR    PrintChar       ; Print it
5950 e5f8 b6 6f d9                   LDA     TEMP1           ; Restore value of A
5951 e5fb 5c                         INCB                    ; Advance pointer
5952 e5fc a6 8b                      LDA     D,X             ; Get third char of mnemonic
5953 e5fe 17 fe 7a                   LBSR    PrintChar       ; Print it
5954 e601 b6 6f d9                   LDA     TEMP1           ; Restore value of A
5955 e604 5c                         INCB                    ; Advance pointer
5956 e605 a6 8b                      LDA     D,X             ; Get fourth char of mnemonic
5957 e607 17 fe 71                   LBSR    PrintChar       ; Print it
5958                         
5959                         ; Display any operands based on addressing mode and call appropriate
5960                         ; routine. TODO: Could use a lookup table for this.
5961                         
5962 e60a b6 6f d3                   LDA     AM              ; Get addressing mode
5963 e60d 81 00                      CMPA    #AM_INVALID
5964 e60f 27 2e                      BEQ     DO_INVALID
5965 e611 81 01                      CMPA    #AM_INHERENT
5966 e613 27 39                      BEQ     DO_INHERENT
5967 e615 81 02                      CMPA    #AM_IMMEDIATE8
5968 e617 27 38                      BEQ     DO_IMMEDIATE8
5969 e619 81 03                      CMPA    #AM_IMMEDIATE16
5970 e61b 10 27 01 af                LBEQ    DO_IMMEDIATE16
5971 e61f 81 04                      CMPA    #AM_DIRECT
5972 e621 10 27 01 c4                LBEQ    DO_DIRECT
5973 e625 81 05                      CMPA    #AM_EXTENDED
5974 e627 10 27 01 d0                LBEQ    DO_EXTENDED
5975 e62b 81 06                      CMPA    #AM_RELATIVE8
5976 e62d 10 27 01 e0                LBEQ    DO_RELATIVE8
5977 e631 81 07                      CMPA    #AM_RELATIVE16
5978 e633 10 27 01 f5                LBEQ    DO_RELATIVE16
5979 e637 81 08                      CMPA    #AM_INDEXED
5980 e639 10 27 02 09                LBEQ    DO_INDEXED
5981 e63d 20 00                      BRA     DO_INVALID      ; Should never be reached
5982                         
5983                         DO_INVALID:                     ; Display "   ; INVALID"
5984 e63f 86 0f                      LDA     #15             ; Want 15 spaces
5985 e641 17 fe 29                   LBSR    PrintSpaces
5986 e644 30 8d 09 53                LEAX    MSG1,PCR
5987 e648 17 fe 52                   LBSR    PrintString
5988 e64b 16 04 67                   LBRA    done
5989                         
5990                         DO_INHERENT:                    ; Nothing else to do
5991 e64e 16 04 64                   LBRA    done
5992                         
5993                         DO_IMMEDIATE8:
5994 e651 b6 6f d4                   LDA     OPTYPE          ; Get opcode type
5995 e654 81 81                      CMPA    #OP_TFR         ; Is is TFR?
5996 e656 27 33                      BEQ     XFREXG          ; Handle special case of TFR
5997 e658 81 37                      CMPA    #OP_EXG         ; Is is EXG?
5998 e65a 27 2f                      BEQ     XFREXG          ; Handle special case of EXG
5999                         
6000 e65c 81 66                      CMPA    #OP_PULS        ; Is is PULS?
6001 e65e 10 27 00 ad                LBEQ    PULPSH
6002 e662 81 67                      CMPA    #OP_PULU        ; Is is PULU?
6003 e664 10 27 00 a7                LBEQ    PULPSH
6004 e668 81 64                      CMPA    #OP_PSHS        ; Is is PSHS?
6005 e66a 10 27 00 a1                LBEQ    PULPSH
6006 e66e 81 65                      CMPA    #OP_PSHU        ; Is is PSHU?
6007 e670 10 27 00 9b                LBEQ    PULPSH
6008                         
6009                                                         ; Display "  #$nn"
6010 e674 17 fd eb                   LBSR    Print2Spaces    ; Two spaces
6011 e677 86 23                      LDA     #'#             ; Number sign
6012 e679 17 fd ff                   LBSR    PrintChar
6013 e67c 17 fd bc                   LBSR    PrintDollar     ; Dollar sign
6014 e67f ae 8d 89 4d                LDX     ADRS,PCR        ; Get address of op code
6015 e683 a6 01                      LDA     1,X             ; Get next byte (immediate data)
6016 e685 17 fd f9                   LBSR    PrintByte       ; Print as hex value
6017 e688 16 04 2a                   LBRA    done
6018                         
6019                         XFREXG:                         ; Handle special case of TFR and EXG
6020                                                         ; Display "  r1,r2"
6021 e68b 17 fd d4                   LBSR    Print2Spaces    ; Two spaces
6022 e68e ae 8d 89 3e                LDX     ADRS,PCR        ; Get address of op code
6023 e692 a6 01                      LDA     1,X             ; Get next byte (postbyte)
6024 e694 84 f0                      ANDA    #%11110000      ; Mask out source register bits
6025 e696 44                         LSRA                    ; Shift into low order bits
6026 e697 44                         LSRA
6027 e698 44                         LSRA
6028 e699 44                         LSRA
6029 e69a 8d 0e                      BSR     TFREXGRegister  ; Print source register name
6030 e69c 86 2c                      LDA     #',             ; Print comma
6031 e69e 17 fd da                   LBSR    PrintChar
6032 e6a1 a6 01                      LDA     1,X             ; Get postbyte again
6033 e6a3 84 0f                      ANDA    #%00001111      ; Mask out destination register bits
6034 e6a5 8d 03                      BSR     TFREXGRegister  ; Print destination register name
6035 e6a7 16 04 0b                   LBRA    done
6036                         
6037                         ; Look up register name (in A) from Transfer/Exchange postbyte. 4 LSB
6038                         ; bits determine the register name. Value is printed. Invalid value
6039                         ; is shown as '?'.
6040                         ; Value:    0 1 2 3 4 5  8 9 10 11
6041                         ; Register: D X Y U S PC A B CC DP
6042                         
6043                         TFREXGRegister:
6044 e6aa 81 00                      CMPA    #0
6045 e6ac 26 04                      BNE     Try1
6046 e6ae 86 44                      LDA     #'D
6047 e6b0 20 50                      BRA     Print1Reg
6048 e6b2 81 01              Try1:   CMPA    #1
6049 e6b4 26 04                      BNE     Try2
6050 e6b6 86 58                      LDA     #'X
6051 e6b8 20 48                      BRA     Print1Reg
6052 e6ba 81 02              Try2:   CMPA    #2
6053 e6bc 26 04                      BNE     Try3
6054 e6be 86 59                      LDA     #'Y
6055 e6c0 20 40                      BRA     Print1Reg
6056 e6c2 81 03              Try3:   CMPA    #3
6057 e6c4 26 04                      BNE     Try4
6058 e6c6 86 55                      LDA     #'U
6059 e6c8 20 38                      BRA     Print1Reg
6060 e6ca 81 04              Try4:   CMPA    #4
6061 e6cc 26 04                      BNE     Try5
6062 e6ce 86 53                      LDA     #'S
6063 e6d0 20 30                      BRA     Print1Reg
6064 e6d2 81 05              Try5:   CMPA    #5
6065 e6d4 26 06                      BNE     Try8
6066 e6d6 86 50                      LDA     #'P
6067 e6d8 c6 43                      LDB     #'C
6068 e6da 20 2a                      BRA     Print2Reg
6069 e6dc 81 08              Try8:   CMPA    #8
6070 e6de 26 04                      BNE     Try9
6071 e6e0 86 41                      LDA     #'A
6072 e6e2 20 1e                      BRA     Print1Reg
6073 e6e4 81 09              Try9:   CMPA    #9
6074 e6e6 26 04                      BNE     Try10
6075 e6e8 86 42                      LDA     #'B
6076 e6ea 20 16                      BRA     Print1Reg
6077 e6ec 81 0a              Try10:  CMPA    #10
6078 e6ee 26 06                      BNE     Try11
6079 e6f0 86 43                      LDA     #'C
6080 e6f2 c6 43                      LDB     #'C
6081 e6f4 20 10                      BRA     Print2Reg
6082 e6f6 81 0b              Try11:  CMPA    #11
6083 e6f8 26 06                      BNE     Inv
6084 e6fa 86 44                      LDA     #'D
6085 e6fc c6 50                      LDB     #'P
6086 e6fe 20 06                      BRA     Print2Reg
6087 e700 86 3f              Inv:    LDA     #'?             ; Invalid
6088                                                         ; Fall through
6089                         Print1Reg:
6090 e702 17 fd 76                   LBSR   PrintChar        ; Print character
6091 e705 39                         RTS
6092                         Print2Reg:
6093 e706 17 fd 72                   LBSR   PrintChar        ; Print first character
6094 e709 1f 98                      TFR    B,A
6095 e70b 17 fd 6d                   LBSR   PrintChar        ; Print second character
6096 e70e 39                         RTS
6097                         
6098                         ; Handle PSHS/PSHU/PULS/PULU instruction operands
6099                         ; Format is a register list, eg; "  A,B,X"
6100                         
6101                         PULPSH:
6102 e70f 17 fd 50                   LBSR    Print2Spaces    ; Two spaces
6103 e712 86 01                      LDA     #1
6104 e714 b7 6f db                   STA     FIRST           ; Flag set before any items printed
6105 e717 ae 8d 88 b5                LDX     ADRS,PCR        ; Get address of op code
6106 e71b a6 01                      LDA     1,X             ; Get next byte (postbyte)
6107                         
6108                         ; Postbyte bits indicate registers to push/pull when 1.
6109                         ; 7  6   5 4 3  2 1 0
6110                         ; PC S/U Y X DP B A CC
6111                         
6112                         ; TODO: Could simplify this with shifting and lookup table.
6113                         
6114 e71d 85 80                      BITA    #%10000000      ; Bit 7 set?
6115 e71f 27 0d                      BEQ     bit6
6116 e721 34 06                      PSHS    A,B
6117 e723 86 50                      LDA     #'P
6118 e725 c6 43                      LDB     #'C
6119 e727 8d dd                      BSR     Print2Reg       ; Print PC
6120 e729 7f 6f db                   CLR     FIRST
6121 e72c 35 06                      PULS    A,B
6122 e72e 85 40              bit6:   BITA    #%01000000      ; Bit 6 set?
6123 e730 27 21                      BEQ     bit5
6124                         
6125                         ; Need to show S or U depending on instruction
6126                         
6127 e732 34 02                      PSHS    A               ; Save postbyte
6128 e734 b6 6f d4                   LDA     OPTYPE          ; Get opcode type
6129 e737 81 66                      CMPA    #OP_PULS
6130 e739 27 12                      BEQ     printu
6131 e73b 81 64                      CMPA    #OP_PSHS
6132 e73d 27 0e                      BEQ     printu
6133 e73f 17 00 81                   LBSR    PrintCommaIfNotFirst
6134 e742 86 53                      LDA     #'S             ; Print S
6135 e744 8d bc              pr1     BSR     Print1Reg
6136 e746 7f 6f db                   CLR     FIRST
6137 e749 35 02                      PULS    A
6138 e74b 20 06                      bra     bit5
6139 e74d 8d 74              printu: BSR     PrintCommaIfNotFirst
6140 e74f 86 55                      LDA     #'U             ; Print U
6141 e751 20 f1                      bra     pr1
6142 e753 85 20              bit5:   BITA    #%00100000      ; Bit 5 set?
6143 e755 27 0d                      BEQ     bit4
6144 e757 34 02                      PSHS    A
6145 e759 8d 68                      BSR     PrintCommaIfNotFirst
6146 e75b 86 59                      LDA     #'Y
6147 e75d 8d a3                      BSR     Print1Reg       ; Print Y
6148 e75f 7f 6f db                   CLR     FIRST
6149 e762 35 02                      PULS    A
6150 e764 85 10              bit4:   BITA    #%00010000      ; Bit 4 set?
6151 e766 27 0d                      BEQ     bit3
6152 e768 34 02                      PSHS    A
6153 e76a 8d 57                      BSR     PrintCommaIfNotFirst
6154 e76c 86 58                      LDA     #'X
6155 e76e 8d 92                      BSR     Print1Reg       ; Print X
6156 e770 7f 6f db                   CLR     FIRST
6157 e773 35 02                      PULS    A
6158 e775 85 08              bit3:   BITA    #%00001000      ; Bit 3 set?
6159 e777 27 0f                      BEQ     bit2
6160 e779 34 06                      PSHS    A,B
6161 e77b 8d 46                      BSR     PrintCommaIfNotFirst
6162 e77d 86 44                      LDA     #'D
6163 e77f c6 50                      LDB     #'P
6164 e781 8d 83                      BSR     Print2Reg       ; Print DP
6165 e783 7f 6f db                   CLR     FIRST
6166 e786 35 06                      PULS    A,B
6167 e788 85 04              bit2:   BITA    #%00000100      ; Bit 2 set?
6168 e78a 27 0e                      BEQ     bit1
6169 e78c 34 02                      PSHS    A
6170 e78e 8d 33                      BSR     PrintCommaIfNotFirst
6171 e790 86 42                      LDA     #'B
6172 e792 17 ff 6d                   LBSR    Print1Reg       ; Print B
6173 e795 7f 6f db                   CLR     FIRST
6174 e798 35 02                      PULS    A
6175 e79a 85 02              bit1:   BITA    #%00000010      ; Bit 1 set?
6176 e79c 27 0e                      BEQ     bit0
6177 e79e 34 02                      PSHS    A
6178 e7a0 8d 21                      BSR     PrintCommaIfNotFirst
6179 e7a2 86 41                      LDA     #'A
6180 e7a4 17 ff 5b                   LBSR    Print1Reg       ; Print A
6181 e7a7 7f 6f db                   CLR     FIRST
6182 e7aa 35 02                      PULS    A
6183 e7ac 85 01              bit0:   BITA    #%00000001      ; Bit 0 set?
6184 e7ae 27 10                      BEQ     done1
6185 e7b0 34 06                      PSHS    A,B
6186 e7b2 8d 0f                      BSR     PrintCommaIfNotFirst
6187 e7b4 86 43                      LDA     #'C
6188 e7b6 c6 43                      LDB     #'C
6189 e7b8 17 ff 4b                   LBSR    Print2Reg       ; Print CC
6190 e7bb 7f 6f db                   CLR     FIRST
6191 e7be 35 06                      PULS    A,B
6192 e7c0 16 02 f2           done1   LBRA    done
6193                         
6194                         ; Print comma if FIRST flag is not set.
6195                         PrintCommaIfNotFirst:
6196 e7c3 7d 6f db                   TST     FIRST
6197 e7c6 26 05                      BNE     ret1
6198 e7c8 86 2c                      LDA     #',
6199 e7ca 17 fc ae                   LBSR    PrintChar
6200 e7cd 39                 ret1:   RTS
6201                         
6202                         DO_IMMEDIATE16:                 ; Display "  #$nnnn"
6203 e7ce 17 fc 91                   LBSR    Print2Spaces    ; Two spaces
6204 e7d1 86 23                      LDA     #'#             ; Number sign
6205 e7d3 17 fc a5                   LBSR    PrintChar
6206 e7d6 17 fc 62                   LBSR    PrintDollar     ; Dollar sign
6207 e7d9 ae 8d 87 f3                LDX     ADRS,PCR        ; Get address of op code
6208 e7dd a6 01                      LDA     1,X             ; Get first byte (immediate data MSB)
6209 e7df e6 02                      LDB     2,X             ; Get second byte (immediate data LSB)
6210 e7e1 1f 01                      TFR     D,X             ; Put in X to print
6211 e7e3 17 fc a9                   LBSR    PrintAddress    ; Print as hex value
6212 e7e6 16 02 cc                   LBRA    done
6213                         
6214                         DO_DIRECT:                      ; Display "  $nn"
6215 e7e9 17 fc 76                   LBSR    Print2Spaces    ; Two spaces
6216 e7ec 17 fc 4c                   LBSR    PrintDollar     ; Dollar sign
6217 e7ef ae 8d 87 dd                LDX     ADRS,PCR        ; Get address of op code
6218 e7f3 a6 01                      LDA     1,X             ; Get next byte (byte data)
6219 e7f5 17 fc 89                   LBSR    PrintByte       ; Print as hex value
6220 e7f8 16 02 ba                   LBRA    done
6221                         
6222                         DO_EXTENDED:                    ; Display "  $nnnn"
6223 e7fb 17 fc 64                   LBSR    Print2Spaces    ; Two spaces
6224 e7fe 17 fc 3a                   LBSR    PrintDollar     ; Dollar sign
6225 e801 ae 8d 87 cb                LDX     ADRS,PCR        ; Get address of op code
6226 e805 a6 01                      LDA     1,X             ; Get first byte (address MSB)
6227 e807 e6 02                      LDB     2,X             ; Get second byte (address LSB)
6228 e809 1f 01                      TFR     D,X             ; Put in X to print
6229 e80b 17 fc 81                   LBSR    PrintAddress    ; Print as hex value
6230 e80e 16 02 a4                   LBRA    done
6231                         
6232                         DO_RELATIVE8:                   ; Display "  $nnnn"
6233 e811 17 fc 4e                   LBSR    Print2Spaces    ; Two spaces
6234 e814 17 fc 24                   LBSR    PrintDollar     ; Dollar sign
6235                         
6236                         ; Destination address for relative branch is address of opcode + (sign
6237                         ; extended)offset + 2, e.g.
6238                         ;   $1015 + $(FF)FC + 2 = $1013
6239                         ;   $101B + $(00)27 + 2 = $1044
6240                         
6241 e817 ae 8d 87 b5                LDX     ADRS,PCR        ; Get address of op code
6242 e81b e6 01                      LDB     1,X             ; Get first byte (8-bit branch offset)
6243 e81d 1d                         SEX                     ; Sign extend to 16 bits
6244 e81e f3 6f d0                   ADDD    ADRS            ; Add address of op code
6245 e821 c3 00 02                   ADDD    #2              ; Add 2
6246 e824 1f 01                      TFR     D,X             ; Put in X to print
6247 e826 17 fc 66                   LBSR    PrintAddress    ; Print as hex value
6248 e829 16 02 89                   LBRA    done
6249                         
6250                         DO_RELATIVE16:                  ; Display "  $nnnn"
6251 e82c 17 fc 33                   LBSR    Print2Spaces    ; Two spaces
6252 e82f 17 fc 09                   LBSR    PrintDollar     ; Dollar sign
6253                         
6254                         ; Destination address calculation is similar to above, except offset
6255                         ; is 16 bits and need to add 3.
6256                         
6257 e832 ae 8d 87 9a                LDX     ADRS,PCR        ; Get address of op code
6258 e836 ec 01                      LDD     1,X             ; Get next 2 bytes (16-bit branch offset)
6259 e838 f3 6f d0                   ADDD    ADRS            ; Add address of op code
6260 e83b c3 00 03                   ADDD    #3              ; Add 3
6261 e83e 1f 01                      TFR     D,X             ; Put in X to print
6262 e840 17 fc 4c                   LBSR    PrintAddress    ; Print as hex value
6263 e843 16 02 6f                   LBRA    done
6264                         
6265                         DO_INDEXED:
6266 e846 17 fc 19                   LBSR    Print2Spaces    ; Two spaces
6267                         
6268                         ; Addressing modes are determined by the postbyte:
6269                         ;
6270                         ; Postbyte  Format  Additional Bytes
6271                         ; --------  ------  ----------------
6272                         ; 0RRnnnnn  n,R     0
6273                         ; 1RR00100  ,R      0
6274                         ; 1RR01000  n,R     1
6275                         ; 1RR01001  n,R     2
6276                         ; 1RR00110  A,R     0
6277                         ; 1RR00101  B,R     0
6278                         ; 1RR01011  D,R     0
6279                         ; 1RR00000  ,R+     0
6280                         ; 1RR00001  ,R++    0
6281                         ; 1RR00010  ,-R     0
6282                         ; 1RR00011  ,--R    0
6283                         ; 1xx01100  n,PCR   1
6284                         ; 1xx01101  n,PCR   2
6285                         ; 1RR10100  [,R]    0
6286                         ; 1RR11000  [n,R]   1
6287                         ; 1RR11001  [n,R]   2
6288                         ; 1RR10110  [A,R]   0
6289                         ; 1RR10101  [B,R]   0
6290                         ; 1RR11011  [D,R]   0
6291                         ; 1RR10001  [,R++]  0
6292                         ; 1RR10011  [,--R]  0
6293                         ; 1xx11100  [n,PCR] 1
6294                         ; 1xx11101  [n,PCR] 2
6295                         ; 10011111  [n]     2
6296                         ;
6297                         ; Where RR: 00=X 01=Y 10=U 11=S
6298                         
6299 e849 b6 6f d5                   LDA     POSTBYT         ; Get postbyte
6300 e84c 2b 14                      BMI     ind2            ; Branch if MSB is 1
6301                         
6302                                                         ; Format is 0RRnnnnn  n,R
6303 e84e 84 1f                      ANDA    #%00011111      ; Get 5-bit offset
6304 e850 17 fb e8                   LBSR    PrintDollar     ; Dollar sign
6305 e853 17 fc 2b                   LBSR    PrintByte       ; Print offset
6306 e856 17 fb eb                   LBSR    PrintComma      ; Print comma
6307 e859 b6 6f d5                   LDA     POSTBYT         ; Get postbyte again
6308 e85c 17 02 35                   LBSR    PrintRegister   ; Print register name
6309 e85f 16 02 53                   LBRA    done
6310                         ind2:
6311 e862 84 9f                      ANDA    #%10011111      ; Mask out register bits
6312 e864 81 84                      CMPA    #%10000100      ; Check against pattern
6313 e866 26 0c                      BNE     ind3
6314                                                         ; Format is 1RR00100  ,R
6315 e868 17 fb d9                   LBSR    PrintComma      ; Print comma
6316 e86b b6 6f d5                   LDA     POSTBYT         ; Get postbyte again
6317 e86e 17 02 23                   LBSR    PrintRegister   ; Print register name
6318 e871 16 02 41                   LBRA    done
6319                         ind3:
6320 e874 81 88                      CMPA    #%10001000      ; Check against pattern
6321 e876 26 18                      BNE     ind4
6322                                                         ; Format is 1RR01000  n,R
6323 e878 ae 8d 87 54                LDX     ADRS,PCR
6324 e87c a6 02                      LDA     2,X             ; Get 8-bit offset
6325 e87e 17 fb ba                   LBSR    PrintDollar     ; Dollar sign
6326 e881 17 fb fd                   LBSR    PrintByte       ; Display it
6327 e884 17 fb bd                   LBSR    PrintComma      ; Print comma
6328 e887 b6 6f d5                   LDA     POSTBYT         ; Get postbyte again
6329 e88a 17 02 07                   LBSR    PrintRegister   ; Print register name
6330 e88d 16 02 25                   LBRA    done
6331                         ind4:
6332 e890 81 89                      CMPA    #%10001001      ; Check against pattern
6333 e892 26 1a                      BNE     ind5
6334                                                         ; Format is 1RR01001  n,R
6335 e894 ae 8d 87 38                LDX     ADRS,PCR
6336 e898 ec 02                      LDD     2,X             ; Get 16-bit offset
6337 e89a 1f 01                      TFR     D,X
6338 e89c 17 fb 9c                   LBSR    PrintDollar     ; Dollar sign
6339 e89f 17 fb ed                   LBSR    PrintAddress    ; Display it
6340 e8a2 17 fb 9f                   LBSR    PrintComma      ; Print comma
6341 e8a5 b6 6f d5                   LDA     POSTBYT         ; Get postbyte again
6342 e8a8 17 01 e9                   LBSR    PrintRegister   ; Print register name
6343 e8ab 16 02 07                   LBRA    done
6344                         ind5:
6345 e8ae 81 86                      CMPA    #%10000110      ; Check against pattern
6346 e8b0 26 11                      BNE     ind6
6347                                                         ; Format is 1RR00110  A,R
6348 e8b2 86 41                      LDA     #'A
6349 e8b4 17 fb c4                   LBSR    PrintChar       ; Print A
6350 e8b7 17 fb 8a           commar: LBSR    PrintComma      ; Print comma
6351 e8ba b6 6f d5                   LDA     POSTBYT         ; Get postbyte again
6352 e8bd 17 01 d4                   LBSR    PrintRegister   ; Print register name
6353 e8c0 16 01 f2                   LBRA    done
6354                         ind6:
6355 e8c3 81 85                      CMPA    #%10000101      ; Check against pattern
6356 e8c5 26 07                      BNE     ind7
6357                                                         ; Format is 1RR00101  B,R
6358 e8c7 86 42                      LDA     #'B
6359 e8c9 17 fb af                   LBSR    PrintChar
6360 e8cc 20 e9                      BRA     commar
6361                         ind7:
6362 e8ce 81 8b                      CMPA    #%10001011      ; Check against pattern
6363 e8d0 26 07                      BNE     ind8
6364                                                         ; Format is 1RR01011  D,R
6365 e8d2 86 44                      LDA     #'D
6366 e8d4 17 fb a4                   LBSR    PrintChar
6367 e8d7 20 de                      BRA     commar
6368                         ind8:
6369 e8d9 81 80                      CMPA    #%10000000      ; Check against pattern
6370 e8db 26 11                      BNE     ind9
6371                                                         ; Format is 1RR00000  ,R+
6372 e8dd 17 fb 64                   LBSR    PrintComma      ; Print comma
6373 e8e0 b6 6f d5                   LDA     POSTBYT         ; Get postbyte again
6374 e8e3 17 01 ae                   LBSR    PrintRegister   ; Print register name
6375 e8e6 86 2b                      LDA     #'+             ; Print plus
6376 e8e8 17 fb 90                   LBSR    PrintChar
6377 e8eb 16 01 c7                   LBRA    done
6378                         ind9:
6379 e8ee 81 81                      CMPA    #%10000001      ; Check against pattern
6380 e8f0 26 14                      BNE     ind10
6381                                                         ; Format is 1RR00001  ,R++
6382 e8f2 17 fb 4f                   LBSR    PrintComma      ; Print comma
6383 e8f5 b6 6f d5                   LDA     POSTBYT         ; Get postbyte again
6384 e8f8 17 01 99                   LBSR    PrintRegister   ; Print register name
6385 e8fb 86 2b                      LDA     #'+             ; Print plus twice
6386 e8fd 17 fb 7b                   LBSR    PrintChar
6387 e900 17 fb 78                   LBSR    PrintChar
6388 e903 16 01 af                   LBRA    done
6389                         ind10:
6390 e906 81 82                      CMPA    #%10000010      ; Check against pattern
6391 e908 26 11                      BNE     ind11
6392                                                         ; Format is 1RR00010  ,-R
6393 e90a 17 fb 37                   LBSR    PrintComma      ; Print comma
6394 e90d 86 2d                      LDA     #'-             ; Print minus
6395 e90f 17 fb 69                   LBSR    PrintChar
6396 e912 b6 6f d5                   LDA     POSTBYT         ; Get postbyte again
6397 e915 17 01 7c                   LBSR    PrintRegister   ; Print register name
6398 e918 16 01 9a                   LBRA    done
6399                         ind11:
6400 e91b 81 83                      CMPA    #%10000011      ; Check against pattern
6401 e91d 26 14                      BNE     ind12
6402                                                         ; Format is 1RR00011  ,--R
6403 e91f 17 fb 22                   LBSR    PrintComma      ; Print comma
6404 e922 86 2d                      LDA     #'-             ; Print minus twice
6405 e924 17 fb 54                   LBSR    PrintChar
6406 e927 17 fb 51                   LBSR    PrintChar
6407 e92a b6 6f d5                   LDA     POSTBYT         ; Get postbyte again
6408 e92d 17 01 64                   LBSR    PrintRegister   ; Print register name
6409 e930 16 01 82                   LBRA    done
6410                         ind12:
6411 e933 81 8c                      CMPA    #%10001100      ; Check against pattern
6412 e935 26 15                      BNE     ind13
6413                                                         ; Format is 1xx01100  n,PCR
6414 e937 ae 8d 86 95                LDX     ADRS,PCR
6415 e93b a6 02                      LDA     2,X             ; Get 8-bit offset
6416 e93d 17 fa fb                   LBSR    PrintDollar     ; Dollar sign
6417 e940 17 fb 3e                   LBSR    PrintByte       ; Display it
6418 e943 17 fa fe                   LBSR    PrintComma      ; Print comma
6419 e946 17 01 64                   LBSR    PrintPCR        ; Print PCR
6420 e949 16 01 69                   LBRA    done
6421                         ind13:
6422 e94c 81 8d                      CMPA    #%10001101      ; Check against pattern
6423 e94e 26 17                      BNE     ind14
6424                                                         ; Format is 1xx01101  n,PCR
6425 e950 ae 8d 86 7c                LDX     ADRS,PCR
6426 e954 ec 02                      LDD     2,X             ; Get 16-bit offset
6427 e956 1f 01                      TFR     D,X
6428 e958 17 fa e0                   LBSR    PrintDollar     ; Dollar sign
6429 e95b 17 fb 31                   LBSR    PrintAddress    ; Display it
6430 e95e 17 fa e3                   LBSR    PrintComma      ; Print comma
6431 e961 17 01 49                   LBSR    PrintPCR        ; Print PCR
6432 e964 16 01 4e                   LBRA    done
6433                         ind14:
6434 e967 81 94                      CMPA    #%10010100      ; Check against pattern
6435 e969 26 12                      BNE     ind15
6436                                                         ; Format is 1RR10100  [,R]
6437 e96b 17 fa df                   LBSR    PrintLBracket   ; Print left bracket
6438 e96e 17 fa d3                   LBSR    PrintComma      ; Print comma
6439 e971 b6 6f d5                   LDA     POSTBYT         ; Get postbyte again
6440 e974 17 01 1d                   LBSR    PrintRegister   ; Print register name
6441 e977 17 fa dc                   LBSR    PrintRBracket   ; Print right bracket
6442 e97a 16 01 38                   LBRA    done
6443                         ind15:
6444 e97d 81 98                      CMPA    #%10011000      ; Check against pattern
6445 e97f 26 1e                      BNE     ind16
6446                                                         ; Format is 1RR11000  [n,R]
6447 e981 17 fa c9                   LBSR    PrintLBracket   ; Print left bracket
6448 e984 ae 8d 86 48                LDX     ADRS,PCR
6449 e988 a6 02                      LDA     2,X             ; Get 8-bit offset
6450 e98a 17 fa ae                   LBSR    PrintDollar     ; Dollar sign
6451 e98d 17 fa f1                   LBSR    PrintByte       ; Display it
6452 e990 17 fa b1                   LBSR    PrintComma      ; Print comma
6453 e993 b6 6f d5                   LDA     POSTBYT         ; Get postbyte again
6454 e996 17 00 fb                   LBSR    PrintRegister   ; Print register name
6455 e999 17 fa ba                   LBSR    PrintRBracket   ; Print right bracket
6456 e99c 16 01 16                   LBRA    done
6457                         ind16:
6458 e99f 81 99                      CMPA    #%10011001      ; Check against pattern
6459 e9a1 26 20                      BNE     ind17
6460                                                         ; Format is 1RR11001  [n,R]
6461 e9a3 17 fa a7                   LBSR    PrintLBracket   ; Print left bracket
6462 e9a6 ae 8d 86 26                LDX     ADRS,PCR
6463 e9aa ec 02                      LDD     2,X             ; Get 16-bit offset
6464 e9ac 1f 01                      TFR     D,X
6465 e9ae 17 fa 8a                   LBSR    PrintDollar     ; Dollar sign
6466 e9b1 17 fa db                   LBSR    PrintAddress    ; Display it
6467 e9b4 17 fa 8d                   LBSR    PrintComma      ; Print comma
6468 e9b7 b6 6f d5                   LDA     POSTBYT         ; Get postbyte again
6469 e9ba 17 00 d7                   LBSR    PrintRegister   ; Print register name
6470 e9bd 17 fa 96                   LBSR    PrintRBracket   ; Print right bracket
6471 e9c0 16 00 f2                   LBRA    done
6472                         ind17:
6473 e9c3 81 96                      CMPA    #%10010110      ; Check against pattern
6474 e9c5 26 17                      BNE     ind18
6475                                                         ; Format is 1RR10110  [A,R]
6476 e9c7 17 fa 83                   LBSR    PrintLBracket   ; Print left bracket
6477 e9ca 86 41                      LDA     #'A
6478 e9cc 17 fa ac                   LBSR    PrintChar       ; Print A
6479 e9cf 17 fa 72           comrb:  LBSR    PrintComma      ; Print comma
6480 e9d2 b6 6f d5                   LDA     POSTBYT         ; Get postbyte again
6481 e9d5 17 00 bc                   LBSR    PrintRegister   ; Print register name
6482 e9d8 17 fa 7b                   LBSR    PrintRBracket   ; Print right bracket
6483 e9db 16 00 d7                   LBRA    done
6484                         ind18:
6485 e9de 81 95                      CMPA    #%10010101      ; Check against pattern
6486 e9e0 26 0a                      BNE     ind19
6487                                                         ; Format is 1RR10101  [B,R]
6488 e9e2 17 fa 68                   LBSR    PrintLBracket   ; Print left bracket
6489 e9e5 86 42                      LDA     #'B
6490 e9e7 17 fa 91                   LBSR    PrintChar
6491 e9ea 20 e3                      BRA     comrb
6492                         ind19:
6493 e9ec 81 9b                      CMPA    #%10011011      ; Check against pattern
6494 e9ee 26 0a                      BNE     ind20
6495                                                         ; Format is 1RR11011  [D,R]
6496 e9f0 17 fa 5a                   LBSR    PrintLBracket   ; Print left bracket
6497 e9f3 86 44                      LDA     #'D
6498 e9f5 17 fa 83                   LBSR    PrintChar
6499 e9f8 20 d5                      BRA     comrb
6500                         ind20:
6501 e9fa 81 91                      CMPA    #%10010001      ; Check against pattern
6502 e9fc 26 1a                      BNE     ind21
6503                                                         ; Format is 1RR10001  [,R++]
6504 e9fe 17 fa 4c                   LBSR    PrintLBracket   ; Print left bracket
6505 ea01 17 fa 40                   LBSR    PrintComma      ; Print comma
6506 ea04 b6 6f d5                   LDA     POSTBYT         ; Get postbyte again
6507 ea07 17 00 8a                   LBSR    PrintRegister   ; Print register name
6508 ea0a 86 2b                      LDA     #'+             ; Print plus twice
6509 ea0c 17 fa 6c                   LBSR    PrintChar
6510 ea0f 17 fa 69                   LBSR    PrintChar
6511 ea12 17 fa 41                   LBSR    PrintRBracket   ; Print right bracket
6512 ea15 16 00 9d                   LBRA    done
6513                         ind21:
6514 ea18 81 93                      CMPA    #%10010011      ; Check against pattern
6515 ea1a 26 1a                      BNE     ind22
6516                                                         ; Format is 1RR10011  [,--R]
6517 ea1c 17 fa 2e                   LBSR    PrintLBracket   ; Print left bracket
6518 ea1f 17 fa 22                   LBSR    PrintComma      ; Print comma
6519 ea22 86 2d                      LDA     #'-             ; Print minus twice
6520 ea24 17 fa 54                   LBSR    PrintChar
6521 ea27 17 fa 51                   LBSR    PrintChar
6522 ea2a b6 6f d5                   LDA     POSTBYT         ; Get postbyte again
6523 ea2d 17 00 64                   LBSR    PrintRegister   ; Print register name
6524 ea30 17 fa 23                   LBSR    PrintRBracket   ; Print right bracket
6525 ea33 16 00 7f                   LBRA    done
6526                         ind22:
6527 ea36 81 9c                      CMPA    #%10011100      ; Check against pattern
6528 ea38 26 1b                      BNE     ind23
6529                                                         ; Format is 1xx11100  [n,PCR]
6530 ea3a 17 fa 10                   LBSR    PrintLBracket   ; Print left bracket
6531 ea3d ae 8d 85 8f                LDX     ADRS,PCR
6532 ea41 a6 02                      LDA     2,X             ; Get 8-bit offset
6533 ea43 17 f9 f5                   LBSR    PrintDollar     ; Dollar sign
6534 ea46 17 fa 38                   LBSR    PrintByte       ; Display it
6535 ea49 17 f9 f8                   LBSR    PrintComma      ; Print comma
6536 ea4c 17 00 5e                   LBSR    PrintPCR        ; Print PCR
6537 ea4f 17 fa 04                   LBSR    PrintRBracket   ; Print right bracket
6538 ea52 16 00 60                   LBRA    done
6539                         ind23:
6540 ea55 81 9d                      CMPA    #%10011101      ; Check against pattern
6541 ea57 26 1d                      BNE     ind24
6542                                                         ; Format is 1xx11101  [n,PCR]
6543 ea59 17 f9 f1                   LBSR    PrintLBracket   ; Print left bracket
6544 ea5c ae 8d 85 70                LDX     ADRS,PCR
6545 ea60 ec 02                      LDD     2,X             ; Get 16-bit offset
6546 ea62 1f 01                      TFR     D,X
6547 ea64 17 f9 d4                   LBSR    PrintDollar     ; Dollar sign
6548 ea67 17 fa 25                   LBSR    PrintAddress    ; Display it
6549 ea6a 17 f9 d7                   LBSR    PrintComma      ; Print comma
6550 ea6d 17 00 3d                   LBSR    PrintPCR        ; Print PCR
6551 ea70 17 f9 e3                   LBSR    PrintRBracket   ; Print right bracket
6552 ea73 16 00 3f                   LBRA    done
6553                         ind24:
6554 ea76 81 9f                      CMPA    #%10011111      ; Check against pattern
6555 ea78 26 17                      BNE     ind25
6556                                                         ; Format is 1xx11111  [n]
6557 ea7a 17 f9 d0                   LBSR    PrintLBracket   ; Print left bracket
6558 ea7d ae 8d 85 4f                LDX     ADRS,PCR
6559 ea81 ec 02                      LDD     2,X             ; Get 16-bit offset
6560 ea83 1f 01                      TFR     D,X
6561 ea85 17 f9 b3                   LBSR    PrintDollar     ; Dollar sign
6562 ea88 17 fa 04                   LBSR    PrintAddress    ; Display it
6563 ea8b 17 f9 c8                   LBSR    PrintRBracket   ; Print right bracket
6564 ea8e 16 00 24                   LBRA    done
6565                         ind25:                          ; Should never be reached
6566 ea91 16 00 21                   LBRA    done
6567                         
6568                         ; Print register name encoded in bits 5 and 6 of A for indexed
6569                         ; addressing: xRRxxxxx where RR: 00=X 01=Y 10=U 11=S
6570                         ; Registers changed: X
6571                         PrintRegister:
6572 ea94 34 02                      PSHS    A               ; Save A
6573 ea96 84 60                      ANDA    #%01100000      ; Mask out other bits
6574 ea98 44                         LSRA                    ; Shift into 2 LSB
6575 ea99 44                         LSRA
6576 ea9a 44                         LSRA
6577 ea9b 44                         LSRA
6578 ea9c 44                         LSRA
6579 ea9d 30 8d 00 08                LEAX    REGTABLE,PCR    ; Lookup table of register name characters
6580 eaa1 a6 86                      LDA     A,X             ; Get character
6581 eaa3 17 f9 d5                   LBSR    PrintChar       ; Print it
6582 eaa6 35 02                      PULS    A               ; Restore A
6583 eaa8 39                         RTS                     ; Return
6584                         REGTABLE:
6585 eaa9 58 59 55 53                FCC     "XYUS"
6586                         
6587                         
6588                         ; Print the string "PCR" on the console.
6589                         ; Registers changed: X
6590                         PrintPCR:
6591 eaad 30 8d 05 1c                LEAX    MSG3,PCR        ; "PCR" string
6592 eab1 17 f9 e9                   LBSR    PrintString
6593 eab4 39                         RTS
6594                         
6595                         ; Print final CR
6596                         
6597 eab5 17 f9 76           done:   LBSR    PrintCR
6598                         
6599                         ; Update address to next instruction
6600                         ; If it was a page 2/3 instruction, we need to subtract one from the
6601                         ; length to account for ADRS being moved to the second byte of the
6602                         ; instruction.
6603                         
6604 eab8 7d 6f dc                   TST     PAGE23          ; Flag set
6605 eabb 27 03                      BEQ     not23           ; Branch if not
6606 eabd 7a 6f d6                   DEC     LENG            ; Decrement length
6607 eac0 4f                 not23:  CLRA                    ; Clear MSB of D
6608 eac1 f6 6f d6                   LDB     LENG            ; Get length byte in LSB of D
6609 eac4 f3 6f d0                   ADDD    ADRS            ; Add to address
6610 eac7 fd 6f d0                   STD     ADRS            ; Write new address
6611                         
6612                         ; Return
6613 eaca 39                         RTS
6614                         
6615                         ; *** DATA
6616                         
6617                         ; Table of instruction strings. 4 bytes per table entry
6618                         MNEMONICS:
6619 eacb 3f 3f 3f 20                FCC     "??? "          ; $00
6620 eacf 41 42 58 20                FCC     "ABX "          ; $01
6621 ead3 41 44 43 41                FCC     "ADCA"          ; $02
6622 ead7 41 44 43 42                FCC     "ADCB"          ; $03
6623 eadb 41 44 44 41                FCC     "ADDA"          ; $04
6624 eadf 41 44 44 42                FCC     "ADDB"          ; $05
6625 eae3 41 44 44 44                FCC     "ADDD"          ; $06
6626 eae7 41 4e 44 41                FCC     "ANDA"          ; $07
6627 eaeb 41 4e 44 42                FCC     "ANDB"          ; $08
6628 eaef 41 4e 44 43                FCC     "ANDC"          ; $09 Should really  be "ANDCC"
6629 eaf3 41 53 4c 20                FCC     "ASL "          ; $0A
6630 eaf7 41 53 4c 41                FCC     "ASLA"          ; $0B
6631 eafb 41 53 4c 42                FCC     "ASLB"          ; $0C
6632 eaff 41 53 52 20                FCC     "ASR "          ; $0D
6633 eb03 41 53 52 41                FCC     "ASRA"          ; $0E
6634 eb07 41 53 52 42                FCC     "ASRB"          ; $0F
6635 eb0b 42 43 43 20                FCC     "BCC "          ; $10
6636 eb0f 42 43 53 20                FCC     "BCS "          ; $11
6637 eb13 42 45 51 20                FCC     "BEQ "          ; $12
6638 eb17 42 47 45 20                FCC     "BGE "          ; $13
6639 eb1b 42 47 54 20                FCC     "BGT "          ; $14
6640 eb1f 42 48 49 20                FCC     "BHI "          ; $15
6641 eb23 42 49 54 41                FCC     "BITA"          ; $16
6642 eb27 42 49 54 42                FCC     "BITB"          ; $17
6643 eb2b 42 4c 45 20                FCC     "BLE "          ; $18
6644 eb2f 42 4c 53 20                FCC     "BLS "          ; $19
6645 eb33 42 4c 54 20                FCC     "BLT "          ; $1A
6646 eb37 42 4d 49 20                FCC     "BMI "          ; $1B
6647 eb3b 42 4e 45 20                FCC     "BNE "          ; $1C
6648 eb3f 42 50 4c 20                FCC     "BPL "          ; $1D
6649 eb43 42 52 41 20                FCC     "BRA "          ; $1E
6650 eb47 42 52 4e 20                FCC     "BRN "          ; $1F
6651 eb4b 42 53 52 20                FCC     "BSR "          ; $20
6652 eb4f 42 56 43 20                FCC     "BVC "          ; $21
6653 eb53 42 56 53 20                FCC     "BVS "          ; $22
6654 eb57 43 4c 52 20                FCC     "CLR "          ; $23
6655 eb5b 43 4c 52 41                FCC     "CLRA"          ; $24
6656 eb5f 43 4c 52 42                FCC     "CLRB"          ; $25
6657 eb63 43 4d 50 41                FCC     "CMPA"          ; $26
6658 eb67 43 4d 50 42                FCC     "CMPB"          ; $27
6659 eb6b 43 4d 50 44                FCC     "CMPD"          ; $28
6660 eb6f 43 4d 50 53                FCC     "CMPS"          ; $29
6661 eb73 43 4d 50 55                FCC     "CMPU"          ; $2A
6662 eb77 43 4d 50 58                FCC     "CMPX"          ; $2B
6663 eb7b 43 4d 50 59                FCC     "CMPY"          ; $2C
6664 eb7f 43 4f 4d 41                FCC     "COMA"          ; $2D
6665 eb83 43 4f 4d 42                FCC     "COMB"          ; $2E
6666 eb87 43 4f 4d 20                FCC     "COM "          ; $2F
6667 eb8b 43 57 41 49                FCC     "CWAI"          ; $30
6668 eb8f 44 41 41 20                FCC     "DAA "          ; $31
6669 eb93 44 45 43 20                FCC     "DEC "          ; $32
6670 eb97 44 45 43 41                FCC     "DECA"          ; $33
6671 eb9b 44 45 43 42                FCC     "DECB"          ; $34
6672 eb9f 45 4f 52 41                FCC     "EORA"          ; $35
6673 eba3 45 4f 52 42                FCC     "EORB"          ; $36
6674 eba7 45 58 47 20                FCC     "EXG "          ; $37
6675 ebab 49 4e 43 20                FCC     "INC "          ; $38
6676 ebaf 49 4e 43 41                FCC     "INCA"          ; $39
6677 ebb3 49 4e 43 42                FCC     "INCB"          ; $3A
6678 ebb7 4a 4d 50 20                FCC     "JMP "          ; $3B
6679 ebbb 4a 53 52 20                FCC     "JSR "          ; $3C
6680 ebbf 4c 42 43 43                FCC     "LBCC"          ; $3D
6681 ebc3 4c 42 43 53                FCC     "LBCS"          ; $3E
6682 ebc7 4c 42 45 51                FCC     "LBEQ"          ; $3F
6683 ebcb 4c 42 47 45                FCC     "LBGE"          ; $40
6684 ebcf 4c 42 47 54                FCC     "LBGT"          ; $41
6685 ebd3 4c 42 48 49                FCC     "LBHI"          ; $42
6686 ebd7 4c 42 4c 45                FCC     "LBLE"          ; $43
6687 ebdb 4c 42 4c 53                FCC     "LBLS"          ; $44
6688 ebdf 4c 42 4c 54                FCC     "LBLT"          ; $45
6689 ebe3 4c 42 4d 49                FCC     "LBMI"          ; $46
6690 ebe7 4c 42 4e 45                FCC     "LBNE"          ; $47
6691 ebeb 4c 42 50 4c                FCC     "LBPL"          ; $48
6692 ebef 4c 42 52 41                FCC     "LBRA"          ; $49
6693 ebf3 4c 42 52 4e                FCC     "LBRN"          ; $4A
6694 ebf7 4c 42 53 52                FCC     "LBSR"          ; $4B
6695 ebfb 4c 42 56 43                FCC     "LBVC"          ; $4C
6696 ebff 4c 42 56 53                FCC     "LBVS"          ; $4D
6697 ec03 4c 44 41 20                FCC     "LDA "          ; $4E
6698 ec07 4c 44 42 20                FCC     "LDB "          ; $4F
6699 ec0b 4c 44 44 20                FCC     "LDD "          ; $50
6700 ec0f 4c 44 53 20                FCC     "LDS "          ; $51
6701 ec13 4c 44 55 20                FCC     "LDU "          ; $52
6702 ec17 4c 44 58 20                FCC     "LDX "          ; $53
6703 ec1b 4c 44 59 20                FCC     "LDY "          ; $54
6704 ec1f 4c 45 41 53                FCC     "LEAS"          ; $55
6705 ec23 4c 45 41 55                FCC     "LEAU"          ; $56
6706 ec27 4c 45 41 58                FCC     "LEAX"          ; $57
6707 ec2b 4c 45 41 59                FCC     "LEAY"          ; $58
6708 ec2f 4c 53 52 20                FCC     "LSR "          ; $59
6709 ec33 4c 53 52 41                FCC     "LSRA"          ; $5A
6710 ec37 4c 53 52 42                FCC     "LSRB"          ; $5B
6711 ec3b 4d 55 4c 20                FCC     "MUL "          ; $5C
6712 ec3f 4e 45 47 20                FCC     "NEG "          ; $5D
6713 ec43 4e 45 47 41                FCC     "NEGA"          ; $5E
6714 ec47 4e 45 47 42                FCC     "NEGB"          ; $5F
6715 ec4b 4e 4f 50 20                FCC     "NOP "          ; $60
6716 ec4f 4f 52 41 20                FCC     "ORA "          ; $61
6717 ec53 4f 52 42 20                FCC     "ORB "          ; $62
6718 ec57 4f 52 43 43                FCC     "ORCC"          ; $63
6719 ec5b 50 53 48 53                FCC     "PSHS"          ; $64
6720 ec5f 50 53 48 55                FCC     "PSHU"          ; $65
6721 ec63 50 55 4c 53                FCC     "PULS"          ; $66
6722 ec67 50 55 4c 55                FCC     "PULU"          ; $67
6723 ec6b 52 4f 4c 20                FCC     "ROL "          ; $68
6724 ec6f 52 4f 4c 41                FCC     "ROLA"          ; $69
6725 ec73 52 4f 4c 42                FCC     "ROLB"          ; $6A
6726 ec77 52 4f 52 20                FCC     "ROR "          ; $6B
6727 ec7b 52 4f 52 41                FCC     "RORA"          ; $6C
6728 ec7f 52 4f 52 42                FCC     "RORB"          ; $6D
6729 ec83 52 54 49 20                FCC     "RTI "          ; $6E
6730 ec87 52 54 53 20                FCC     "RTS "          ; $6F
6731 ec8b 53 42 43 41                FCC     "SBCA"          ; $70
6732 ec8f 53 42 43 42                FCC     "SBCB"          ; $71
6733 ec93 53 45 58 20                FCC     "SEX "          ; $72
6734 ec97 53 54 41 20                FCC     "STA "          ; $73
6735 ec9b 53 54 42 20                FCC     "STB "          ; $74
6736 ec9f 53 54 44 20                FCC     "STD "          ; $75
6737 eca3 53 54 53 20                FCC     "STS "          ; $76
6738 eca7 53 54 55 20                FCC     "STU "          ; $77
6739 ecab 53 54 58 20                FCC     "STX "          ; $78
6740 ecaf 53 54 59 20                FCC     "STY "          ; $79
6741 ecb3 53 55 42 41                FCC     "SUBA"          ; $7A
6742 ecb7 53 55 42 42                FCC     "SUBB"          ; $7B
6743 ecbb 53 55 42 44                FCC     "SUBD"          ; $7C
6744 ecbf 53 57 49 20                FCC     "SWI "          ; $7D
6745 ecc3 53 57 49 32                FCC     "SWI2"          ; $7E
6746 ecc7 53 57 49 33                FCC     "SWI3"          ; $7F
6747 eccb 53 59 4e 43                FCC     "SYNC"          ; $80
6748 eccf 54 46 52 20                FCC     "TFR "          ; $81
6749 ecd3 54 53 54 20                FCC     "TST "          ; $82
6750 ecd7 54 53 54 41                FCC     "TSTA"          ; $83
6751 ecdb 54 53 54 42                FCC     "TSTB"          ; $84
6752                         
6753                         ; Lengths of instructions given an addressing mode. Matches values of
6754                         ; AM_* Indexed addessing instructions length can increase due to post
6755                         ; byte.
6756                         LENGTHS:
6757 ecdf 01                         FCB     1               ; 0 AM_INVALID
6758 ece0 01                         FCB     1               ; 1 AM_INHERENT
6759 ece1 02                         FCB     2               ; 2 AM_IMMEDIATE8
6760 ece2 03                         FCB     3               ; 3 AM_IMMEDIATE16
6761 ece3 02                         FCB     2               ; 4 AM_DIRECT
6762 ece4 03                         FCB     3               ; 5 AM_EXTENDED
6763 ece5 02                         FCB     2               ; 6 AM_RELATIVE8
6764 ece6 03                         FCB     3               ; 7 AM_RELATIVE16
6765 ece7 02                         FCB     2               ; 8 AM_INDEXED
6766                         
6767                         ; Lookup table to return needed remaining spaces to print to pad out
6768                         ; instruction to correct column in disassembly.
6769                         ; # bytes: 1 2 3 4
6770                         ; Padding: 9 6 3 0
6771                         PADDING:
6772 ece8 0a 07 04 01                FCB     10, 7, 4, 1
6773                         
6774                         ; Lookup table to return number of additional bytes for indexed
6775                         ; addressing based on low order 5 bits of postbyte. Based on
6776                         ; detailed list of values below.
6777                         
6778                         POSTBYTES:
6779 ecec 00 00 00 00 00 00          FCB     0, 0, 0, 0, 0, 0, 0, 0
     00 00
6780 ecf4 01 02 00 00 01 02          FCB     1, 2, 0, 0, 1, 2, 0, 0
     00 00
6781 ecfc 00 00 00 00 00 00          FCB     0, 0, 0, 0, 0, 0, 0, 0
     00 00
6782 ed04 01 02 00 00 01 02          FCB     1, 2, 0, 0, 1, 2, 0, 2
     00 02
6783                         
6784                         ; Pattern:  # Extra bytes:
6785                         ; --------  --------------
6786                         ; 0XXXXXXX   0
6787                         ; 1XX00000   0
6788                         ; 1XX00001   0
6789                         ; 1XX00010   0
6790                         ; 1XX00011   0
6791                         ; 1XX00100   0
6792                         ; 1X000101   0
6793                         ; 1XX00110   0
6794                         ; 1XX00111   0 (INVALID)
6795                         ; 1XX01000   1
6796                         ; 1XX01001   2
6797                         ; 1XX01010   0 (INVALID)
6798                         ; 1XX01011   0
6799                         ; 1XX01100   1
6800                         ; 1XX01101   2
6801                         ; 1XX01110   0 (INVALID)
6802                         ; 1XX01111   0 (INVALID)
6803                         ; 1XX10000   0 (INVALID)
6804                         ; 1XX10001   0
6805                         ; 1XX10010   0 (INVALID)
6806                         ; 1XX10011   0
6807                         ; 1XX10100   0
6808                         ; 1XX10101   0
6809                         ; 1XX10110   0
6810                         ; 1XX10111   0 (INVALID)
6811                         ; 1XX11000   1
6812                         ; 1XX11001   2
6813                         ; 1XX11010   0 (INVALID)
6814                         ; 1XX11011   0
6815                         ; 1XX11100   1
6816                         ; 1XX11101   2
6817                         ; 1XX11110   0 (INVALID)
6818                         ; 1XX11111   2
6819                         
6820                         ; Opcodes. Listed in order indexed by op code. Defines the mnemonic.
6821                         OPCODES:
6822 ed0c 5d                         FCB     OP_NEG          ; 00
6823 ed0d 00                         FCB     OP_INV          ; 01
6824 ed0e 00                         FCB     OP_INV          ; 02
6825 ed0f 2e                         FCB     OP_COMB         ; 03
6826 ed10 59                         FCB     OP_LSR          ; 04
6827 ed11 00                         FCB     OP_INV          ; 05
6828 ed12 6b                         FCB     OP_ROR          ; 06
6829 ed13 0d                         FCB     OP_ASR          ; 07
6830 ed14 0a                         FCB     OP_ASL          ; 08
6831 ed15 68                         FCB     OP_ROL          ; 09
6832 ed16 32                         FCB     OP_DEC          ; 0A
6833 ed17 00                         FCB     OP_INV          ; 0B
6834 ed18 38                         FCB     OP_INC          ; 0C
6835 ed19 82                         FCB     OP_TST          ; 0D
6836 ed1a 3b                         FCB     OP_JMP          ; 0E
6837 ed1b 23                         FCB     OP_CLR          ; 0F
6838                         
6839 ed1c 00                         FCB     OP_INV          ; 10 Page 2 extended opcodes (see other table)
6840 ed1d 00                         FCB     OP_INV          ; 11 Page 3 extended opcodes (see other table)
6841 ed1e 60                         FCB     OP_NOP          ; 12
6842 ed1f 80                         FCB     OP_SYNC         ; 13
6843 ed20 00                         FCB     OP_INV          ; 14
6844 ed21 00                         FCB     OP_INV          ; 15
6845 ed22 49                         FCB     OP_LBRA         ; 16
6846 ed23 4b                         FCB     OP_LBSR         ; 17
6847 ed24 00                         FCB     OP_INV          ; 18
6848 ed25 31                         FCB     OP_DAA          ; 19
6849 ed26 63                         FCB     OP_ORCC         ; 1A
6850 ed27 00                         FCB     OP_INV          ; 1B
6851 ed28 09                         FCB     OP_ANDCC        ; 1C
6852 ed29 72                         FCB     OP_SEX          ; 1D
6853 ed2a 37                         FCB     OP_EXG          ; 1E
6854 ed2b 81                         FCB     OP_TFR          ; 1F
6855                         
6856 ed2c 1e                         FCB     OP_BRA          ; 20
6857 ed2d 1f                         FCB     OP_BRN          ; 21
6858 ed2e 15                         FCB     OP_BHI          ; 22
6859 ed2f 19                         FCB     OP_BLS          ; 23
6860 ed30 10                         FCB     OP_BCC          ; 24
6861 ed31 11                         FCB     OP_BCS          ; 25
6862 ed32 1c                         FCB     OP_BNE          ; 26
6863 ed33 12                         FCB     OP_BEQ          ; 27
6864 ed34 21                         FCB     OP_BVC          ; 28
6865 ed35 22                         FCB     OP_BVS          ; 29
6866 ed36 1d                         FCB     OP_BPL          ; 2A
6867 ed37 1b                         FCB     OP_BMI          ; 2B
6868 ed38 13                         FCB     OP_BGE          ; 2C
6869 ed39 1a                         FCB     OP_BLT          ; 2D
6870 ed3a 14                         FCB     OP_BGT          ; 2E
6871 ed3b 18                         FCB     OP_BLE          ; 2F
6872                         
6873 ed3c 57                         FCB     OP_LEAX         ; 30
6874 ed3d 58                         FCB     OP_LEAY         ; 31
6875 ed3e 55                         FCB     OP_LEAS         ; 32
6876 ed3f 56                         FCB     OP_LEAU         ; 33
6877 ed40 64                         FCB     OP_PSHS         ; 34
6878 ed41 66                         FCB     OP_PULS         ; 35
6879 ed42 65                         FCB     OP_PSHU         ; 36
6880 ed43 67                         FCB     OP_PULU         ; 37
6881 ed44 00                         FCB     OP_INV          ; 38
6882 ed45 6f                         FCB     OP_RTS          ; 39
6883 ed46 01                         FCB     OP_ABX          ; 3A
6884 ed47 6e                         FCB     OP_RTI          ; 3B
6885 ed48 30                         FCB     OP_CWAI         ; 3C
6886 ed49 5c                         FCB     OP_MUL          ; 3D
6887 ed4a 00                         FCB     OP_INV          ; 3E
6888 ed4b 7d                         FCB     OP_SWI          ; 3F
6889                         
6890 ed4c 5e                         FCB     OP_NEGA         ; 40
6891 ed4d 00                         FCB     OP_INV          ; 41
6892 ed4e 00                         FCB     OP_INV          ; 42
6893 ed4f 2d                         FCB     OP_COMA         ; 43
6894 ed50 5a                         FCB     OP_LSRA         ; 44
6895 ed51 00                         FCB     OP_INV          ; 45
6896 ed52 6c                         FCB     OP_RORA         ; 46
6897 ed53 0e                         FCB     OP_ASRA         ; 47
6898 ed54 0b                         FCB     OP_ASLA         ; 48
6899 ed55 69                         FCB     OP_ROLA         ; 49
6900 ed56 33                         FCB     OP_DECA         ; 4A
6901 ed57 00                         FCB     OP_INV          ; 4B
6902 ed58 39                         FCB     OP_INCA         ; 4C
6903 ed59 83                         FCB     OP_TSTA         ; 4D
6904 ed5a 00                         FCB     OP_INV          ; 4E
6905 ed5b 24                         FCB     OP_CLRA         ; 4F
6906                         
6907 ed5c 5f                         FCB     OP_NEGB         ; 50
6908 ed5d 00                         FCB     OP_INV          ; 51
6909 ed5e 00                         FCB     OP_INV          ; 52
6910 ed5f 2e                         FCB     OP_COMB         ; 53
6911 ed60 5b                         FCB     OP_LSRB         ; 54
6912 ed61 00                         FCB     OP_INV          ; 55
6913 ed62 6d                         FCB     OP_RORB         ; 56
6914 ed63 0f                         FCB     OP_ASRB         ; 57
6915 ed64 0c                         FCB     OP_ASLB         ; 58
6916 ed65 6a                         FCB     OP_ROLB         ; 59
6917 ed66 34                         FCB     OP_DECB         ; 5A
6918 ed67 00                         FCB     OP_INV          ; 5B
6919 ed68 3a                         FCB     OP_INCB         ; 5C
6920 ed69 84                         FCB     OP_TSTB         ; 5D
6921 ed6a 00                         FCB     OP_INV          ; 5E
6922 ed6b 25                         FCB     OP_CLRB         ; 5F
6923                         
6924 ed6c 5d                         FCB     OP_NEG          ; 60
6925 ed6d 00                         FCB     OP_INV          ; 61
6926 ed6e 00                         FCB     OP_INV          ; 62
6927 ed6f 2f                         FCB     OP_COM          ; 63
6928 ed70 59                         FCB     OP_LSR          ; 64
6929 ed71 00                         FCB     OP_INV          ; 65
6930 ed72 6b                         FCB     OP_ROR          ; 66
6931 ed73 0d                         FCB     OP_ASR          ; 67
6932 ed74 0a                         FCB     OP_ASL          ; 68
6933 ed75 68                         FCB     OP_ROL          ; 69
6934 ed76 32                         FCB     OP_DEC          ; 6A
6935 ed77 00                         FCB     OP_INV          ; 6B
6936 ed78 38                         FCB     OP_INC          ; 6C
6937 ed79 82                         FCB     OP_TST          ; 6D
6938 ed7a 3b                         FCB     OP_JMP          ; 6E
6939 ed7b 23                         FCB     OP_CLR          ; 6F
6940                         
6941 ed7c 5d                         FCB     OP_NEG          ; 70
6942 ed7d 00                         FCB     OP_INV          ; 71
6943 ed7e 00                         FCB     OP_INV          ; 72
6944 ed7f 2f                         FCB     OP_COM          ; 73
6945 ed80 59                         FCB     OP_LSR          ; 74
6946 ed81 00                         FCB     OP_INV          ; 75
6947 ed82 6b                         FCB     OP_ROR          ; 76
6948 ed83 0d                         FCB     OP_ASR          ; 77
6949 ed84 0a                         FCB     OP_ASL          ; 78
6950 ed85 68                         FCB     OP_ROL          ; 79
6951 ed86 32                         FCB     OP_DEC          ; 7A
6952 ed87 00                         FCB     OP_INV          ; 7B
6953 ed88 38                         FCB     OP_INC          ; 7C
6954 ed89 82                         FCB     OP_TST          ; 7D
6955 ed8a 3b                         FCB     OP_JMP          ; 7E
6956 ed8b 23                         FCB     OP_CLR          ; 7F
6957                         
6958 ed8c 7a                         FCB     OP_SUBA         ; 80
6959 ed8d 26                         FCB     OP_CMPA         ; 81
6960 ed8e 70                         FCB     OP_SBCA         ; 82
6961 ed8f 7c                         FCB     OP_SUBD         ; 83
6962 ed90 07                         FCB     OP_ANDA         ; 84
6963 ed91 16                         FCB     OP_BITA         ; 85
6964 ed92 4e                         FCB     OP_LDA          ; 86
6965 ed93 00                         FCB     OP_INV          ; 87
6966 ed94 35                         FCB     OP_EORA         ; 88
6967 ed95 02                         FCB     OP_ADCA         ; 89
6968 ed96 61                         FCB     OP_ORA          ; 8A
6969 ed97 04                         FCB     OP_ADDA         ; 8B
6970 ed98 2b                         FCB     OP_CMPX         ; 8C
6971 ed99 20                         FCB     OP_BSR          ; 8D
6972 ed9a 53                         FCB     OP_LDX          ; 8E
6973 ed9b 00                         FCB     OP_INV          ; 8F
6974                         
6975 ed9c 7a                         FCB     OP_SUBA         ; 90
6976 ed9d 26                         FCB     OP_CMPA         ; 91
6977 ed9e 70                         FCB     OP_SBCA         ; 92
6978 ed9f 7c                         FCB     OP_SUBD         ; 93
6979 eda0 07                         FCB     OP_ANDA         ; 94
6980 eda1 16                         FCB     OP_BITA         ; 95
6981 eda2 4e                         FCB     OP_LDA          ; 96
6982 eda3 73                         FCB     OP_STA          ; 97
6983 eda4 35                         FCB     OP_EORA         ; 98
6984 eda5 02                         FCB     OP_ADCA         ; 99
6985 eda6 61                         FCB     OP_ORA          ; 9A
6986 eda7 04                         FCB     OP_ADDA         ; 9B
6987 eda8 2b                         FCB     OP_CMPX         ; 9C
6988 eda9 3c                         FCB     OP_JSR          ; 9D
6989 edaa 53                         FCB     OP_LDX          ; 9E
6990 edab 78                         FCB     OP_STX          ; 9F
6991                         
6992 edac 7a                         FCB     OP_SUBA         ; A0
6993 edad 26                         FCB     OP_CMPA         ; A1
6994 edae 70                         FCB     OP_SBCA         ; A2
6995 edaf 7c                         FCB     OP_SUBD         ; A3
6996 edb0 07                         FCB     OP_ANDA         ; A4
6997 edb1 16                         FCB     OP_BITA         ; A5
6998 edb2 4e                         FCB     OP_LDA          ; A6
6999 edb3 73                         FCB     OP_STA          ; A7
7000 edb4 35                         FCB     OP_EORA         ; A8
7001 edb5 02                         FCB     OP_ADCA         ; A9
7002 edb6 61                         FCB     OP_ORA          ; AA
7003 edb7 04                         FCB     OP_ADDA         ; AB
7004 edb8 2b                         FCB     OP_CMPX         ; AC
7005 edb9 3c                         FCB     OP_JSR          ; AD
7006 edba 53                         FCB     OP_LDX          ; AE
7007 edbb 78                         FCB     OP_STX          ; AF
7008                         
7009 edbc 7a                         FCB     OP_SUBA         ; B0
7010 edbd 26                         FCB     OP_CMPA         ; B1
7011 edbe 70                         FCB     OP_SBCA         ; B2
7012 edbf 7c                         FCB     OP_SUBD         ; B3
7013 edc0 07                         FCB     OP_ANDA         ; B4
7014 edc1 16                         FCB     OP_BITA         ; B5
7015 edc2 4e                         FCB     OP_LDA          ; B6
7016 edc3 73                         FCB     OP_STA          ; B7
7017 edc4 35                         FCB     OP_EORA         ; B8
7018 edc5 02                         FCB     OP_ADCA         ; B9
7019 edc6 61                         FCB     OP_ORA          ; BA
7020 edc7 04                         FCB     OP_ADDA         ; BB
7021 edc8 2b                         FCB     OP_CMPX         ; BC
7022 edc9 3c                         FCB     OP_JSR          ; BD
7023 edca 53                         FCB     OP_LDX          ; BE
7024 edcb 78                         FCB     OP_STX          ; BF
7025                         
7026 edcc 7b                         FCB     OP_SUBB         ; C0
7027 edcd 27                         FCB     OP_CMPB         ; C1
7028 edce 71                         FCB     OP_SBCB         ; C2
7029 edcf 06                         FCB     OP_ADDD         ; C3
7030 edd0 08                         FCB     OP_ANDB         ; C4
7031 edd1 17                         FCB     OP_BITB         ; C5
7032 edd2 4f                         FCB     OP_LDB          ; C6
7033 edd3 00                         FCB     OP_INV          ; C7
7034 edd4 36                         FCB     OP_EORB         ; C8
7035 edd5 03                         FCB     OP_ADCB         ; C9
7036 edd6 62                         FCB     OP_ORB          ; CA
7037 edd7 05                         FCB     OP_ADDB         ; CB
7038 edd8 50                         FCB     OP_LDD          ; CC
7039 edd9 00                         FCB     OP_INV          ; CD
7040 edda 52                         FCB     OP_LDU          ; CE
7041 eddb 00                         FCB     OP_INV          ; CF
7042                         
7043 eddc 7b                         FCB     OP_SUBB         ; D0
7044 eddd 27                         FCB     OP_CMPB         ; D1
7045 edde 71                         FCB     OP_SBCB         ; D2
7046 eddf 06                         FCB     OP_ADDD         ; D3
7047 ede0 08                         FCB     OP_ANDB         ; D4
7048 ede1 17                         FCB     OP_BITB         ; D5
7049 ede2 4f                         FCB     OP_LDB          ; D6
7050 ede3 74                         FCB     OP_STB          ; D7
7051 ede4 36                         FCB     OP_EORB         ; D8
7052 ede5 03                         FCB     OP_ADCB         ; D9
7053 ede6 62                         FCB     OP_ORB          ; DA
7054 ede7 05                         FCB     OP_ADDB         ; DB
7055 ede8 50                         FCB     OP_LDD          ; DC
7056 ede9 75                         FCB     OP_STD          ; DD
7057 edea 52                         FCB     OP_LDU          ; DE
7058 edeb 77                         FCB     OP_STU          ; DF
7059                         
7060 edec 7b                         FCB     OP_SUBB         ; E0
7061 eded 27                         FCB     OP_CMPB         ; E1
7062 edee 71                         FCB     OP_SBCB         ; E2
7063 edef 06                         FCB     OP_ADDD         ; E3
7064 edf0 08                         FCB     OP_ANDB         ; E4
7065 edf1 17                         FCB     OP_BITB         ; E5
7066 edf2 4f                         FCB     OP_LDB          ; E6
7067 edf3 74                         FCB     OP_STB          ; E7
7068 edf4 36                         FCB     OP_EORB         ; E8
7069 edf5 03                         FCB     OP_ADCB         ; E9
7070 edf6 62                         FCB     OP_ORB          ; EA
7071 edf7 05                         FCB     OP_ADDB         ; EB
7072 edf8 50                         FCB     OP_LDD          ; EC
7073 edf9 75                         FCB     OP_STD          ; ED
7074 edfa 52                         FCB     OP_LDU          ; EE
7075 edfb 77                         FCB     OP_STU          ; EF
7076                         
7077 edfc 7b                         FCB     OP_SUBB         ; F0
7078 edfd 27                         FCB     OP_CMPB         ; F1
7079 edfe 71                         FCB     OP_SBCB         ; F2
7080 edff 06                         FCB     OP_ADDD         ; F3
7081 ee00 08                         FCB     OP_ANDB         ; F4
7082 ee01 17                         FCB     OP_BITB         ; F5
7083 ee02 4f                         FCB     OP_LDB          ; F6
7084 ee03 74                         FCB     OP_STB          ; F7
7085 ee04 36                         FCB     OP_EORB         ; F8
7086 ee05 03                         FCB     OP_ADCB         ; F9
7087 ee06 62                         FCB     OP_ORB          ; FA
7088 ee07 05                         FCB     OP_ADDB         ; FB
7089 ee08 50                         FCB     OP_LDD          ; FC
7090 ee09 75                         FCB     OP_STD          ; FD
7091 ee0a 52                         FCB     OP_LDU          ; FE
7092 ee0b 77                         FCB     OP_STU          ; FF
7093                         
7094                         ; Table of addressing modes. Listed in order,indexed by op code.
7095                         MODES:
7096 ee0c 04                         FCB     AM_DIRECT       ; 00
7097 ee0d 00                         FCB     AM_INVALID      ; 01
7098 ee0e 00                         FCB     AM_INVALID      ; 02
7099 ee0f 04                         FCB     AM_DIRECT       ; 03
7100 ee10 04                         FCB     AM_DIRECT       ; 04
7101 ee11 00                         FCB     AM_INVALID      ; 05
7102 ee12 04                         FCB     AM_DIRECT       ; 06
7103 ee13 04                         FCB     AM_DIRECT       ; 07
7104 ee14 04                         FCB     AM_DIRECT       ; 08
7105 ee15 04                         FCB     AM_DIRECT       ; 09
7106 ee16 04                         FCB     AM_DIRECT       ; 0A
7107 ee17 00                         FCB     AM_INVALID      ; 0B
7108 ee18 04                         FCB     AM_DIRECT       ; 0C
7109 ee19 04                         FCB     AM_DIRECT       ; 0D
7110 ee1a 04                         FCB     AM_DIRECT       ; 0E
7111 ee1b 04                         FCB     AM_DIRECT       ; 0F
7112                         
7113 ee1c 00                         FCB     AM_INVALID      ; 10 Page 2 extended opcodes (see other table)
7114 ee1d 00                         FCB     AM_INVALID      ; 11 Page 3 extended opcodes (see other table)
7115 ee1e 01                         FCB     AM_INHERENT     ; 12
7116 ee1f 01                         FCB     AM_INHERENT     ; 13
7117 ee20 00                         FCB     AM_INVALID      ; 14
7118 ee21 00                         FCB     AM_INVALID      ; 15
7119 ee22 07                         FCB     AM_RELATIVE16   ; 16
7120 ee23 07                         FCB     AM_RELATIVE16   ; 17
7121 ee24 00                         FCB     AM_INVALID      ; 18
7122 ee25 01                         FCB     AM_INHERENT     ; 19
7123 ee26 02                         FCB     AM_IMMEDIATE8   ; 1A
7124 ee27 00                         FCB     AM_INVALID      ; 1B
7125 ee28 02                         FCB     AM_IMMEDIATE8   ; 1C
7126 ee29 01                         FCB     AM_INHERENT     ; 1D
7127 ee2a 02                         FCB     AM_IMMEDIATE8   ; 1E
7128 ee2b 02                         FCB     AM_IMMEDIATE8   ; 1F
7129                         
7130 ee2c 06                         FCB     AM_RELATIVE8    ; 20
7131 ee2d 06                         FCB     AM_RELATIVE8    ; 21
7132 ee2e 06                         FCB     AM_RELATIVE8    ; 22
7133 ee2f 06                         FCB     AM_RELATIVE8    ; 23
7134 ee30 06                         FCB     AM_RELATIVE8    ; 24
7135 ee31 06                         FCB     AM_RELATIVE8    ; 25
7136 ee32 06                         FCB     AM_RELATIVE8    ; 26
7137 ee33 06                         FCB     AM_RELATIVE8    ; 27
7138 ee34 06                         FCB     AM_RELATIVE8    ; 28
7139 ee35 06                         FCB     AM_RELATIVE8    ; 29
7140 ee36 06                         FCB     AM_RELATIVE8    ; 2A
7141 ee37 06                         FCB     AM_RELATIVE8    ; 2B
7142 ee38 06                         FCB     AM_RELATIVE8    ; 2C
7143 ee39 06                         FCB     AM_RELATIVE8    ; 2D
7144 ee3a 06                         FCB     AM_RELATIVE8    ; 2E
7145 ee3b 06                         FCB     AM_RELATIVE8    ; 2F
7146                         
7147 ee3c 08                         FCB     AM_INDEXED      ; 30
7148 ee3d 08                         FCB     AM_INDEXED      ; 31
7149 ee3e 08                         FCB     AM_INDEXED      ; 32
7150 ee3f 08                         FCB     AM_INDEXED      ; 33
7151 ee40 02                         FCB     AM_IMMEDIATE8   ; 34
7152 ee41 02                         FCB     AM_IMMEDIATE8   ; 35
7153 ee42 02                         FCB     AM_IMMEDIATE8   ; 36
7154 ee43 02                         FCB     AM_IMMEDIATE8   ; 37
7155 ee44 00                         FCB     AM_INVALID      ; 38
7156 ee45 01                         FCB     AM_INHERENT     ; 39
7157 ee46 01                         FCB     AM_INHERENT     ; 3A
7158 ee47 01                         FCB     AM_INHERENT     ; 3B
7159 ee48 02                         FCB     AM_IMMEDIATE8   ; 3C
7160 ee49 01                         FCB     AM_INHERENT     ; 3D
7161 ee4a 00                         FCB     AM_INVALID      ; 3E
7162 ee4b 01                         FCB     AM_INHERENT     ; 3F
7163                         
7164 ee4c 01                         FCB     AM_INHERENT     ; 40
7165 ee4d 00                         FCB     AM_INVALID      ; 41
7166 ee4e 00                         FCB     AM_INVALID      ; 42
7167 ee4f 01                         FCB     AM_INHERENT     ; 43
7168 ee50 01                         FCB     AM_INHERENT     ; 44
7169 ee51 00                         FCB     AM_INVALID      ; 45
7170 ee52 01                         FCB     AM_INHERENT     ; 46
7171 ee53 01                         FCB     AM_INHERENT     ; 47
7172 ee54 01                         FCB     AM_INHERENT     ; 48
7173 ee55 01                         FCB     AM_INHERENT     ; 49
7174 ee56 01                         FCB     AM_INHERENT     ; 4A
7175 ee57 00                         FCB     AM_INVALID      ; 4B
7176 ee58 01                         FCB     AM_INHERENT     ; 4C
7177 ee59 01                         FCB     AM_INHERENT     ; 4D
7178 ee5a 00                         FCB     AM_INVALID      ; 4E
7179 ee5b 01                         FCB     AM_INHERENT     ; 4F
7180                         
7181 ee5c 01                         FCB     AM_INHERENT     ; 50
7182 ee5d 00                         FCB     AM_INVALID      ; 51
7183 ee5e 00                         FCB     AM_INVALID      ; 52
7184 ee5f 01                         FCB     AM_INHERENT     ; 53
7185 ee60 01                         FCB     AM_INHERENT     ; 54
7186 ee61 00                         FCB     AM_INVALID      ; 55
7187 ee62 01                         FCB     AM_INHERENT     ; 56
7188 ee63 01                         FCB     AM_INHERENT     ; 57
7189 ee64 01                         FCB     AM_INHERENT     ; 58
7190 ee65 01                         FCB     AM_INHERENT     ; 59
7191 ee66 01                         FCB     AM_INHERENT     ; 5A
7192 ee67 00                         FCB     AM_INVALID      ; 5B
7193 ee68 01                         FCB     AM_INHERENT     ; 5C
7194 ee69 01                         FCB     AM_INHERENT     ; 5D
7195 ee6a 00                         FCB     AM_INVALID      ; 5E
7196 ee6b 01                         FCB     AM_INHERENT     ; 5F
7197                         
7198 ee6c 08                         FCB     AM_INDEXED      ; 60
7199 ee6d 00                         FCB     AM_INVALID      ; 61
7200 ee6e 00                         FCB     AM_INVALID      ; 62
7201 ee6f 08                         FCB     AM_INDEXED      ; 63
7202 ee70 08                         FCB     AM_INDEXED      ; 64
7203 ee71 00                         FCB     AM_INVALID      ; 65
7204 ee72 08                         FCB     AM_INDEXED      ; 66
7205 ee73 08                         FCB     AM_INDEXED      ; 67
7206 ee74 08                         FCB     AM_INDEXED      ; 68
7207 ee75 08                         FCB     AM_INDEXED      ; 69
7208 ee76 08                         FCB     AM_INDEXED      ; 6A
7209 ee77 00                         FCB     AM_INVALID      ; 6B
7210 ee78 08                         FCB     AM_INDEXED      ; 6C
7211 ee79 08                         FCB     AM_INDEXED      ; 6D
7212 ee7a 08                         FCB     AM_INDEXED      ; 6E
7213 ee7b 08                         FCB     AM_INDEXED      ; 6F
7214                         
7215 ee7c 05                         FCB     AM_EXTENDED     ; 70
7216 ee7d 00                         FCB     AM_INVALID      ; 71
7217 ee7e 00                         FCB     AM_INVALID      ; 72
7218 ee7f 05                         FCB     AM_EXTENDED     ; 73
7219 ee80 05                         FCB     AM_EXTENDED     ; 74
7220 ee81 00                         FCB     AM_INVALID      ; 75
7221 ee82 05                         FCB     AM_EXTENDED     ; 76
7222 ee83 05                         FCB     AM_EXTENDED     ; 77
7223 ee84 05                         FCB     AM_EXTENDED     ; 78
7224 ee85 05                         FCB     AM_EXTENDED     ; 79
7225 ee86 05                         FCB     AM_EXTENDED     ; 7A
7226 ee87 00                         FCB     AM_INVALID      ; 7B
7227 ee88 05                         FCB     AM_EXTENDED     ; 7C
7228 ee89 05                         FCB     AM_EXTENDED     ; 7D
7229 ee8a 05                         FCB     AM_EXTENDED     ; 7E
7230 ee8b 05                         FCB     AM_EXTENDED     ; 7F
7231                         
7232 ee8c 02                         FCB     AM_IMMEDIATE8   ; 80
7233 ee8d 02                         FCB     AM_IMMEDIATE8   ; 81
7234 ee8e 02                         FCB     AM_IMMEDIATE8   ; 82
7235 ee8f 03                         FCB     AM_IMMEDIATE16  ; 83
7236 ee90 02                         FCB     AM_IMMEDIATE8   ; 84
7237 ee91 02                         FCB     AM_IMMEDIATE8   ; 85
7238 ee92 02                         FCB     AM_IMMEDIATE8   ; 86
7239 ee93 00                         FCB     AM_INVALID      ; 87
7240 ee94 02                         FCB     AM_IMMEDIATE8   ; 88
7241 ee95 02                         FCB     AM_IMMEDIATE8   ; 89
7242 ee96 02                         FCB     AM_IMMEDIATE8   ; 8A
7243 ee97 02                         FCB     AM_IMMEDIATE8   ; 8B
7244 ee98 03                         FCB     AM_IMMEDIATE16  ; 8C
7245 ee99 06                         FCB     AM_RELATIVE8    ; 8D
7246 ee9a 03                         FCB     AM_IMMEDIATE16  ; 8E
7247 ee9b 00                         FCB     AM_INVALID      ; 8F
7248                         
7249 ee9c 04                         FCB     AM_DIRECT       ; 90
7250 ee9d 04                         FCB     AM_DIRECT       ; 91
7251 ee9e 04                         FCB     AM_DIRECT       ; 92
7252 ee9f 04                         FCB     AM_DIRECT       ; 93
7253 eea0 04                         FCB     AM_DIRECT       ; 94
7254 eea1 04                         FCB     AM_DIRECT       ; 95
7255 eea2 04                         FCB     AM_DIRECT       ; 96
7256 eea3 04                         FCB     AM_DIRECT       ; 97
7257 eea4 04                         FCB     AM_DIRECT       ; 98
7258 eea5 04                         FCB     AM_DIRECT       ; 99
7259 eea6 04                         FCB     AM_DIRECT       ; 9A
7260 eea7 04                         FCB     AM_DIRECT       ; 9B
7261 eea8 04                         FCB     AM_DIRECT       ; 9C
7262 eea9 04                         FCB     AM_DIRECT       ; 9D
7263 eeaa 04                         FCB     AM_DIRECT       ; 9E
7264 eeab 04                         FCB     AM_DIRECT       ; 9F
7265                         
7266 eeac 08                         FCB     AM_INDEXED      ; A0
7267 eead 08                         FCB     AM_INDEXED      ; A1
7268 eeae 08                         FCB     AM_INDEXED      ; A2
7269 eeaf 08                         FCB     AM_INDEXED      ; A3
7270 eeb0 08                         FCB     AM_INDEXED      ; A4
7271 eeb1 08                         FCB     AM_INDEXED      ; A5
7272 eeb2 08                         FCB     AM_INDEXED      ; A6
7273 eeb3 08                         FCB     AM_INDEXED      ; A7
7274 eeb4 08                         FCB     AM_INDEXED      ; A8
7275 eeb5 08                         FCB     AM_INDEXED      ; A9
7276 eeb6 08                         FCB     AM_INDEXED      ; AA
7277 eeb7 08                         FCB     AM_INDEXED      ; AB
7278 eeb8 08                         FCB     AM_INDEXED      ; AC
7279 eeb9 08                         FCB     AM_INDEXED      ; AD
7280 eeba 08                         FCB     AM_INDEXED      ; AE
7281 eebb 08                         FCB     AM_INDEXED      ; AF
7282                         
7283 eebc 05                         FCB     AM_EXTENDED     ; B0
7284 eebd 05                         FCB     AM_EXTENDED     ; B1
7285 eebe 05                         FCB     AM_EXTENDED     ; B2
7286 eebf 05                         FCB     AM_EXTENDED     ; B3
7287 eec0 05                         FCB     AM_EXTENDED     ; B4
7288 eec1 05                         FCB     AM_EXTENDED     ; B5
7289 eec2 05                         FCB     AM_EXTENDED     ; B6
7290 eec3 05                         FCB     AM_EXTENDED     ; B7
7291 eec4 05                         FCB     AM_EXTENDED     ; B8
7292 eec5 05                         FCB     AM_EXTENDED     ; B9
7293 eec6 05                         FCB     AM_EXTENDED     ; BA
7294 eec7 05                         FCB     AM_EXTENDED     ; BB
7295 eec8 05                         FCB     AM_EXTENDED     ; BC
7296 eec9 05                         FCB     AM_EXTENDED     ; BD
7297 eeca 05                         FCB     AM_EXTENDED     ; BE
7298 eecb 05                         FCB     AM_EXTENDED     ; BF
7299                         
7300 eecc 02                         FCB     AM_IMMEDIATE8   ; C0
7301 eecd 02                         FCB     AM_IMMEDIATE8   ; C1
7302 eece 02                         FCB     AM_IMMEDIATE8   ; C2
7303 eecf 03                         FCB     AM_IMMEDIATE16  ; C3
7304 eed0 02                         FCB     AM_IMMEDIATE8   ; C4
7305 eed1 02                         FCB     AM_IMMEDIATE8   ; C5
7306 eed2 02                         FCB     AM_IMMEDIATE8   ; C6
7307 eed3 00                         FCB     AM_INVALID      ; C7
7308 eed4 02                         FCB     AM_IMMEDIATE8   ; C8
7309 eed5 02                         FCB     AM_IMMEDIATE8   ; C9
7310 eed6 02                         FCB     AM_IMMEDIATE8   ; CA
7311 eed7 02                         FCB     AM_IMMEDIATE8   ; CB
7312 eed8 03                         FCB     AM_IMMEDIATE16  ; CC
7313 eed9 01                         FCB     AM_INHERENT     ; CD
7314 eeda 03                         FCB     AM_IMMEDIATE16  ; CE
7315 eedb 00                         FCB     AM_INVALID      ; CF
7316                         
7317 eedc 04                         FCB     AM_DIRECT       ; D0
7318 eedd 04                         FCB     AM_DIRECT       ; D1
7319 eede 04                         FCB     AM_DIRECT       ; D2
7320 eedf 04                         FCB     AM_DIRECT       ; D3
7321 eee0 04                         FCB     AM_DIRECT       ; D4
7322 eee1 04                         FCB     AM_DIRECT       ; D5
7323 eee2 04                         FCB     AM_DIRECT       ; D6
7324 eee3 04                         FCB     AM_DIRECT       ; D7
7325 eee4 04                         FCB     AM_DIRECT       ; D8
7326 eee5 04                         FCB     AM_DIRECT       ; D9
7327 eee6 04                         FCB     AM_DIRECT       ; DA
7328 eee7 04                         FCB     AM_DIRECT       ; DB
7329 eee8 04                         FCB     AM_DIRECT       ; DC
7330 eee9 04                         FCB     AM_DIRECT       ; DD
7331 eeea 04                         FCB     AM_DIRECT       ; DE
7332 eeeb 04                         FCB     AM_DIRECT       ; DF
7333                         
7334 eeec 08                         FCB     AM_INDEXED      ; E0
7335 eeed 08                         FCB     AM_INDEXED      ; E1
7336 eeee 08                         FCB     AM_INDEXED      ; E2
7337 eeef 08                         FCB     AM_INDEXED      ; E3
7338 eef0 08                         FCB     AM_INDEXED      ; E4
7339 eef1 08                         FCB     AM_INDEXED      ; E5
7340 eef2 08                         FCB     AM_INDEXED      ; E6
7341 eef3 08                         FCB     AM_INDEXED      ; E7
7342 eef4 08                         FCB     AM_INDEXED      ; E8
7343 eef5 08                         FCB     AM_INDEXED      ; E9
7344 eef6 08                         FCB     AM_INDEXED      ; EA
7345 eef7 08                         FCB     AM_INDEXED      ; EB
7346 eef8 08                         FCB     AM_INDEXED      ; EC
7347 eef9 08                         FCB     AM_INDEXED      ; ED
7348 eefa 08                         FCB     AM_INDEXED      ; EE
7349 eefb 08                         FCB     AM_INDEXED      ; EF
7350                         
7351 eefc 05                         FCB     AM_EXTENDED     ; F0
7352 eefd 05                         FCB     AM_EXTENDED     ; F1
7353 eefe 05                         FCB     AM_EXTENDED     ; F2
7354 eeff 05                         FCB     AM_EXTENDED     ; F3
7355 ef00 05                         FCB     AM_EXTENDED     ; F4
7356 ef01 05                         FCB     AM_EXTENDED     ; F5
7357 ef02 05                         FCB     AM_EXTENDED     ; F6
7358 ef03 05                         FCB     AM_EXTENDED     ; F7
7359 ef04 05                         FCB     AM_EXTENDED     ; F8
7360 ef05 05                         FCB     AM_EXTENDED     ; F9
7361 ef06 05                         FCB     AM_EXTENDED     ; FA
7362 ef07 05                         FCB     AM_EXTENDED     ; FB
7363 ef08 05                         FCB     AM_EXTENDED     ; FC
7364 ef09 05                         FCB     AM_EXTENDED     ; FD
7365 ef0a 05                         FCB     AM_EXTENDED     ; FE
7366 ef0b 05                         FCB     AM_EXTENDED     ; FF
7367                         
7368                         ; Special table for page 2 instructions prefixed by $10.
7369                         ; Format: opcode (less 10), instruction, addressing mode
7370                         
7371                         PAGE2:
7372 ef0c 21 4a 07                   FCB     $21, OP_LBRN,  AM_RELATIVE16
7373 ef0f 22 42 07                   FCB     $22, OP_LBHI,  AM_RELATIVE16
7374 ef12 23 44 07                   FCB     $23, OP_LBLS,  AM_RELATIVE16
7375 ef15 24 3d 07                   FCB     $24, OP_LBCC,  AM_RELATIVE16
7376 ef18 25 3e 07                   FCB     $25, OP_LBCS,  AM_RELATIVE16
7377 ef1b 26 47 07                   FCB     $26, OP_LBNE,  AM_RELATIVE16
7378 ef1e 27 3f 07                   FCB     $27, OP_LBEQ,  AM_RELATIVE16
7379 ef21 28 4c 07                   FCB     $28, OP_LBVC,  AM_RELATIVE16
7380 ef24 29 4d 07                   FCB     $29, OP_LBVS,  AM_RELATIVE16
7381 ef27 2a 48 07                   FCB     $2A, OP_LBPL,  AM_RELATIVE16
7382 ef2a 2b 46 07                   FCB     $2B, OP_LBMI,  AM_RELATIVE16
7383 ef2d 2c 40 07                   FCB     $2C, OP_LBGE,  AM_RELATIVE16
7384 ef30 2d 45 07                   FCB     $2D, OP_LBLT,  AM_RELATIVE16
7385 ef33 2e 41 07                   FCB     $2E, OP_LBGT,  AM_RELATIVE16
7386 ef36 2f 43 07                   FCB     $2F, OP_LBLE,  AM_RELATIVE16
7387 ef39 3f 7e 01                   FCB     $3F, OP_SWI2,  AM_INHERENT
7388 ef3c 83 28 03                   FCB     $83, OP_CMPD,  AM_IMMEDIATE16
7389 ef3f 8c 2c 03                   FCB     $8C, OP_CMPY,  AM_IMMEDIATE16
7390 ef42 8e 54 03                   FCB     $8E, OP_LDY,   AM_IMMEDIATE16
7391 ef45 93 28 04                   FCB     $93, OP_CMPD,  AM_DIRECT
7392 ef48 9c 2c 04                   FCB     $9C, OP_CMPY,  AM_DIRECT
7393 ef4b 9e 54 04                   FCB     $9E, OP_LDY,   AM_DIRECT
7394 ef4e 9d 79 04                   FCB     $9D, OP_STY,   AM_DIRECT
7395 ef51 a3 28 08                   FCB     $A3, OP_CMPD,  AM_INDEXED
7396 ef54 ac 2c 08                   FCB     $AC, OP_CMPY,  AM_INDEXED
7397 ef57 ae 54 08                   FCB     $AE, OP_LDY,   AM_INDEXED
7398 ef5a af 79 08                   FCB     $AF, OP_STY,   AM_INDEXED
7399 ef5d b3 28 05                   FCB     $B3, OP_CMPD,  AM_EXTENDED
7400 ef60 bc 2c 05                   FCB     $BC, OP_CMPY,  AM_EXTENDED
7401 ef63 be 54 05                   FCB     $BE, OP_LDY,   AM_EXTENDED
7402 ef66 bf 79 05                   FCB     $BF, OP_STY,   AM_EXTENDED
7403 ef69 ce 51 03                   FCB     $CE, OP_LDS,   AM_IMMEDIATE16
7404 ef6c de 51 04                   FCB     $DE, OP_LDS,   AM_DIRECT
7405 ef6f dd 76 04                   FCB     $DD, OP_STS,   AM_DIRECT
7406 ef72 ee 51 08                   FCB     $EE, OP_LDS,   AM_INDEXED
7407 ef75 ef 76 08                   FCB     $EF, OP_STS,   AM_INDEXED
7408 ef78 fe 51 05                   FCB     $FE, OP_LDS,   AM_EXTENDED
7409 ef7b ff 76 05                   FCB     $FF, OP_STS,   AM_EXTENDED
7410 ef7e 00                         FCB     0                             ; indicates end of table
7411                         
7412                         ; Special table for page 3 instructions prefixed by $11.
7413                         ; Same format as table above.
7414                         
7415                         PAGE3:
7416 ef7f 3f 7f 01                   FCB     $3F, OP_SWI3,  AM_INHERENT
7417 ef82 83 2a 03                   FCB     $83, OP_CMPU,  AM_IMMEDIATE16
7418 ef85 8c 29 03                   FCB     $8C, OP_CMPS,  AM_IMMEDIATE16
7419 ef88 93 2a 04                   FCB     $93, OP_CMPU,  AM_DIRECT
7420 ef8b 9c 29 04                   FCB     $9C, OP_CMPS,  AM_DIRECT
7421 ef8e a3 2a 08                   FCB     $A3, OP_CMPU,  AM_INDEXED
7422 ef91 ac 29 08                   FCB     $AC, OP_CMPS,  AM_INDEXED
7423 ef94 b3 2a 05                   FCB     $B3, OP_CMPU,  AM_EXTENDED
7424 ef97 bc 29 05                   FCB     $BC, OP_CMPS,  AM_EXTENDED
7425 ef9a 00                         FCB     0                             ; indicates end of table
7426                         
7427                         ; Display strings. Should be terminated in EOT character.
7428                         
7429 ef9b 3b 20 49 4e 56 41  MSG1:   FCC     "; INVALID"
     4c 49 44
7430 efa4 04                         FCB     EOT
7431                         
7432 efa5 50 52 45 53 53 20  MSG2:   FCC     "PRESS <SPACE> TO CONTINUE, <Q> TO QUIT "
     3c 53 50 41 43 45
     3e 20 54 4f 20 43
     4f 4e 54 49 4e 55
     45 2c 20 3c 51 3e
     20 54 4f 20 51 55
     49 54 20
7433 efcc 04                         FCB     EOT
7434                         
7435 efcd 50 43 52           MSG3:   FCC     "PCR"
7436 efd0 04                         FCB     EOT
7437                         
7438                         ; ========================================================================
7439                         ;
7440                         ; 6809 Trace Utility
7441                         ;
7442                         ; Copyright (C) 2019 by Jeff Tranter <tranter@pobox.com>
7443                         ;
7444                         ; Licensed under the Apache License, Version 2.0 (the "License");
7445                         ; you may not use this file except in compliance with the License.
7446                         ; You may obtain a copy of the License at
7447                         ;
7448                         ;   http://www.apache.org/licenses/LICENSE-2.0
7449                         ;
7450                         ; Unless required by applicable law or agreed to in writing, software
7451                         ; distributed under the License is distributed on an "AS IS" BASIS,
7452                         ; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
7453                         ; See the License for the specific language governing permissions and
7454                         ; limitations under the License.
7455                         
7456                         ; Start address for RAM variables
7457 6fe0                            ORG     $6FE0
7458                         
7459                         ; Variables
7460                         
7461 6fe0                    SAVE_CC RMB     1               ; Saved register values
7462 6fe1                    SAVE_A  RMB     1
7463 6fe2                    SAVE_B  RMB     1
7464 6fe1                    SAVE_D  equ     SAVE_A          ; Synonym for SAVE_A and SAVE_B
7465 6fe3                    SAVE_DP RMB     1
7466 6fe4                    SAVE_X  RMB     2
7467 6fe6                    SAVE_Y  RMB     2
7468 6fe8                    SAVE_U  RMB     2
7469 6fea                    SAVE_S  RMB     2
7470 6fec                    SAVE_PC RMB     2
7471 6fee                    OURS    RMB     2               ; This program's user stack pointer
7472 6ff0                    OURU    RMB     2               ; This program's system stack pointer
7473 6ff2                    BUFFER  RMB     10              ; Buffer holding traced instruction (up to 10 bytes)
7474                         
7475 f000                            ORG     $F000
7476                         
7477                         ;------------------------------------------------------------------------
7478                         ; Trace Command.
7479                         ; Accepts a start address on the command line. Traces and disassembles
7480                         ; an instruction. Pressing Q or q will go to monitor, any other key
7481                         ; will trace another instruction.
7482                         
7483 f000 17 0e 5d           TRACE   lbsr    CDNUM           ; Parse command line, return 16-bit number in D
7484 f003 fd 6f ec                   std     SAVE_PC         ; Store it
7485 f006 8d 1a              loop    bsr     step            ; Step one instruction
7486 f008 30 8c 9a                   leax    MSG2,pcr        ; Display message to press a key
7487 f00b 17 f4 8f                   lbsr    PrintString
7488 f00e 17 f4 6d                   lbsr    GetChar         ; Wait for a key press
7489 f011 17 f4 1a                   lbsr    PrintCR
7490 f014 81 51                      cmpa    #'Q'            ; Check for Q
7491 f016 27 06                      beq     quit            ; If so, quit
7492 f018 81 71                      cmpa    #'q'            ; Check for q
7493 f01a 27 02                      beq     quit            ; If so, quit
7494 f01c 20 e8                      bra     loop            ; If not, continue
7495 f01e 6e 9f ff fe        quit    jmp     [$fffe]         ; Go back to ASSIST09 via reset vector
7496                         
7497                         ;------------------------------------------------------------------------
7498                         ; Step: Step one instruction
7499                         ; Disassemble next instruction
7500                         ; Call Trace
7501                         ; Display register values
7502                         ; Return
7503                         
7504 f022 17 06 c3           step    lbsr    Disassemble     ; Disassemble the instruction
7505 f025 8d 04                      bsr     Trace           ; Trace/execute the instruction
7506 f027 17 05 98                   lbsr    DisplayRegs     ; Display register values
7507 f02a 39                         rts
7508                         
7509                         ;------------------------------------------------------------------------
7510                         ; Trace one instruction.
7511                         ; Input: Address of instruction in SAVE_PC
7512                         ; Returns: Updates saved register values.
7513                         
7514                         Trace
7515                         
7516                         ; At this point we have set: OPCODE, OPTYPE, LENG, AM, PAGE23, POSTBYT
7517                         ; Now check for special instructions that change flow of control or otherwise
7518                         ; need special handling rather than being directly executed.
7519                         
7520                         ; Invalid op code?
7521 f02b b6 6f d4                   lda     OPTYPE          ; Get op code type
7522 f02e 81 00                      cmpa    #OP_INV         ; Is it an invalid instruction?
7523 f030 10 27 05 83                lbeq    update          ; If so, nothing to do (length is 1 byte)
7524                         
7525                         ; Check for PC relative indexed addressing modes that we don't
7526                         ; currently handle. If so, display a warning but still trace the
7527                         ; instruction.
7528                         
7529 f034 b6 6f d3                   lda    AM               ; Get address mode
7530 f037 81 08                      cmpa   #AM_INDEXED      ; Indexed addressing
7531 f039 26 13                      bne    trysync          ; Branch if not
7532 f03b b6 6f d5                   lda    POSTBYT          ; Get the post byte
7533                         
7534                         ; It is a PCR mode if the post byte has the pattern 1xxx110x
7535                         
7536 f03e 84 8e                      anda   #%10001110       ; Mask bits we want to check
7537 f040 81 8c                      cmpa   #%10001100       ; Check for pattern
7538 f042 26 0a                      bne    trysync          ; Branch if no match
7539                         
7540                         ; Display "Warning: instruction not supported, expect incorrect results."
7541                         
7542 f044 30 8d 06 62                leax    TMSG12,PCR      ; Message string
7543 f048 17 f4 52                   lbsr    PrintString     ; Display it
7544 f04b 17 f3 e0                   lbsr    PrintCR
7545                         
7546                         ; SYNC instruction. Continue (emulate interrupt and then RTI
7547                         ; happenning or mask interrupt and instruction continuing).
7548                         
7549 f04e b6 6f d4           trysync lda     OPTYPE          ; Get op code type
7550 f051 81 80                      cmpa    #OP_SYNC        ; Is it a SYNC instruction?
7551 f053 10 27 05 60                lbeq    update          ; If so, nothing to do (length is 1 byte)
7552                         
7553                         ; CWAI #$XX instruction. AND operand with CC. Set E flag in CC. Continue (emulate interrupt and then RTI happenning).
7554                         
7555 f057 b6 6f d4                   lda     OPTYPE          ; Get op code type
7556 f05a 81 30                      cmpa    #OP_CWAI        ; Is it a CWAI instruction?
7557 f05c 26 10                      bne     tryswi
7558 f05e be 6f ec                   ldx     SAVE_PC         ; Get address of instruction
7559 f061 a6 01                      lda     1,x             ; Get operand
7560 f063 8a 80                      ora     #%10000000      ; Set E bit
7561 f065 ba 6f e0                   ora     SAVE_CC         ; Or with CC
7562 f068 b7 6f e0                   sta     SAVE_CC         ; Save CC
7563 f06b 16 05 49                   lbra    update          ; Done
7564                         
7565                         ; SWI instruction. Increment PC. Save all registers except S on hardware stack.
7566                         ; Set I and F in CC. Set new PC to [FFFA,FFFB].
7567                         
7568 f06e 81 7d              tryswi  cmpa    #OP_SWI
7569 f070 26 4e                      bne     tryswi2
7570 f072 be 6f ec                   ldx     SAVE_PC         ; Get address of instruction
7571 f075 30 01                      leax    1,x             ; Add one
7572 f077 bf 6f ec                   stx     SAVE_PC         ; Save new PC
7573                         
7574                         ; push CC, A, B, DP, X, Y, U, PC
7575                         
7576 f07a 10 ff 6f ee                sts     OURS            ; Save our SP
7577 f07e 10 fe 6f ea                lds     SAVE_S          ; Use program's SP to push
7578                         
7579 f082 b6 6f e0                   lda     SAVE_CC
7580 f085 34 02                      pshs    a
7581 f087 8a 50                      ora     #%01010000      ; Set I and F bits
7582 f089 b7 6f e0                   sta     SAVE_CC
7583 f08c b6 6f e1                   lda     SAVE_A
7584 f08f 34 02                      pshs    a
7585 f091 b6 6f e2                   lda     SAVE_B
7586 f094 34 02                      pshs    a
7587 f096 b6 6f e3                   lda     SAVE_DP
7588 f099 34 02                      pshs    a
7589 f09b be 6f e4                   ldx     SAVE_X
7590 f09e 34 10                      pshs    x
7591 f0a0 be 6f e6                   ldx     SAVE_Y
7592 f0a3 34 10                      pshs    x
7593 f0a5 be 6f e8                   ldx     SAVE_U
7594 f0a8 34 10                      pshs    x
7595 f0aa be 6f ec                   ldx     SAVE_PC
7596 f0ad 34 10                      pshs    x
7597 f0af 10 ff 6f ea                sts     SAVE_S          ; Save new value of SP
7598 f0b3 10 fe 6f ee                lds     OURS            ; Restore our SP
7599                         
7600 f0b7 be ff fa                   ldx     $FFFA           ; Get address of SWI vector
7601 f0ba bf 6f ec                   stx     SAVE_PC         ; Set as new address
7602                         
7603 f0bd 16 05 01                   lbra    don             ; Done
7604                         
7605                         ; SWI2 instruction. Increment PC. Save all registers except S on
7606                         ; stack. Set new PC to [FFF4,FFF5].
7607                         
7608 f0c0 81 7e              tryswi2 cmpa    #OP_SWI2
7609 f0c2 26 49                      bne     tryswi3
7610 f0c4 be 6f ec                   ldx     SAVE_PC         ; Get address of instruction
7611 f0c7 30 01                      leax    1,x             ; Add one
7612 f0c9 bf 6f ec                   stx     SAVE_PC         ; Save new PC
7613                         
7614                         ; push CC, A, B, DP, X, Y, U, PC
7615                         
7616 f0cc 10 ff 6f ee                sts     OURS            ; Save our SP
7617 f0d0 10 fe 6f ea                lds     SAVE_S          ; Use program's SP to push
7618                         
7619 f0d4 b6 6f e0                   lda     SAVE_CC
7620 f0d7 34 02                      pshs    a
7621 f0d9 b6 6f e1                   lda     SAVE_A
7622 f0dc 34 02                      pshs    a
7623 f0de b6 6f e2                   lda     SAVE_B
7624 f0e1 34 02                      pshs    a
7625 f0e3 b6 6f e3                   lda     SAVE_DP
7626 f0e6 34 02                      pshs    a
7627 f0e8 be 6f e4                   ldx     SAVE_X
7628 f0eb 34 10                      pshs    x
7629 f0ed be 6f e6                   ldx     SAVE_Y
7630 f0f0 34 10                      pshs    x
7631 f0f2 be 6f e8                   ldx     SAVE_U
7632 f0f5 34 10                      pshs    x
7633 f0f7 be 6f ec                   ldx     SAVE_PC
7634 f0fa 34 10                      pshs    x
7635 f0fc 10 ff 6f ea                sts     SAVE_S          ; Save new value of SP
7636 f100 10 fe 6f ee                lds     OURS            ; Restore our SP
7637                         
7638 f104 be ff f4                   ldx     $FFF4           ; Get address of SWI2 vector
7639 f107 bf 6f ec                   stx     SAVE_PC         ; Set as new address
7640                         
7641 f10a 16 04 b4                   lbra    don             ; Done
7642                         
7643                         ; SWI3 instruction. Increment PC. Save all registers except S on
7644                         ; stack. Set new PC to [FFF2,FFF3].
7645                         
7646 f10d 81 7f              tryswi3 cmpa    #OP_SWI3
7647 f10f 26 49                      bne     tryjmp
7648 f111 be 6f ec                   ldx     SAVE_PC         ; Get address of instruction
7649 f114 30 01                      leax    1,x             ; Add one
7650 f116 bf 6f ec                   stx     SAVE_PC         ; Save new PC
7651                         
7652                         ; push CC, A, B, DP, X, Y, U, PC
7653                         
7654 f119 10 ff 6f ee                sts     OURS            ; Save our SP
7655 f11d 10 fe 6f ea                lds     SAVE_S          ; Use program's SP to push
7656                         
7657 f121 b6 6f e0                   lda     SAVE_CC
7658 f124 34 02                      pshs    a
7659 f126 b6 6f e1                   lda     SAVE_A
7660 f129 34 02                      pshs    a
7661 f12b b6 6f e2                   lda     SAVE_B
7662 f12e 34 02                      pshs    a
7663 f130 b6 6f e3                   lda     SAVE_DP
7664 f133 34 02                      pshs    a
7665 f135 be 6f e4                   ldx     SAVE_X
7666 f138 34 10                      pshs    x
7667 f13a be 6f e6                   ldx     SAVE_Y
7668 f13d 34 10                      pshs    x
7669 f13f be 6f e8                   ldx     SAVE_U
7670 f142 34 10                      pshs    x
7671 f144 be 6f ec                   ldx     SAVE_PC
7672 f147 34 10                      pshs    x
7673 f149 10 ff 6f ea                sts     SAVE_S          ; Save new value of SP
7674 f14d 10 fe 6f ee                lds     OURS            ; Restore our SP
7675                         
7676 f151 be ff f2                   ldx     $FFF2           ; Get address of SWI3 vector
7677 f154 bf 6f ec                   stx     SAVE_PC         ; Set as new address
7678                         
7679 f157 16 04 67                   lbra    don             ; Done
7680                         
7681                         ; JMP instruction. Next PC is operand effective address. Need to
7682                         ; handle extended, direct, and indexed modes.
7683                         
7684 f15a 81 3b              tryjmp  cmpa    #OP_JMP         ; Is it a JMP instruction?
7685 f15c 10 26 00 7b                lbne    tryjsr          ; Branch if not.
7686 f160 b6 6f d2                   lda     OPCODE          ; Get the actual op code
7687 f163 81 7e                      cmpa    #$7E            ; Extended, e.g. JMP $XXXX ?
7688 f165 26 0b                      bne     jmp1
7689 f167 be 6f ec                   ldx     SAVE_PC         ; Get address of instruction
7690 f16a ae 01                      ldx     1,x             ; Get 16-bit operand (JMP destination)
7691 f16c bf 6f ec                   stx     SAVE_PC         ; Set as new instruction address
7692 f16f 16 04 4f                   lbra    don             ; Done
7693                         
7694 f172 81 0e              jmp1    cmpa    #$0E            ; Direct, e.g. JMP $XX ?
7695 f174 26 0e                      bne     jmp2
7696 f176 be 6f ec                   ldx     SAVE_PC         ; Get address of instruction
7697 f179 e6 01                      ldb     1,x             ; Get 8-bit operand (JMP destination)
7698 f17b b6 6f e3                   lda     SAVE_DP         ; Get DP register
7699 f17e fd 6f ec                   std     SAVE_PC         ; Full address is DP (in A) + operand (in B)
7700 f181 16 04 3d                   lbra    don             ; Done
7701                         
7702                         ; Must be indexed, e.g. JMP 1,X. Can't get effective address directly
7703                         ; from instruction. Instead we use this trick: Run a LEAU instruction
7704                         ; with the same indexed operand. Then examine value of X, which should
7705                         ; be the new PC. Need to run it with the current index register values
7706                         ; of X, Y, U, and S.
7707                         ; TODO: Not handled: addressing modes that change U register like JMP ,U++.
7708                         ; TODO: Not handled correctly: PCR modes like JMP 10,PCR
7709                         
7710 f184 be 6f ec           jmp2    ldx     SAVE_PC         ; Address of instruction
7711 f187 10 8e 6f f2                ldy     #BUFFER         ; Address of buffer
7712 f18b c6 33                      ldb     #$33            ; LEAU instruction
7713 f18d 4f                         clra                    ; Loop counter and index
7714 f18e e7 a6                      stb     a,y             ; Write LEAU instruction to buffer
7715 f190 4c                         inca                    ; Move to next byte
7716 f191 e6 86              copy1   ldb     a,x             ; Get instruction byte
7717 f193 e7 a6                      stb     a,y             ; Write to buffer
7718 f195 4c                         inca                    ; Increment counter
7719 f196 b1 6f d6                   cmpa    LENG            ; Copied all bytes?
7720 f199 26 f6                      bne     copy1
7721                         
7722                         ; Add a jump after the instruction to where we want to go after it is executed (ReturnFromJump).
7723                         
7724 f19b c6 7e                      ldb     #$7E            ; JMP $XXXX instruction
7725 f19d e7 a6                      stb     a,y             ; Store in buffer
7726 f19f 4c                         inca                    ; Advance buffer
7727 f1a0 8e f1 c3                   ldx     #ReturnFromJump ; Destination address of JMP
7728 f1a3 af a6                      stx     a,y             ; Store in buffer
7729                         
7730                         ; Restore registers from saved values.
7731                         
7732 f1a5 10 ff 6f ee                sts     OURS            ; Save this program's stack pointers
7733 f1a9 ff 6f f0                   stu     OURU
7734                         
7735 f1ac b6 6f e1                   lda     SAVE_A
7736 f1af f6 6f e2                   ldb     SAVE_B
7737 f1b2 be 6f e4                   ldx     SAVE_X
7738 f1b5 10 be 6f e6                ldy     SAVE_Y
7739 f1b9 10 fe 6f ea                lds     SAVE_S
7740 f1bd fe 6f e8                   ldu     SAVE_U
7741                         
7742                         ; Call instruction in buffer. It is followed by a JMP ReturnFromJump so we get back.
7743                         
7744 f1c0 7e 6f f2                   jmp     BUFFER
7745                         
7746                         ReturnFromJump
7747                         
7748                         ; Restore saved registers (except U and PC).
7749                         
7750 f1c3 bf 6f e4                   stx     SAVE_X
7751 f1c6 10 bf 6f e6                sty     SAVE_Y
7752 f1ca 10 ff 6f ea                sts     SAVE_S
7753                         
7754                         ; Restore this program's stack pointers so RTS etc. will still work.
7755                         
7756 f1ce 10 fe 6f ee                lds     OURS
7757 f1d2 fe 6f f0                   ldu     OURU
7758                         
7759                         ; Value of X is new PC
7760                         
7761 f1d5 bf 6f ec                   stx     SAVE_PC         ; Set as new instruction address
7762 f1d8 16 03 e6                   lbra    don             ; Done
7763                         
7764                         ; JSR instruction. Next PC is operand effective address. Push return
7765                         ; address on stack. Need to handle extended, direct, and indexed
7766                         ; modes.
7767                         
7768 f1db 81 3c              tryjsr  cmpa    #OP_JSR         ; Is it a JSR instruction?
7769 f1dd 10 26 00 72                lbne    tryrts          ; Branch if not.
7770 f1e1 b6 6f d2                   lda     OPCODE          ; Get the actual op code
7771 f1e4 81 bd                      cmpa    #$BD            ; Extended, e.g. JSR $XXXX ?
7772 f1e6 26 24                      bne     jsr1
7773                         
7774 f1e8 4f                         clra                    ; Set MSB to zero
7775 f1e9 f6 6f d6                   ldb     LENG            ; Get instruction length (byte)
7776 f1ec f3 6f ec                   addd    SAVE_PC         ; 16-bit add
7777                         
7778 f1ef 10 ff 6f ee                sts     OURS            ; Save this program's stack pointer
7779 f1f3 10 fe 6f ea                lds     SAVE_S          ; Get program's stack pointer
7780 f1f7 34 06                      pshs    d               ; Push return address
7781 f1f9 10 ff 6f ea                sts     SAVE_S          ; Save program's new stack pointer
7782 f1fd 10 fe 6f ee                lds     OURS            ; Restore our stack pointer
7783                         
7784 f201 be 6f ec                   ldx     SAVE_PC         ; Get address of instruction
7785 f204 ae 01                      ldx     1,x             ; Get 16-bit operand (JSR destination)
7786 f206 bf 6f ec                   stx     SAVE_PC         ; Set as new instruction address
7787 f209 16 03 b5                   lbra    don             ; Done
7788                         
7789 f20c 81 9d              jsr1    cmpa    #$9D            ; Direct, e.g. JSR $XX ?
7790 f20e 26 27                      bne     jsr2
7791                         
7792 f210 4f                         clra                    ; Set MSB to zero
7793 f211 f6 6f d6                   ldb     LENG            ; Get instruction length (byte)
7794 f214 f3 6f ec                   addd    SAVE_PC         ; 16-bit add
7795                         
7796 f217 10 ff 6f ee                sts     OURS            ; Save this program's stack pointer
7797 f21b 10 fe 6f ea                lds     SAVE_S          ; Get program's stack pointer
7798 f21f 34 06                      pshs    d               ; Push return address
7799 f221 10 ff 6f ea                sts     SAVE_S          ; Save program's new stack pointer
7800 f225 10 fe 6f ee                lds     OURS            ; Restore our stack pointer
7801                         
7802 f229 be 6f ec                   ldx     SAVE_PC         ; Get address of instruction
7803 f22c e6 01                      ldb     1,x             ; Get 8-bit operand (JSR destination)
7804 f22e b6 6f e3                   lda     SAVE_DP         ; Get DP register
7805 f231 fd 6f ec                   std     SAVE_PC         ; Full address is DP (in A) + operand (in B)
7806 f234 16 03 8a                   lbra    don             ; Done
7807                         
7808                         ; Must be indexed, e.g. JSR 1,X. Use same LEAU trick as for JMP.
7809                         ; TODO: Not handled: addressing modes that change U register like JSR ,U++.
7810                         ; TODO: Not handled correctly: PCR modes like JSR 10,PCR
7811                         
7812 f237 4f                 jsr2    clra                    ; Set MSB to zero
7813 f238 f6 6f d6                   ldb     LENG            ; Get instruction length (byte)
7814 f23b f3 6f ec                   addd    SAVE_PC         ; 16-bit add
7815                         
7816 f23e 10 ff 6f ee                sts     OURS            ; Save this program's stack pointer
7817 f242 10 fe 6f ea                lds     SAVE_S          ; Get program's stack pointer
7818 f246 34 06                      pshs    d               ; Push return address
7819 f248 10 ff 6f ea                sts     SAVE_S          ; Save program's new stack pointer
7820 f24c 10 fe 6f ee                lds     OURS            ; Restore our stack pointer
7821                         
7822 f250 16 ff 31                   lbra    jmp2            ; Rest of code is shared with JMP routine
7823                         
7824                         ; RTS instruction. Pop PC from stack and set it to next address.
7825                         
7826 f253 81 6f              tryrts  cmpa    #OP_RTS         ; Is it a RTS instruction?
7827 f255 26 18                      bne     tryrti          ; Branch if not.
7828 f257 10 ff 6f ee                sts     OURS            ; Save this program's stack pointer
7829 f25b 10 fe 6f ea                lds     SAVE_S          ; Get program's stack pointer
7830 f25f 35 10                      puls    x               ; Pull return address
7831 f261 10 ff 6f ea                sts     SAVE_S          ; Save program's new stack pointer
7832 f265 10 fe 6f ee                lds     OURS            ; Restore our stack pointer
7833 f269 bf 6f ec                   stx     SAVE_PC         ; Set as new instruction address
7834 f26c 16 03 52                   lbra    don             ; Done
7835                         
7836                         ; RTI instruction.
7837                         ; If E flag is not set, pop PC and CC.
7838                         ; If E flag is set, pop PC, U, Y, X, DP, B, A, and CC.
7839                         ; Set next instruction to PC.
7840                         
7841 f26f 81 6e              tryrti  cmpa    #OP_RTI         ; Is it a RTI instruction?
7842 f271 26 40                      bne     trybsr          ; Branch if not.
7843 f273 10 ff 6f ee                sts     OURS            ; Save this program's stack pointer
7844 f277 10 fe 6f ea                lds     SAVE_S          ; Get program's stack pointer
7845 f27b 35 10                      puls    x               ; Pull PC
7846 f27d bf 6f ec                   stx     SAVE_PC         ; Set as new instruction address
7847                         
7848 f280 b6 6f e0                   lda     SAVE_CC         ; Test CC
7849 f283 2a 1e                      bpl     notEntire       ; Branch if Entire bit (MSB is not set)
7850 f285 35 10                      puls    x               ; Pull U
7851 f287 bf 6f e8                   stx     SAVE_U
7852 f28a 35 10                      puls    x               ; Pull Y
7853 f28c bf 6f e6                   stx     SAVE_Y
7854 f28f 35 10                      puls    x               ; Pull X
7855 f291 bf 6f e4                   stx     SAVE_X
7856 f294 35 02                      puls    a               ; Pull DP
7857 f296 b7 6f e3                   sta     SAVE_DP
7858 f299 35 02                      puls    a               ; Pull B
7859 f29b b7 6f e2                   sta     SAVE_B
7860 f29e 35 02                      puls    a               ; Pull A
7861 f2a0 b7 6f e1                   sta     SAVE_A
7862                         notEntire
7863 f2a3 35 02                      puls    a               ; Pull CC
7864 f2a5 b7 6f e0                   sta     SAVE_CC
7865                         
7866 f2a8 10 ff 6f ea                sts     SAVE_S          ; Save program's new stack pointer
7867 f2ac 10 fe 6f ee                lds     OURS            ; Restore our stack pointer
7868 f2b0 16 03 0e                   lbra    don             ; Done
7869                         
7870                         ; BSR instruction. Similar to JSR but EA is relative.
7871                         
7872 f2b3 81 20              trybsr  cmpa    #OP_BSR         ; Is it a BSR instruction?
7873 f2b5 26 2c                      bne     trylbsr         ; Branch if not.
7874                         
7875                         ; Push return address on stack.
7876                         
7877 f2b7 4f                         clra                    ; Set MSB to zero
7878 f2b8 f6 6f d6                   ldb     LENG            ; Get instruction length (byte)
7879 f2bb f3 6f ec                   addd    SAVE_PC         ; 16-bit add
7880                         
7881 f2be 10 ff 6f ee                sts     OURS            ; Save this program's stack pointer
7882 f2c2 10 fe 6f ea                lds     SAVE_S          ; Get program's stack pointer
7883 f2c6 34 06                      pshs    d               ; Push return address
7884 f2c8 10 ff 6f ea                sts     SAVE_S          ; Save program's new stack pointer
7885 f2cc 10 fe 6f ee                lds     OURS            ; Restore our stack pointer
7886                         
7887                         ; Next PC is PC plus instruction length (2) plus offset operand.
7888                         
7889 f2d0 be 6f ec                   ldx     SAVE_PC         ; Get address of instruction
7890 f2d3 4f                         clra                    ; Clear MSB
7891 f2d4 e6 01                      ldb     1,x             ; Get 8-bit signed branch offset
7892 f2d6 1d                         sex                     ; Sign extend to 16-bits
7893 f2d7 c3 00 02                   addd    #2              ; Add instruction length (2)
7894 f2da f3 6f ec                   addd    SAVE_PC         ; Add to address
7895 f2dd fd 6f ec                   std     SAVE_PC         ; Store new address value
7896 f2e0 16 02 de                   lbra    don             ; Done
7897                         
7898                         ; LBSR instruction. Similar to BSR above.
7899                         
7900 f2e3 81 4b              trylbsr cmpa    #OP_LBSR        ; Is it a LBSR instruction?
7901 f2e5 26 2a                      bne     trybxx          ; Branch if not.
7902                         
7903                         ; Push return address on stack.
7904                         
7905 f2e7 4f                         clra                    ; Set MSB to zero
7906 f2e8 f6 6f d6                   ldb     LENG            ; Get instruction length (byte)
7907 f2eb f3 6f ec                   addd    SAVE_PC         ; 16-bit add
7908                         
7909 f2ee 10 ff 6f ee                sts     OURS            ; Save this program's stack pointer
7910 f2f2 10 fe 6f ea                lds     SAVE_S          ; Get program's stack pointer
7911 f2f6 34 06                      pshs    d               ; Push return address
7912 f2f8 10 ff 6f ea                sts     SAVE_S          ; Save program's new stack pointer
7913 f2fc 10 fe 6f ee                lds     OURS            ; Restore our stack pointer
7914                         
7915                         ; Next PC is PC plus instruction length (3) plus 16-bit offset operand.
7916                         
7917 f300 be 6f ec                   ldx     SAVE_PC         ; Get address of instruction
7918 f303 ec 01                      ldd     1,x             ; Get 16-bit signed branch offset
7919 f305 c3 00 03                   addd    #3              ; Add instruction length (3)
7920 f308 f3 6f ec                   addd    SAVE_PC         ; Add to address
7921 f30b fd 6f ec                   std     SAVE_PC         ; Store new address value
7922 f30e 16 02 b0                   lbra    don             ; Done
7923                         
7924                         ; Bxx instructions.
7925                         ; These are executed but we change the destination of the branch so we
7926                         ; catch whether they are taken or not.
7927                         ; The code in the buffer will look like this:
7928                         ;
7929                         ;       JMP BUFFER
7930                         ;       ...
7931                         ; XXXX XX 03           Bxx $03 (Taken)         ; Instruction being traced
7932                         ; XXXX 7E XX XX        JMP BranchNotTaken
7933                         ; XXXX 7E XX XX Taken  JMP BranchTaken
7934                         ;        ...
7935                         ;
7936                         ; If we come back via BranchNotTaken, next PC is instruction after the branch (PC plus 2).
7937                         ; If we come back via BranchTaken, next PC is PC plus offset plus 2.
7938                         ; Need to set CC to program's value before the branch is executed.
7939                         
7940 f311 b6 6f d3           trybxx  lda     AM              ; Get addressing mode
7941 f314 81 06                      cmpa    #AM_RELATIVE8   ; Is it a relative branch?
7942 f316 26 4b                      bne     trylbxx
7943                         
7944 f318 be 6f ec                   ldx     SAVE_PC         ; Address of instruction
7945 f31b 10 8e 6f f2                ldy     #BUFFER         ; Address of buffer
7946 f31f a6 84                      lda     ,x              ; Get branch instruction
7947 f321 a7 a4                      sta     ,y              ; Store in buffer
7948 f323 86 03                      lda     #3              ; Branch offset (Taken)
7949 f325 a7 21                      sta     1,y             ; Store in buffer
7950 f327 86 7e                      lda     #$7E            ; JMP $XXXX instruction
7951 f329 a7 22                      sta     2,y             ; Store in buffer
7952 f32b 8e f3 54                   ldx     #BranchNotTaken ; Address for branch
7953 f32e af 23                      stx     3,y             ; Store in buffer
7954 f330 86 7e                      lda     #$7E            ; JMP $XXXX instruction
7955 f332 a7 25                      sta     5,y             ; Store in buffer
7956 f334 8e f3 41                   ldx     #BranchTaken    ; Address for branch
7957 f337 af 26                      stx     6,y             ; Store in buffer
7958                         
7959                         ; Restore CC from saved value.
7960                         
7961 f339 b6 6f e0                   lda     SAVE_CC
7962 f33c 1f 8a                      tfr     a,cc
7963                         
7964                         ; Call instruction in buffer. It is followed by a JMP so we get back.
7965                         
7966 f33e 7e 6f f2                   jmp     BUFFER
7967                         
7968                         BranchTaken                     ; Next PC is PC plus offset plus 2.
7969                         
7970 f341 be 6f ec                   ldx     SAVE_PC         ; Get address of instruction
7971 f344 4f                         clra                    ; Clear MSB
7972 f345 e6 01                      ldb     1,x             ; Get 8-bit signed branch offset
7973 f347 1d                         sex                     ; Sign extend to 16-bits
7974 f348 c3 00 02                   addd    #2              ; Add instruction length (2)
7975 f34b f3 6f ec                   addd    SAVE_PC         ; Add to address
7976 f34e fd 6f ec                   std     SAVE_PC         ; Store new address value
7977 f351 16 02 6d                   lbra    don             ; Done
7978                         
7979                         BranchNotTaken                  ; Next PC is instruction after the branch (PC plus 2).
7980                         
7981 f354 fc 6f ec                   ldd     SAVE_PC         ; Get address of instruction
7982 f357 c3 00 02                   addd    #2              ; Add instruction length (2)
7983 f35a fd 6f ec                   std     SAVE_PC         ; Store new address value
7984 f35d fd 6f ec                   std     SAVE_PC
7985 f360 16 02 5e                   lbra    don             ; Done
7986                         
7987                         ; LBxx instructions. Similar to Bxx above.
7988                         
7989 f363 81 07              trylbxx cmpa    #AM_RELATIVE16  ; Is it a long relative branch?
7990 f365 10 26 00 85                lbne    trytfr
7991                         
7992                         ; Note Long branch instructions are 4 bytes (prefixed by 10) except
7993                         ; LBRA which is only 3 bytes.
7994                         ; BUFFER in this case is:
7995                         ; XXXX 16 00 03        LBRA $0003 (Taken)   ; Instruction being traced
7996                         ; XXXX 7E XX XX        JMP  BranchNotTaken1
7997                         ; XXX  7E XX XX Taken  JMP  BranchTaken1
7998                         ;
7999                         ; Or:
8000                         ;
8001                         ; XXXX 10 XX 00 03       LBxx $0003 (Taken) ; Instruction being traced
8002                         ; XXXX 7E XX XX          JMP  BranchNotTaken1
8003                         ; XXXX 7E XX XX   Taken  JMP  BranchTaken1
8004                         
8005 f369 b6 6f d2                   lda     OPCODE          ; Get  opcode
8006 f36c 81 16                      cmpa    #$16            ; Is it LBRA?
8007 f36e 26 24                      bne     long            ; Branch if it is one of the other 4 byte instructions
8008                         
8009 f370 be 6f ec                   ldx     SAVE_PC         ; Address of instruction
8010 f373 10 8e 6f f2                ldy     #BUFFER         ; Address of buffer
8011 f377 a6 84                      lda     ,x              ; Get branch instruction
8012 f379 a7 a4                      sta     ,y              ; Store in buffer
8013 f37b 8e 00 03                   ldx     #3              ; Branch offset (Taken)
8014 f37e af 21                      stx     1,y             ; Store in buffer
8015 f380 86 7e                      lda     #$7E            ; JMP $XXXX instruction
8016 f382 a7 23                      sta     3,y             ; Store in buffer
8017 f384 8e f3 e0                   ldx     #BranchNotTaken1 ; Address for branch
8018 f387 af 24                      stx     4,y             ; Store in buffer
8019 f389 86 7e                      lda     #$7E            ; JMP $XXXX instruction
8020 f38b a7 26                      sta     6,y             ; Store in buffer
8021 f38d 8e f3 be                   ldx     #BranchTaken1   ; Address for branch
8022 f390 af 27                      stx     7,y             ; Store in buffer
8023 f392 20 22                      bra     branch
8024                         
8025 f394 be 6f ec           long    ldx     SAVE_PC         ; Address of instruction
8026 f397 10 8e 6f f2                ldy     #BUFFER         ; Address of buffer
8027 f39b ae 84                      ldx     ,x              ; Get two byte branch instruction
8028 f39d af a4                      stx     ,y              ; Store in buffer
8029 f39f 8e 00 03                   ldx     #3              ; Branch offset (Taken)
8030 f3a2 af 22                      stx     2,y             ; Store in buffer
8031 f3a4 86 7e                      lda     #$7E            ; JMP $XXXX instruction
8032 f3a6 a7 24                      sta     4,y             ; Store in buffer
8033 f3a8 8e f3 e0                   ldx     #BranchNotTaken1 ; Address for branch
8034 f3ab af 25                      stx     5,y             ; Store in buffer
8035 f3ad 86 7e                      lda     #$7E            ; JMP $XXXX instruction
8036 f3af a7 27                      sta     7,y             ; Store in buffer
8037 f3b1 8e f3 be                   ldx     #BranchTaken1   ; Address for branch
8038 f3b4 af 28                      stx     8,y             ; Store in buffer
8039                         
8040                         ; Restore CC from saved value.
8041                         
8042 f3b6 b6 6f e0           branch  lda     SAVE_CC
8043 f3b9 1f 8a                      tfr     a,cc
8044                         
8045                         ; Call instruction in buffer. It is followed by a JMP so we get back.
8046                         
8047 f3bb 7e 6f f2                   jmp     BUFFER
8048                         
8049                         BranchTaken1                    ; Next PC is PC plus offset plus instruction length (3 or 4)
8050                         
8051                         ; Offset is 1,X for LBRA (2 byte instruction) and 2,X for others (3 byte instructions)
8052                         
8053 f3be be 6f ec                   ldx     SAVE_PC
8054 f3c1 b6 6f d2                   lda     OPCODE          ; Get  opcode
8055 f3c4 81 16                      cmpa    #$16            ; Is it LBRA?
8056 f3c6 26 0a                      bne     long1           ; Branch if it is one of the other 4 byte instructions
8057                         
8058 f3c8 fc 6f ec                   ldd     SAVE_PC         ; Get address
8059 f3cb c3 00 03                   addd    #3              ; Plus 3
8060 f3ce e3 01                      addd    1,x             ; Add 16-bit signed branch offset
8061 f3d0 20 08                      bra     upd
8062                         
8063 f3d2 fc 6f ec           long1   ldd     SAVE_PC         ; Get address
8064 f3d5 c3 00 04                   addd    #4              ; Plus 4
8065 f3d8 e3 02                      addd    2,x             ; Add 16-bit signed branch offset
8066                         
8067 f3da fd 6f ec           upd     std     SAVE_PC         ; Store new address value
8068 f3dd 16 01 e1                   lbra    don             ; Done
8069                         
8070                         BranchNotTaken1                 ; Next PC is instruction after the branch (PC plus 3 or 4).
8071                         
8072 f3e0 4f                         clra                    ; Clear MSB
8073 f3e1 f6 6f d6                   ldb     LENG            ; Get instruction length
8074 f3e4 1d                         sex                     ; Sign extend to 16 bits
8075 f3e5 f3 6f ec                   addd    SAVE_PC         ; Add instruction address
8076 f3e8 fd 6f ec                   std     SAVE_PC         ; Store new address value
8077 f3eb 16 01 d3                   lbra    don             ; Done
8078                         
8079                         ; Handle TFR instruction.
8080                         ; Need to manually handle cases where source or destination is the PC
8081                         ; since it won't run correctly from the buffer.
8082                         
8083 f3ee b6 6f d2           trytfr  lda     OPCODE          ; Get the actual op code
8084 f3f1 81 1f                      cmpa    #$1F            ; Is it TFR R1,R2 ?
8085 f3f3 10 26 00 91                lbne    tryexg          ; Branch if not
8086 f3f7 be 6f ec                   ldx     SAVE_PC         ; Get address of instruction
8087 f3fa a6 01                      lda     1,x             ; Get operand byte
8088 f3fc 84 f0                      anda    #%11110000      ; Mask source bits
8089 f3fe 81 50                      cmpa    #%01010000      ; Is source register PC?
8090 f400 26 44                      bne     checkdest       ; Branch if not
8091                         
8092 f402 10 be 6f ec                ldy     SAVE_PC         ; Get current PC
8093 f406 31 22                      leay    2,y             ; Add instruction length
8094                         
8095 f408 a6 01                      lda     1,x             ; Get operand byte
8096 f40a 84 0f                      anda    #%00001111      ; Mask destination bits
8097 f40c 81 00                      cmpa    #%00000000      ; D?
8098 f40e 27 13                      beq     to_d
8099 f410 81 01                      cmpa    #%00000001      ; X?
8100 f412 27 16                      beq     to_x
8101 f414 81 02                      cmpa    #%00000010      ; Y?
8102 f416 27 19                      beq     to_y
8103 f418 81 03                      cmpa    #%00000011      ; U?
8104 f41a 27 1c                      beq     to_u
8105 f41c 81 04                      cmpa    #%00000100      ; S?
8106 f41e 27 1f                      beq     to_s
8107 f420 16 01 94                   lbra    update          ; Anything else is invalid or PC to PC, so ignore
8108                         
8109 f423 10 bf 6f e1        to_d    sty     SAVE_D          ; Write new PC to D
8110 f427 16 01 8d                   lbra    update          ; Done
8111 f42a 10 bf 6f e4        to_x    sty     SAVE_X          ; Write new PC to X
8112 f42e 16 01 86                   lbra    update          ; Done
8113 f431 10 bf 6f e6        to_y    sty     SAVE_Y          ; Write new PC to Y
8114 f435 16 01 7f                   lbra    update          ; Done
8115 f438 10 bf 6f e8        to_u    sty     SAVE_U          ; Write new PC to U
8116 f43c 16 01 78                   lbra    update          ; Done
8117 f43f 10 bf 6f ea        to_s    sty     SAVE_S          ; Write new PC to S
8118 f443 16 01 71                   lbra    update          ; Done
8119                         
8120                         checkdest
8121 f446 a6 01                      lda     1,x             ; Get operand byte
8122 f448 84 0f                      anda    #%00001111      ; Mask destination bits
8123 f44a 81 05                      cmpa    #%00000101      ; Is destination register PC?
8124 f44c 10 26 00 f7                lbne    norml           ; Branch to normal instruction handling if not
8125                         
8126 f450 a6 01                      lda     1,x             ; Get operand byte
8127 f452 84 f0                      anda    #%11110000      ; Mask source bits
8128 f454 81 00                      cmpa    #%00000000      ; D?
8129 f456 27 13                      beq     from_d
8130 f458 81 10                      cmpa    #%00010000      ; X?
8131 f45a 27 14                      beq     from_x
8132 f45c 81 20                      cmpa    #%00100000      ; Y?
8133 f45e 27 15                      beq     from_y
8134 f460 81 30                      cmpa    #%00110000      ; U?
8135 f462 27 16                      beq     from_u
8136 f464 81 40                      cmpa    #%01000000      ; S?
8137 f466 27 17                      beq     from_s
8138 f468 16 01 4c                   lbra    update          ; Anything else is invalid or PC to PC, so ignore
8139                         
8140 f46b be 6f e1           from_d  ldx     SAVE_D          ; Get D
8141 f46e 20 12                      bra     write
8142 f470 be 6f e4           from_x  ldx     SAVE_X          ; Get X
8143 f473 20 0d                      bra     write
8144 f475 be 6f e6           from_y  ldx     SAVE_Y          ; Get Y
8145 f478 20 08                      bra     write
8146 f47a be 6f e8           from_u  ldx     SAVE_U          ; Get U
8147 f47d 20 03                      bra     write
8148 f47f be 6f ea           from_s  ldx     SAVE_S          ; Get S
8149                         
8150 f482 bf 6f ec           write   stx     SAVE_PC
8151 f485 16 01 39                   lbra    don
8152                         
8153                         ; Handle EXG instruction.
8154                         ; Need to manually handle cases where source or destination is the PC
8155                         ; since it won't run correctly from the buffer.
8156                         
8157 f488 b6 6f d2           tryexg  lda     OPCODE          ; Get the actual op code
8158 f48b 81 1e                      cmpa    #$1E            ; Is it EXG R1,R2 ?
8159 f48d 26 75                      bne     trypul          ; Branch if not
8160                         
8161 f48f be 6f ec                   ldx     SAVE_PC         ; Get address of instruction
8162 f492 a6 01                      lda     1,x             ; Get operand byte
8163 f494 84 f0                      anda    #%11110000      ; Mask source bits
8164 f496 81 50                      cmpa    #%01010000      ; Is source register PC?
8165 f498 26 06                      bne     checkdest1      ; Branch if not
8166 f49a a6 01                      lda     1,x             ; Get operand byte again
8167 f49c 84 0f                      anda    #%00001111      ; Mask destination bits
8168 f49e 20 16                      bra     doexg           ; Do the exchange
8169                         checkdest1
8170 f4a0 a6 01                      lda     1,x             ; Get operand byte
8171 f4a2 84 0f                      anda    #%00001111      ; Mask destination bits
8172 f4a4 81 05                      cmpa    #%00000101      ; Is destination register PC?
8173 f4a6 10 26 00 9d                lbne    norml           ; Branch and execute normally if not
8174 f4aa a6 01                      lda     1,x             ; Get operand byte again
8175 f4ac 84 f0                      anda    #%11110000      ; Mask source bits
8176 f4ae 04 00                      lsr                     ; Shift into low nybble
8177 f4b0 04 00                      lsr
8178 f4b2 04 00                      lsr
8179 f4b4 04 00                      lsr                     ; And fall thru to code below
8180                         
8181 f4b6 10 be 6f ec        doexg   ldy     SAVE_PC         ; Get current PC
8182 f4ba 31 22                      leay    2,y             ; Add instruction length
8183                         
8184 f4bc 81 00                      cmpa    #%00000000      ; Exchange D?
8185 f4be 27 13                      beq     exg_d
8186 f4c0 81 01                      cmpa    #%00000001      ; Exchange X?
8187 f4c2 27 19                      beq     exg_x
8188 f4c4 81 02                      cmpa    #%00000010      ; Exchange Y?
8189 f4c6 27 1d                      beq     exg_y
8190 f4c8 81 03                      cmpa    #%00000011      ; Exchange U?
8191 f4ca 27 21                      beq     exg_u
8192 f4cc 81 04                      cmpa    #%00000100      ; Exchange S?
8193 f4ce 27 25                      beq     exg_s
8194 f4d0 16 00 e4                   lbra    update          ; Anything else is invalid or PC to PC, so ignore
8195                         
8196                         ; At this point Y contains PC
8197                         
8198                         exg_d                           ; Swap PC and D
8199 f4d3 be 6f e1                   ldx     SAVE_D
8200 f4d6 1e 12                      exg     x,y
8201 f4d8 bf 6f e1                   stx     SAVE_D
8202 f4db 20 20                      bra     fin
8203 f4dd be 6f e4           exg_x   ldx     SAVE_X          ; Swap PC and X
8204 f4e0 1e 12                      exg     x,y
8205 f4e2 bf 6f e4                   stx     SAVE_X
8206 f4e5 be 6f e6           exg_y   ldx     SAVE_Y          ; Swap PC and Y
8207 f4e8 1e 12                      exg     x,y
8208 f4ea bf 6f e6                   stx     SAVE_Y
8209 f4ed be 6f e8           exg_u   ldx     SAVE_U          ; Swap PC and U
8210 f4f0 1e 12                      exg     x,y
8211 f4f2 bf 6f e8                   stx     SAVE_U
8212 f4f5 be 6f ea           exg_s   ldx     SAVE_S          ; Swap PC and S
8213 f4f8 1e 12                      exg     x,y
8214 f4fa bf 6f ea                   stx     SAVE_S
8215 f4fd 10 bf 6f ec        fin     sty     SAVE_PC
8216 f501 16 00 bd                   lbra    don
8217                         
8218                         ; Handle PULS/PULU PC,r,r,r
8219                         ; Could support it, but handling all the combinations of registers
8220                         ; would take a lot of code. For now, just generate warning that
8221                         ; instruction is unsupported and being ignored.
8222                         
8223 f504 b6 6f d2           trypul  lda     OPCODE          ; Get the actual op code
8224 f507 81 35                      cmpa    #$35            ; Is it PULS ?
8225 f509 27 04                      beq     pull            ; If so, handle it.
8226 f50b 81 37                      cmpa    #$37            ; Is it PULU ?
8227 f50d 26 18                      bne     trypush         ; If no, skip
8228                         
8229 f50f be 6f ec           pull    ldx     SAVE_PC         ; Get address of instruction
8230 f512 a6 01                      lda     1,x             ; Get operand byte
8231 f514 84 80                      anda    #%10000000      ; Mask PC bit
8232 f516 81 80                      cmpa    #%10000000      ; Is PC bit set?
8233 f518 26 2d                      bne     norml           ; If not, handle nornmally
8234                         
8235                         ; Display "Warning: instruction not supported, skipping."
8236                         
8237 f51a 30 8d 01 5e                leax    TMSG11,PCR      ; Message string
8238 f51e 17 ef 7c                   lbsr    PrintString     ; Display it
8239 f521 17 ef 0a                   lbsr    PrintCR
8240 f524 16 00 90                   lbra    update          ; Don't execute it
8241                         
8242                         ; Handle PSHS/PSHU PC,r,r,r
8243                         ; Could support it, but handling all the combinations of registers
8244                         ; would take a lot of code. For now just generate warning that
8245                         ; instruction is unsupported and results will be incorrect.
8246                         ; Still execute the instruction.
8247                         
8248 f527 b6 6f d2           trypush lda     OPCODE          ; Get the actual op code
8249 f52a 81 34                      cmpa    #$34            ; Is it PSHS ?
8250 f52c 27 04                      beq     push            ; If so, handle it.
8251 f52e 81 36                      cmpa    #$36            ; Is it PSHU ?
8252 f530 26 15                      bne     norml           ; If no, skip
8253                         
8254 f532 be 6f ec           push    ldx     SAVE_PC         ; Get address of instruction
8255 f535 a6 01                      lda     1,x             ; Get operand byte
8256 f537 84 80                      anda    #%10000000      ; Mask PC bit
8257 f539 81 80                      cmpa    #%10000000      ; Is PC bit set?
8258 f53b 26 0a                      bne     norml           ; If not, handle nornmally
8259                         
8260                         ; Display "Warning: instruction not supported, expect incorrect results."
8261                         
8262 f53d 30 8d 01 69                leax    TMSG12,PCR      ; Message string
8263 f541 17 ef 59                   lbsr    PrintString     ; Display it
8264 f544 17 ee e7                   lbsr    PrintCR
8265                                                         ; Fall through and execute it
8266                         
8267                         ; Otherwise:
8268                         ; Not a special instruction. We execute it from the buffer.
8269                         ; Copy instruction and operands to RAM buffer (based on LEN, can be 1 to 5 bytes)
8270                         ; TODO: Handle PC relative instructions.
8271                         
8272                         
8273                         ; Thoughts on handling PC relative modes:
8274                         ; Original code:
8275                         ; 2013  A6 8D 00 14                lda     tbl,pcr
8276                         ; 202B  01 02 03 04 05     tbl     fcb     1,2,3,4,5
8277                         ; Offset $0014 = $202B - ($2013 + 4)
8278                         ;
8279                         ; When running in buffer:
8280                         ; 101C  A6 8D 10 0B                lda     tbl,pcr
8281                         ; Offset should be $202B - ($101C + 4) = $100B
8282                         ; Change offset by $100B - $0014 = $0FF7
8283                         ; Original Address - Buffer Address = $2013 - $101C - $0FF7
8284                         ; Should be able to fix up offset to run in buffer.
8285                         ; Can't handle case where offset is 8 bits but won't reach buffer.
8286                         
8287                         
8288 f547 be 6f ec           norml   ldx     SAVE_PC         ; Address of instruction
8289 f54a 10 8e 6f f2                ldy     #BUFFER         ; Address of buffer
8290 f54e 4f                         clra                    ; Loop counter and index
8291 f54f e6 86              copy    ldb     a,x             ; Get instruction byte
8292 f551 e7 a6                      stb     a,y             ; Write to buffer
8293 f553 4c                         inca                    ; Increment counter
8294 f554 b1 6f d6                   cmpa    LENG            ; Copied all bytes?
8295 f557 26 f6                      bne     copy
8296                         
8297                         ; Add a jump after the instruction to where we want to go after it is executed (ReturnFromTrace).
8298                         
8299 f559 c6 7e                      ldb     #$7E            ; JMP $XXXX instruction
8300 f55b e7 a6                      stb     a,y             ; Store in buffer
8301 f55d 4c                         inca                    ; Advance buffer
8302 f55e 8e f5 8d                   ldx     #ReturnFromTrace ; Destination address of JMP
8303 f561 af a6                      stx     a,y             ; Store in buffer
8304                         
8305                         ; Restore registers from saved values.
8306                         
8307 f563 10 ff 6f ee                sts     OURS            ; Save this program's stack pointers
8308 f567 ff 6f f0                   stu     OURU
8309                         
8310 f56a f6 6f e2                   ldb     SAVE_B
8311 f56d be 6f e4                   ldx     SAVE_X
8312 f570 10 be 6f e6                ldy     SAVE_Y
8313 f574 10 fe 6f ea                lds     SAVE_S
8314 f578 fe 6f e8                   ldu     SAVE_U
8315 f57b b6 6f e3                   lda     SAVE_DP
8316 f57e 1f 8b                      tfr     a,dp
8317 f580 b6 6f e0                   lda     SAVE_CC
8318 f583 36 02                      pshu    a
8319 f585 b6 6f e1                   lda     SAVE_A
8320 f588 37 01                      pulu    cc              ; Has to be last so CC is left unchanged
8321                         
8322                         ; Call instruction in buffer. It is followed by a JMP ReturnFromTrace so we get back.
8323                         
8324 f58a 7e 6f f2                   jmp     BUFFER
8325                         
8326                         ReturnFromTrace
8327                         
8328                         ; Restore saved registers (except PC).
8329                         
8330 f58d 36 01                      pshu    cc              ; Have to save before it changes
8331 f58f b7 6f e1                   sta     SAVE_A
8332 f592 37 02                      pulu    a
8333 f594 b7 6f e0                   sta     SAVE_CC
8334 f597 1f b8                      tfr     dp,a
8335 f599 b7 6f e3                   sta     SAVE_DP
8336 f59c f7 6f e2                   stb     SAVE_B
8337 f59f bf 6f e4                   stx     SAVE_X
8338 f5a2 10 bf 6f e6                sty     SAVE_Y
8339 f5a6 10 ff 6f ea                sts     SAVE_S
8340 f5aa ff 6f e8                   stu     SAVE_U
8341                         
8342                         ; Restore this program's stack pointers so RTS etc. will still work.
8343                         
8344 f5ad 10 fe 6f ee                lds     OURS
8345 f5b1 fe 6f f0                   ldu     OURU
8346                         
8347                         ; Set this program's DP register to zero just in case calling program changed it.
8348                         
8349 f5b4 4f                         clra
8350 f5b5 1f 8b                      tfr     a,dp
8351                         
8352                         ; Update new SAVE_PC value based on instruction address and length
8353                         
8354 f5b7 4f                 update  clra                    ; Set MSB to zero
8355 f5b8 f6 6f d6                   ldb     LENG            ; Get length byte
8356 f5bb f3 6f ec                   addd    SAVE_PC         ; 16-bit add
8357 f5be fd 6f ec                   std     SAVE_PC         ; Store new address value
8358                         
8359                         ; And return.
8360                         
8361 f5c1 39                 don     rts
8362                         
8363                         ;------------------------------------------------------------------------
8364                         ; Display register values
8365                         ; Uses values in SAVED_A etc.
8366                         ; e.g.
8367                         ; PC=FEED A=01 B=02 X=1234 Y=2345 S=2000 U=2000 DP=00 CC=10001101 (EFHINZVC)
8368                         
8369                         DisplayRegs
8370 f5c2 30 8d 00 8c                leax    TMSG1,PCR
8371 f5c6 17 ee d4                   lbsr    PrintString
8372 f5c9 be 6f ec                   ldx     SAVE_PC
8373 f5cc 17 ee c0                   lbsr    PrintAddress
8374                         
8375 f5cf 30 8d 00 83                leax    TMSG2,PCR
8376 f5d3 17 ee c7                   lbsr    PrintString
8377 f5d6 b6 6f e1                   lda     SAVE_A
8378 f5d9 17 ee a5                   lbsr    PrintByte
8379                         
8380 f5dc 30 8d 00 79                leax    TMSG3,PCR
8381 f5e0 17 ee ba                   lbsr    PrintString
8382 f5e3 b6 6f e2                   lda     SAVE_B
8383 f5e6 17 ee 98                   lbsr    PrintByte
8384                         
8385 f5e9 30 8d 00 6f                leax    TMSG4,PCR
8386 f5ed 17 ee ad                   lbsr    PrintString
8387 f5f0 be 6f e4                   ldx     SAVE_X
8388 f5f3 17 ee 99                   lbsr    PrintAddress
8389                         
8390 f5f6 30 8d 00 65                leax    TMSG5,PCR
8391 f5fa 17 ee a0                   lbsr    PrintString
8392 f5fd be 6f e6                   ldx     SAVE_Y
8393 f600 17 ee 8c                   lbsr    PrintAddress
8394                         
8395 f603 30 8d 00 5b                leax    TMSG6,PCR
8396 f607 17 ee 93                   lbsr    PrintString
8397 f60a be 6f ea                   ldx     SAVE_S
8398 f60d 17 ee 7f                   lbsr    PrintAddress
8399                         
8400 f610 30 8d 00 51                leax    TMSG7,PCR
8401 f614 17 ee 86                   lbsr    PrintString
8402 f617 be 6f e8                   ldx     SAVE_U
8403 f61a 17 ee 72                   lbsr    PrintAddress
8404                         
8405 f61d 30 8d 00 47                leax    TMSG8,PCR
8406 f621 17 ee 79                   lbsr    PrintString
8407 f624 b6 6f e3                   lda     SAVE_DP
8408 f627 17 ee 57                   lbsr    PrintByte
8409                         
8410 f62a 30 8d 00 3e                leax    TMSG9,PCR       ; Show CC in binary
8411 f62e 17 ee 6c                   lbsr    PrintString
8412 f631 8e 00 08                   ldx     #8              ; Loop counter
8413 f634 f6 6f e0                   ldb     SAVE_CC         ; Get CC byte
8414 f637 58                 ploop   aslb                    ; Shift bit into carry
8415 f638 25 04                      bcs     one             ; Branch if it is a one
8416 f63a 86 30                      lda     #'0'            ; Print '0'
8417 f63c 20 02                      bra     prn
8418 f63e 86 31              one     lda     #'1'            ; Print '1'
8419 f640 bd e4 7b           prn     jsr     PrintChar
8420 f643 30 1f                      leax    -1,x            ; Decrement loop counter
8421 f645 26 f0                      bne     ploop           ; Branch if not done
8422                         
8423 f647 30 8d 00 25                leax    TMSG10,PCR
8424 f64b 17 ee 4f                   lbsr    PrintString
8425 f64e 17 ed dd                   lbsr    PrintCR
8426 f651 39                         rts
8427                         
8428 f652 50 43 3d           TMSG1   FCC     "PC="
8429 f655 04                         FCB     EOT
8430 f656 41 3d              TMSG2   FCC     "A="
8431 f658 04                         FCB     EOT
8432 f659 42 3d              TMSG3   FCC     "B="
8433 f65b 04                         FCB     EOT
8434 f65c 58 3d              TMSG4   FCC     "X="
8435 f65e 04                         FCB     EOT
8436 f65f 59 3d              TMSG5   FCC     "Y="
8437 f661 04                         FCB     EOT
8438 f662 53 3d              TMSG6   FCC     "S="
8439 f664 04                         FCB     EOT
8440 f665 55 3d              TMSG7   FCC     "U="
8441 f667 04                         FCB     EOT
8442 f668 44 50 3d           TMSG8   FCC     "DP="
8443 f66b 04                         FCB     EOT
8444 f66c 43 43 3d           TMSG9   FCC     "CC="
8445 f66f 04                         FCB     EOT
8446 f670 20 28 45 46 48 49  TMSG10  FCC     " (EFHINZVC)"
     4e 5a 56 43 29
8447 f67b 04                         FCB     EOT
8448 f67c 57 61 72 6e 69 6e  TMSG11  FCC     "Warning: instruction not supported, skipping."
     67 3a 20 69 6e 73
     74 72 75 63 74 69
     6f 6e 20 6e 6f 74
     20 73 75 70 70 6f
     72 74 65 64 2c 20
     73 6b 69 70 70 69
     6e 67 2e
8449 f6a9 04                         FCB     EOT
8450 f6aa 57 61 72 6e 69 6e  TMSG12  FCC     "Warning: instruction not supported, expect incorrect results."
     67 3a 20 69 6e 73
     74 72 75 63 74 69
     6f 6e 20 6e 6f 74
     20 73 75 70 70 6f
     72 74 65 64 2c 20
     65 78 70 65 63 74
     20 69 6e 63 6f 72
     72 65 63 74 20 72
     65 73 75 6c 74 73
     2e
8451 f6e7 04                         FCB     EOT
8452                         
8453                         ;------------------------------------------------------------------------
8454                         ; Disassemble an instruction. Uses ASSIST09 ROM code.
8455                         ; e.g.
8456                         ; 1053 2001 86 01    lda     #$01
8457                         
8458                         Disassemble
8459 f6e8 be 6f ec                   ldx     SAVE_PC         ; Get address of instruction
8460 f6eb bf 6f d0                   stx     ADRS            ; Pass it to the disassembler
8461 f6ee bd e5 a4                   jsr     DISASM          ; Disassemble one instruction
8462 f6f1 39                         rts
8463                         
8464                         ;========================================================================
8465                         
8466 f800                            ORG     $F800
8467                         
8468                         *************************************
8469                         * COPYRIGHT (C) MOTOROLA, INC. 1979 *
8470                         *************************************
8471                         
8472                         *************************************
8473                         * THIS IS THE BASE ASSIST09 ROM.
8474                         * IT MAY RUN WITH OR WITHOUT THE
8475                         * EXTENSION ROM WHICH
8476                         * WHEN PRESENT WILL BE AUTOMATICALLY
8477                         * INCORPORATED BY THE BLDVTR
8478                         * SUBROUTINE.
8479                         *************************************
8480                         
8481                         *********************************************
8482                         * GLOBAL MODULE EQUATES
8483                         ********************************************
8484 f800                    ROMBEG  EQU     $F800           ; ROM START ASSEMBLY ADDRESS
8485 ffff7800                    RAMOFS  EQU     -$8800          ; ROM OFFSET TO RAM WORK PAGE
8486 0800                    ROMSIZ  EQU     2048            ; ROM SIZE
8487 f000                    ROM2OF  EQU     ROMBEG-ROMSIZ   ; START OF EXTENSION ROM
8488 a000                    ACIA    EQU     $A000           ; DEFAULT ACIA ADDRESS
8489 0000                    PTM     EQU     $0000           ; DEFAULT PTM ADDRESS
8490 0000                    DFTCHP  EQU     0               ; DEFAULT CHARACTER PAD COUNT
8491 0005                    DFTNLP  EQU     5               ; DEFAULT NEW LINE PAD COUNT
8492 003e                    PROMPT  EQU     '>              ; PROMPT CHARACTER
8493 0008                    NUMBKP  EQU     8               ; NUMBER OF BREAKPOINTS
8494                         *********************************************
8495                         
8496                         *********************************************
8497                         * MISCELANEOUS EQUATES
8498                         *********************************************
8499 0004                    EOT     EQU     $04             ; END OF TRANSMISSION
8500 0007                    BELL    EQU     $07             ; BELL CHARACTER
8501 000a                    LF      EQU     $0A             ; LINE FEED
8502                         *CR     EQU     $0D             ; CARRIAGE RETURN
8503 0010                    DLE     EQU     $10             ; DATA LINK ESCAPE
8504 0018                    CAN     EQU     $18             ; CANCEL (CTL-X)
8505                         
8506                         * PTM ACCESS DEFINITIONS
8507 0001                    PTMSTA  EQU     PTM+1           ; READ STATUS REGISTER
8508 0000                    PTMC13  EQU     PTM             ; CONTROL REGISTERS 1 AND 3
8509 0001                    PTMC2   EQU     PTM+1           ; CONTROL REGISTER 2
8510 0002                    PTMTM1  EQU     PTM+2           ; LATCH 1
8511 0004                    PTMTM2  EQU     PTM+4           ; LATCH 2
8512 0006                    PTMTM3  EQU     PTM+6           ; LATCH 3
8513 008c                    SKIP2   EQU     $8C             ; "CMPX #" OPCODE - SKIPS TWO BYTES
8514                         
8515                         *******************************************
8516                         * ASSIST09 MONITOR SWI FUNCTIONS
8517                         * THE FOLLOWING EQUATES DEFINE FUNCTIONS PROVIDED
8518                         * BY THE ASSIST09 MONITOR VIA THE SWI INSTRUCTION.
8519                         ******************************************
8520 0000                    INCHNP  EQU     0               ; INPUT CHAR IN A REG - NO PARITY
8521 0001                    OUTCH   EQU     1               ; OUTPUT CHAR FROM A REG
8522 0002                    PDATA1  EQU     2               ; OUTPUT STRING
8523 0003                    PDATA   EQU     3               ; OUTPUT CR/LF THEN STRING
8524 0004                    OUT2HS  EQU     4               ; OUTPUT TWO HEX AND SPACE
8525 0005                    OUT4HS  EQU     5               ; OUTPUT FOUR HEX AND SPACE
8526 0006                    PCRLF   EQU     6               ; OUTPUT CR/LF
8527 0007                    SPACEF  EQU     7               ; OUTPUT A SPACE
8528 0008                    MONITR  EQU     8               ; ENTER ASSIST09 MONITOR
8529 0009                    VCTRSW  EQU     9               ; VECTOR EXAMINE/SWITCH
8530 000a                    BRKPT   EQU     10              ; USER PROGRAM BREAKPOINT
8531 000b                    PAUSE   EQU     11              ; TASK PAUSE FUNCTION
8532 000b                    NUMFUN  EQU     11              ; NUMBER OF AVAILABLE FUNCTIONS
8533                         
8534                         * NEXT SUB-CODES FOR ACCESSING THE VECTOR TABLE.
8535                         * THEY ARE EQUIVALENT TO OFFSETS IN THE TABLE.
8536                         * RELATIVE POSITIONING MUST BE MAINTAINED
8537                         
8538 0000                    .AVTBL  EQU     0               ; ADDRESS OF VECTOR TABLE
8539 0002                    .CMDL1  EQU     2               ; FIRST COMMAND LIST
8540 0004                    .RSVD   EQU     4               ; RESERVED HARDWARE VECTOR
8541 0006                    .SWI3   EQU     6               ; SWI3 ROUTINE
8542 0008                    .SWI2   EQU     8               ; SWI2 ROUTINE
8543 000a                    .FIRQ   EQU     10              ; FIRQ ROUTINE
8544 000c                    .IRQ    EQU     12              ; IRQ ROUTINE
8545 000e                    .SWI    EQU     14              ; SWI ROUTINE
8546 0010                    .NMI    EQU     16              ; NMI ROUTINE
8547 0012                    .RESET  EQU     18              ; RESET ROUTINE
8548 0014                    .CION   EQU     20              ; CONSOLE ON
8549 0016                    .CIDTA  EQU     22              ; CONSOLE INPUT DATA
8550 0018                    .CIOFF  EQU     24              ; CONSOLE INPUT OFF
8551 001a                    .COON   EQU     26              ; CONSOLE OUTPUT ON
8552 001c                    .CODTA  EQU     28              ; CONSOLE OUTPUT DATA
8553 001e                    .COOFF  EQU     30              ; CONSOLE OUTPUT OFF
8554 0020                    .HSDTA  EQU     32              ; HIGH SPEED PRINTDATA
8555 0022                    .BSON   EQU     34              ; PUNCH/LOAD ON
8556 0024                    .BSDTA  EQU     36              ; PUNCH/LOAD DATA
8557 0026                    .BSOFF  EQU     38              ; PUNCH/LOAD OFF
8558 0028                    .PAUSE  EQU     40              ; TASK PAUSE ROUTINE
8559 002a                    .EXPAN  EQU     42              ; EXPRESSION ANALYZER
8560 002c                    .CMDL2  EQU     44              ; SECOND COMMAND LIST
8561 002e                    .ACIA   EQU     46              ; ACIA ADDRESS
8562 0030                    .PAD    EQU     48              ; CHARACTER PAD AND NEW LINE PAD
8563 0032                    .ECHO   EQU     50              ; ECHO/LOAD AND NULL BKPT FLAG
8564 0034                    .PTM    EQU     52              ; PTM ADDRESS
8565 001b                    NUMVTR  EQU     52/2+1          ; NUMBER OF VECTORS
8566 0034                    HIVTR   EQU     52              ; HIGHEST VECTOR OFFSET
8567                         
8568                         ******************************************
8569                         *           WORK AREA
8570                         * THIS WORK AREA IS ASSIGNED TO THE PAGE ADDRESSED BY
8571                         * -$1800,PCR FROM THE BASE ADDRESS OF THE ASSIST09
8572                         * ROM. THE DIRECT PAGE REGISTER DURING MOST ROUTINE
8573                         * OPERATIONS WILL POINT TO THIS WORK AREA. THE STACK
8574                         * INITIALLY STARTS UNDER THE RESERVED WORK AREAS AS
8575                         * DEFINED HEREIN.
8576                         ******************************************
8577 7000                    WORKPG  EQU     ROMBEG+RAMOFS   ; SETUP DIRECT PAGE ADDRESS
8578                         *       SETDP   =WORKPG         ; NOTIFY ASSEMBLER
8579 7100                            ORG     WORKPG+256      ; READY PAGE DEFINITIONS
8580                         
8581                         * THE FOLLOWING THRU BKPTOP MUST RESIDE IN THIS ORDER
8582                         * FOR PROPER INITIALIZATION
8583 70fc                            ORG     *-4
8584 70fc                    PAUSER  EQU     *               ; PAUSE ROUTINE
8585 70fb                            ORG     *-1
8586 70fb                    SWIBFL  EQU     *               ; BYPASS SWI AS BREAKPOINT FLAG
8587 70fa                            ORG     *-1
8588 70fa                    BKPTCT  EQU     *               ; BREAKPOINT COUNT
8589 70f8                            ORG     *-2             ; SLEVEL EQU
8590 70f8                    SLEVEL  EQU     *               ; STACK TRACE LEVEL
8591 70c2                            ORG     -NUMVTR*2+*
8592 70c2                    VECTAB  EQU     *               ; VECTOR TABLE
8593 70b2                            ORG     -2*NUMBKP+*
8594 70b2                    BKPTBL  EQU     *               ; BREAKPOINT TABLE
8595 70a2                            ORG     -2*NUMBKP+*
8596 70a2                    BKPTOP  EQU     *               ; BREAKPOINT OPCODE TABLE
8597 70a0                            ORG     *-2
8598 70a0                    WINDOW  EQU     *               ; WINDOW
8599 709e                            ORG     *-2
8600 709e                    ADDR    EQU     *               ; ADDRESS POINTER VALUE
8601 709d                            ORG     *-1
8602 709d                    BASEPG  EQU     *               ; BASE PAGE VALUE
8603 709b                            ORG     *-2
8604 709b                    NUMBER  EQU     *               ; BINARY BUILD AREA
8605 7099                            ORG     *-2
8606 7099                    LASTOP  EQU     *               ; LAST OPCODE TRACED
8607 7097                            ORG     *-2
8608 7097                    RSTACK  EQU     *               ; RESET STACK POINTER
8609 7095                            ORG     *-2
8610 7095                    PSTACK  EQU     *               ; COMMAND RECOVERY STACK
8611 7093                            ORG     *-2
8612 7093                    PCNTER  EQU     *               ; LAST PROGRAM COUNTER
8613 7091                            ORG     *-2
8614 7091                    TRACEC  EQU     *               ; TRACE COUNT
8615 7090                            ORG     *-1
8616 7090                    SWICNT  EQU     *               ; TRACE "SWI" NEST LEVEL COUNT
8617 708f                            ORG     *-1             ; (MISFLG MUST FOLLOW SWICNT)
8618 708f                    MISFLG  EQU     *               ; LOAD CMD/THRU BREAKPOINT FLAG
8619 708e                            ORG     *-1
8620 708e                    DELIM   EQU     *               ; EXPRESSION DELIMITER/WORK BYTE
8621 7066                            ORG     *-40
8622 7066                    ROM2WK  EQU     *               ; EXTENSION ROM RESERVED AREA
8623 7051                            ORG     *-21
8624 7051                    TSTACK  EQU     *               ; TEMPORARY STACK HOLD
8625 7051                    STACK   EQU     *               ; START OF INITIAL STACK
8626                         
8627                         ******************************************
8628                         * DEFAULT THE ROM BEGINNING ADDRESS TO 'ROMBEG'
8629                         * ASSIST09 IS POSITION ADDRESS INDEPENDENT, HOWEVER
8630                         * WE ASSEMBLE ASSUMING CONTROL OF THE HARDWARE VECTORS.
8631                         * NOTE THAT THE WORK RAM PAGE MUST BE 'RAMOFS'
8632                         * FROM THE ROM BEGINNING ADDRESS.
8633                         ********************************************
8634 f800                            ORG     ROMBEG          ; ROM ASSEMBLY/DEFAULT ADDRESS
8635                         
8636                         *****************************************************
8637                         * BLDVTR - BUILD ASSIST09 VECTOR TABLE
8638                         * HARDWARE RESET CALLS THIS SUBROUTINE TO BUILD THE
8639                         * ASSIST09 VECTOR TABLE. THIS SUBROUTINE RESIDES AT
8640                         * THE FIRST BYTE OF THE ASSIST09 ROM, AND CAN BE
8641                         * CALLED VIA EXTERNAL CONTROL CODE FOR REMOTE
8642                         * ASSIST09 EXECUTION.
8643                         * INPUT: S->VALID STACK RAM
8644                         * OUTPUT: U->VECTOR TABLE ADDRESS
8645                         * DPR->ASSIST09 WORK AREA PAGE
8646                         * THE VECTOR TABLE AND DEFAULTS ARE INITIALIZED
8647                         * ALL REGISTERS VOLATILE
8648                         *************************************************
8649 f800 30 8d 78 be        BLDVTR  LEAX    VECTAB,PCR      ; ADDRESS VECTOR TABLE
8650 f804 1f 10                      TFR     X,D             ; OBTAIN BASE PAGE ADDRESS
8651 f806 1f 8b                      TFR     A,DP            ; SETUP DPR
8652 f808 97 9d                      STA     <BASEPG         ; STORE FOR QUICK REFERENCE
8653 f80a 33 84                      LEAU    ,X              ; RETURN TABLE TO CALLER
8654 f80c 31 8c 35                   LEAY    <INITVT,PCR     ; LOAD FROM ADDR
8655 f80f ef 81                      STU     ,X++            ; INIT VECTOR TABLE ADDRESS
8656 f811 c6 16                      LDB     #NUMVTR-5       ; NUMBER RELOCATABLE VECTORS
8657 f813 34 04                      PSHS    B               ; STORE INDEX ON STACK
8658 f815 1f 20              BLD2    TFR     Y,D             ; PREPARE ADDRESS RESOLVE
8659 f817 e3 a1                      ADDD    ,Y++            ; TO ABSOLUTE ADDRESS
8660 f819 ed 81                      STD     ,X++            ; INTO VECTOR TABLE
8661 f81b 6a e4                      DEC     ,S              ; COUNT DOWN
8662 f81d 26 f6                      BNE     BLD2            ; BRANCH IF MORE TO INSERT
8663 f81f c6 0d                      LDB     #INTVE-INTVS    ; STATIC VALUE INIT LENGTH
8664 f821 a6 a0              BLD3    LDA     ,Y+             ; LOAD NEXT BYTE
8665 f823 a7 80                      STA     ,X+             ; STORE INTO POSITION
8666 f825 5a                         DECB                    ; COUNT DOWN
8667 f826 26 f9                      BNE     BLD3            ; LOOP UNTIL DONE
8668 f828 31 8d f7 d4                LEAY    ROM2OF,PCR      ; TEST POSSIBLE EXTENSION ROM
8669 f82c 8e 20 fe                   LDX     #$20FE          ; LOAD "BRA *" FLAG PATTERN
8670 f82f ac a1                      CMPX    ,Y++            ; ? EXTENDED ROM HERE
8671 f831 26 02                      BNE     BLDRTN          ; BRANCH NOT OUR ROM TO RETURN
8672 f833 ad a4                      JSR     ,Y              ; CALL EXTENDED ROM INITIALIZE
8673 f835 35 84              BLDRTN  PULS    PC,B            ; RETURN TO INITIALIZER
8674                         
8675                         *****************************************************
8676                         *                RESET ENTRY POINT
8677                         * HARDWARE RESET ENTERS HERE IF ASSIST09 IS ENABLED
8678                         * TO RECEIVE THE MC6809 HARDWARE VECTORS. WE CALL
8679                         * THE BLDVTR SUBROUTINE TO INITIALIZE THE VECTOR
8680                         * TABLE, STACK, AND THEN FIREUP THE MONITOR VIA SWI
8681                         * CALL.
8682                         *******************************************************
8683 f837 32 8d 78 16        RESET   LEAS    STACK,PCR       ; SETUP INITIAL STACK
8684 f83b 8d c3                      BSR     BLDVTR          ; BUILD VECTOR TABLE
8685 f83d 4f                 RESET2  CLRA                    ; ISSUE STARTUP MESSAGE
8686 f83e 1f 8b                      TFR     A,DP            ; DEFAULT TO PAGE ZERO
8687 f840 3f                         SWI                     ; PERFORM MONITOR FIREUP
8688 f841 08                         FCB     MONITR          ; TO ENTER COMMAND PROCESSING
8689 f842 20 f9                      BRA     RESET2          ; REENTER MONITOR IF 'CONTINUE'
8690                         
8691                         ******************************************************
8692                         *        INITVT - INITIAL VECTOR TABLE
8693                         * THIS TABLE IS RELOCATED TO RAM AND REPRESENTS THE
8694                         * INITIAL STATE OF THE VECTOR TABLE. ALL ADDRESSES
8695                         * ARE CONVERTED TO ABSOLUTE FORM. THIS TABLE STARTS
8696                         * WITH THE SECOND ENTRY, ENDS WITH STATIC CONSTANT
8697                         * INITIALIZATION DATA WHICH CARRIES BEYOND THE TABLE.
8698                         ************************************************
8699 f844 01 60              INITVT  FDB     CMDTBL-*        ; DEFAULT FIRST COMMAND TABLE
8700 f846 02 92                      FDB     RSRVDR-*        ; DEFAULT UNDEFINED HARDWARE VECTOR
8701 f848 02 90                      FDB     SWI3R-*         ; DEFAULT SWI3
8702 f84a 02 8e                      FDB     SWI2R-*         ; DEFAULT SWI2
8703 f84c 02 70                      FDB     FIRQR-*         ; DEFAULT FIRQ
8704 f84e 02 8a                      FDB     IRQR-*          ; DEFAULT IRQ ROUTINE
8705 f850 00 45                      FDB     SWIR-*          ; DEFAULT SWI ROUTINE
8706 f852 02 2b                      FDB     NMIR-*          ; DEFAULT NMI ROUTINE
8707 f854 ff e3                      FDB     RESET-*         ; RESTART VECTOR
8708 f856 02 90                      FDB     CION-*          ; DEFAULT CION
8709 f858 02 84                      FDB     CIDTA-*         ; DEFAULT CIDTA
8710 f85a 02 96                      FDB     CIOFF-*         ; DEFAULT CIOFF
8711 f85c 02 8a                      FDB     COON-*          ; DEFAULT COON
8712 f85e 02 93                      FDB     CODTA-*         ; DEFAULT CODTA
8713 f860 02 90                      FDB     COOFF-*         ; DEFAULT COOFF
8714 f862 03 9a                      FDB     HSDTA-*         ; DEFAULT HSDTA
8715 f864 02 b7                      FDB     BSON-*          ; DEFAULT BSON
8716 f866 02 d2                      FDB     BSDTA-*         ; DEFAULT BSDTA
8717 f868 02 bf                      FDB     BSOFF-*         ; DEFAULT BSOFF
8718 f86a 78 92                      FDB     PAUSER-*        ; DEFAULT PAUSE ROUTINE
8719 f86c 04 7d                      FDB     EXP1-*          ; DEFAULT EXPRESSION ANALYZER
8720 f86e 01 2d                      FDB     CMDTB2-*        ; DEFAULT SECOND COMMAND TABLE
8721                         * CONSTANTS
8722 f870 a0 00              INTVS   FDB     ACIA            ; DEFAULT ACIA
8723 f872 00 05                      FCB     DFTCHP,DFTNLP   ; DEFAULT NULL PADDS
8724 f874 00 00                      FDB     0               ; DEFAULT ECHO
8725 f876 00 00                      FDB     PTM             ; DEFAULT PTM
8726 f878 00 00                      FDB     0               ; INITIAL STACK TRACE LEVEL
8727 f87a 00                         FCB     0               ; INITIAL BREAKPOINT COUNT
8728 f87b 00                         FCB     0               ; SWI BREAKPOINT LEVEL
8729 f87c 39                         FCB     $39             ; DEFAULT PAUSE ROUTINE (RTS)
8730 f87d                    INTVE   EQU     *
8731                         *B
8732                         ***********************************************
8733                         *            ASSIST09 SWI HANDLER
8734                         * THE SWI HANDLER PROVIDES ALL INTERFACING NECESSARY
8735                         * FOR A USER PROGRAM. A FUNCTION BYTE IS ASSUMED TO
8736                         * FOLLOW THE SWI INSTRUCTION. IT IS BOUND CHECKED
8737                         * AND THE PROPER ROUTINE IS GIVEN CONTROL. THIS
8738                         * INVOCATION MAY ALSO BE A BREAKPOINT INTERRUPT.
8739                         * IF SO, THE BREAKPOINT HANDLER IS ENTERED.
8740                         * INPUT: MACHINE STATE DEFINED FOR SWI
8741                         * OUTPUT: VARIES ACCORDING TO FUNCTION CALLED. PC ON
8742                         * CALLERS STACK INCREMENTED BY ONE IF VALID CALL.
8743                         * VOLATILE REGISTERS: SEE FUNCTIONS CALLED
8744                         * STATE: RUNS DISABLED UNLESS FUNCTION CLEARS I FLAG.
8745                         ************************************************
8746                         * SWI FUNCTION VECTOR TABLE
8747 f87d 01 94              SWIVTB  FDB     ZINCH-SWIVTB    ; INCHNP
8748 f87f 01 b1                      FDB     ZOTCH1-SWIVTB   ; OUTCH
8749 f881 01 cb                      FDB     ZPDTA1-SWIVTB   ; PDATA1
8750 f883 01 c3                      FDB     ZPDATA-SWIVTB   ; PDATA
8751 f885 01 75                      FDB     ZOT2HS-SWIVTB   ; OUT2HS
8752 f887 01 73                      FDB     ZOT4HS-SWIVTB   ; OUT4HS
8753 f889 01 c0                      FDB     ZPCRLF-SWIVTB   ; PCRLF
8754 f88b 01 79                      FDB     ZSPACE-SWIVTB   ; SPACE
8755 f88d 00 55                      FDB     ZMONTR-SWIVTB   ; MONITR
8756 f88f 01 7d                      FDB     ZVSWTH-SWIVTB   ; VCTRSW
8757 f891 02 56                      FDB     ZBKPNT-SWIVTB   ; BREAKPOINT
8758 f893 01 d1                      FDB     ZPAUSE-SWIVTB   ; TASK PAUSE
8759                         
8760 f895 6a 8d 77 f7        SWIR    DEC     SWICNT,PCR      ; UP "SWI" LEVEL FOR TRACE
8761 f899 17 02 25                   LBSR    LDDP            ; SETUP PAGE AND VERIFY STACK
8762                         * CHECK FOR BREAKPOINT TRAP
8763 f89c ee 6a                      LDU     10,S            ; LOAD PROGRAM COUNTER
8764 f89e 33 5f                      LEAU    -1,U            ; BACK TO SWI ADDRESS
8765 f8a0 0d fb                      TST     <SWIBFL         ; ? THIS "SWI" BREAKPOINT
8766 f8a2 26 11                      BNE     SWIDNE          ; BRANCH IF SO TO LET THROUGH
8767 f8a4 17 06 9b                   LBSR    CBKLDR          ; OBTAIN BREAKPOINT POINTERS
8768 f8a7 50                         NEGB                    ; OBTAIN POSITIVE COUNT
8769 f8a8 5a                 SWILP   DECB                    ; COUNT DOWN
8770 f8a9 2b 0a                      BMI     SWIDNE          ; BRANCH WHEN DONE
8771 f8ab 11 a3 a1                   CMPU    ,Y++            ; ? WAS THIS A BREAKPOINT
8772 f8ae 26 f8                      BNE     SWILP           ; BRANCH IF NOT
8773 f8b0 ef 6a                      STU     10,S            ; SET PROGRAM COUNTER BACK
8774 f8b2 16 02 1e                   LBRA    ZBKPNT          ; GO DO BREAKPOINT
8775 f8b5 0f fb              SWIDNE  CLR     <SWIBFL         ; CLEAR IN CASE SET
8776 f8b7 37 06                      PULU    D               ; OBTAIN FUNCTION BYTE, UP PC
8777 f8b9 c1 0b                      CMPB    #NUMFUN         ; ? TOO HIGH
8778 f8bb 10 22 02 0f                LBHI    ERROR           ; YES, DO BREAKPOINT
8779 f8bf ef 6a                      STU     10,S            ; BUMP PROGRAM COUNTER PAST SWI
8780 f8c1 58                         ASLB                    ; FUNCTION CODE TIMES TWO
8781 f8c2 33 8c b8                   LEAU    SWIVTB,PCR      ; OBTAIN VECTOR BRANCH ADDRESS
8782 f8c5 ec c5                      LDD     B,U             ; LOAD OFFSET
8783 f8c7 6e cb                      JMP     D,U             ; JUMP TO ROUTINE
8784                         
8785                         **********************************************
8786                         * REGISTERS TO FUNCTION ROUTINES:
8787                         *  DP-> WORK AREA PAGE
8788                         *  D,Y,U=UNRELIABLE           X=AS CALLED FROM USER
8789                         *  S=AS FROM SWI INTERRUPT
8790                         *********************************************
8791                         
8792                         **************************************************
8793                         *            [SWI FUNCTION 8]
8794                         *              MONITOR ENTRY
8795                         *  FIREUP THE ASSIST09 MONITOR.
8796                         *  THE STACK WITH ITS VALUES FOR THE DIRECT PAGE
8797                         *  REGISTER AND CONDITION CODE FLAGS ARE USED AS IS.
8798                         *   1) INITIALIZE CONSOLE I/O
8799                         *   2) OPTIONALLY PRINT SIGNON
8800                         *   3) INITIALIZE PTM FOR SINGLE STEPPING
8801                         *   4) ENTER COMMAND PROCESSOR
8802                         * INPUT: A=0 INIT CONSOLE AND PRINT STARTUP MESSAGE
8803                         *        A#0 OMIT CONSOLE INIT AND STARTUP MESSAGE
8804                         *************************************************
8805                         
8806 f8c9 41 53 53 49 53 54  SIGNON  FCC     /ASSIST09/      ; SIGNON EYE-CATCHER
     30 39
8807 f8d1 04                         FCB     EOT
8808 f8d2 10 df 97           ZMONTR  STS     <RSTACK         ; SAVE FOR BAD STACK RECOVERY
8809 f8d5 6d 61                      TST     1,S             ; ? INIT CONSOLE AND SEND MSG
8810 f8d7 26 0d                      BNE     ZMONT2          ; BRANCH IF NOT
8811 f8d9 ad 9d 77 f9                JSR     [VECTAB+.CION,PCR] ; READY CONSOLE INPUT
8812 f8dd ad 9d 77 fb                JSR     [VECTAB+.COON,PCR] ; READY CONSOLE OUTPUT
8813 f8e1 30 8c e5                   LEAX    SIGNON,PCR         ; READY SIGNON EYE-CATCHER
8814 f8e4 3f                         SWI                     ; PERFORM
8815 f8e5 03                         FCB     PDATA           ; PRINT STRING
8816 f8e6 9e f6              ZMONT2  LDX     <VECTAB+.PTM    ; LOAD PTM ADDRESS
8817 f8e8 27 0d                      BEQ     CMD             ; BRANCH IF NOT TO USE A PTM
8818 f8ea 6f 02                      CLR     PTMTM1-PTM,X    ; SET LATCH TO CLEAR RESET
8819 f8ec 6f 03                      CLR     PTMTM1+1-PTM,X  ; AND SET GATE HIGH
8820 f8ee cc 01 a6                   LDD     #$01A6          ; SETUP TIMER 1 MODE
8821 f8f1 a7 01                      STA     PTMC2-PTM,X     ; SETUP FOR CONTROL REGISTER1
8822 f8f3 e7 84                      STB     PTMC13-PTM,X    ; SET OUTPUT ENABLED/
8823                         * SINGLE SHOT/ DUAL 8 BIT/INTERNAL MODE/OPERATE
8824 f8f5 6f 01                      CLR     PTMC2-PTM,X     ; SET CR2 BACK TO RESET FORM
8825                         * FALL INTO COMMAND PROCESSOR
8826                         
8827                         ***************************************************
8828                         *          COMMAND HANDLER
8829                         *  BREAKPOINTS ARE REMOVED AT THIS TIME.
8830                         *  PROMPT FOR A COMMAND, AND STORE ALL CHARACTERS
8831                         *  UNTIL A SEPARATOR ON THE STACK.
8832                         *  SEARCH FOR FIRST MATCHING COMMAND SUBSET,
8833                         *  CALL IT OR GIVE '?' RESPONSE.
8834                         *  DURING COMMAND SEARCH:
8835                         *      B=OFFSET TO NEXT ENTRY ON X
8836                         *      U=SAVED S
8837                         *      U-1=ENTRY SIZE+2
8838                         *      U-2=VALID NUMBER FLAG (>=0 VALID)/COMPARE CNT
8839                         *      U-3=CARRIAGE RETURN FLAG (0=CR HAS BEEN DONE)
8840                         *      U-4=START OF COMMAND STORE
8841                         *      S+0=END OF COMMAND STORE
8842                         ***********************************************
8843                         
8844 f8f7 3f                 CMD     SWI                     ; TO NEW LINE
8845 f8f8 06                         FCB     PCRLF           ; FUNCTION
8846                         * DISARM THE BREAKPOINTS
8847 f8f9 17 06 46           CMDNEP  LBSR    CBKLDR          ; OBTAIN BREAKPOINT POINTERS
8848 f8fc 2a 0c                      BPL     CMDNOL          ; BRANCH IF NOT ARMED OR NONE
8849 f8fe 50                         NEGB                    ; MAKE POSITIVE
8850 f8ff d7 fa                      STB     <BKPTCT         ; FLAG AS DISARMED
8851 f901 5a                 CMDDDL  DECB                    ; ? FINISHED
8852 f902 2b 06                      BMI     CMDNOL          ; BRANCH IF SO
8853 f904 a6 30                      LDA     -NUMBKP*2,Y     ; LOAD OPCODE STORED
8854 f906 a7 b1                      STA     [,Y++]          ; STORE BACK OVER "SWI"
8855 f908 20 f7                      BRA     CMDDDL          ; LOOP UNTIL DONE
8856 f90a ae 6a              CMDNOL  LDX     10,S            ; LOAD USERS PROGRAM COUNTER
8857 f90c 9f 93                      STX     <PCNTER         ; SAVE FOR EXPRESSION ANALYZER
8858 f90e 86 3e                      LDA     #PROMPT         ; LOAD PROMPT CHARACTER
8859 f910 3f                         SWI                     ; SEND TO OUTPUT HANDLER
8860 f911 01                         FCB     OUTCH           ; FUNCTION
8861 f912 33 e4                      LEAU    ,S              ; REMEMBER STACK RESTORE ADDRESS
8862 f914 df 95                      STU     <PSTACK         ; REMEMBER STACK FOR ERROR USE
8863 f916 4f                         CLRA                    ; PREPARE ZERO
8864 f917 5f                         CLRB                    ; PREPARE ZERO
8865 f918 dd 9b                      STD     <NUMBER         ; CLEAR NUMBER BUILD AREA
8866 f91a dd 8f                      STD     <MISFLG         ; CLEAR MISCEL. AND SWICNT FLAGS
8867 f91c dd 91                      STD     <TRACEC         ; CLEAR TRACE COUNT
8868 f91e c6 02                      LDB     #2              ; SET D TO TWO
8869 f920 34 07                      PSHS    D,CC            ; PLACE DEFAULTS ONTO STACK
8870                         * CHECK FOR "QUICK" COMMANDS.
8871 f922 17 04 54                   LBSR    READC           ; OBTAIN FIRST CHARACTER
8872 f925 30 8d 05 81                LEAX    CDOT+2,PCR      ; PRESET FOR SINGLE TRACE
8873 f929 81 2e                      CMPA    #'.             ; ? QUICK TRACE
8874 f92b 27 5a                      BEQ     CMDXQT          ; BRANCH EQUAL FOR TRACE ONE
8875 f92d 30 8d 04 e9                LEAX    CMPADP+2,PCR    ; READY MEMORY ENTRY POINT
8876 f931 81 2f                      CMPA    #'/             ; ? OPEN LAST USED MEMORY
8877 f933 27 52                      BEQ     CMDXQT          ; BRANCH TO DO IT IF SO
8878                         * PROCESS NEXT CHARACTER
8879 f935 81 20              CMD2    CMPA    #'              ; ? BLANK OR DELIMITER
8880 f937 23 14                      BLS    CMDGOT           ; BRANCH YES, WE HAVE IT
8881 f939 34 02                      PSHS   A                ; BUILD ONTO STACK
8882 f93b 6c 5f                      INC    -1,U             ; COUNT THIS CHARACTER
8883 f93d 81 2f                      CMPA   #'/              ; ? MEMORY COMMAND
8884 f93f 27 4f                      BEQ    CMDMEM           ; BRANCH IF SO
8885 f941 17 04 0b                   LBSR   BLDHXC           ; TREAT AS HEX VALUE
8886 f944 27 02                      BEQ    CMD3             ; BRANCH IF STILL VALID NUMBER
8887 f946 6a 5e                      DEC    -2,U             ; FLAG AS INVALID NUMBER
8888 f948 17 04 2e           CMD3    LBSR   READC            ; OBTAIN NEXT CHARACTER
8889 f94b 20 e8                      BRA    CMD2             ; TEST NEXT CHARACTER
8890                         * GOT COMMAND, NOW SEARCH TABLES
8891 f94d 80 0d              CMDGOT  SUBA   #CR              ; SET ZERO IF CARRIAGE RETURN
8892 f94f a7 5d                      STA    -3,U             ; SETUP FLAG
8893 f951 9e c4                      LDX    <VECTAB+.CMDL1   ; START WITH FIRST CMD LIST
8894 f953 e6 80              CMDSCH  LDB    ,X+              ; LOAD ENTRY LENGTH
8895 f955 2a 10                      BPL    CMDSME           ; BRANCH IF NOT LIST END
8896 f957 9e ee                      LDX    <VECTAB+.CMDL2   ; NOW TO SECOND CMD LITS
8897 f959 5c                         INCB                    ; ? TO CONTINUE TO DEFAULT LIST
8898 f95a 27 f7                      BEQ     CMDSCH          ; BRANCH IF SO
8899 f95c 10 de 95           CMDBAD  LDS     <PSTACK         ; RESTORE STACK
8900 f95f 30 8d 01 5a                LEAX    ERRMSG,PCR      ; POINT TO ERROR STRING
8901 f963 3f                         SWI                     ; SEND OUT
8902 f964 02                         FCB     PDATA1          ; TO CONSOLE
8903 f965 20 90                      BRA     CMD             ; AND TRY AGAIN
8904                         * SEARCH NEXT ENTRY
8905 f967 5a                 CMDSME  DECB                    ; TAKE ACCOUNT OF LENGTH BYTE
8906 f968 e1 5f                      CMPB    -1,U            ; ? ENTERED LONGER THAN ENTRY
8907 f96a 24 03                      BHS     CMDSIZ          ; BRANCH IF NOT TOO LONG
8908 f96c 3a                 CMDFLS  ABX                     ; SKIP TO NEXT ENTRY
8909 f96d 20 e4                      BRA     CMDSCH          ; AND TRY NEXT
8910 f96f 31 5d              CMDSIZ  LEAY    -3,U            ; PREPARE TO COMPARE
8911 f971 a6 5f                      LDA     -1,U            ; LOAD SIZE+2
8912 f973 80 02                      SUBA    #2              ; TO ACTUAL SIZE ENTERED
8913 f975 a7 5e                      STA     -2,U            ; SAVE SIZE FOR COUNTDOWN
8914 f977 5a                 CMDCMP  DECB                    ; DOWN ONE BYTE
8915 f978 a6 80                      LDA     ,X+             ; NEXT COMMAND CHARACTER
8916 f97a a1 a2                      CMPA    ,-Y             ; ? SAME AS THAT ENTERED
8917 f97c 26 ee                      BNE     CMDFLS          ; BRANCH TO FLUSH IF NOT
8918 f97e 6a 5e                      DEC     -2,U            ; COUNT DOWN LENGTH OF ENTRY
8919 f980 26 f5                      BNE     CMDCMP          ; BRANCH IF MORE TO TEST
8920 f982 3a                         ABX                     ; TO NEXT ENTRY
8921 f983 ec 1e                      LDD     -2,X            ; LOAD OFFSET
8922 f985 30 8b                      LEAX    D,X             ; COMPUTE ROUTINE ADDRESS+2
8923 f987 6d 5d              CMDXQT  TST     -3,U            ; SET CC FOR CARRIAGE RETURN TEST
8924 f989 32 c4                      LEAS    ,U              ; DELETE STACK WORK AREA
8925 f98b ad 1e                      JSR     -2,X            ; CALL COMMAND
8926 f98d 16 ff 7a                   LBRA    CMDNOL          ; GO GET NEXT COMMAND
8927 f990 6d 5e              CMDMEM  TST     -2,U            ; ? VALID HEX NUMBER ENTERED
8928 f992 2b c8                      BMI     CMDBAD          ; BRANCH ERROR IF NOT
8929 f994 30 88 ae                   LEAX    <CMEMN-CMPADP,X ; TO DIFFERENT ENTRY
8930 f997 dc 9b                      LDD     <NUMBER         ; LOAD NUMBER ENTERED
8931 f999 20 ec                      BRA     CMDXQT          ; AND ENTER MEMORY COMMAND
8932                         
8933                         ** COMMANDS ARE ENTERED AS A SUBROUTINE WITH:
8934                         **    DPR->ASSIST09 DIRECT PAGE WORK AREA
8935                         **    Z=1 CARRIAGE RETURN ENTERED
8936                         **    Z=0 NON CARRIAGE RETURN DELIMITER
8937                         **    S=NORMAL RETURN ADDRESS
8938                         ** THE LABEL "CMDBAD" MAY BE ENTERED TO ISSUE AN
8939                         ** AN ERROR FLAG (*).
8940                         **************************************************
8941                         *       ASSIST09 COMMAND TABLES
8942                         * THESE ARE THE DEFAULT COMMAND TABLES. EXTERNAL
8943                         * TABLES OF THE SAME FORMAT MAY EXTEND/REPLACE
8944                         * THESE BY USING THE VECTOR SWAP FUNCTION.
8945                         *
8946                         * ENTRY FORMAT:
8947                         *    +0...TOTAL SIZE OF ENTRY (INCLUDING THIS BYTE)
8948                         *    +1...COMMAND STRING
8949                         *    +N...TWO BYTE OFFSET TO COMMAND (ENTRYADDR-*)
8950                         *
8951                         * THE TABLES TERMINATE WITH A ONE BYTE -1 OR -2.
8952                         * THE -1 CONTINUES THE COMMAND SEARCH WITH THE
8953                         *        SECOND COMMAND TABLE.
8954                         * THE -2 TERMINATES COMMAND SEARCHES.
8955                         *****************************************************
8956                         
8957                         * THIS IS THE DEFAULT LIST FOR THE SECOND COMMAND
8958                         * LIST ENTRY.
8959                         
8960 f99b 04                 CMDTB2  FCB     4               ; TABLE ENTRY LENGTH
8961 f99c 55                         FCC     'U'             ; 'UNASSEMBLE' COMMAND
8962 f99d ea 63                      FDB     CUNAS-*         ; POINTER TO COMMAND (RELATIVE TO HERE)
8963 f99f 04                         FCB     4               ; TABLE ENTRY LENGTH
8964 f9a0 54                         FCC     'T'             ; 'TRACE' COMMAND
8965 f9a1 f6 5f                      FDB     TRACE-*         ; POINTER TO COMMAND (RELATIVE TO HERE)
8966 f9a3 fe                         FCB     -2              ; -2 INDICATES END OF TABLE
8967                         
8968                         * THIS IS THE DEFAULT LIST FOR THE FIRST COMMAND
8969                         * LIST ENTRY.
8970                         
8971 f9a4                    CMDTBL  EQU     *               ; MONITOR COMMAND TABLE
8972 f9a4 04                         FCB     4
8973 f9a5 42                         FCC     /B/             ; 'BREAKPOINT' COMMAND
8974 f9a6 05 45                      FDB     CBKPT-*
8975 f9a8 04                         FCB     4
8976 f9a9 43                         FCC     /C/             ; 'CALL' COMMAND
8977 f9aa 04 0f                      FDB     CCALL-*
8978 f9ac 04                         FCB     4
8979 f9ad 44                         FCC     /D/             ; 'DISPLAY' COMMAND
8980 f9ae 04 95                      FDB     CDISP-*
8981 f9b0 04                         FCB     4
8982 f9b1 45                         FCC     /E/             ; 'ENCODE' COMMAND
8983 f9b2 05 97                      FDB     CENCDE-*
8984 f9b4 04                         FCB     4
8985 f9b5 47                         FCC     /G/             ; 'GO' COMMAND
8986 f9b6 03 ca                      FDB     CGO-*
8987 f9b8 04                         FCB     4
8988 f9b9 4c                         FCC     /L/             ; 'LOAD' COMMAND
8989 f9ba 04 d5                      FDB     CLOAD-*
8990 f9bc 04                         FCB     4
8991 f9bd 4d                         FCC     /M/             ; 'MEMORY' COMMAND
8992 f9be 04 05                      FDB     CMEM-*
8993 f9c0 04                         FCB     4
8994 f9c1 4e                         FCC     /N/             ; 'NULLS' COMMAND
8995 f9c2 04 f5                      FDB     CNULLS-*
8996 f9c4 04                         FCB     4
8997 f9c5 4f                         FCC     /O/             ; 'OFFSET' COMMAND
8998 f9c6 05 02                      FDB     COFFS-*
8999 f9c8 04                         FCB     4
9000 f9c9 50                         FCC     /P/             ; 'PUNCH' COMMAND
9001 f9ca 04 a7                      FDB     CPUNCH-*
9002 f9cc 04                         FCB     4
9003 f9cd 52                         FCC     /R/             ; 'REGISTERS' COMMAND
9004 f9ce 02 7c                      FDB     CREG-*
9005                         ;       FCB     4
9006                         ;       FCC     /S/             ; 'STLEVEL' COMMAND - NOT SUPPORTED IN THIS VERSION
9007                         ;       FDB     CSTLEV-*
9008                         ;       FCB     4
9009                         ;       FCC     /T/             ; 'TRACE' COMMAND - NOT SUPPORTED IN THIS VERSION
9010                         ;       FDB     CTRACE-*
9011 f9d0 04                         FCB     4
9012 f9d1 56                         FCC     /V/             ; 'VERIFY' COMMAND
9013 f9d2 04 cf                      FDB     CVER-*
9014 f9d4 04                         FCB     4
9015 f9d5 57                         FCC     /W/             ; 'WINDOW' COMMAND
9016 f9d6 04 68                      FDB     CWINDO-*
9017 f9d8 ff                         FCB     -1              ; END, CONTINUE WITH THE SECOND
9018                         
9019                         *************************************************
9020                         *             [SWI FUNCTIONS 4 AND 5]
9021                         *      4 - OUT2HS - DECODE BYTE TO HEX AND ADD SPACE
9022                         *      5 - OUT4HS - DECODE WORD TO HEX AND ADD SPACE
9023                         * INPUT: X->BYTE OR WORD TO DECODE
9024                         * OUTPUT: CHARACTERS SENT TO OUTPUT HANDLER
9025                         *         X->NEXT BYTE OR WORD
9026                         *************************************************
9027 f9d9 a6 80              ZOUT2H  LDA     ,X+             ; LOAD NEXT BYTE
9028 f9db 34 06                      PSHS    D               ; SAVE - DO NOT REREAD
9029 f9dd c6 10                      LDB     #16             ; SHIFT BY 4 BITS
9030 f9df 3d                         MUL                     ; WITH MULTIPLY
9031 f9e0 8d 04                      BSR     ZOUTHX          ; SEND OUT AS HEX
9032 f9e2 35 06                      PULS    D               ; RESTORE BYTES
9033 f9e4 84 0f                      ANDA    #$0F            ; ISOLATE RIGHT HEX
9034 f9e6 8b 90              ZOUTHX  ADDA    #$90            ; PREPARE A-F ADJUST
9035 f9e8 19                         DAA                     ; ADJUST
9036 f9e9 89 40                      ADCA    #$40            ; PREPARE CHARACTER BITS
9037 f9eb 19                         DAA                     ; ADJUST
9038 f9ec 6e 9d 76 ee        SEND    JMP     [VECTAB+.CODTA,PCR] ; SEND TO OUT HANDLER
9039                         
9040 f9f0 8d e7              ZOT4HS  BSR     ZOUT2H          ; CONVERT FIRST BYTE
9041 f9f2 8d e5              ZOT2HS  BSR     ZOUT2H          ; CONVERT BYTE TO HEX
9042 f9f4 af 64                      STX     4,S             ; UPDATE USERS X REGISTER
9043                         * FALL INTO SPACE ROUTINE
9044                         
9045                         *************************************************
9046                         *            [SWI FUNCTION 7]
9047                         *         SPACE - SEND BLANK TO OUTPUT HANDLER
9048                         * INPUT: NONE
9049                         * OUTPUT: BLANK SEND TO CONSOLE HANDLER
9050                         *************************************************
9051 f9f6 86 20              ZSPACE  LDA     #'              ; LOAD BLANK
9052 f9f8 20 3d                      BRA     ZOTCH2          ; SEND AND RETURN
9053                         
9054                         ***********************************************
9055                         *             [SWI FUNCTION 9]
9056                         *          SWAP VECTOR TABLE ENTRY
9057                         * INPUT: A=VECTOR TABLE CODE (OFFSET)
9058                         * X=0 OR REPLACEMENT VALUE
9059                         * OUTPUT: X=PREVIOUS VALUE
9060                         ***********************************************
9061 f9fa a6 61              ZVSWTH  LDA     1,S             ; LOAD REQUESTERS A
9062 f9fc 81 34                      CMPA    #HIVTR          ; ? SUB-CODE TOO HIGH
9063 f9fe 22 39                      BHI     ZOTCH3          ; IGNORE CALL IF SO
9064 fa00 10 9e c2                   LDY     <VECTAB+.AVTBL  ; LOAD VECTOR TABLE ADDRESS
9065 fa03 ee a6                      LDU     A,Y             ; U=OLD ENTRY
9066 fa05 ef 64                      STU     4,S             ; RETURN OLD VALUE TO CALLERS X
9067 fa07 af 7e                      STX     -2,S            ; ? X=0
9068 fa09 27 2e                      BEQ     ZOTCH3          ; YES, DO NOT CHANGE ENTRY
9069 fa0b af a6                      STX     A,Y             ; REPLACE ENTRY
9070 fa0d 20 2a                      BRA     ZOTCH3          ; RETURN FROM SWI
9071                         *D
9072                         
9073                         ************************************************
9074                         *               [SWI FUNCTION 0]
9075                         *  INCHNP - OBTAIN INPUT CHAR IN A (NO PARITY)
9076                         * NULLS AND RUBOUTS ARE IGNORED.
9077                         * AUTOMATIC LINE FEED IS SENT UPON RECEIVING A
9078                         * CARRIAGE RETURN.
9079                         * UNLESS WE ARE LOADING FROM TAPE.
9080                         ************************************************
9081 fa0f 8d 5d              ZINCHP  BSR     XQPAUS          ; RELEASE PROCESSOR
9082 fa11 8d 5f              ZINCH   BSR     XQCIDT          ; CALL INPUT DATA APPENDAGE
9083 fa13 24 fa                      BCC     ZINCHP          ; LOOP IF NONE AVAILABLE
9084 fa15 4d                         TSTA                    ; ? TEST FOR NULL
9085 fa16 27 f9                      BEQ     ZINCH           ; IGNORE NULL
9086 fa18 81 7f                      CMPA    #$7F            ; ? RUBOUT
9087 fa1a 27 f5                      BEQ     ZINCH           ; BRANCH YES TO IGNORE
9088 fa1c a7 61                      STA     1,S             ; STORE INTO CALLERS A
9089 fa1e 0d 8f                      TST     <MISFLG         ; ? LOAD IN PROGRESS
9090 fa20 26 17                      BNE     ZOTCH3          ; BRANCH IF SO TO NOT ECHO
9091 fa22 81 0d                      CMPA    #CR             ; ? CARRIAGE RETURN
9092 fa24 26 04                      BNE     ZIN2            ; NO, TEST ECHO BYTE
9093 fa26 86 0a                      LDA     #LF             ; LOAD LINE FEED
9094 fa28 8d c2                      BSR     SEND            ; ALWAYS ECHO LINE FEED
9095 fa2a 0d f4              ZIN2    TST     <VECTAB+.ECHO   ; ? ECHO DESIRED
9096 fa2c 26 0b                      BNE     ZOTCH3          ; NO, RETURN
9097                         * FALL THROUGH TO OUTCH
9098                         ************************************************
9099                         *            [SWI FUNCTION 1]
9100                         *        OUTCH - OUTPUT CHARACTER FROM A
9101                         * INPUT: NONE
9102                         * OUTPUT: IF LINEFEED IS THE OUTPUT CHARACTER THEN
9103                         * C=0 NO CTL-X RECEIVED, C=1 CTL-X RECEIVED
9104                         ************************************************
9105 fa2e a6 61              ZOTCH1  LDA     1,S             ; LOAD CHARACTER TO SEND
9106 fa30 30 8c 09                   LEAX    <ZPCRLS,PCR     ; DEFAULT FOR LINE FEED
9107 fa33 81 0a                      CMPA    #LF             ; ? LINE FEED
9108 fa35 27 0f                      BEQ     ZPDTLP          ; BRANCH TO CHECK PAUSE IF SO
9109 fa37 8d b3              ZOTCH2  BSR     SEND            ; SEND TO OUTPUT ROUTINE
9110 fa39 0c 90              ZOTCH3  INC     <SWICNT         ; BUMP UP "SWI" TRACE NEST LEVEL
9111 fa3b 3b                         RTI                     ; RETURN FROM "SWI" FUNCTION
9112                         
9113                         **************************************************
9114                         * [SWI FUNCTION 6]
9115                         * PCRLF - SEND CR/LF TO CONSOLE HANDLER
9116                         * INPUT: NONE
9117                         * OUTPUT: CR AND LF SENT TO HANDLER
9118                         * C=0 NO CTL-X, C=1 CTL-X RECEIVED
9119                         **************************************************
9120 fa3c 04                 ZPCRLS  FCB     EOT             ; NULL STRING
9121 fa3d 30 8c fc           ZPCRLF LEAX     ZPCRLS,PCR      ; READY CR,LF STRING
9122                         * FALL INTO CR/LF CODE
9123                         
9124                         **************************************************
9125                         * [SWI FUNCTION 3]
9126                         * PDATA - OUTPUT CR/LF AND STRING
9127                         * INPUT: X->STRING
9128                         * OUTPUT: CR/LF AND STRING SENT TO OUTPUT CONSOLE
9129                         * HANDLER.
9130                         * C=0 NO CTL-X, C=1 CTL-X RECEIVED
9131                         * NOTE: LINE FEED MUST FOLLOW CARRIAGE RETURN FOR
9132                         * PROPER PUNCH DATA.
9133                         **************************************************
9134                         
9135 fa40 86 0d              ZPDATA  LDA     #CR             ; LOAD CARRIAGE RETURN
9136 fa42 8d a8                      BSR     SEND            ; SEND IT
9137 fa44 86 0a                      LDA     #LF             ; LOAD LINE FEED
9138                         * FALL INTO PDATA1
9139                         
9140                         *************************************************
9141                         * [SWI FUNCTION 2]
9142                         * PDATA1 - OUTPUT STRING TILL EOT ($04)
9143                         * THIS ROUTINE PAUSES IF AN INPUT BYTE BECOMES
9144                         * AVAILABLE DURING OUTPUT TRANSMISSION UNTIL A
9145                         * SECOND IS RECEIVED.
9146                         * INPUT: X->STRING
9147                         * OUTPUT: STRING SENT TO OUTPUT CONSOLE DRIVER
9148                         * C=0 NO CTL-X, C=1 CTL-X RECEIVED
9149                         *************************************************
9150                         
9151 fa46 8d a4              ZPDTLP  BSR     SEND            ; SEND CHARACTER TO DRIVER
9152 fa48 a6 80              ZPDTA1  LDA     ,X+             ; LOAD NEXT CHARACTER
9153 fa4a 81 04                      CMPA    #EOT            ; ? EOT
9154 fa4c 26 f8                      BNE     ZPDTLP          ; LOOP IF NOT
9155                         * FALL INTO PAUSE CHECK FUNCTION
9156                         
9157                         ********************************************
9158                         * [SWI FUNCTION 12]
9159                         * PAUSE - RETURN TO TASK DISPATCHING AND CHECK
9160                         * FOR FREEZE CONDITION OR CTL-X BREAK
9161                         * THIS FUNCTION ENTERS THE TASK PAUSE HANDLER SO
9162                         * OPTIONALLY OTHER 6809 PROCESSES MAY GAIN CONTROL.
9163                         * UPON RETURN, CHECK FOR A 'FREEZE' CONDITION
9164                         * WITH A RESULTING WAIT LOOP, OR CONDITION CODE
9165                         * RETURN IF A CONTROL-X IS ENTERED FROM THE INPUT
9166                         * HANDLER.
9167                         * OUTPUT: C=1 IF CTL-X HAS ENTERED, C=0 OTHERWISE
9168                         ******************************************
9169                         
9170 fa4e 8d 1e              ZPAUSE  BSR     XQPAUS          ; RELEASE CONTROL AT EVERY LINE
9171 fa50 8d 06                      BSR     CHKABT          ; CHECK FOR FREEZE OR ABORT
9172 fa52 1f a9                      TFR     CC,B            ; PREPARE TO REPLACE CC
9173 fa54 e7 e4                      STB     ,S              ; OVERLAY OLD ONE ON STACK
9174 fa56 20 e1                      BRA     ZOTCH3          ; RETURN FROM "SWI"
9175                         
9176                         * CHKABT - SCAN FOR INPUT PAUSE/ABORT DURING OUTPUT
9177                         * OUTPUT: C=0 OK, C=1 ABORT (CTL-X ISSUED)
9178                         * VOLATILE: U,X,D
9179 fa58 8d 18              CHKABT  BSR     XQCIDT          ; ATTEMPT INPUT
9180 fa5a 24 05                      BCC     CHKRTN          ; BRANCH NO TO RETURN
9181 fa5c 81 18                      CMPA    #CAN            ; ? CTL-X FOR ABORT
9182 fa5e 26 02                      BNE     CHKWT           ; BRANCH NO TO PAUSE
9183 fa60 53                 CHKSEC  COMB                    ; SET CARRY
9184 fa61 39                 CHKRTN  RTS                     ; RETURN TO CALLER WITH CC SET
9185 fa62 8d 0a              CHKWT   BSR     XQPAUS          ; PAUSE FOR A MOMENT
9186 fa64 8d 0c                      BSR     XQCIDT          ; ? KEY FOR START
9187 fa66 24 fa                      BCC     CHKWT           ; LOOP UNTIL RECEIVED
9188 fa68 81 18                      CMPA    #CAN            ; ? ABORT SIGNALED FROM WAIT
9189 fa6a 27 f4                      BEQ     CHKSEC          ; BRANCH YES
9190 fa6c 4f                         CLRA                    ; SET C=0 FOR NO ABORT
9191 fa6d 39                         RTS                     ; AND RETURN
9192                         
9193                         * SAVE MEMORY WITH JUMPS
9194 fa6e 6e 9d 76 78        XQPAUS  JMP   [VECTAB+.PAUSE,PCR] ; TO PAUSE ROUTINE
9195 fa72 ad 9d 76 62        XQCIDT  JSR   [VECTAB+.CIDTA,PCR] ; TO INPUT ROUTINE
9196 fa76 84 7f                      ANDA  #$7F              ; STRIP PARITY
9197 fa78 39                         RTS                     ; RETURN TO CALLER
9198                         
9199                         ********************************************
9200                         * NMI DEFAULT INTERRUPT HANDLER
9201                         * THE NMI HANDLER IS USED FOR TRACING INSTRUCTIONS.
9202                         * TRACE PRINTOUTS OCCUR ONLY AS LONG AS THE STACK
9203                         * TRACE LEVEL IS NOT BREACHED BY FALLING BELOW IT.
9204                         * TRACING CONTINUES UNTIL THE COUNT TURNS ZERO OR
9205                         * A CTL-X IS ENTERED FROM THE INPUT CONSOLE DEVICE.
9206                         *********************************************
9207                         
9208 fa79 4f 50 2d 04        MSHOWP  FCB     'O,'P,'-,EOT    ; OPCODE PREP
9209                         
9210 fa7d 8d 42              NMIR    BSR     LDDP            ; LOAD PAGE AND VERIFY STACK
9211 fa7f 0d 8f                      TST     <MISFLG         ; ? THRU A BREAKPOINT
9212 fa81 26 34                      BNE     NMICON          ; BRANCH IF SO TO CONTINUE
9213 fa83 0d 90                      TST     <SWICNT         ; ? INHIBIT "SWI" DURING TRACE
9214 fa85 2b 29                      BMI     NMITRC          ; BRANCH YES
9215 fa87 30 6c                      LEAX    12,S            ; OBTAIN USERS STACK POINTER
9216 fa89 9c f8                      CMPX    <SLEVEL         ; ? TO TRACE HERE
9217 fa8b 25 23                      BLO     NMITRC          ; BRANCH IF TOO LOW TO DISPLAY
9218 fa8d 30 8c e9                   LEAX    MSHOWP,PCR      ; LOAD OP PREP
9219 fa90 3f                         SWI                     ; SEND TO CONSOLE
9220 fa91 02                         FCB     PDATA1          ; FUNCTION
9221 fa92 09 8e                      ROL     <DELIM          ; SAVE CARRY BIT
9222 fa94 30 8d 76 01                LEAX    LASTOP,PCR      ; POINT TO LAST OP
9223 fa98 3f                         SWI                     ; SEND OUT AS HEX
9224 fa99 05                         FCB     OUT4HS          ; FUNCTION
9225 fa9a 8d 17                      BSR     REGPRS          ; FOLLOW MEMORY WITH REGISTERS
9226 fa9c 25 37                      BCS     ZBKCMD          ; BRANCH IF "CANCEL"
9227 fa9e 06 8e                      ROR     <DELIM          ; RESTORE CARRY BIT
9228 faa0 25 33                      BCS     ZBKCMD          ; BRANCH IF "CANCEL"
9229 faa2 9e 91                      LDX     <TRACEC         ; LOAD TRACE COUNT
9230 faa4 27 2f                      BEQ     ZBKCMD          ; IF ZERO TO COMMAND HANDLER
9231 faa6 30 1f                      LEAX    -1,X            ; MINUS ONE
9232 faa8 9f 91                      STX     <TRACEC         ; REFRESH
9233 faaa 27 29                      BEQ     ZBKCMD          ; STOP TRACE WHEN ZERO
9234 faac 8d aa                      BSR     CHKABT          ; ? ABORT THE TRACE
9235 faae 25 25                      BCS     ZBKCMD          ; BRANCH YES TO COMMAND HANDLER
9236 fab0 16 03 f7           NMITRC  LBRA    CTRCE3          ; NO, TRACE ANOTHER INSTRUCTION
9237                         
9238 fab3 17 01 b9           REGPRS  LBSR    REGPRT          ; PRINT REGISTERS AS FROM COMMAND
9239 fab6 39                         RTS                     ; RETURN TO CALLER
9240                         
9241                         * JUST EXECUTED THRU A BRKPNT. NOW CONTINUE NORMALLY
9242                         
9243 fab7 0f 8f              NMICON  CLR     <MISFLG        ; CLEAR THRU FLAG
9244 fab9 17 02 eb                   LBSR    ARMBK2         ; ARM BREAKPOINTS
9245 fabc 3b                 RTI     RTI                    ; AND CONTINUE USERS PROGRAM
9246                         
9247                         * LDDP - SETUP DIRECT PAGE REGISTER, VERIFY STACK.
9248                         * AN INVALID STACK CAUSES A RETURN TO THE COMMAND
9249                         * HANDLER.
9250                         * INPUT: FULLY STACKED REGISTERS FROM AN INTERRUPT
9251                         * OUTPUT: DPR LOADED TO WORK PAGE
9252                         
9253 fabd 3f 07 20 04        ERRMSG  FCB     '?,BELL,$20,EOT ; ERROR RESPONSE
9254                         
9255 fac1 e6 8d 75 d8        LDDP    LDB     BASEPG,PCR      ; LOAD DIRECT PAGE HIGH BYTE
9256 fac5 1f 9b                      TFR     B,DP            ; SETUP DIRECT PAGE REGISTER
9257 fac7 a1 63                      CMPA    3,S             ; ? IS STACK VALID
9258 fac9 27 25                      BEQ     RTS             ; YES, RETURN
9259 facb 10 de 97                   LDS     <RSTACK         ; RESET TO INITIAL STACK POINTER
9260 face 30 8c ec           ERROR   LEAX    ERRMSG,PCR      ; LOAD ERROR REPORT
9261 fad1 3f                         SWI                     ; SEND OUT BEFORE REGISTERS
9262 fad2 03                         FCB     PDATA           ; ON NEXT LINE
9263                         * FALL INTO BREAKPOINT HANDLER
9264                         
9265                         **********************************************
9266                         * [SWI FUNCTION 10]
9267                         * BREAKPOINT PROGRAM FUNCTION
9268                         * PRINT REGISTERS AND GO TO COMMAND HANLER
9269                         ***********************************************
9270                         
9271 fad3 8d de              ZBKPNT  BSR     REGPRS          ; PRINT OUT REGISTERS
9272 fad5 16 fe 21           ZBKCMD  LBRA    CMDNEP          ; NOW ENTER COMMAND HANDLER
9273                         
9274                         ********************************************
9275                         * IRQ, RESERVED, SWI2 AND SWI3 INTERRUPT HANDLERS
9276                         * THE DEFAULT HANDLING IS TO CAUSE A BREAKPOINT.
9277                         ********************************************
9278 fad8                    SWI2R   EQU     *               ; SWI2 ENTRY
9279 fad8                    SWI3R   EQU     *               ; SWI3 ENTRY
9280 fad8                    IRQR    EQU     *               ; IRQ ENTRY
9281 fad8 8d e7              RSRVDR  BSR     LDDP            ; SET BASE PAGE, VALIDATE STACK
9282 fada 20 f7                      BRA     ZBKPNT          ; FORCE A BREAKPOINT
9283                         
9284                         ******************************************
9285                         * FIRQ HANDLER
9286                         * JUST RETURN FOR THE FIRQ INTERRUPT
9287                         ******************************************
9288 fabc                    FIRQR   EQU     RTI             ; IMMEDIATE RETURN
9289                         
9290                         **************************************************
9291                         * DEFAULT I/O DRIVERS
9292                         **************************************************
9293                         * CIDTA - RETURN CONSOLE INPUT CHARACTER
9294                         * OUTPUT: C=0 IF NO DATA READY, C=1 A=CHARACTER
9295                         * U VOLATILE
9296                         
9297 fadc de f0              CIDTA   LDU     <VECTAB+.ACIA   ; LOAD ACIA ADDRESS
9298 fade a6 c4                      LDA     ,U              ; LOAD STATUS REGISTER
9299 fae0 44                         LSRA                    ; TEST RECEIVER REGISTER FLAG
9300 fae1 24 02                      BCC     CIRTN           ; RETURN IF NOTHING
9301 fae3 a6 41                      LDA     1,U             ; LOAD DATA BYTE
9302 fae5 39                 CIRTN   RTS                     ; RETURN TO CALLER
9303                         
9304                         * CION - INPUT CONSOLE INITIALIZATION
9305                         * COON - OUTPUT CONSOLE INITIALIZATION
9306                         * A,X VOLATILE
9307 fae6                    CION   EQU      *
9308 fae6 86 13              COON   LDA      #$13            ; RESET ACIA CODE
9309 fae8 9e f0                     LDX      <VECTAB+.ACIA   ; LOAD ACIA ADDRESS
9310 faea a7 84                     STA      ,X              ; STORE INTO STATUS REGISTER
9311 faec 86 15                     LDA      #$15            ; SET CONTROL
9312 faee a7 84                     STA      ,X              ; REGISTER UP
9313 faf0 39                 RTS    RTS                      ; RETURN TO CALLER
9314                         
9315                         * THE FOLLOWING HAVE NO DUTIES TO PERFORM
9316 faf0                    CIOFF EQU       RTS             ; CONSOLE INPUT OFF
9317 faf0                    COOFF EQU       RTS             ; CONSOLE OUTPUT OFF
9318                         
9319                         * CODTA - OUTPUT CHARACTER TO CONSOLE DEVICE
9320                         * INPUT: A=CHARACTER TO SEND
9321                         * OUTPUT: CHAR SENT TO TERMINAL WITH PROPER PADDING
9322                         * ALL REGISTERS TRANSPARENT
9323                         
9324 faf1 34 47              CODTA   PSHS    U,D,CC          ; SAVE REGISTERS,WORK BYTE
9325 faf3 de f0                      LDU     <VECTAB+.ACIA   ; ADDRESS ACIA
9326 faf5 8d 1b                      BSR     CODTAO          ; CALL OUTPUT CHAR SUBROUTINE
9327 faf7 81 10                      CMPA    #DLE            ; ? DATA LINE ESCAPE
9328 faf9 27 12                      BEQ     CODTRT          ; YES, RETURN
9329 fafb d6 f2                      LDB     <VECTAB+.PAD    ; DEFAULT TO CHAR PAD COUNT
9330 fafd 81 0d                      CMPA    #CR             ; ? CR
9331 faff 26 02                      BNE     CODTPD          ; BRANCH NO
9332 fb01 d6 f3                      LDB     <VECTAB+.PAD+1  ; LOAD NEW LINE PAD COUNT
9333 fb03 4f                 CODTPD  CLRA                    ; CREATE NULL
9334 fb04 e7 e4                      STB     ,S              ; SAVE COUNT
9335 fb06 8c                         FCB     SKIP2           ; ENTER LOOP
9336 fb07 8d 09              CODTLP  BSR     CODTAO          ; SEND NULL
9337 fb09 6a e4                      DEC     ,S              ; ? FINISHED
9338 fb0b 2a fa                      BPL     CODTLP          ; NO, CONTINUE WITH MORE
9339 fb0d 35 c7              CODTRT  PULS    PC,U,D,CC       ; RESTORE REGISTERS AND RETURN
9340                         
9341 fb0f 17 ff 5c           CODTAD  LBSR    XQPAUS          ; TEMPORARY GIVE UP CONTROL
9342 fb12 e6 c4              CODTAO  LDB     ,U              ; LOAD ACIA CONTROL REGISTER
9343 fb14 c5 02                      BITB    #$02            ; ? TX REGISTER CLEAR >LSAB FIXME
9344 fb16 27 f7                      BEQ     CODTAD          ; RELEASE CONTROL IF NOT
9345 fb18 a7 41                      STA     1,U             ; STORE INTO DATA REGISTER
9346 fb1a 39                         RTS                     ; RETURN TO CALLER
9347                         *E
9348                         
9349                         * BSON - TURN ON READ/VERIFY/PUNCH MECHANISM
9350                         * A IS VOLATILE
9351                         
9352 fb1b 86 11              BSON    LDA     #$11            ; SET READ CODE
9353 fb1d 6d 66                      TST     6,S             ; ? READ OR VERIFY
9354 fb1f 26 01                      BNE     BSON2           ; BRANCH YES
9355 fb21 4c                         INCA                    ; SET TO WRITE
9356 fb22 3f                 BSON2   SWI                     ; PERFORM OUTPUT
9357 fb23 01                         FCB     OUTCH           ; FUNCTION
9358 fb24 0c 8f                      INC     <MISFLG         ; SET LOAD IN PROGRESS FLAG
9359 fb26 39                         RTS                     ; RETURN TO CALLER
9360                         
9361                         * BSOFF - TURN OFF READ/VERIFY/PUNCH MECHANISM
9362                         * A,X VOLATILE
9363                         
9364 fb27 86 14              BSOFF   LDA     #$14            ; TO DC4 - STOP
9365 fb29 3f                         SWI                     ; SEND OUT
9366 fb2a 01                         FCB     OUTCH           ; FUNCTION
9367 fb2b 4a                         DECA                    ; CHANGE TO DC3 (X-OFF)
9368 fb2c 3f                         SWI                     ; SEND OUT
9369 fb2d 01                         FCB     OUTCH           ; FUNCTION
9370 fb2e 0a 8f                      DEC     <MISFLG         ; CLEAR LOAD IN PROGRESS FLAG
9371 fb30 8e 61 a8                   LDX     #25000          ; DELAY 1 SECOND (2MHZ CLOCK)
9372 fb33 30 1f              BSOFLP  LEAX    -1,X            ; COUNT DOWN
9373 fb35 26 fc                      BNE     BSOFLP          ; LOOP TILL DONE
9374 fb37 39                         RTS                     ; RETURN TO CALLER
9375                         
9376                         * BSDTA - READ/VERIFY/PUNCH HANDLER
9377                         * INPUT: S+6=CODE BYTE, VERIFY(-1),PUNCH(0),LOAD(1)
9378                         * S+4=START ADDRESS
9379                         * S+2=STOP ADDRESS
9380                         * S+0=RETURN ADDRESS
9381                         * OUTPUT: Z=1 NORMAL COMPLETION, Z=0 INVALID LOAD/VER
9382                         * REGISTERS ARE VOLATILE
9383 fb38 ee 62              BSDTA   LDU     2,S             ; U=TO ADDRESS OR OFFSET
9384 fb3a 6d 66                      TST     6,S             ; ? PUNCH
9385 fb3c 27 54                      BEQ     BSDPUN          ; BRANCH YES
9386                         
9387                         * DURING READ/VERIFY: S+2=MSB ADDRESS SAVE BYTE
9388                         * S+1=BYTE COUNTER
9389                         * S+0=CHECKSUM
9390                         * U HOLDS OFFSET
9391 fb3e 32 7d                      LEAS    -3,S            ; ROOM FOR WORK/COUNTER/CHECKSUM
9392 fb40 3f                 BSDLD1  SWI                     ; GET NEXT CHARACTER
9393 fb41 00                         FCB     INCHNP          ; FUNCTION
9394 fb42 81 53              BSDLD2  CMPA    #'S             ; ? START OF S1/S9
9395 fb44 26 fa                      BNE     BSDLD1          ; BRANCH NOT
9396 fb46 3f                         SWI                     ; GET NEXT CHARACTER
9397 fb47 00                         FCB     INCHNP          ; FUNCTION
9398 fb48 81 39                      CMPA    #'9             ; ? HAVE S9
9399 fb4a 27 22                      BEQ     BSDSRT          ; YES, RETURN GOOD CODE
9400 fb4c 81 31                      CMPA    #'1             ; ? HAVE NEW RECORD
9401 fb4e 26 f2                      BNE     BSDLD2          ; BRANCH IF NOT
9402 fb50 6f e4                      CLR     ,S              ; CLEAR CHECKSUM
9403 fb52 8d 21                      BSR     BYTE            ; OBTAIN BYTE COUNT
9404 fb54 e7 61                      STB     1,S             ; SAVE FOR DECREMENT
9405                         
9406                         * READ ADDRESS
9407 fb56 8d 1d                      BSR     BYTE            ; OBTAIN HIGH VALUE
9408 fb58 e7 62                      STB     2,S             ; SAVE IT
9409 fb5a 8d 19                      BSR     BYTE            ; OBTAIN LOW VALUE
9410 fb5c a6 62                      LDA     2,S             ; MAKE D=VALUE
9411 fb5e 31 cb                      LEAY    D,U             ; Y=ADDRESS+OFFSET
9412                         * STORE TEXT
9413 fb60 8d 13              BSDNXT  BSR     BYTE            ; NEXT BYTE
9414 fb62 27 0c                      BEQ     BSDEOL          ; BRANCH IF CHECKSUM
9415 fb64 6d 69                      TST     9,S             ; ? VERIFY ONLY
9416 fb66 2b 02                      BMI     BSDCMP          ; YES, ONLY COMPARE
9417 fb68 e7 a4                      STB     ,Y              ; STORE INTO MEMORY
9418 fb6a e1 a0              BSDCMP  CMPB    ,Y+             ; ? VALID RAM
9419 fb6c 27 f2                      BEQ     BSDNXT          ; YES, CONTINUE READING
9420 fb6e 35 92              BSDSRT  PULS    PC,X,A          ; RETURN WITH Z SET PROPER
9421 fb70 4c                 BSDEOL  INCA                    ; ? VALID CHECKSUM
9422 fb71 27 cd                      BEQ     BSDLD1          ; BRANCH YES
9423 fb73 20 f9                      BRA     BSDSRT          ; RETURN Z=0 INVALID
9424                         
9425                         * BYTE BUILDS 8 BIT VALUE FROM TWO HEX DIGITS IN
9426 fb75 8d 12              BYTE    BSR     BYTHEX         ; OBTAIN FIRST HEX
9427 fb77 c6 10                      LDB     #16            ; PREPARE SHIFT
9428 fb79 3d                         MUL                    ; OVER TO A
9429 fb7a 8d 0d                      BSR     BYTHEX         ; OBTAIN SECOND HEX
9430 fb7c 34 04                      PSHS    B              ; SAVE HIGH HEX
9431 fb7e ab e0                      ADDA    ,S+            ; COMBINE BOTH SIDES
9432 fb80 1f 89                      TFR     A,B            ; SEND BACK IN B
9433 fb82 ab 62                      ADDA    2,S            ; COMPUTE NEW CHECKSUM
9434 fb84 a7 62                      STA     2,S            ; STORE BACK
9435 fb86 6a 63                      DEC     3,S            ; DECREMENT BYTE COUNT
9436 fb88 39                 BYTRTS  RTS                    ; RETURN TO CALLER
9437                         
9438 fb89 3f                 BYTHEX  SWI                    ; GET NEXT HEX
9439 fb8a 00                         FCB     INCHNP         ; CHARACTER
9440 fb8b 17 01 d4                   LBSR    CNVHEX         ; CONVERT TO HEX
9441 fb8e 27 f8                      BEQ     BYTRTS         ; RETURN IF VALID HEX
9442 fb90 35 f2                      PULS    PC,U,Y,X,A     ; RETURN TO CALLER WITH Z=0
9443                         
9444                         * PUNCH STACK USE: S+8=TO ADDRESS
9445                         *                  S+6=RETURN ADDRESS
9446                         *                  S+4=SAVED PADDING VALUES
9447                         *                  S+2 FROM ADDRESS
9448                         *                  S+1=FRAME COUNT/CHECKSUM
9449                         *                  S+0=BYTE COUNT
9450                         
9451 fb92 de f2              BSDPUN  LDU     <VECTAB+.PAD    ; LOAD PADDING VALUES
9452 fb94 ae 64                      LDX     4,S             ; X=FROM ADDRESS
9453 fb96 34 56                      PSHS    U,X,D           ; CREATE STACK WORK AREA
9454 fb98 cc 00 18                   LDD     #24             ; SET A=0, B=24
9455 fb9b d7 f2                      STB     <VECTAB+.PAD    ; SETUP 24 CHARACTER PADS
9456 fb9d 3f                         SWI                     ; SEND NULLS OUT
9457 fb9e 01                         FCB     OUTCH           ; FUNCTION
9458 fb9f c6 04                      LDB     #4              ; SETUP NEW LINE PAD TO 4
9459 fba1 dd f2                      STD     <VECTAB+.PAD    ; SETUP PUNCH PADDING
9460                         * CALCULATE SIZE
9461 fba3 ec 68              BSPGO   LDD     8,S             ; LOAD TO
9462 fba5 a3 62                      SUBD    2,S             ; MINUS FROM=LENGTH
9463 fba7 10 83 00 18                CMPD    #24             ; ? MORE THAN 23
9464 fbab 25 02                      BLO     BSPOK           ; NO, OK
9465 fbad c6 17                      LDB     #23             ; FORCE TO 23 MAX
9466 fbaf 5c                 BSPOK   INCB                    ; PREPARE COUNTER
9467 fbb0 e7 e4                      STB     ,S              ; STORE BYTE COUNT
9468 fbb2 cb 03                      ADDB    #3              ; ADJUST TO FRAME COUNT
9469 fbb4 e7 61                      STB     1,S             ; SAVE
9470                         
9471                         *PUNCH CR,LF,NULS,S,1
9472 fbb6 30 8c 33                  LEAX     <BSPSTR,PCR     ; LOAD START RECORD HEADER
9473 fbb9 3f                        SWI                      ; SEND OUT
9474 fbba 03                        FCB      PDATA           ; FUNCTION
9475                         * SEND FRAME COUNT
9476 fbbb 5f                        CLRB                     ; INITIALIZE CHECKSUM
9477 fbbc 30 61                     LEAX     1,S             ; POINT TO FRAME COUNT AND ADDR
9478 fbbe 8d 27                     BSR      BSPUN2          ; SEND FRAME COUNT
9479                         *DATA ADDRESS
9480 fbc0 8d 25                    BSR       BSPUN2          ; SEND ADDRESS HI
9481 fbc2 8d 23                    BSR       BSPUN2          ; SEND ADDRESS LOW
9482                         *PUNCH DATA
9483 fbc4 ae 62                     LDX      2,S             ; LOAD START DATA ADDRESS
9484 fbc6 8d 1f              BSPMRE BSR      BSPUN2          ; SEND OUT NEXT BYTE
9485 fbc8 6a e4                     DEC      ,S              ; ? FINAL BYTE
9486 fbca 26 fa                     BNE      BSPMRE          ; LOOP IF NOT DONE
9487 fbcc af 62                     STX      2,S             ; UPDATE FROM ADDRESS VALUE
9488                         *PUNCH CHECKSUM
9489 fbce 53                        COMB                     ; COMPLEMENT
9490 fbcf e7 61                     STB      1,S             ; STORE FOR SENDOUT
9491 fbd1 30 61                     LEAX     1,S             ; POINT TO IT
9492 fbd3 8d 14                     BSR      BSPUNC          ; SEND OUT AS HEX
9493 fbd5 ae 68                     LDX      8,S             ; LOAD TOP ADDRESS
9494 fbd7 ac 62                     CMPX     2,S             ; ? DONE
9495 fbd9 24 c8                     BHS      BSPGO           ; BRANCH NOT
9496 fbdb 30 8c 11                  LEAX     <BSPEOF,PCR     ; PREPARE END OF FILE
9497 fbde 3f                        SWI                      ; SEND OUT STRING
9498 fbdf 03                        FCB      PDATA           ; FUNCTION
9499 fbe0 ec 64                     LDD      4,S             ; RECOVER PAD COUNTS
9500 fbe2 dd f2                     STD      <VECTAB+.PAD    ; RESTORE
9501 fbe4 4f                        CLRA                     ; SET Z=1 FOR OK RETURN
9502 fbe5 35 d6                     PULS     PC,U,X,D        ; RETURN WITH OK CODE
9503 fbe7 eb 84              BSPUN2 ADDB     ,X              ; ADD TO CHECKSUM
9504 fbe9 16 fd ed           BSPUNC LBRA     ZOUT2H          ; SEND OUT AS HEX AND RETURN
9505                         
9506 fbec 53 01 04           BSPSTR FCB      'S,1,EOT        ; CR,LF,NULLS,S,1
9507 fbef 53 39 30 33 30 30  BSPEOF FCC      /S9030000FC/         ; EOF STRING
     30 30 46 43
9508 fbf9 0d 0a 04                  FCB      CR,LF,EOT
9509                         
9510                         * HSDTA - HIGH SPEED PRINT MEMORY
9511                         * INPUT: S+4=START ADDRESS
9512                         * S+2=STOP ADDRESS
9513                         * S+0=RETURN ADDRESS
9514                         * X,D VOLATILE
9515                         
9516                         * SEND TITLE
9517                         
9518 fbfc 3f                 HSDTA   SWI                     ; SEND NEW LINE
9519 fbfd 06                         FCB     PCRLF           ; FUNCTION
9520 fbfe c6 06                      LDB     #6              ; PREPARE 6 SPACES
9521 fc00 3f                 HSBLNK  SWI                     ; SEND BLANK
9522 fc01 07                         FCB     SPACEF          ; FUNCTION
9523 fc02 5a                         DECB                    ; COUNT DOWN
9524 fc03 26 fb                      BNE     HSBLNK          ; LOOP IF MORE
9525 fc05 5f                         CLRB                    ; SETUP BYTE COUNT
9526 fc06 1f 98              HSHTTL  TFR     B,A             ; PREPARE FOR CONVERT
9527 fc08 17 fd db                   LBSR    ZOUTHX          ; CONVERT TO A HEX DIGIT
9528 fc0b 3f                         SWI                     ; SEND BLANK
9529 fc0c 07                         FCB     SPACEF          ; FUNCTION
9530 fc0d 3f                         SWI                     ; SEND ANOTHER
9531 fc0e 07                         FCB     SPACEF          ; BLANK
9532 fc0f 5c                         INCB                    ; UP ANOTHER
9533 fc10 c1 10                      CMPB    #$10            ; ? PAST 'F'
9534 fc12 25 f2                      BLO     HSHTTL          ; LOOP UNTIL SO
9535 fc14 3f                 HSHLNE  SWI                     ; TO NEXT LINE
9536 fc15 06                         FCB     PCRLF           ; FUNCTION
9537 fc16 25 2f                      BCS     HSDRTN          ; RETURN IF USER ENTERED CTL-X
9538 fc18 30 64                      LEAX    4,S             ; POINT AT ADDRESS TO CONVERT
9539 fc1a 3f                         SWI                     ; PRINT OUT ADDRESS
9540 fc1b 05                         FCB     OUT4HS          ; FUNCTION
9541 fc1c ae 64                      LDX     4,S             ; LOAD ADDRESS PROPER
9542 fc1e c6 10                      LDB     #16             ; NEXT SIXTEEN
9543 fc20 3f                 HSHNXT  SWI                     ; CONVERT BYTE TO HEX AND SEND
9544 fc21 04                         FCB     OUT2HS          ; FUNCTION
9545 fc22 5a                         DECB                    ; COUNT DOWN
9546 fc23 26 fb                      BNE     HSHNXT          ; LOOP IF NOT SIXTEENTH
9547 fc25 3f                         SWI                     ; SEND BLANK
9548 fc26 07                         FCB     SPACEF          ; FUNCTION
9549 fc27 ae 64                      LDX     4,S             ; RELOAD FROM ADDRESS
9550 fc29 c6 10                      LDB     #16             ; COUNT
9551 fc2b a6 80              HSHCHR  LDA     ,X+             ; NEXT BYTE
9552 fc2d 2b 04                      BMI     HSHDOT          ; TOO LARGE, TO A DOT
9553 fc2f 81 20                      CMPA    #'              ; ? LOWER THAN A BLANK
9554 fc31 24 02                      BHS     HSHCOK          ; NO, BRANCH OK
9555 fc33 86 2e              HSHDOT  LDA     #'.             ; CONVERT INVALID TO A BLANK
9556 fc35 3f                 HSHCOK  SWI                     ; SEND CHARACTER
9557 fc36 01                         FCB     OUTCH           ; FUNCTION
9558 fc37 5a                         DECB                    ; ? DONE
9559 fc38 26 f1                      BNE     HSHCHR          ; BRANCH NO
9560 fc3a ac 62                      CPX     2,S             ; ? PAST LAST ADDRESS
9561 fc3c 24 09                      BHS     HSDRTN          ; QUIT IF SO
9562 fc3e af 64                      STX     4,S             ; UPDATE FROM ADDRESS
9563 fc40 a6 65                      LDA     5,S             ; LOAD LOW BYTE ADDRESS
9564 fc42 48                         ASLA                    ; ? TO SECTION BOUNDARY
9565 fc43 26 cf                      BNE     HSHLNE          ; BRANCH IF NOT
9566 fc45 20 b5                      BRA     HSDTA           ; BRANCH IF SO
9567 fc47 3f                 HSDRTN  SWI                     ; SEND NEW LINE
9568 fc48 06                         FCB     PCRLF           ; FUNCTION
9569 fc49 39                         RTS                     ; RETURN TO CALLER
9570                         *F
9571                         
9572                         ***********************************************
9573                         *     A S S I S T 0 9    C O M M A N D S
9574                         ***********************************************
9575                         
9576                         *************REGISTERS - DISPLAY AND CHANGE REGISTERS
9577 fc4a 8d 23              CREG    BSR     REGPRT          ; PRINT REGISTERS
9578 fc4c 4c                         INCA                    ; SET FOR CHANGE FUNCTION
9579 fc4d 8d 21                      BSR     REGCHG          ; GO CHANGE, DISPLAY REGISTERS
9580 fc4f 39                         RTS                     ; RETURN TO COMMAND PROCESSOR
9581                         
9582                         ********************************************
9583                         * REGPRT - PRINT/CHANGE REGISTERS SUBROUTINE
9584                         * WILL ABORT TO 'CMDBAD' IF OVERFLOW DETECTED DURING
9585                         * A CHANGE OPERATION. CHANGE DISPLAYS REGISTERS WHEN
9586                         * DONE.
9587                         
9588                         * REGISTER MASK LIST CONSISTS OF:
9589                         * A) CHARACTERS DENOTING REGISTER
9590                         * B) ZERO FOR ONE BYTE, -1 FOR TWO
9591                         * C) OFFSET ON STACK TO REGISTER POSITION
9592                         * INPUT: SP+4=STACKED REGISTERS
9593                         * A=0 PRINT, A#0 PRINT AND CHANGE
9594                         * OUTPUT: (ONLY FOR REGISTER DISPLAY)
9595                         * C=1 CONTROL-X ENTERED, C=0 OTHERWISE
9596                         * VOLATILE: D,X (CHANGE)
9597                         * B,X (DISPLAY)
9598                         *******************************************
9599                         
9600 fc50 50 43 ff 13        REGMSK  FCB     'P,'C,-1,19     ; PC REG
9601 fc54 41 00 0a                   FCB     'A,0,10         ; A REG
9602 fc57 42 00 0b                   FCB     'B,0,11         ; B REG
9603 fc5a 58 ff 0d                   FCB     'X,-1,13        ; X REG
9604 fc5d 59 ff 0f                   FCB     'Y,-1,15        ; Y REG
9605 fc60 55 ff 11                   FCB     'U,-1,17        ; U REG
9606 fc63 53 ff 01                   FCB     'S,-1,1         ; S REG
9607 fc66 43 43 00 09                FCB     'C,'C,0,9       ; CC REG
9608 fc6a 44 50 00 0c                FCB     'D,'P,0,12      ; DP REG
9609 fc6e 00                         FCB     0               ; END OF LIST
9610                         
9611 fc6f 4f                 REGPRT  CLRA                    ; SETUP PRINT ONLY FLAG
9612 fc70 30 e8 10           REGCHG  LEAX    4+12,S          ; READY STACK VALUE
9613 fc73 34 32                      PSHS    Y,X,A           ; SAVE ON STACK WITH OPTION
9614 fc75 31 8c d8                   LEAY    REGMSK,PCR      ; LOAD REGISTER MASK
9615 fc78 ec a0              REGP1   LDD     ,Y+             ; LOAD NEXT CHAR OR <=0
9616 fc7a 4d                         TSTA                    ; ? END OF CHARACTERS
9617 fc7b 2f 04                      BLE     REGP2           ; BRANCH NOT CHARACTER
9618 fc7d 3f                         SWI                     ; SEND TO CONSOLE
9619 fc7e 01                         FCB     OUTCH           ; FUNCTION BYTE
9620 fc7f 20 f7                      BRA     REGP1           ; CHECK NEXT
9621 fc81 86 2d              REGP2   LDA     #'-             ; READY '-'
9622 fc83 3f                         SWI                     ; SEND OUT
9623 fc84 01                         FCB     OUTCH           ; WITH OUTCH
9624 fc85 30 e5                      LEAX    B,S             ; X->REGISTER TO PRINT
9625 fc87 6d e4                      TST     ,S              ; ? CHANGE OPTION
9626 fc89 26 12                      BNE     REGCNG          ; BRANCH YES
9627 fc8b 6d 3f                      TST     -1,Y            ; ? ONE OR TWO BYTES
9628 fc8d 27 03                      BEQ     REGP3           ; BRANCH ZERO MEANS ONE
9629 fc8f 3f                         SWI                     ; PERFORM WORD HEX
9630 fc90 05                         FCB     OUT4HS          ; FUNCTION
9631 fc91 8c                         FCB     SKIP2           ; SKIP BYTE PRINT
9632 fc92 3f                 REGP3   SWI                     ; PERFORM BYTE HEX
9633 fc93 04                         FCB     OUT2HS          ; FUNCTION
9634 fc94 ec a0              REG4    LDD     ,Y+             ; TO FRONT OF NEXT ENTRY
9635 fc96 5d                         TSTB                    ; ? END OF ENTRIES
9636 fc97 26 df                      BNE     REGP1           ; LOOP IF MORE
9637 fc99 3f                         SWI                     ; FORCE NEW LINE
9638 fc9a 06                         FCB     PCRLF           ; FUNCTION
9639 fc9b 35 b2              REGRTN  PULS    PC,Y,X,A        ; RESTORE STACK AND RETURN
9640                         
9641 fc9d 8d 40              REGCNG  BSR     BLDNNB          ; INPUT BINARY NUMBER
9642 fc9f 27 10                      BEQ     REGNXC          ; IF CHANGE THEN JUMP
9643 fca1 81 0d                      CMPA    #CR             ; ? NO MORE DESIRED
9644 fca3 27 1e                      BEQ     REGAGN          ; BRANCH NOPE
9645 fca5 e6 3f                      LDB     -1,Y            ; LOAD SIZE FLAG
9646 fca7 5a                         DECB                    ; MINUS ONE
9647 fca8 50                         NEGB                    ; MAKE POSITIVE
9648 fca9 58                         ASLB                    ; TIMES TWO (=2 OR =4)
9649 fcaa 3f                 REGSKP  SWI                     ; PERFORM SPACES
9650 fcab 07                         FCB     SPACEF          ; FUNCTION
9651 fcac 5a                         DECB
9652 fcad 26 fb                      BNE     REGSKP          ; LOOP IF MORE
9653 fcaf 20 e3                      BRA     REG4            ; CONTINUE WITH NEXT REGISTER
9654 fcb1 a7 e4              REGNXC  STA     ,S              ; SAVE DELIMITER IN OPTION
9655                         *                               ; (ALWAYS > 0)
9656 fcb3 dc 9b                      LDD     <NUMBER         ; OBTAIN BINARY RESULT
9657 fcb5 6d 3f                      TST     -1,Y            ; ? TWO BYTES WORTH
9658 fcb7 26 02                      BNE     REGTWO          ; BRANCH YES
9659 fcb9 a6 82                      LDA     ,-X             ; SETUP FOR TWO
9660 fcbb ed 84              REGTWO  STD     ,X              ; STORE IN NEW VALUE
9661 fcbd a6 e4                      LDA     ,S              ; RECOVER DELIMITER
9662 fcbf 81 0d                      CMPA    #CR             ; ? END OF CHANGES
9663 fcc1 26 d1                      BNE     REG4            ; NO, KEEP ON TRUCK'N
9664                         * MOVE STACKED DATA TO NEW STACK IN CASE STACK
9665                         * POINTER HAS CHANGED
9666 fcc3 30 8d 73 8a        REGAGN  LEAX    TSTACK,PCR      ; LOAD TEMP AREA
9667 fcc7 c6 15                      LDB     #21             ; LOAD COUNT
9668 fcc9 35 02              REGTF1  PULS    A               ; NEXT BYTE
9669 fccb a7 80                      STA     ,X+             ; STORE INTO TEMP
9670 fccd 5a                         DECB                    ; COUNT DOWN
9671 fcce 26 f9                      BNE     REGTF1          ; LOOP IF MORE
9672 fcd0 10 ee 88 ec                LDS     -20,X           ; LOAD NEW STACK POINTER
9673 fcd4 c6 15                      LDB     #21             ; LOAD COUNT AGAIN
9674 fcd6 a6 82              REGTF2 LDA      ,-X             ; NEXT TO STORE
9675 fcd8 34 02                     PSHS     A               ; BACK ONTO NEW STACK
9676 fcda 5a                        DECB                     ; COUNT DOWN
9677 fcdb 26 f9                     BNE      REGTF2          ; LOOP IF MORE
9678 fcdd 20 bc                     BRA      REGRTN          ; GO RESTART COMMAND
9679                         
9680                         *********************************************
9681                         * BLDNUM - BUILDS BINARY VALUE FROM INPUT HEX
9682                         * THE ACTIVE EXPRESSION HANDLER IS USED.
9683                         * INPUT: S=RETURN ADDRESS
9684                         * OUTPUT: A=DELIMITER WHICH TERMINATED VALUE
9685                         * (IF DELM NOT ZERO)
9686                         * "NUMBER"=WORD BINARY RESULT
9687                         * Z=1 IF INPUT RECEIVED, Z=0 IF NO HEX RECEIVED
9688                         * REGISTERS ARE TRANSPARENT
9689                         **********************************************
9690                         * EXECUTE SINGLE OR EXTENDED ROM EXPRESSION HANDLER
9691                         *
9692                         * THE FLAG "DELIM" IS USED AS FOLLOWS:
9693                         * DELIM=0 NO LEADING BLANKS, NO FORCED TERMINATOR
9694                         * DELIM=CHR ACCEPT LEADING 'CHR'S, FORCED TERMINATOR
9695 fcdf 4f                 BLDNNB  CLRA                    ; NO DYNAMIC DELIMITER
9696 fce0 8c                         FCB     SKIP2           ; SKIP NEXT INSTRUCTION
9697                         * BUILD WITH LEADING BLANKS
9698 fce1 86 20              BLDNUM  LDA     #'              ; ALLOW LEADING BLANKS
9699 fce3 97 8e                      STA     <DELIM          ; STORE AS DELIMITER
9700 fce5 6e 9d 74 03                JMP     [VECTAB+.EXPAN,PCR]   ; TO EXP ANALYZER
9701                         * THIS IS THE DEFAULT SINGLE ROM ANALYZER. WE ACCEPT:
9702                         * 1) HEX INPUT
9703                         * 2) 'M' FOR LAST MEMORY EXAMINE ADDRESS
9704                         * 3) 'P' FOR PROGRAM COUNTER ADDRESS
9705                         * 4) 'W' FOR WINDOW VALUE
9706                         * 5) '@' FOR INDIRECT VALUE
9707                         
9708 fce9 34 14              EXP1    PSHS    X,B             ; SAVE REGISTERS
9709 fceb 8d 5c              EXPDLM  BSR     BLDHXI          ; CLEAR NUMBER, CHECK FIRST CHAR
9710 fced 27 18                      BEQ     EXP2            ; IF HEX DIGIT CONTINUE BUILDING
9711                         * SKIP BLANKS IF DESIRED
9712 fcef 91 8e                      CMPA    <DELIM          ; ? CORRECT DELIMITER
9713 fcf1 27 f8                      BEQ     EXPDLM          ; YES, IGNORE IT
9714                         * TEST FOR M OR P
9715 fcf3 9e 9e                      LDX     <ADDR           ; DEFAULT FOR 'M'
9716 fcf5 81 4d                      CMPA    #'M             ; ? MEMORY EXAMINE ADDR WANTED
9717 fcf7 27 16                      BEQ     EXPTDL          ; BRANCH IF SO
9718 fcf9 9e 93                      LDX     <PCNTER         ; DEFAULT FOR 'P'
9719 fcfb 81 50                      CMPA    #'P             ; ? LAST PROGRAM COUNTER WANTED
9720 fcfd 27 10                      BEQ     EXPTDL          ; BRANCH IF SO
9721 fcff 9e a0                      LDX     <WINDOW         ; DEFAULT TO WINDOW
9722 fd01 81 57                      CMPA    #'W             ; ? WINDOW WANTED
9723 fd03 27 0a                      BEQ     EXPTDL
9724                         
9725 fd05 35 94              EXPRTN  PULS    PC,X,B          ; RETURN AND RESTORE REGISTERS
9726                         * GOT HEX, NOW CONTINUE BUILDING
9727 fd07 8d 44              EXP2    BSR     BLDHEX          ; COMPUTE NEXT DIGIT
9728 fd09 27 fc                      BEQ     EXP2            ; CONTINUE IF MORE
9729 fd0b 20 0a                      BRA     EXPCDL          ; SEARCH FOR +/-
9730                         * STORE VALUE AND CHECK IF NEED DELIMITER
9731 fd0d ae 84              EXPTDI  LDX     ,X              ; INDIRECTION DESIRED
9732 fd0f 9f 9b              EXPTDL  STX     <NUMBER         ; STORE RESULT
9733 fd11 0d 8e                      TST     <DELIM          ; ? TO FORCE A DELIMITER
9734 fd13 27 f0                      BEQ     EXPRTN          ; RETURN IF NOT WITH VALUE
9735 fd15 8d 62                      BSR     READC           ; OBTAIN NEXT CHARACTER
9736                         * TEST FOR + OR -
9737 fd17 9e 9b              EXPCDL  LDX     <NUMBER         ; LOAD LAST VALUE
9738 fd19 81 2b                      CMPA    #'+             ; ? ADD OPERATOR
9739 fd1b 26 0e                      BNE     EXPCHM          ; BRANCH NOT
9740 fd1d 8d 23                      BSR     EXPTRM          ; COMPUTE NEXT TERM
9741 fd1f 34 02                      PSHS    A               ; SAVE DELIMITER
9742 fd21 dc 9b                      LDD     <NUMBER         ; LOAD NEW TERM
9743 fd23 30 8b              EXPADD  LEAX    D,X             ; ADD TO X
9744 fd25 9f 9b                      STX     <NUMBER         ; STORE AS NEW RESULT
9745 fd27 35 02                      PULS    A               ; RESTORE DELIMITER
9746 fd29 20 ec                      BRA     EXPCDL          ; NOW TEST IT
9747 fd2b 81 2d              EXPCHM  CMPA    #'-             ; ? SUBTRACT OPERATOR
9748 fd2d 27 07                      BEQ     EXPSUB          ; BRANCH IF SO
9749 fd2f 81 40                      CMPA    #'@             ; ? INDIRECTION DESIRED
9750 fd31 27 da                      BEQ     EXPTDI          ; BRANCH IF SO
9751 fd33 5f                         CLRB                    ; SET DELIMITER RETURN
9752 fd34 20 cf                      BRA     EXPRTN          ; AND RETURN TO CALLER
9753 fd36 8d 0a              EXPSUB  BSR     EXPTRM          ; OBTAIN NEXT TERM
9754 fd38 34 02                      PSHS    A               ; SAVE DELIMITER
9755 fd3a dc 9b                      LDD     <NUMBER         ; LOAD UP NEXT TERM
9756 fd3c 40                         NEGA                    ; NEGATE A
9757 fd3d 50                         NEGB                    ; NEGATE B
9758 fd3e 82 00                      SBCA    #0              ; CORRECT FOR A
9759 fd40 20 e1                      BRA     EXPADD          ; GO ADD TO EXPRESSION
9760                         * COMPUTE NEXT EXPRESSION TERM
9761                         * OUTPUT: X=OLD VALUE
9762                         * 'NUMBER'=NEXT TERM
9763 fd42 8d 9d              EXPTRM  BSR     BLDNUM          ; OBTAIN NEXT VALUE
9764 fd44 27 32                      BEQ     CNVRTS          ; RETURN IF VALID NUMBER
9765 fd46 16 fc 13           BLDBAD  LBRA    CMDBAD          ; ABORT COMMAND IF INVALID
9766                         
9767                         *********************************************
9768                         * BUILD BINARY VALUE USING INPUT CHARACTERS.
9769                         * INPUT: A=ASCII HEX VALUE OR DELIMITER
9770                         * SP+0=RETURN ADDRESS
9771                         * SP+2=16 BIT RESULT AREA
9772                         * OUTPUT: Z=1 A=BINARY VALUE
9773                         * Z=0 IF INVALID HEX CHARACTER (A UNCHANGED)
9774                         * VOLATILE: D
9775                         ****************************************
9776 fd49 0f 9b              BLDHXI  CLR     <NUMBER         ; CLEAR NUMBER
9777 fd4b 0f 9c                      CLR     <NUMBER+1       ; CLEAR NUMBER
9778 fd4d 8d 2a              BLDHEX  BSR     READC           ; GET INPUT CHARACTER
9779 fd4f 8d 11              BLDHXC  BSR     CNVHEX          ; CONVERT AND TEST CHARACTER
9780 fd51 26 25                      BNE     CNVRTS          ; RETURN IF NOT A NUMBER
9781 fd53 c6 10                      LDB     #16             ; PREPARE SHIFT
9782 fd55 3d                         MUL                     ; BY FOUR PLACES
9783 fd56 86 04                      LDA     #4              ; ROTATE BINARY INTO VALUE
9784 fd58 58                 BLDSHF  ASLB                    ; OBTAIN NEXT BIT
9785 fd59 09 9c                      ROL     <NUMBER+1       ; INTO LOW BYTE
9786 fd5b 09 9b                      ROL     <NUMBER         ; INTO HI BYTE
9787 fd5d 4a                         DECA                    ; COUNT DOWN
9788 fd5e 26 f8                      BNE     BLDSHF          ; BRANCH IF MORE TO DO
9789 fd60 20 14                      BRA     CNVOK           ; SET GOOD RETURN CODE
9790                         
9791                         ****************************************
9792                         * CONVERT ASCII CHARACTER TO BINARY BYTE
9793                         * INPUT: A=ASCII
9794                         * OUTPUT: Z=1 A=BINARY VALUE
9795                         * Z=0 IF INVALID
9796                         * ALL REGISTERS TRANSPARENT
9797                         * (A UNALTERED IF INVALID HEX)
9798                         **************************************
9799 fd62 81 30              CNVHEX  CMPA    #'0             ; ? LOWER THAN A ZERO
9800 fd64 25 12                      BLO     CNVRTS          ; BRANCH NOT VALUE
9801 fd66 81 39                      CMPA    #'9             ; ? POSSIBLE A-F
9802 fd68 2f 0a                      BLE     CNVGOT          ; BRANCH NO TO ACCEPT
9803 fd6a 81 41                      CMPA    #'A             ; ? LESS THEN TEN
9804 fd6c 25 0a                      BLO     CNVRTS          ; RETURN IF MINUS (INVALID)
9805 fd6e 81 46                      CMPA    #'F             ; ? NOT TOO LARGE
9806 fd70 22 06                      BHI     CNVRTS          ; NO, RETURN TOO LARGE
9807 fd72 80 07                      SUBA    #7              ; DOWN TO BINARY
9808 fd74 84 0f              CNVGOT  ANDA    #$0F            ; CLEAR HIGH HEX
9809 fd76 1a 04              CNVOK   ORCC    #4              ; FORCE ZERO ON FOR VALID HEX
9810 fd78 39                 CNVRTS  RTS                     ; RETURN TO CALLER
9811                         
9812                         * GET INPUT CHAR, ABORT COMMAND IF CONTROL-X (CANCEL)
9813 fd79 3f                 READC    SWI                    ; GET NEXT CHARACTER
9814 fd7a 00                          FCB    INCHNP          ; FUNCTION
9815 fd7b 81 18                       CMPA   #CAN            ; ? ABORT COMMAND
9816 fd7d 27 c7                       BEQ    BLDBAD          ; BRANCH TO ABORT IF SO
9817 fd7f 39                          RTS                    ; RETURN TO CALLER
9818                         *G
9819                         
9820                         ***************GO - START PROGRAM EXECUTION
9821 fd80 8d 01              CGO      BSR    GOADDR          ; BUILD ADDRESS IF NEEDED
9822 fd82 3b                          RTI                    ; START EXECUTING
9823                         
9824                         * FIND OPTIONAL NEW PROGRAM COUNTER. ALSO ARM THE
9825                         * BREAKPOINTS.
9826 fd83 35 30              GOADDR   PULS   Y,X             ; RECOVER RETURN ADDRESS
9827 fd85 34 10                       PSHS   X               ; STORE RETURN BACK
9828 fd87 26 19                       BNE    GONDFT          ; IF NO CARRIAGE RETURN THEN NEW PC
9829                         
9830                         * DEFAULT PROGRAM COUNTER, SO FALL THROUGH IF
9831                         * IMMEDIATE BREAKPOINT.
9832 fd89 17 01 b6                    LBSR   CBKLDR          ; SEARCH BREAKPOINTS
9833 fd8c ae 6c                       LDX    12,S            ; LOAD PROGRAM COUNTER
9834 fd8e 5a                 ARMBLP  DECB                    ; COUNT DOWN
9835 fd8f 2b 16                      BMI     ARMBK2          ; DONE, NONE TO SINGLE TRACE
9836 fd91 a6 30                      LDA     -NUMBKP*2,Y     ; PRE-FETCH OPCODE
9837 fd93 ac a1                      CMPX    ,Y++            ; ? IS THIS A BREAKPOINT
9838 fd95 26 f7                      BNE     ARMBLP          ; LOOP IF NOT
9839 fd97 81 3f                      CMPA    #$3F            ; ? SWI BREAKPOINTED
9840 fd99 26 02                      BNE     ARMNSW          ; NO, SKIP SETTING OF PASS FLAG
9841 fd9b 97 fb                      STA     <SWIBFL         ; SHOW UPCOMING SWI NOT BRKPNT
9842 fd9d 0c 8f              ARMNSW  INC     <MISFLG         ; FLAG THRU A BREAKPOINT
9843 fd9f 16 01 06                   LBRA    CDOT            ; DO SINGLE TRACE W/O BREAKPOINTS
9844                         
9845                         * OBTAIN NEW PROGRAM COUNTER
9846 fda2 17 00 bb           GONDFT  LBSR    CDNUM           ; OBTAIN NEW PROGRAM COUNTER
9847 fda5 ed 6c                      STD     12,S            ; STORE INTO STACK
9848 fda7 17 01 98           ARMBK2  LBSR    CBKLDR          ; OBTAIN TABLE
9849 fdaa 00 fa                      NEG     <BKPTCT         ; COMPLEMENT TO SHOW ARMED
9850 fdac 5a                 ARMLOP  DECB                    ; ? DONE
9851 fdad 2b c9                      BMI     CNVRTS          ; RETURN WHEN DONE
9852 fdaf a6 b4                      LDA     [,Y]            ; LOAD OPCODE
9853 fdb1 a7 30                      STA     -NUMBKP*2,Y     ; STORE INTO OPCODE TABLE
9854 fdb3 86 3f                      LDA     #$3F            ; READY "SWI" OPCODE
9855 fdb5 a7 b1                      STA     [,Y++]          ; STORE AND MOVE UP TABLE
9856 fdb7 20 f3                      BRA     ARMLOP          ; AND CONTINUE
9857                         
9858                         *******************CALL - CALL ADDRESS AS SUBROUTINE
9859 fdb9 8d c8              CCALL   BSR     GOADDR          ; FETCH ADDRESS IF NEEDED
9860 fdbb 35 7f                      PULS    U,Y,X,DP,D,CC   ; RESTORE USERS REGISTERS
9861 fdbd ad f1                      JSR     [,S++]          ; CALL USER SUBROUTINE
9862 fdbf 3f                 CGOBRK  SWI                     ; PERFORM BREAKPOINT
9863 fdc0 0a                         FCB     BRKPT           ; FUNCTION
9864 fdc1 20 fc                      BRA     CGOBRK          ; LOOP UNTIL USER CHANGES PC
9865                         
9866                         ****************MEMORY - DISPLAY/CHANGE MEMORY
9867                         * CMEMN AND CMPADP ARE DIRECT ENTRY POINTS FROM
9868                         * THE COMMAND HANDLER FOR QUICK COMMANDS
9869 fdc3 17 00 9a           CMEM    LBSR    CDNUM           ; OBTAIN ADDRESS
9870 fdc6 dd 9e              CMEMN   STD     <ADDR           ; STORE DEFAULT
9871 fdc8 9e 9e              CMEM2   LDX     <ADDR           ; LOAD POINTER
9872 fdca 17 fc 0c                   LBSR    ZOUT2H          ; SEND OUT HEX VALUE OF BYTE
9873 fdcd 86 2d                      LDA     #'-             ; LOAD DELIMITER
9874 fdcf 3f                         SWI                     ; SEND OUT
9875 fdd0 01                         FCB     OUTCH           ; FUNCTION
9876 fdd1 17 ff 0b           CMEM4   LBSR    BLDNNB          ; OBTAIN NEW BYTE VALUE
9877 fdd4 27 0a                      BEQ     CMENUM          ; BRANCH IF NUMBER
9878                         * COMA - SKIP BYTE
9879 fdd6 81 2c                      CMPA    #',             ; ? COMMA
9880 fdd8 26 0e                      BNE     CMNOTC          ; BRANCH NOT
9881 fdda 9f 9e                      STX     <ADDR           ; UPDATE POINTER
9882 fddc 30 01                      LEAX    1,X             ; TO NEXT BYTE
9883 fdde 20 f1                      BRA     CMEM4           ; AND INPUT IT
9884 fde0 d6 9c              CMENUM  LDB     <NUMBER+1       ; LOAD LOW BYTE VALUE
9885 fde2 8d 47                      BSR     MUPDAT          ; GO OVERLAY MEMORY BYTE
9886 fde4 81 2c                      CMPA    #',             ; ? CONTINUE WITH NO DISPLAY
9887 fde6 27 e9                      BEQ     CMEM4           ; BRANCH YES
9888                         * QUOTED STRING
9889 fde8 81 27              CMNOTC  CMPA    #$27            ; ? QUOTED STRING
9890 fdea 26 0c                      BNE     CMNOTQ          ; BRANCH NO
9891 fdec 8d 8b              CMESTR  BSR     READC           ; OBTAIN NEXT CHARACTER
9892 fdee 81 27                      CMPA    #$27            ; ? END OF QUOTED STRING
9893 fdf0 27 0c                      BEQ     CMSPCE          ; YES, QUIT STRING MODE
9894 fdf2 1f 89                      TFR     A,B             ; TO B FOR SUBROUTINE
9895 fdf4 8d 35                      BSR     MUPDAT          ; GO UPDATE BYTE
9896 fdf6 20 f4                      BRA     CMESTR          ; GET NEXT CHARACTER
9897                         * BLANK - NEXT BYTE
9898 fdf8 81 20              CMNOTQ  CMPA    #$20            ; ? BLANK FOR NEXT BYTE
9899 fdfa 26 06                      BNE     CMNOTB          ; BRANCH NOT
9900 fdfc 9f 9e                      STX     <ADDR           ; UPDATE POINTER
9901 fdfe 3f                 CMSPCE  SWI                     ; GIVE SPACE
9902 fdff 07                         FCB     SPACEF          ; FUNCTION
9903 fe00 20 c6                      BRA     CMEM2           ; NOW PROMPT FOR NEXT
9904                         
9905                         * LINE FEED - NEXT BYTE WITH ADDRESS
9906 fe02 81 0a              CMNOTB  CMPA    #LF             ; ? LINE FEED FOR NEXT BYTE
9907 fe04 26 08                      BNE     CMNOTL          ; BRANCH NO
9908 fe06 86 0d                      LDA     #CR             ; GIVE CARRIAGE RETURN
9909 fe08 3f                         SWI                     ; TO CONSOLE
9910 fe09 01                         FCB     OUTCH           ; HANDLER
9911 fe0a 9f 9e                      STX     <ADDR           ; STORE NEXT ADDRESS
9912 fe0c 20 0a                      BRA     CMPADP          ; BRANCH TO SHOW
9913                         
9914                         * UP ARROW - PREVIOUS BYTE AND ADDRESS
9915 fe0e 81 5e              CMNOTL  CMPA    #'^             ; ? UP ARROW FOR PREVIOUS BYTE
9916 fe10 26 0a                      BNE     CMNOTU          ; BRANCH NOT
9917 fe12 30 1e                      LEAX    -2,X            ; DOWN TO PREVIOUS BYTE
9918 fe14 9f 9e                      STX     <ADDR           ; STORE NEW POINTER
9919 fe16 3f                 CMPADS  SWI                     ; FORCE NEW LINE
9920 fe17 06                         FCB     PCRLF           ; FUNCTION
9921 fe18 8d 07              CMPADP  BSR     PRTADR          ; GO PRINT ITS VALUE
9922 fe1a 20 ac                      BRA     CMEM2           ; THEN PROMPT FOR INPUT
9923                         
9924                         * SLASH - NEXT BYTE WITH ADDRESS
9925 fe1c 81 2f              CMNOTU  CMPA    #'/             ; ? SLASH FOR CURRENT DISPLAY
9926 fe1e 27 f6                      BEQ     CMPADS          ; YES, SEND ADDRESS
9927 fe20 39                         RTS                     ; RETURN FROM COMMAND
9928                         
9929                         * PRINT CURRENT ADDRESS
9930 fe21 9e 9e              PRTADR  LDX     <ADDR           ; LOAD POINTER VALUE
9931 fe23 34 10                      PSHS    X               ; SAVE X ON STACK
9932 fe25 30 e4                      LEAX    ,S              ; POINT TO IT FOR DISPLAY
9933 fe27 3f                         SWI                     ; DISPLAY POINTER IN HEX
9934 fe28 05                         FCB     OUT4HS          ; FUNCTION
9935 fe29 35 90                      PULS    PC,X            ; RECOVER POINTER AND RETURN
9936                         
9937                         * UPDATE BYTE
9938 fe2b 9e 9e              MUPDAT  LDX     <ADDR           ; LOAD NEXT BYTE POINTER
9939 fe2d e7 80                      STB     ,X+             ; STORE AND INCREMENT X
9940 fe2f e1 1f                      CMPB    -1,X            ; ? SUCCESFULL STORE
9941 fe31 26 03                      BNE     MUPBAD          ; BRANCH FOR '?' IF NOT
9942 fe33 9f 9e                      STX     <ADDR           ; STORE NEW POINTER VALUE
9943 fe35 39                         RTS                     ; BACK TO CALLER
9944 fe36 34 02              MUPBAD  PSHS    A               ; SAVE A REGISTER
9945 fe38 86 3f                      LDA     #'?             ; SHOW INVALID
9946 fe3a 3f                         SWI                     ; SEND OUT
9947 fe3b 01                         FCB     OUTCH           ; FUNCTION
9948 fe3c 35 82                      PULS    PC,A            ; RETURN TO CALLER
9949                         
9950                         ********************WINDOW - SET WINDOW VALUE
9951 fe3e 8d 20              CWINDO  BSR     CDNUM           ; OBTAIN WINDOW VALUE
9952 fe40 dd a0                      STD     <WINDOW         ; STORE IT IN
9953 fe42 39                         RTS                     ; END COMMAND
9954                         
9955                         ******************DISPLAY - HIGH SPEED DISPLAY MEMORY
9956 fe43 8d 1b              CDISP   BSR     CDNUM           ; FETCH ADDRESS
9957 fe45 c4 f0                      ANDB    #$F0            ; FORCE TO 16 BOUNDARY
9958 fe47 1f 02                      TFR     D,Y             ; SAVE IN Y
9959 fe49 30 2f                      LEAX    15,Y            ; DEFAULT LENGTH
9960 fe4b 25 04                      BCS     CDISPS          ; BRANCH IF END OF INPUT
9961 fe4d 8d 11                      BSR     CDNUM           ; OBTAIN COUNT
9962 fe4f 30 ab                      LEAX    D,Y             ; ASSUME COUNT, COMPUTE END ADDR
9963 fe51 34 30              CDISPS  PSHS    Y,X             ; SETUP PARAMETERS FOR HSDATA
9964 fe53 10 a3 62                   CMPD    2,S             ; ? WAS IT COUNT
9965 fe56 23 02                      BLS     CDCNT           ; BRANCH YES
9966 fe58 ed e4                      STD     ,S              ; STORE HIGH ADDRESS
9967 fe5a ad 9d 72 84        CDCNT   JSR     [VECTAB+.HSDTA,PCR] ; CALL PRINT ROUTINE
9968 fe5e 35 e0                      PULS    PC,U,Y          ; CLEAN STACK AND END COMMAND
9969                         
9970                         * OBTAIN NUMBER - ABORT IF NONE
9971                         * ONLY DELIMITERS OF CR, BLANK, OR '/' ARE ACCEPTED
9972                         * OUTPUT: D=VALUE, C=1 IF CARRIAGE RETURN DELMITER,
9973                         * ELSE C=0
9974 fe60 17 fe 7e           CDNUM   LBSR    BLDNUM          ; OBTAIN NUMBER
9975 fe63 26 09                      BNE     CDBADN          ; BRANCH IF INVALID
9976 fe65 81 2f                      CMPA    #'/             ; ? VALID DELIMITER
9977 fe67 22 05                      BHI     CDBADN          ; BRANCH IF NOT FOR ERROR
9978 fe69 81 0e                      CMPA    #CR+1           ; LEAVE COMPARE FOR CARRIAGE RET
9979 fe6b dc 9b                      LDD     <NUMBER         ; LOAD NUMBER
9980 fe6d 39                         RTS                     ; RETURN WITH COMPARE
9981 fe6e 16 fa eb           CDBADN  LBRA    CMDBAD          ; RETURN TO ERROR MECHANISM
9982                         
9983                         *****************PUNCH - PUNCH MEMORY IN S1-S9 FORMAT
9984 fe71 8d ed              CPUNCH  BSR     CDNUM           ; OBTAIN START ADDRESS
9985 fe73 1f 02                      TFR     D,Y             ; SAVE IN Y
9986 fe75 8d e9                      BSR     CDNUM           ; OBTAIN END ADDRESS
9987 fe77 6f e2                      CLR     ,-S             ; SETUP PUNCH FUNCTION CODE
9988 fe79 34 26                      PSHS    Y,D             ; STORE VALUES ON STACK
9989 fe7b ad 9d 72 65        CCALBS  JSR     [VECTAB+.BSON,PCR] ; INITIALIZE HANDLER
9990 fe7f ad 9d 72 63                JSR     [VECTAB+.BSDTA,PCR] ; PERFORM FUNCTION
9991 fe83 34 01                      PSHS    CC              ; SAVE RETURN CODE
9992 fe85 ad 9d 72 5f                JSR     [VECTAB+.BSOFF,PCR] ; TURN OFF HANDLER
9993 fe89 35 01                      PULS    CC              ; OBTAIN CONDITION CODE SAVED
9994 fe8b 26 e1                      BNE     CDBADN          ; BRANCH IF ERROR
9995 fe8d 35 b2                      PULS    PC,Y,X,A        ; RETURN FROM COMMAND
9996                         
9997                         *****************LOAD - LOAD MEMORY FROM S1-S9 FORMAT
9998 fe8f 8d 01              CLOAD   BSR     CLVOFS          ; CALL SETUP AND PASS CODE
9999 fe91 01                         FCB     1               ; LOAD FUNCTION CODE FOR PACKET
10000                         
10001 fe92 33 f1              CLVOFS  LEAU    [,S++]          ; LOAD CODE IN HIGH BYTE OF U
10002 fe94 33 d4                      LEAU    [,U]            ; NOT CHANGING CC AND RESTORE S
10003 fe96 27 03                      BEQ     CLVDFT          ; BRANCH IF CARRIAGE RETURN NEXT
10004 fe98 8d c6                      BSR     CDNUM           ; OBTAIN OFFSET
10005 fe9a 8c                         FCB     SKIP2           ; SKIP DEFAULT OFFSET
10006 fe9b 4f                 CLVDFT  CLRA                    ; CREATE ZERO OFFSET
10007 fe9c 5f                         CLRB                    ; AS DEFAULT
10008 fe9d 34 4e                      PSHS    U,DP,D          ; SETUP CODE, NULL WORD, OFFSET
10009 fe9f 20 da                      BRA     CCALBS          ; ENTER CALL TO BS ROUTINES
10010                         
10011                         ******************VERIFY - COMPARE MEMORY WITH FILES
10012 fea1 8d ef              CVER    BSR     CLVOFS          ; COMPUTE OFFSET IF ANY
10013 fea3 ff                         FCB     -1              ; VERIFY FNCTN CODE FOR PACKET
10014                         
10015                         *******************TRACE - TRACE INSTRUCTIONS
10016                         ******************* . - SINGLE STEP TRACE
10017 fea4 8d ba              CTRACE  BSR     CDNUM           ; OBTAIN TRACE COUNT
10018 fea6 dd 91                      STD     <TRACEC         ; STORE COUNT
10019 fea8 32 62              CDOT    LEAS    2,S             ; RID COMMAND RETURN FROM STACK
10020 feaa ee f8 0a           CTRCE3  LDU     [10,S]          ; LOAD OPCODE TO EXECUTE
10021 fead df 99                      STU     <LASTOP         ; STORE FOR TRACE INTERRUPT
10022 feaf de f6                      LDU     <VECTAB+.PTM    ; LOAD PTM ADDRESS
10023 feb1 cc 07 01                   LDD     #$0701          ; 7,1 CYCLES DOWN+CYCLES UP
10024 feb4 ed 42                      STD     PTMTM1-PTM,U    ; START NMI TIMEOUT
10025 feb6 3b                         RTI                     ; RETURN FOR ONE INSTRUCTION
10026                         
10027                         *************NULLS  -  SET NEW LINE AND CHAR PADDING
10028 feb7 8d a7              CNULLS  BSR     CDNUM           ; OBTAIN NEW LINE PAD
10029 feb9 dd f2                      STD     <VECTAB+.PAD    ; RESET VALUES
10030 febb 39                         RTS                     ; END COMMAND
10031                         
10032                         ******************STLEVEL - SET STACK TRACE LEVEL
10033 febc 27 05              CSTLEV  BEQ     STLDFT          ; TAKE DEFAULT
10034 febe 8d a0                      BSR     CDNUM           ; OBTAIN NEW STACK LEVEL
10035 fec0 dd f8                      STD     <SLEVEL         ; STORE NEW ENTRY
10036 fec2 39                         RTS                     ; TO COMMAND HANDLER
10037 fec3 30 6e              STLDFT  LEAX    14,S            ; COMPUTE NMI COMPARE
10038 fec5 9f f8                      STX     <SLEVEL         ; AND STORE IT
10039 fec7 39                         RTS                     ; END COMMAND
10040                         
10041                         ******************OFFSET - COMPUTE SHORT AND LONG
10042                         ******************                  BRANCH OFFSETS
10043 fec8 8d 96              COFFS   BSR     CDNUM           ; OBTAIN INSTRUCTION ADDRESS
10044 feca 1f 01                      TFR     D,X             ; USE AS FROM ADDRESS
10045 fecc 8d 92                      BSR     CDNUM           ; OBTAIN TO ADDRESS
10046                         * D=TO INSTRUCTION, X=FROM INSTRUCTION OFFSET BYTE(S)
10047 fece 30 01                      LEAX    1,X             ; ADJUST FOR *+2 SHORT BRANCH
10048 fed0 34 30                      PSHS    Y,X             ; STORE WORK WORD AND VALUE ON S
10049 fed2 a3 e4                      SUBD    ,S              ; FIND OFFSET
10050 fed4 ed e4                      STD     ,S              ; SAVE OVER STACK
10051 fed6 30 61                      LEAX    1,S             ; POINT FOR ONE BYTE DISPLAY
10052 fed8 1d                         SEX                     ; SIGN EXTEND LOW BYTE
10053 fed9 a1 e4                      CMPA    ,S              ; ? VALID ONE BYTE OFFSET
10054 fedb 26 02                      BNE     COFNO1          ; BRANCH IF NOT
10055 fedd 3f                         SWI                     ; SHOW ONE BYTE OFFSET
10056 fede 04                         FCB     OUT2HS          ; FUNCTION
10057 fedf ee e4              COFNO1  LDU     ,S              ; RELOAD OFFSET
10058 fee1 33 5f                      LEAU    -1,U            ; CONVERT TO LONG BRANCH OFFSET
10059 fee3 ef 84                      STU     ,X              ; STORE BACK WHERE X POINTS NOW
10060 fee5 3f                         SWI                     ; SHOW TWO BYTE OFFSET
10061 fee6 05                         FCB     OUT4HS          ; FUNCTION
10062 fee7 3f                         SWI                     ; FORCE NEW LINE
10063 fee8 06                         FCB     PCRLF           ; FUNCTION
10064 fee9 35 96                      PULS    PC,X,D          ; RESTORE STACK AND END COMMAND
10065                         *H
10066                         
10067                         *************BREAKPOINT - DISPLAY/ENTER/DELETE/CLEAR
10068                         *************             BREAKPOINTS
10069 feeb 27 23              CBKPT   BEQ     CBKDSP          ; BRANCH DISPLAY OF JUST 'B'
10070 feed 17 fd f1                   LBSR    BLDNUM          ; ATTEMPT VALUE ENTRY
10071 fef0 27 2c                      BEQ     CBKADD          ; BRANCH TO ADD IF SO
10072 fef2 81 2d                      CMPA    #'-             ; ? CORRECT DELIMITER
10073 fef4 26 3f                      BNE     CBKERR          ; NO, BRANCH FOR ERROR
10074 fef6 17 fd e8                   LBSR    BLDNUM          ; ATTEMPT DELETE VALUE
10075 fef9 27 03                      BEQ     CBKDLE          ; GOT ONE, GO DELETE IT
10076 fefb 0f fa                      CLR     <BKPTCT         ; WAS 'B -', SO ZERO COUNT
10077 fefd 39                 CBKRTS  RTS                     ; END COMMAND
10078                         * DELETE THE ENTRY
10079 fefe 8d 40              CBKDLE  BSR     CBKSET          ; SETUP REGISTERS AND VALUE
10080 ff00 5a                 CBKDLP  DECB                    ; ? ANY ENTRIES IN TABLE
10081 ff01 2b 32                      BMI     CBKERR          ; BRANCH NO, ERROR
10082 ff03 ac a1                      CMPX    ,Y++            ; ? IS THIS THE ENTRY
10083 ff05 26 f9                      BNE     CBKDLP          ; NO, TRY NEXT
10084                         * FOUND, NOW MOVE OTHERS UP IN ITS PLACE
10085 ff07 ae a1              CBKDLM  LDX     ,Y++            ; LOAD NEXT ONE UP
10086 ff09 af 3c                      STX     -4,Y            ; MOVE DOWN BY ONE
10087 ff0b 5a                         DECB                    ; ? DONE
10088 ff0c 2a f9                      BPL     CBKDLM          ; NO, CONTINUE MOVE
10089 ff0e 0a fa                      DEC     <BKPTCT         ; DECREMENT BREAKPOINT COUNT
10090 ff10 8d 2e              CBKDSP  BSR     CBKSET          ; SETUP REGISTERS AND LOAD VALUE
10091 ff12 27 e9                      BEQ     CBKRTS          ; RETURN IF NONE TO DISPLY
10092 ff14 30 a1              CBKDSL  LEAX    ,Y++            ; POINT TO NEXT ENTRY
10093 ff16 3f                         SWI                     ; DISPLAY IN HEX
10094 ff17 05                         FCB     OUT4HS          ; FUNCTION
10095 ff18 5a                         DECB                    ; COUNT DOWN
10096 ff19 26 f9                      BNE     CBKDSL          ; LOOP IF NGABLE RAM
10097 ff1b 3f                         SWI                     ; SKIP TO NEW LINK
10098 ff1c 06                         FCB     PCRLF           ; FUNCTIONRTS
10099 ff1d 39                         RTS
10100                         
10101                         * ADD NEW ENTRY
10102 ff1e 8d 20              CBKADD  BSR     CBKSET          ; SETUP REGISTERS
10103 ff20 c1 08                      CMPB    #NUMBKP         ; ? ALREADY FULL
10104 ff22 27 11                      BEQ     CBKERR          ; BRANCH ERROR IF SO
10105 ff24 a6 84                      LDA     ,X              ; LOAD BYTE TO TRAP
10106 ff26 e7 84                      STB     ,X              ; TRY TO CHANGE
10107 ff28 e1 84                      CMPB    ,X              ; ? CHANGEABLE RAM
10108 ff2a 26 09                      BNE     CBKERR          ; BRANCH ERROR IF NOT
10109 ff2c a7 84                      STA ,X                  ; RESTORE BYTE
10110 ff2e 5a                 CBKADL  DECB                    ; COUNT DOWN
10111 ff2f 2b 07                      BMI     CBKADT          ; BRANCH IF DONE TO ADD IT
10112 ff31 ac a1                      CMPX    ,Y++            ; ? ENTRY ALREADY HERE
10113 ff33 26 f9                      BNE     CBKADL          ; LOOP IF NOT
10114 ff35 16 fa 24           CBKERR  LBRA    CMDBAD          ; RETURN TO ERROR PRODUCE
10115 ff38 af a4              CBKADT  STX ,Y                  ; ADD THIS ENTRY
10116 ff3a 6f 31                      CLR     -NUMBKP*2+1,Y   ; CLEAR OPTIONAL BYTE
10117 ff3c 0c fa                      INC     <BKPTCT         ; ADD ONE TO COUNT
10118 ff3e 20 d0                      BRA     CBKDSP          ; AND NOW DISPLAY ALL OF 'EM
10119                         * SETUP REGISTERS FOR SCAN
10120 ff40 9e 9b              CBKSET  LDX     <NUMBER         ; LOAD VALUE DESIRED
10121 ff42 31 8d 71 6c        CBKLDR  LEAY    BKPTBL,PCR      ; LOAD START OF TABLE
10122 ff46 d6 fa                      LDB     <BKPTCT         ; LOAD ENTRY COUNT
10123 ff48 39                         RTS                     ; RETURN
10124                         
10125                         *****************ENCODE  -  ENCODE A POSTBYTE
10126 ff49 6f e2              CENCDE  CLR     ,-S             ; DEFAULT TO NOT INDIRECT
10127 ff4b 5f                         CLRB                    ; ZERO POSTBYTE VALUE
10128 ff4c 30 8c 3f                   LEAX    <CONV1,PCR      ; START TABLE SEARCH
10129 ff4f 3f                         SWI                     ; OBTAIN FIRST CHARACTER
10130 ff50 00                         FCB     INCHNP          ; FUNCTION
10131 ff51 81 5b                      CMPA    #'[             ; ? INDIRECT HERE
10132 ff53 26 06                      BNE     CEN2            ; BRANCH IF NOT
10133 ff55 86 10                      LDA     #$10            ; SET INDIRECT BIT ON
10134 ff57 a7 e4                      STA     ,S              ; SAVE FOR LATER
10135 ff59 3f                 CENGET  SWI                     ; OBTAIN NEXT CHARACTER
10136 ff5a 00                         FCB     INCHNP          ; FUNCTION
10137 ff5b 81 0d              CEN2    CMPA    #CR             ; ? END OF ENTRY
10138 ff5d 27 0c                      BEQ     CEND1           ; BRANCH YES
10139 ff5f 6d 84              CENLP1  TST     ,X              ; ? END OF TABLE
10140 ff61 2b d2                      BMI     CBKERR          ; BRANCH ERROR IF SO
10141 ff63 a1 81                      CMPA    ,X++            ; ? THIS THE CHARACTER
10142 ff65 26 f8                      BNE     CENLP1          ; BRANCH IF NOT
10143 ff67 eb 1f                      ADDB    -1,X            ; ADD THIS VALUE
10144 ff69 20 ee                      BRA     CENGET          ; GET NEXT INPUT
10145 ff6b 30 8c 49           CEND1   LEAX    <CONV2,PCR      ; POINT AT TABLE 2
10146 ff6e 1f 98                      TFR     B,A             ; SAVE COPY IN A
10147 ff70 84 60                      ANDA    #$60            ; ISOLATE REGISTER MASK
10148 ff72 aa e4                      ORA     ,S              ; ADD IN INDIRECTION BIT
10149 ff74 a7 e4                      STA     ,S              ; SAVE BACK AS POSTBYTE SKELETON
10150 ff76 c4 9f                      ANDB    #$9F            ; CLEAR REGISTER BITS
10151 ff78 6d 84              CENLP2  TST     ,X              ; ? END OF TABLE
10152 ff7a 27 b9                      BEQ     CBKERR          ; BRANCH ERROR IF SO
10153 ff7c e1 81                      CMPB    ,X++            ; ? SAME VALUE
10154 ff7e 26 f8                      BNE     CENLP2          ; LOOP IF NOT
10155 ff80 e6 1f                      LDB     -1,X            ; LOAD RESULT VALUE
10156 ff82 ea e4                      ORB     ,S              ; ADD TO BASE SKELETON
10157 ff84 e7 e4                      STB     ,S              ; SAVE POSTBYTE ON STACK
10158 ff86 30 e4                      LEAX    ,S              ; POINT TO IT
10159 ff88 3f                         SWI                     ; SEND OUT AS HEX
10160 ff89 04                         FCB     OUT2HS          ; FUNCTION
10161 ff8a 3f                         SWI                     ; TO NEXT LINE
10162 ff8b 06                         FCB     PCRLF           ; FUNCTION
10163 ff8c 35 84                      PULS    PC,B            ; END OF COMMAND
10164                         
10165                         * TABLE ONE DEFINES VALID INPUT IN SEQUENCE
10166                         CONV1
10167 ff8e 41 04 42 05 44 06          FCB     'A,$04,'B,$05,'D,$06,'H,$01
     48 01
10168 ff96 48 01 48 01 48 00          FCB     'H,$01,'H,$01,'H,$00,',,$00
     2c 00
10169 ff9e 2d 09 2d 01 53 70          FCB     '-,$09,'-,$01,'S,$70,'Y,$30
     59 30
10170 ffa6 55 50 58 10 2b 07          FCB     'U,$50,'X,$10,'+,$07,'+,$01
     2b 01
10171 ffae 50 80 43 00 52 00          FCB     'P,$80,'C,$00,'R,$00,'],$00
     5d 00
10172 ffb6 ff                         FCB     $FF             ; END OF TABLE
10173                         
10174                         * CONV2 USES ABOVE CONVERSION TO SET POSTBYTE
10175                         * BIT SKELETON.
10176                         CONV2
10177 ffb7 10 84 11 00                FDB     $1084,$1100     ; R,      H,R
10178 ffbb 12 88 13 89                FDB     $1288,$1389     ; HH,R    HHHH,R
10179 ffbf 14 86 15 85                FDB     $1486,$1585     ; A,R     B,R
10180 ffc3 16 8b 17 80                FDB     $168B,$1780     ; D,R     ,R+
10181 ffc7 18 81 19 82                FDB     $1881,$1982     ; ,R++    ,-R
10182 ffcb 1a 83 82 8c                FDB     $1A83,$828C     ; ,--R    HH,PCR
10183 ffcf 83 8d 03 9f                FDB     $838D,$039F     ; HHHH,PCR [HHHH]
10184 ffd3 00                         FCB     0               ; END OF TABLE
10185                         
10186                         ****************************************************
10187                         *            DEFAULT INTERRUPT TRANSFERS           *
10188                         ****************************************************
10189 ffd4 6e 9d 70 ee        RSRVD   JMP     [VECTAB+.RSVD,PCR]      ; RESERVED VECTOR
10190 ffd8 6e 9d 70 ec        SWI3    JMP     [VECTAB+.SWI3,PCR]      ; SWI3 VECTOR
10191 ffdc 6e 9d 70 ea        SWI2    JMP     [VECTAB+.SWI2,PCR]      ; SWI2 VECTOR
10192 ffe0 6e 9d 70 e8        FIRQ    JMP     [VECTAB+.FIRQ,PCR]      ; FIRQ VECTOR
10193 ffe4 6e 9d 70 e6        IRQ     JMP     [VECTAB+.IRQ,PCR]       ; IRQ VECTOR
10194 ffe8 6e 9d 70 e4        SWI     JMP     [VECTAB+.SWI,PCR]       ; SWI VECTOR
10195 ffec 6e 9d 70 e2        NMI     JMP     [VECTAB+.NMI,PCR]       ; NMI VECTOR
10196                         
10197                         ******************************************************
10198                         *            ASSIST09 HARDWARE VECTOR TABLE
10199                         * THIS TABLE IS USED IF THE ASSIST09 ROM ADDRESSES
10200                         * THE MC6809 HARDWARE VECTORS.
10201                         ******************************************************
10202 fff0                            ORG     ROMBEG+ROMSIZ-16 ; SETUP HARDWARE VECTORS
10203 fff0 ff d4                      FDB     RSRVD           ; RESERVED SLOT
10204 fff2 ff d8                      FDB     SWI3            ; SOFTWARE INTERRUPT 3
10205 fff4 ff dc                      FDB     SWI2            ; SOFTWARE INTERRUPT 2
10206 fff6 ff e0                      FDB     FIRQ            ; FAST INTERRUPT REQUEST
10207 fff8 ff e4                      FDB     IRQ             ; INTERRUPT REQUEST
10208 fffa ff e8                      FDB     SWI             ; SOFTWARE INTERRUPT
10209 fffc ff ec                      FDB     NMI             ; NON-MASKABLE INTERRUPT
10210 fffe f8 37                      FDB     RESET           ; RESTART
