<!DOCTYPE HTML PUBLIC "-//SQ//DTD HTML 2.0 + all extensions//EN" "hmpro3.dtd">
<HTML>
<HEAD>
<TITLE>The Telemark Assembler (TASM) User' Manual</TITLE><!--$Revision: 1.3 $--></HEAD>
<BODY>
<H1 ALIGN="CENTER"><A NAME="Top">The Telemark Assembler (TASM) User's Manual</A></H1>
<P ALIGN="CENTER"><FONT SIZE="+2">Version 3.1<BR>February, 1998</FONT></P>
<P ALIGN="CENTER">Thomas N. Anderson
<BR>Squak Valley Software<BR>837 Front Street South, <BR>Issaquah, WA   98027
<BR>Compuserve: 73770,3612
<BR>Internet: andersontn@acm.org<BR>www.halcyon.com/squakvly/</P>
<P> Copyright (C) 1998 by Squak Valley Software.  All rights reserved.</P>
<HR>
<H1><A NAME="TABLE OF CONTENTS">TABLE OF CONTENTS</A></H1>
<UL>
<LI><A HREF="#INTRODUCTION">INTRODUCTION</A></LI>
<LI><A HREF="#SHAREWARE">SHAREWARE</A></LI>
<LI><A HREF="#INVOCATION">INVOCATION</A></LI>
<LI><A HREF="#ENVIRONMENT%20VARIABLES">ENVIRONMENT VARIABLES</A></LI>
<LI><A HREF="#EXIT%20CODES">EXIT CODES</A></LI>
<LI><A HREF="#SOURCE%20FILE%20FORMAT">SOURCE FILE FORMAT</A></LI>
<LI><A HREF="#EXPRESSIONS">EXPRESSIONS</A></LI>
<LI><A HREF="#ASSEMBLER%20DIRECTIVES">ASSEMBLER DIRECTIVES</A></LI>
<LI><A HREF="#OBJECT%20FILE%20FORMATS">OBJECT FILE FORMATS</A></LI>
<LI><A HREF="#LISTING%20FILE%20FORMAT">LISTING FILE FORMAT</A></LI>
<LI><A HREF="#PROM%20PROGRAMMING">PROM PROGRAMMING</A></LI>
<LI><A HREF="#ERROR%20MESSAGES">ERROR MESSAGES</A></LI>
<LI><A HREF="#LIMITATIONS">LIMITATIONS</A></LI></UL>
<HR>
<H1><A NAME="INTRODUCTION">INTRODUCTION</A></H1>
<P>The Telemark Assembler (TASM) is a table driven cross assembler for the
MS-DOS and LINUX environments.  Assembly source code, written in the appropriate
dialect (generally very close to the manufacturers assembly language), can be
assembled with TASM, and the resulting object code transferred to the target
microprocessor system via PROM or other mechanisms.</P>
<P>The microprocessor families supported by TASM are:</P>
<UL>
<LI>6502</LI>
<LI>6800/6801/68HC11</LI>
<LI>6805</LI>
<LI>8048</LI>
<LI>8051</LI>
<LI>8080/8085, Z80</LI>
<LI>TMS32010, TMS320C25</LI>
<LI>TMS7000</LI>
<LI>8096/80196</LI></UL>
<P>The user so inclined may build tables for other microprocessors.  The
descriptions of the various existing tables and instructions on building new
tables are not in this document but can be found in the TASMTABS.HTM file on the
TASM distribution disk.</P>
<P>TASM characteristics include:</P>
<OL>
<LI> Powerful expression parsing (17 operators).
</LI>
<LI> Supports a subset of the 'C' preprocessor commands.
</LI>
<LI> Macro capability (through use of DEFINE directive).
</LI>
<LI> Multiple statements per line.
</LI>
<LI> Four object file formats: Intel hex, MOS Technology hex, Motorola hex,
binary.
</LI>
<LI> Absolute code generation only.
</LI>
<LI> Source code available (in C).
</LI>
<LI> Uniform syntax across versions for different target machines.
</LI>
<LI> Features in support of PROM programming (preset memory, contiguous block).
</LI>
<LI> Supports extended instructions for many of the supported microprocessor
families.
</LI>
<LI> Tables read at run time - single TASM executable for all table versions.
</LI>
<LI> Symbol table export for inclusion in subsequent assemblies.
</LI>
<LI> Symbol table export file for import with some simulator products.</LI></OL>
<H1><A NAME="SHAREWARE">SHAREWARE</A></H1>
<P>TASM is distributed as shareware.  TASM is not in the public domain. The
TASM distribution files may be freely copied (excluding the source code files)
and freely used for the purpose of evaluating the suitability of TASM for a
given purpose. Use of TASM beyond a reasonable evaluation period requires
registration. Prolonged use without registration is unethical.</P>
<H1><A NAME="INVOCATION">INVOCATION</A></H1>
<P>TASM can be invoked as follows (optional fields shown in brackets, symbolic
fields in italics):</P>
<PRE>  tasm -pn [-options ...] <I>src_file</I> [<I>obj_file</I> [<I>lst_file</I> [<I>exp_file</I> [<I>sym_file</I>]]]]</PRE>
<P>Where <I>options</I> can be one or more of the following:</P>
<TABLE BORDER="BORDER">
<TR>
<TD ALIGN="Left" VALIGN="Top"> -<I>table</I> </TD>
<TD ALIGN="Left" VALIGN="Top">Specify version (<I>table</I> = table
designation) </TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">-t<I>table</I> </TD>
<TD ALIGN="Left" VALIGN="Top">Table (alternate form of above) </TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">-a<I>amask</I> </TD>
<TD ALIGN="Left" VALIGN="Top">Assembly control (optional error checking) </TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">-b </TD>
<TD ALIGN="Left" VALIGN="Top">Produce object in binary (.COM) format </TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">-c </TD>
<TD ALIGN="Left" VALIGN="Top">Object file written as a contiguous block </TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">-d<I>macro</I> </TD>
<TD ALIGN="Left" VALIGN="Top">Define a macro (or just a macro label) 
</TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">-e  </TD>
<TD ALIGN="Left" VALIGN="Top">Show source lines after macro expansion </TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">-f<I>fillbyte</I> </TD>
<TD ALIGN="Left" VALIGN="Top">Fill entire memory space with fillbyte (hex)
</TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">-g<I>objtype</I> </TD>
<TD ALIGN="Left" VALIGN="Top">Object file (0=Intel Hex, 1=MOS Tech, 2=Motorola,
3=binary,4=Intel Hex (Word)) </TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">-h </TD>
<TD ALIGN="Left" VALIGN="Top">Produce hex table of the assembled code (in list
file) </TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">-i  </TD>
<TD ALIGN="Left" VALIGN="Top">Ignore case for labels </TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">-l[al] </TD>
<TD ALIGN="Left" VALIGN="Top">Produce a label table in the listing </TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">-m </TD>
<TD ALIGN="Left" VALIGN="Top">Produce object in MOS Technology format </TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">-o<I>obytes</I> </TD>
<TD ALIGN="Left" VALIGN="Top">Bytes per object record (for hex obj formats)
</TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">-p[<I>lines</I>] </TD>
<TD ALIGN="Left" VALIGN="Top">Page the listing file (lines per page.
default=60) </TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">-q </TD>
<TD ALIGN="Left" VALIGN="Top">Quiet, disable the listing file </TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">-r<I>kb</I> </TD>
<TD ALIGN="Left" VALIGN="Top">Set read buffer size in Kbytes (default 2 Kbytes)
</TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">-s  </TD>
<TD ALIGN="Left" VALIGN="Top">Write a symbol table file </TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">-x[<I>xmask</I>] </TD>
<TD ALIGN="Left" VALIGN="Top">Enable extended instruction set (if any) </TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">-y </TD>
<TD ALIGN="Left" VALIGN="Top">Time the assembly  </TD></TR></TABLE>
<P>The filename parameters are defined as follows:</P>
<TABLE BORDER="BORDER">
<TR>
<TD ALIGN="Left" VALIGN="Top"><I>src_file </I></TD>
<TD ALIGN="Left" VALIGN="Top">Source file name </TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top"><I>obj_file </I></TD>
<TD ALIGN="Left" VALIGN="Top">Object code file name </TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top"><I>lst_file </I></TD>
<TD ALIGN="Left" VALIGN="Top">Listing file name </TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top"><I>exp_file </I></TD>
<TD ALIGN="Left" VALIGN="Top">Symbol export file (only if the EXPORT directive
is used).</TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top"><I>sym_file </I></TD>
<TD ALIGN="Left" VALIGN="Top">Symbol table file (only if the <B>-s</B> option
or the SYM/AVSYM directives are used).  </TD></TR></TABLE>
<P>The source file must be specified. If not, some usage information is
displayed. Default file names for all the other files are generated if they are
not explicitly provided. The filename is formed by taking the source filename
and changing the extension to one of the following:</P>
<TABLE BORDER="BORDER">
<TR>
<TD ALIGN="Left" VALIGN="Top"><STRONG>Extension </STRONG></TD>
<TD ALIGN="Left" VALIGN="Top"><STRONG>File type </STRONG></TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">.OBJ </TD>
<TD ALIGN="Left" VALIGN="Top">Object file </TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">.LST </TD>
<TD ALIGN="Left" VALIGN="Top">Listing file </TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">.EXP </TD>
<TD ALIGN="Left" VALIGN="Top">Symbol export file </TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">.SYM </TD>
<TD ALIGN="Left" VALIGN="Top">Symbol table file </TD></TR></TABLE>
<P>TASM has no built-in instruction set tables.  Instruction set definition
files are read at run time.  TASM determines which table to use based on the '-<I>table'</I>
field shown above.  For example, to assemble the code in a file called
<I>source.asm</I>, one would enter</P>
<TABLE>
<TR>
<TD ALIGN="Left"><TT>tasm -48   source.asm </TT></TD>
<TD ALIGN="Left">for an 8048 assembly  </TD></TR>
<TR>
<TD ALIGN="Left"><TT>tasm -65   source.asm </TT></TD>
<TD ALIGN="Left">for a  6502 assembly  </TD></TR>
<TR>
<TD ALIGN="Left"><TT>tasm -51   source.asm </TT></TD>
<TD ALIGN="Left">for an 8051 assembly. </TD></TR>
<TR>
<TD ALIGN="Left"><TT>tasm -85   source.asm </TT></TD>
<TD ALIGN="Left">for an 8085 assembly. </TD></TR>
<TR>
<TD ALIGN="Left"><TT>tasm -80   source.asm </TT></TD>
<TD ALIGN="Left">for a  Z80  assembly. </TD></TR>
<TR>
<TD ALIGN="Left"><TT>tasm -05   source.asm </TT></TD>
<TD ALIGN="Left">for a  6805 assembly. </TD></TR>
<TR>
<TD ALIGN="Left"><TT>tasm -68   source.asm </TT></TD>
<TD ALIGN="Left">for a  6800/6801/68HC11 assembly.  </TD></TR>
<TR>
<TD ALIGN="Left"><TT>tasm -70   source.asm </TT></TD>
<TD ALIGN="Left">for a  TMS7000  assembly.  </TD></TR>
<TR>
<TD ALIGN="Left"><TT>tasm -3210 source.asm </TT></TD>
<TD ALIGN="Left">for a  TMS32010 assembly.  </TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top"><TT>tasm -3225 source.asm </TT></TD>
<TD ALIGN="Left" VALIGN="Top">for a  TMS320C25 assembly.  
</TD></TR>
<TR>
<TD><TT>tasm -96   source.asm </TT></TD>
<TD>for a 8096/80196 assembly</TD></TR></TABLE>
<P>Tables are read from a file named by taking the digits specified after the
'-' and appending it to 'TASM' then appending the '.TAB' extension.  Thus, the
<B>-48</B> flag would cause the tables to be read from the file 'TASM48.TAB'.</P>
<P>It is possible to designate tables by non numeric part numbers if the <B>-t</B>
flag is used.  For example, if a user built a table called TASMF8.TAB then TASM
could be invoked as follows:</P>
<PRE>    tasm -tf8 source.asm</PRE>
<P>Each option flag must be preceded by a dash.  Options need not precede the
file names.  The various options are described in the sections that follow.</P>
<H2>a - Assembly Control</H2>
<P>TASM can provide additional error checking by specifying the <I>-a</I>
option at the time of execution.  If the <I>-a</I> is provided without a digit
following, then all the available error checking is done.  If a digit follows,
then it is used as a mask to determine the error checks to be made.  The bits of
the mask are defined as follows:</P>
<TABLE BORDER="BORDER">
<TR>
<TD ALIGN="CENTER" VALIGN="Top"><STRONG>Bit     </STRONG></TD>
<TD ALIGN="CENTER" VALIGN="Top"><STRONG>Option  </STRONG></TD>
<TD ALIGN="CENTER" VALIGN="Top"><STRONG>Default </STRONG></TD>
<TD ALIGN="Left" VALIGN="Top"><STRONG>Description </STRONG></TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top">0   </TD>
<TD ALIGN="CENTER" VALIGN="Top">-a1 </TD>
<TD ALIGN="CENTER" VALIGN="Top">OFF </TD>
<TD ALIGN="Left" VALIGN="Top">Check for apparent illegal use of indirection
</TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top">1   </TD>
<TD ALIGN="CENTER" VALIGN="Top">-a2 </TD>
<TD ALIGN="CENTER" VALIGN="Top">ON  </TD>
<TD ALIGN="Left" VALIGN="Top">Check for unused data in the arguments </TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top">2   </TD>
<TD ALIGN="CENTER" VALIGN="Top">-a4 </TD>
<TD ALIGN="CENTER" VALIGN="Top">ON  </TD>
<TD ALIGN="Left" VALIGN="Top">Check for duplicate labels </TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top">3   </TD>
<TD ALIGN="CENTER" VALIGN="Top">-a8 </TD>
<TD ALIGN="CENTER" VALIGN="Top">OFF </TD>
<TD ALIGN="Left" VALIGN="Top">Check for non-unary operators at start of
expression.  </TD></TR></TABLE>
<P>Combinations of the above bits can also be used.  For example, <I>-a5</I>
would enable the checking for illegal indirection and duplicate labels.
</P>
<P>Illegal indirection applies to micros that use parenthesis around an
argument to indicate indirection.  Since it is always legal to put an extra pair
of parenthesis around any expression  (as far as the expression parser is
concerned), the user may think that he/she is indicating indirection for an
instruction that has no indirection and TASM would not complain.  Enabling this
checking will result in an error message (warning) whenever an outer pair of
parenthesis is used and the instruction set definition table does not explicitly
indicate that to be a valid form of addressing.</P>
<P>Unused data in arguments applies to cases where a single byte of data is
needed from an argument, but the argument contains more than one byte of data. 
If a full sixteen bit address is used in a  'Load Immediate' type instruction
that needs only a single byte, for example, an error message would be generated.
Here is an example (6502 code):</P>
<PRE>    0001   1234                    .org $1234
    test.asm line 0002: Unused data in MS byte of argument.
    0002   1234 A9 34       start  lda  #start</PRE>
<P>To make the above checks occur whenever you do an assembly, add a line like
this to your AUTOEXEC.BAT file:</P>
<PRE>    SET TASMOPTS=-a</PRE>
<H2>b - Binary Object Format</H2>
<P>This option causes the object file to be written in binary  - one byte for
each byte of code/data.  Note that no address information is included in the
object file in this format. The contiguous block (-c) output mode is forced when
this option is invoked.  This flag is equivalent to <I>-g3</I>.</P>
<H2>c - Contiguous Block Output</H2>
<P>If this option is specified, then all bytes in the range from the lowest
used byte to the highest will be defined in the object file. Normally, with the
default Intel Hex object format enabled, if the Program Counter  (PC) jumps
forward because of an  .ORG directive, the bytes skipped over will not have any
value assigned them in the object file.  With this option enabled, no output to
the object file occurs until the end of the assembly at which time the whole
block is written.  This is useful when using TASM to generate code that will be
put into a PROM so that all locations will have a known value.  This option is
often used in conjunction with the -f option to ensure all unused bytes will
have a known value.</P>
<H2>d - Define a Macro</H2>
<P>Macros are defined on the command line generally to control the assembly of
various IFDEF's that are in the source file.   This is a convenient way to
generate various versions of object code from a single source file.</P>
<H2>e - Expand Source. </H2>
<P>Normally TASM shows lines in the listing file just as they are in the source
file. If macros are in use (via the DEFINE directive) it is sometimes desirable
to see the source lines after expansion.  Use the '-e' flag to accomplish this.</P>
<H2>f - Fill Memory.</H2>
<P>This option causes the memory image that TASM maintains to be initialized to
the value specified by the two hex characters immediately following the 'f'. 
TASM maintains a memory image that is a full 64K bytes in size (even if the
target processor cannot utilize that memory space).  Invocation of this option
introduces a delay at start up of up to 2 seconds (time required to initialize
all 64K bytes).</P>
<H2>g - Object File Format.</H2>
<P>TASM can generate object code in four different formats as indicated below:</P>
<TABLE BORDER="BORDER">
<TR>
<TD><STRONG>Option	</STRONG></TD>
<TD><STRONG>Description</STRONG></TD></TR>
<TR>
<TD ALIGN="CENTER">-g0 </TD>
<TD ALIGN="Left">Intel hex (default) </TD></TR>
<TR>
<TD ALIGN="CENTER">-g1 </TD>
<TD ALIGN="Left">MOS Technology hex (same as <B>-m</B>) </TD></TR>
<TR>
<TD ALIGN="CENTER">-g2 </TD>
<TD ALIGN="Left">Motorola hex </TD></TR>
<TR>
<TD ALIGN="CENTER">-g3 </TD>
<TD ALIGN="Left">binary (same as <B>-b</B>) </TD></TR>
<TR>
<TD ALIGN="CENTER">-g4 </TD>
<TD ALIGN="Left">Intel hex with word addresses</TD></TR></TABLE>
<P>The <B>-m</B> and <B>-b</B> flags may also be used, as indicated above. 
If both are used the right-most option on the command line will be obeyed.</P>
<P>See the section on <B>OBJECT FILE FORMATS</B> for descriptions of each of
the above.</P>
<H2>h - Hex Object Code Table. </H2>
<P>This option causes a hex table of the produced object code to appear in the
listing file.   Each line of the table shows sixteen bytes of code.</P>
<H2>i - Ignore Case in Labels.</H2>
<P>TASM is normally case sensitive when dealing with labels.  For those that
prefer case insensitivity, the  '-i' command line option can be employed.</P>
<H2>l - Label Table.</H2>
<P>This option causes a label table to appear in the listing file.  Each label
is shown with its corresponding value. Macro labels (as established via the
DEFINE directives) do not appear.</P>
<P>Two optional suffixes may follow the <B>-l</B> option:</P>
<TABLE BORDER="BORDER">
<TR>
<TD ALIGN="Left" VALIGN="Top"><STRONG>Suffix </STRONG></TD>
<TD ALIGN="Left" VALIGN="Top"><STRONG>Description </STRONG></TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top">l </TD>
<TD ALIGN="Left" VALIGN="Top">Use long form listing </TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top">a </TD>
<TD ALIGN="Left" VALIGN="Top">Show all labels (including local labels) </TD></TR></TABLE>
<P>The suffix should immediately follow the '-l'. Here are some examples:</P>
<TABLE>
<TR>
<TD ALIGN="Left" VALIGN="Top"><TT>-l </TT></TD>
<TD ALIGN="Left" VALIGN="Top">to show non-local labels in the short form </TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top"><TT>-la </TT></TD>
<TD ALIGN="Left" VALIGN="Top">to show all labels in the short form </TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top"><TT>-ll </TT></TD>
<TD ALIGN="Left" VALIGN="Top">to show non-local labels in the long form </TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top"><TT>-lal </TT></TD>
<TD ALIGN="Left" VALIGN="Top">to show all labels in the long form </TD></TR></TABLE>
<H2>m - MOS Technology Object Format.</H2>
<P>This option causes the object file to be written in MOS Technology hex
format rather than the default Intel hex format.  See section on OBJECT FILE
FORMATS for a description of the format.</P>
<H2>o - Set Number of Bytes per Object Record.</H2>
<P>When generating object code in either the MOS Technology format or the Intel
hex format, a default of 24 (decimal) bytes of object are defined on each
record. This can be altered by invoking the '-o' option immediately followed by
two hex digits defining the number of bytes per record desired. For example, if
32 bytes per record are desired, one might invoke TASM as:</P>
<PRE>    tasm -48 -o20 source.asm</PRE>
<H2>p - Page Listing File. </H2>
<P>This option causes the listing file to have top of page headers and form
feeds inserted at appropriate intervals (every sixty lines of output).  To
override the default of sixty lines per page, indicate the desired number of
lines per page as a decimal number immediately following the '-p'.  Here is an
example:</P>
<PRE>    tasm -48 -p56 source.asm</PRE>
<H2>q - Disable Listing File.</H2>
<P>This option causes all output to the listing file to be suppressed, unless a
.LIST directive is encountered in the source file (see LIST/NOLIST directives).</P>
<H2>r - Set Read Buffer Size.</H2>
<P>This option overrides the default read buffer size of 2 Kbytes.  The first
hexadecimal digit immediately after the 'r' is taken as the number of K bytes to
allocate for the read buffer  (.e.g. <B>-r8</B> indicates an 8K byte buffer,
<B>-rf</B> indicates a 15K byte buffer).  Note that that read buffers are taken
from the same memory pool as labels and macro storage, and that additional read
buffers are needed if &quot;includes&quot; are used.  Thus, using 8K byte
buffers may be suitable for most assemblies, but programs with large numbers of
symbols may not allow such a value. Also, reducing the buffer size to 1 Kbyte
can increase the memory pool available for label storage, if such is needed.</P>
<H2>s - Enable Symbol File Generation.</H2>
<P>If this flag is set, a symbol file is generated at the end of the assembly. 
The format of the file is one line per label, each label starts in the first
column and is followed by white space and then four hexadecimal digits
representing the value of the label.  The following illustrates the format:</P>
<PRE>    label1         FFFE
    label2         FFFF
    label3         1000</PRE>
<P>The symbol file name can be provided as the fifth file name on the command
line, or the name will be generated from the source file name with a '.SYM'
extension.  The symbol table file can also be generated by invoking the SYM
directive.  The AVSYM directive also generates the symbol file but in a
different format (see section on ASSEMBLER DIRECTIVES).</P>
<H2>t - Table Name.</H2>
<P>As an alternative to specifying the instruction set table as two decimal
digits, the table indication may be proceeded by the '-t' option. This is useful
if the desired table name starts with a non-numeric. Thus, a table for an F8
might be selected as:</P>
<PRE>    tasm -tf8 source.asm</PRE>
<P>TASM would expect to read the instruction set definition tables from a file
named TASMF8.TAB.</P>
<H2>x - Enable Extended Instruction Set.  </H2>
<P>If a processor family has instructions that are valid for only certain
members, this option can be used to enable those beyond the basic standard
instruction set. A hex digit may follow the 'x' to indicate a mask value used in
selecting the appropriate instruction set. Bit 0 of the mask selects the basic
instruction set, thus a '-x1' would have no effect. A  '-x3' would enable the
basic set plus whatever instructions have bit 1 set in their class mask. A '-x'
without a digit following is equivalent to a '-xf' which sets all four of the
mask bits. The following table indicates the current extended instruction sets
available in the TASM tables:</P>
<TABLE BORDER="BORDER">
<TR>
<TD ALIGN="Left" VALIGN="Top"><STRONG>Base Table  </STRONG></TD>
<TD ALIGN="Left" VALIGN="Top"><STRONG>Base Family </STRONG></TD>
<TD ALIGN="Left" VALIGN="Top"><STRONG>Ext 1 (-x3) </STRONG></TD>
<TD ALIGN="Left" VALIGN="Top"><STRONG>Ext 2 (-x7) </STRONG></TD>
<TD ALIGN="Left" VALIGN="Top"><STRONG>Ext 3 (-x5) </STRONG></TD>
<TD ALIGN="Left" VALIGN="Top"><STRONG>Ext 4 (-x9) </STRONG></TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">48 </TD>
<TD ALIGN="Left" VALIGN="Top"> 8048 
</TD>
<TD ALIGN="Left" VALIGN="Top">8041A
</TD>
<TD ALIGN="Left" VALIGN="Top"></TD>
<TD ALIGN="Left" VALIGN="Top">8022
</TD>
<TD ALIGN="Left" VALIGN="Top">8021
</TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">65
</TD>
<TD ALIGN="Left" VALIGN="Top">6502
</TD>
<TD ALIGN="Left" VALIGN="Top">R65C02
</TD>
<TD ALIGN="Left" VALIGN="Top"></TD>
<TD ALIGN="Left" VALIGN="Top">R65C00/21
</TD>
<TD ALIGN="Left" VALIGN="Top"></TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">05
</TD>
<TD ALIGN="Left" VALIGN="Top">6805
</TD>
<TD ALIGN="Left" VALIGN="Top">M146805 CMOS
</TD>
<TD ALIGN="Left" VALIGN="Top"></TD>
<TD ALIGN="Left" VALIGN="Top">HC05C4
</TD>
<TD ALIGN="Left" VALIGN="Top"></TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">80
</TD>
<TD ALIGN="Left" VALIGN="Top">Z80
</TD>
<TD ALIGN="Left" VALIGN="Top">HD64180
</TD>
<TD ALIGN="Left" VALIGN="Top"></TD>
<TD ALIGN="Left" VALIGN="Top"></TD>
<TD ALIGN="Left" VALIGN="Top"></TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">68
</TD>
<TD ALIGN="Left" VALIGN="Top">6800
</TD>
<TD ALIGN="Left" VALIGN="Top">6801/6803
</TD>
<TD ALIGN="Left" VALIGN="Top">68HC11
</TD>
<TD ALIGN="Left" VALIGN="Top"></TD>
<TD ALIGN="Left" VALIGN="Top"></TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">51
</TD>
<TD ALIGN="Left" VALIGN="Top">8051
</TD>
<TD ALIGN="Left" VALIGN="Top"></TD>
<TD ALIGN="Left" VALIGN="Top"></TD>
<TD ALIGN="Left" VALIGN="Top"></TD>
<TD ALIGN="Left" VALIGN="Top"></TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">85
</TD>
<TD ALIGN="Left" VALIGN="Top">8080
</TD>
<TD ALIGN="Left" VALIGN="Top"></TD>
<TD ALIGN="Left" VALIGN="Top"></TD>
<TD ALIGN="Left" VALIGN="Top"></TD>
<TD ALIGN="Left" VALIGN="Top"></TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">3210
</TD>
<TD ALIGN="Left" VALIGN="Top">TMS32010
</TD>
<TD ALIGN="Left" VALIGN="Top"></TD>
<TD ALIGN="Left" VALIGN="Top"></TD>
<TD ALIGN="Left" VALIGN="Top"></TD>
<TD ALIGN="Left" VALIGN="Top"></TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">3225
</TD>
<TD ALIGN="Left" VALIGN="Top">TMS320C25
</TD>
<TD ALIGN="Left" VALIGN="Top"></TD>
<TD ALIGN="Left" VALIGN="Top"></TD>
<TD ALIGN="Left" VALIGN="Top">TMS320C26
</TD>
<TD ALIGN="Left" VALIGN="Top"></TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">70
</TD>
<TD ALIGN="Left" VALIGN="Top">TMS7000
</TD>
<TD ALIGN="Left" VALIGN="Top"></TD>
<TD ALIGN="Left" VALIGN="Top"></TD>
<TD ALIGN="Left" VALIGN="Top"></TD>
<TD ALIGN="Left" VALIGN="Top"></TD></TR></TABLE>
<P>The above table does not attempt to show the many microprocessor family
members that may apply under a given column.</P>
<P>See the TASMTABS.TXT on-line document for details on each specific table.</P>
<H2>y - Enable Assembly Timing</H2>
<P>If this option is enabled TASM will generate a statement of elapsed time and
assembled lines per second at the end of the assembly.</P>
<H1><A NAME="ENVIRONMENT VARIABLES">ENVIRONMENT VARIABLES</A></H1>
<P>The TASM environment can be customized by using the environment variables
listed below:</P>
<H2>TASMTABS</H2>
<P>The TASMTABS variable specifies the path to be searched for TASM instruction
set definition tables. If it is not defined then the table(s) must exist in the
current working directory.  The following examples illustrate possible usage:</P>
<TABLE>
<TR>
<TD>For MSDOS    </TD>
<TD><TT>set TASMTABS=C:\TASM</TT></TD></TR>
<TR>
<TD>For LINUX    </TD>
<TD><TT>TASMTABS=/tasm</TT></TD></TR></TABLE>
<H2>TASMOPTS</H2>
<P>This variable specifies TASM command line options that are to be invoked
every time TASM is executed. For example, if TASM is being used for 8048
assemblies with binary object file output desired, the following statement would
be appropriate in the AUTOEXEC.BAT file:</P>
<PRE>    set TASMOPTS=-48 -b</PRE>
<H1><A NAME="EXIT CODES">EXIT CODES</A></H1>
<P>When TASM terminates, it will return to the OS the following exit codes:</P>
<TABLE BORDER="BORDER">
<TR>
<TD ALIGN="Left" VALIGN="Top"><STRONG>Exit Code </STRONG></TD>
<TD ALIGN="Left" VALIGN="Top"><B>Definition</B></TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top">0 </TD>
<TD ALIGN="Left" VALIGN="Top">Normal completion, no assembly errors </TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top">1 </TD>
<TD ALIGN="Left" VALIGN="Top">Normal completion, with assembly errors </TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top">2 </TD>
<TD ALIGN="Left" VALIGN="Top">Abnormal completion, insufficient memory </TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top">3 </TD>
<TD ALIGN="Left" VALIGN="Top">Abnormal completion, file access error </TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top">4 </TD>
<TD ALIGN="Left" VALIGN="Top">Abnormal completion, general error </TD></TR></TABLE>
<P>Exit codes 2 and above will also be accompanied by messages to the console
concerning the error.</P>
<H1><A NAME="SOURCE FILE FORMAT">SOURCE FILE FORMAT</A></H1>
<P>Statements in the source file must conform to a format as follows (except
for assembler directive statements which are described in a subsequent section):</P>
<P><I>label  operation    operand       comment</I></P>
<P>All of the fields are optional, under appropriate circumstances. An
arbitrary amount of white space (space and tabs) can separate each field (as
long as the maximum line length of 255 characters is not exceeded). Each of the
fields are described in the following sections.</P>
<H2>Label Field.</H2>
<P>If the first character of the line is alphabetic, it is assumed to be the
start of a label. Subsequent characters are accepted as part of that label until
a space, tab, or ':' is encountered. The assembler assigns a value to the label
corresponding to the current location counter. Labels can be a maximum of 32
characters long. Labels can contain upper and lower case letters, digits,
underscores, and periods (the first character must be alphabetic).  Labels are
case sensitive - the label 'START' is a different label from 'start' - unless
the '-i' (ignore case) option is enabled.</P>
<H2>Operation Field.</H2>
<P>The operation field contains an instruction mnemonic which specifies the
action to be carried out by the target processor when this instruction is
executed. The interpretation of each mnemonic is dependent on the target
microprocessor  (as indicated by the selected TASM table). The operation field
may begin in any column except the first. The operation field is case
insensitive.</P>
<H2>Operand Field.</H2>
<P>The operand field specifies the data to be operated on by the instruction.
It may include expressions and/or special symbols describing the addressing mode
to be used. The actual format and interpretation is dependent on the target
processor. For a description of the format for currently supported processors,
see the TASMTABS.DOC file on the TASM distribution disk.</P>
<H2>Comment Field. </H2>
<P>The comment field always begins with a semicolon. The rest of the line from
the semicolon to the end of the line is ignored by TASM, but passed on to the
listing file for annotation purposes.  The comment field must be the last field
on a line, but it may be the only field, starting in column one, if desired.</P>
<H2>Multiple Statement Lines.</H2>
<P>If the backslash character is encountered on a source line, it is treated as
a newline.  The remainder of the line following the backslash will be processed
as an independent line of source code. This allows one to put multiple
statements on a line. This facility is not so useful of itself, but when coupled
with the capability of the DEFINE directive, powerful multiple statement macros
can be constructed  (see section on <B>ASSEMBLER DIRECTIVES</B>). Note that
when using the statement separator, the character immediately following it
should be considered the first character of a new line, and thus must either be
a start of a label or white space (not an instruction). As the examples show, a
space is put between the backslash and the start of the next instruction.</P>
<H2>Sample Source Listing.</H2>
<P>Some examples of valid source statements follow (6502 mnemonics shown):</P>
<PRE>  lab1       lda    byte1   ;get the first byte
             dec    byte1
             jne    label1
  ;            
  lab2       sta    byte2,X
  ;  a multiple statement line follows
             lda    byte1\ sta byte1+4\ lda byte2\ sta byte2+4</PRE>
<H1><A NAME="EXPRESSIONS">EXPRESSIONS</A></H1>
<P>Expressions are made up of various syntactic elements combined according to
a set of syntactical rules.  Expressions can be comprised of the following
elements:</P>
<UL>
<LI>Labels</LI>
<LI>Constants</LI>
<LI>Location Counter Symbol</LI>
<LI>Operators</LI>
<LI>Parenthesis</LI></UL>
<H2>Labels</H2>
<P>Labels are strings of characters that have a numeric value associated with
them, generally representing an address.  Labels can contain upper and lower
case letters, digits, underscores, and periods.  The first character must be a
letter or the local label prefix  (default '_'). The value of a label is limited
to 32 bit precision.  Labels can contain up to 32 characters, all of which are
significant (none are ignored when looking at a label's value, as in some
assemblers).  Case is significant unless the  '-i' command line option is
invoked.</P>
<P>Local labels must only be unique within the scope of the current module. 
Modules are defined with the MODULE directive. Here is an example:</P>
<PRE>          .MODULE xxx
          lda regx
          jne _skip
          dec
   _skip  rts
          .MODULE yyy
          lda regy
          jne _skip
          dec
   _skip  rts
</PRE>
<P>In the above example, the<I> _skip</I> label is reused without harm.  As a
default, local labels are not shown in the label table listing (resulting from
the  '-l' command line option).  See also sections on MODULE and LOCALLABELCHAR
directives.</P>
<H2>Numeric Constants</H2>
<P>Numeric constants must always begin with a decimal digit (thus hexadecimal
constants that start with a letter must be prefixed by a '0' unless the  '$'
prefix is used). The radix is determined by a letter immediately following the
digit string according to the following table:</P>
<TABLE BORDER="BORDER">
<TR>
<TD ALIGN="Left" VALIGN="Top"><STRONG>Radix </STRONG></TD>
<TD ALIGN="Left" VALIGN="Top"><STRONG>Suffix </STRONG></TD>
<TD ALIGN="Left" VALIGN="Top"><STRONG>Prefix </STRONG></TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top">2 </TD>
<TD ALIGN="Left" VALIGN="Top">B or b </TD>
<TD ALIGN="CENTER" VALIGN="Top">% </TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top">8 </TD>
<TD ALIGN="Left" VALIGN="Top">O or o </TD>
<TD ALIGN="CENTER" VALIGN="Top">@ </TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top">10 </TD>
<TD ALIGN="Left" VALIGN="Top">D or d (or nothing) </TD>
<TD ALIGN="Left" VALIGN="Top"></TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top">16 </TD>
<TD ALIGN="Left" VALIGN="Top">H or h </TD>
<TD ALIGN="CENTER" VALIGN="Top">$ </TD></TR></TABLE>
<P>Decimal is the default radix, so decimal constants need no suffix or prefix.</P>
<P>The following representations are equivalent:</P>
<PRE>    1234H          or     $1234
    100d           or     100
    177400o        or     @177400
    01011000b      or     %01011000
</PRE>
<P>The prefixes are provided for compatibility with some other source code
formats but introduce a problem of ambiguity.  Both '%' and  '$' have alternate
uses ('%' for modulo,  '$' for location counter symbol).  The ambiguity is
resolved by examining the context. The '%' character is interpreted as the
modulo operator only if it is in a position suitable for a binary operator.
Similarly, if the first character following a '$' is a valid hexadecimal digit,
it is assumed to be a radix specifier and not the location counter.</P>
<H2>Character Constants</H2>
<P>Character constants are single characters surrounded by single quotes. The
ASCII value of the character in the quotes is returned.  No escape provision
exists to represent non-printable characters within the quotes, but this is not
necessary since these can be just as easily represented as numeric constants (or
using the TEXT directive which does allow escapes).</P>
<H2>String Constants.</H2>
<P>String constants are one or more characters surrounded by double quotes. 
Note that string constants are not allowed in expressions.  They are only
allowable following the TITLE, BYTE, DB, and TEXT assembler directives. The
quoted strings may also contain escape sequences to put in unprintable values. 
The following escape sequences are supported:</P>
<TABLE BORDER="BORDER">
<TR>
<TD ALIGN="Left" VALIGN="Top"><STRONG>Escape Sequence </STRONG></TD>
<TD ALIGN="Left" VALIGN="Top"><STRONG>Description</STRONG> </TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top">\n </TD>
<TD ALIGN="Left" VALIGN="Top">Line Feed </TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top">\r </TD>
<TD ALIGN="Left" VALIGN="Top">Carriage return </TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top">\b </TD>
<TD ALIGN="Left" VALIGN="Top">Backspace </TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top">\t </TD>
<TD ALIGN="Left" VALIGN="Top">Tab </TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top">\f </TD>
<TD ALIGN="Left" VALIGN="Top">Formfeed </TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top">\\ </TD>
<TD ALIGN="Left" VALIGN="Top">Backslash </TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top">\&quot; </TD>
<TD ALIGN="Left" VALIGN="Top">Quote </TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top">\000 </TD>
<TD ALIGN="Left" VALIGN="Top">Octal value of character </TD></TR></TABLE>
<H2>Location Counter Symbol</H2>
<P>The current value of the location counter (PC) can be used in expressions by
placing a  '$' in the desired place.  The Location Counter Symbol is allowable
anywhere a numeric constant is.   (Note that if the '$' is followed by a decimal
digit then it is taken to be the hexadecimal radix indicator instead of the
Location Counter symbol, as mentioned above).  The '*' may also be used to
represent the location counter, but is less preferred because of its ambiguity
with the multiplicative operator.</P>
<H2>Operators</H2>
<P>Expressions can optionally contain operators to perform some alterations or
calculations on particular values.  The operators are summarized as follows:</P>
<TABLE BORDER="BORDER">
<TR>
<TD ALIGN="CENTER" VALIGN="Top"><STRONG>Operator </STRONG></TD>
<TD ALIGN="CENTER" VALIGN="Top"><STRONG>Type </STRONG></TD>
<TD ALIGN="Left" VALIGN="Top"><STRONG>Description </STRONG></TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top">+ </TD>
<TD ALIGN="CENTER" VALIGN="Top">Additive
</TD>
<TD ALIGN="Left" VALIGN="Top">addition
</TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top">-
</TD>
<TD ALIGN="Left" VALIGN="Top"></TD>
<TD ALIGN="Left" VALIGN="Top">subtraction
</TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top">*
</TD>
<TD ALIGN="Left" VALIGN="Top">Multiplicative
</TD>
<TD ALIGN="Left" VALIGN="Top">multiplication
</TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top">/
</TD>
<TD ALIGN="Left" VALIGN="Top"></TD>
<TD ALIGN="Left" VALIGN="Top">division
</TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top">%
</TD>
<TD ALIGN="Left" VALIGN="Top"></TD>
<TD ALIGN="Left" VALIGN="Top">modulo
</TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top">&lt;&lt;</TD>
<TD ALIGN="Left" VALIGN="Top"></TD>
<TD ALIGN="Left" VALIGN="Top">logical shift left
</TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top">&gt;&gt; 
</TD>
<TD ALIGN="Left" VALIGN="Top"></TD>
<TD ALIGN="Left" VALIGN="Top">logical shift right
</TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top">~ 
</TD>
<TD ALIGN="Left" VALIGN="Top">Unary
</TD>
<TD ALIGN="Left" VALIGN="Top">bit inversion (one's complement)
</TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top">-
</TD>
<TD ALIGN="Left" VALIGN="Top"></TD>
<TD ALIGN="Left" VALIGN="Top">unary negation
</TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top">=
</TD>
<TD ALIGN="Left" VALIGN="Top">Relational
</TD>
<TD ALIGN="Left" VALIGN="Top">equal
</TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top">==
</TD>
<TD ALIGN="Left" VALIGN="Top"></TD>
<TD ALIGN="Left" VALIGN="Top">equal
</TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top">!=
</TD>
<TD ALIGN="Left" VALIGN="Top"></TD>
<TD ALIGN="Left" VALIGN="Top">not equal
</TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top">&lt;</TD>
<TD ALIGN="Left" VALIGN="Top"></TD>
<TD ALIGN="Left" VALIGN="Top">less than
</TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top">&gt;</TD>
<TD ALIGN="Left" VALIGN="Top"></TD>
<TD ALIGN="Left" VALIGN="Top">greater than
</TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top">&lt;= 
</TD>
<TD ALIGN="Left" VALIGN="Top"></TD>
<TD ALIGN="Left" VALIGN="Top">less than or equal
</TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top">&gt;= 
</TD>
<TD ALIGN="Left" VALIGN="Top"></TD>
<TD ALIGN="Left" VALIGN="Top">greater than or equal
</TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top">&amp;</TD>
<TD ALIGN="Left" VALIGN="Top">Binary
</TD>
<TD ALIGN="Left" VALIGN="Top"> binary 'and' </TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top"> | </TD>
<TD ALIGN="Left" VALIGN="Top"></TD>
<TD ALIGN="Left" VALIGN="Top"> binary 'or' </TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top"> ^ </TD>
<TD ALIGN="Left" VALIGN="Top"></TD>
<TD ALIGN="Left" VALIGN="Top">binary 'exclusive or'
</TD></TR></TABLE>
<P>The syntax is much the same as in 'C' with the following notes:</P>
<OL>
<LI> No operator precedence is in effect.  Evaluation is from left to right
unless grouped by parenthesis (see example below).
</LI>
<LI> All evaluations are done with 32 bit signed precision.
</LI>
<LI> Both '=' and '==' are allowable equality checkers.  This is allowed since
the syntax does not provide assignment capability (as  '=' would normally
imply).
</LI></OL>
<P>The relational operators return a value of 1 if the relation is true and 0
if it is false.  Thirty-two bit signed arithmetic is used.</P>
<P>It is always a good idea to explicitly indicate the desired order of
evaluation with parenthesis, especially to maintain portability since TASM does
not evaluate expressions in the same manner as many other assemblers.   To
understand how it does arrive at the values for expressions, consider the
following example:</P>
<PRE>    1 + 2*3 + 4</PRE>
<P>TASM would evaluate this as:</P>
<PRE>    (((1 + 2) * 3) + 4) = 13</PRE>
<P>Typical rules of precedence would cause the (2*3) to be evaluated first,
such as:</P>
<PRE>    1 + (2*3) + 4      = 11</PRE>
<P>To make sure you get the desired order of evaluation, use parenthesis
liberally. Here are some examples of valid expressions:</P>
<PRE>    (0f800H + tab)
    (label_2 &gt;&gt; 8)
    (label_3 &lt;&lt; 8) &amp; $f000
    $ + 4
    010010000100100b + 'a'
    (base + ((label_4 &gt;&gt; 5) &amp; (mask &lt;&lt; 2))
</PRE>
<H1><A NAME="ASSEMBLER DIRECTIVES">ASSEMBLER DIRECTIVES</A></H1>
<P>Most of the assembler directives have a format similar to the machine
instruction format. However, instead of specifying operations for the processor
to carry out, the directives cause the assembler to perform some function
related to the assembly process. TASM has two types of assembler directives -
those that mimic the 'C' preprocessor functions, and those that resemble the
more traditional assembler directive functions.  Each of these will be
discussed.</P>
<P>The 'C' preprocessor style directives are invoked with a  '#' as the first
character of the line followed by the appropriate directive (just as in 'C').
Thus, these directives cannot have a label preceding them (on the same line).
Note that in the examples directives are shown in upper case, however, either
upper or lower case is acceptable.</P>
<H2>ADDINSTR</H2>
<P>The ADDINSTR directive can be used to define additional instructions for
TASM to use in this assembly.  The format is:</P>
<PRE>    [<I>label</I>] .ADDINSTR <I>inst args opcode nbytes rule class shift binor</I></PRE>
<P>The fields are separated by white space just as they would appear in an
instruction definition file.  See the TASMTABS.TXT file on the TASM distribution
disk for more detail.</P>
<H2>AVSYM</H2>
<P>See SYM/AVSYM.</P>
<H2>BLOCK</H2>
<P>The BLOCK directive causes the Instruction Pointer to advance the specified
number of bytes without assigning values to the skipped over locations.  The
format is:</P>
<PRE>    [<I>label</I>] .BLOCK        <I>expr</I></PRE>
<P>Some valid examples are:</P>
<PRE>    word1   .BLOCK     2
    byte1   .block     1
    buffer  .block     80
</PRE>
<H2>BSEG/CSEG/DSEG/NSEG/XSEG</H2>
<P>These directives can be invoked to indicate the appropriate address space
for symbols and labels defined in the subsequent code.  The invocation of these
directives in no way affects the code generated, only provides more information
in the symbol table file if the AVSYM directive is employed. Segment control
directives such as these are generally supported by assemblers that generate
relocatable object code. TASM does not generate relocatable object code and does
not support a link phase, so these directives have no direct effect on the
resulting object code. The segments are defined as follows:</P>
<TABLE BORDER="BORDER">
<TR>
<TD ALIGN="CENTER" VALIGN="Top"><STRONG>Directive </STRONG></TD>
<TD ALIGN="Left" VALIGN="Top"><STRONG>Segment Description </STRONG></TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top">BSEG </TD>
<TD ALIGN="Left" VALIGN="Top">Bit address </TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top">CSEG </TD>
<TD ALIGN="Left" VALIGN="Top">Code address </TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top">DSEG </TD>
<TD ALIGN="Left" VALIGN="Top">Data address (internal RAM) </TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top">NSEG </TD>
<TD ALIGN="Left" VALIGN="Top">Number or constant (EQU) </TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top">XSEG </TD>
<TD ALIGN="Left" VALIGN="Top">External data address (external RAM) </TD></TR></TABLE>
<H2>BYTE</H2>
<P>The BYTE directive allows a value assignment to the byte pointed to by the
current Instruction Pointer.  The format is:</P>
<PRE>    [<I>label</I>] .BYTE   <I>expr</I> [, <I>expr</I> ...]</PRE>
<P>Only the lower eight bits of <I>expr</I> are used. Multiple bytes may be
assigned by separating them with commas or (for printable strings) enclosed in
double quotes. Here are some examples:</P>
<PRE>    label1   .BYTE     10010110B
             .byte     'a'
             .byte     0
             .byte     100010110b,'a',0
             .byte     &quot;Hello&quot;, 10, 13, &quot;World&quot;
</PRE>
<H2>CHK</H2>
<P>The CHK directive causes a checksum to be computed and deposited at the
current location. The starting point of the checksum calculation is indicated as
an argument. Here is the format:</P>
<PRE>    [<I>label</I>]    .CHK    <I>starting_addr</I></PRE>
<P>Here is an example:</P>
<PRE>    start: NOP
           LDA #1
           .CHK start
</PRE>
<P>The checksum is calculated as the simple arithmetic sum of all bytes
starting at the <I>starting_addr</I> up to but not including the address of the
CHK directive.  The least significant byte is all that is used.</P>
<H2>CODES/NOCODES</H2>
<P>The CODES/NOCODES directives can be used to alternately turn on or off the
generation of formatted listing output with line numbers, opcodes, data, etc.
With NOCODES in effect, the source lines are sent to the listing file untouched.
 This is useful around blocks of comments that need a full 80 columns of width
for clarity.</P>
<H2>DB</H2>
<P>This is alternate form of the BYTE directive.</P>
<H2>DW</H2>
<P>This is alternate form of the WORD directive.</P>
<H2>DEFINE</H2>
<P>The DEFINE directive is one of the most powerful of the directives and
allows string substitution with optional arguments (macros).  The format is as
follows:</P>
<PRE>    #DEFINE  <I>macro_label</I>[(<I>arg_list</I>)]  [<I>macro_definition</I>]</PRE>
<P>Where:</P>
<DL>
<DT><I>macro_label</I></DT>
<DD>character string to be expanded when found in the source file</DD>
<DT><I>arg_list</I></DT>
<DD>optional argument list for variable substitution in macro expansion</DD>
<DT><I>macro_def</I></DT>
<DD>string to replace the occurrences of <I>macro_label</I> in the source
file.</DD></DL>
<P>The simplest form of the DEFINE directive might look like this:</P>
<PRE>    #DEFINE         MLABEL</PRE>
<P>Notice that no substitutionary string is specified. The purpose of a
statement like this would typically be to define a label for the purpose of
controlling some subsequent conditional assembly (IFDEF or IFNDEF).</P>
<P>A more complicated example, performing simple substitution, might look like
this:</P>
<PRE>    #DEFINE         VAR1_LO         (VAR1 &amp; 255)</PRE>
<P>This statement would cause all occurrences of the string  'VAR1_LO' in the
source to be substituted with '(VAR1 &amp; 255)'.</P>
<P>As a more complicated example, using the argument expansion capability,
consider this:</P>
<PRE>    #DEFINE  ADD(xx,yy)    clc\ lda xx\ adc yy\ sta xx</PRE>
<P>If the source file then contained a line like this:</P>
<PRE>    ADD(VARX,VARY)</PRE>
<P>It would be expanded to:</P>
<PRE>    clc\ lda VARX\ adc VARY\ sta VARX</PRE>
<P>The above example shows the use of the backslash ('\') character as a
multiple instruction statement delimiter. This approach allows the definition of
fairly powerful, multiple statement macros. The example shown generates 6502
instructions to add one memory location to another.</P>
<P>Some rules associated with the argument list:</P>
<OL>
<LI> Use a maximum of 10 arguments.
</LI>
<LI> Each argument should be a maximum of 15 characters.
</LI></OL>
<P>Note that macros can be defined on the TASM command line, also, with the
<STRONG>-d</STRONG> option flag.</P>
<H2>DEFCONT</H2>
<P>The DEFCONT directive can be used to add to the last macro started with a
DEFINE directive.  This provides a convenient way to define long macros without
running off the edge of the page. The ADD macro shown above could be defined as
follows:</P>
<PRE>    #DEFINE         ADD(xx,yy)     clc
    #DEFCONT                     \ lda xx
    #DEFCONT                     \ adc yy
    #DEFCONT                     \ sta xx</PRE>
<H2>ECHO</H2>
<P>The ECHO directive can be used to send output to the console (stderr). It
can accept either a quoted text string (with the standard escape sequences
allowed) or a valid expression.  It can accept only one or the other, however.
Multiple instances of the directive may be used to create output that contains
both. Consider the following example:</P>
<PRE>    .ECHO &quot;The size of the table is &quot;
    .ECHO (table_end - table_start)
    .ECHO &quot; bytes long.\n&quot;
</PRE>
<P>This would result in a single line of output something like this:</P>
<PRE>    The size of the table is 196 bytes long.</PRE>
<H2>EJECT</H2>
<P>The EJECT directive can be used to force a top-of-form and the generation of
a page header on the list file.  It has no effect if the paging mode is off (see
PAGE/NOPAGE).  The format is:</P>
<PRE>    [<I>label</I>]    .EJECT</PRE>
<H2>ELSE</H2>
<P>The ELSE directive can optionally be used with IFDEF, IFNDEF and IF to
delineate an alternate block of code to be assembled if the block immediately
following the IFDEF, IFNDEF or IF is not assembled.</P>
<P>Here are some examples of the use of IFDEF, IFNDEF, IF, ELSE, and ENDIF:</P>
<PRE>    #IFDEF   label1
        lda      byte1
        sta      byte2
    #ENDIF   

    #ifdef   label1
        lda      byte1
    #else    
        lda      byte2
    #endif   

    #ifndef  label1
        lda      byte2
    #else    
        lda      byte1
    #endif   

    #if ($ &gt;= 1000h)
    ; generate an invalid statement to cause an error
    ;  when we go over the 4K boundary.
    !!! PROM bounds exceeded.
    #endif
</PRE>
<H2>END</H2>
<P>The END directive should follow all code/data generating statements in the
source file. It forces the last record to be written to the object file. The
format is:</P>
<PRE>    [<I>label</I>]       .END [<I>addr</I>]</PRE>
<P>The optional <I>addr</I> will appear in the last object record (Motorola S9
record type) if the object format is Motorola hex.  The <I>addr</I> field is
ignored for all other object formats.</P>
<H2>ENDIF</H2>
<P>The ENDIF directive must always follow an IFDEF, IFNDEF, or IF directive and
signifies the end of the conditional block.</P>
<H2>EQU</H2>
<P>The EQU directive can be used to assign values to labels. The labels can
then be used in expressions in place of the literal constant.  The format is:</P>
<PRE>    <I>label</I>   .EQU   <I>expr</I></PRE>
<P>Here is an example:</P>
<PRE>    MASK   .EQU  0F0H
    ;
           lda   IN_BYTE
           and   MASK
           sta   OUT_BYTE
</PRE>
<P>An alternate form of the EQU directive is '='.  The previous example is
equivalent to any of the following:</P>
<PRE>    MASK    =   0F0H
    MASK    =0F0H
    MASK    =$F0
</PRE>
<P>White space must exist after the <I>label</I>, but none is required after
the '='.</P>
<H2>EXPORT</H2>
<P>The EXPORT directive can be used to define labels (symbols) that are to be
written to the export symbol file.  The symbols are written as equates (using
the .EQU directive) so that the resulting file can be included in a subsequent
assembly.  This feature can help overcome some of the deficiencies of TASM due
to its lack of a relocating linker. The format is:</P>
<PRE>    [<I>label</I>]  .EXPORT      <I>label</I> [,<I>label</I>...]</PRE>
<P>The following example illustrates the use of the EXPORT directive and the
format of the resulting export file:</P>
<P>Source file:</P>
<PRE>    EXPORT        read_byte
    EXPORT        write_byte, open_file
</PRE>
<P>Resulting export file:</P>
<PRE>    read_byte      .EQU   $1243
    write_byte     .EQU   $12AF
    open_file      .EQU   $1301
</PRE>
<H2>FILL</H2>
<P>The FILL directive can be used to fill a selected number of object bytes
with a fixed value.  Object memory is filled from the current program counter
forward.  The format is as follows:</P>
<PRE>    [<I>label</I>]  .FILL      <I>number_of_bytes</I> [,<I>fill_value</I>]</PRE>
<P>The <I>number_of_bytes</I> value can be provided as any valid expression. 
The optional fill_value can also be any valid expression.  If <I>fill_value</I>
is not provided, a default value of 255 ($FF) is used.</P>
<H2>IFDEF</H2>
<P>The IFDEF directive can be used to optionally assemble a block of code.  It
has the following form:</P>
<PRE>    #IFDEF  macro_label</PRE>
<P>When invoked, the list of macro labels (established via DEFINE directives)
is searched.  If the label is found, the following lines of code are assembled. 
If not found, the input file is skipped until an ENDIF or ELSE directive is
found.</P>
<P>Lines that are skipped over still appear in the listing file, but a '~' will
appear immediately after the current PC and no object code will be generated
(this is applicable to IFDEF, IFNDEF, and IF).</P>
<H2>IFNDEF</H2>
<P>The IFNDEF directive is the opposite of the IFDEF directive.  The block of
code following is assembled only if the specified <I>macro_label</I> is
undefined.  It has the following form:</P>
<PRE>    #IFNDEF  <I>macro_label</I></PRE>
<P>When invoked, the list of macro labels (established via DEFINE directives)
is searched.  If the label is not found, the following lines of code are
assembled. If it is found, the input file is skipped until an ENDIF or  ELSE
directive is found.</P>
<H2>IF</H2>
<P>The IF directive can be used to optionally assemble a block of code
dependent on the value of a given expression.  The format is as follows:</P>
<PRE>    #IF     <I>expr</I></PRE>
<P>If the expression <I>expr</I> evaluates to non-zero, the following block of
code is assembled (until an ENDIF or ELSE is encountered).</P>
<H2>INCLUDE</H2>
<P>The INCLUDE directive reads in and assembles the indicated source file.
INCLUDEs can be nested up to six levels.   This allows a convenient means to
keep common definitions, declarations, or subroutines in files to be included as
needed.  The format is as follows:</P>
<PRE>#INCLUDE        <I>filename</I></PRE>
<P>The <I>filename</I> must be enclosed in double quotes.  Here are some
examples:</P>
<PRE>    #INCLUDE       &quot;macros.h&quot;
    #include       &quot;equates&quot;
    #include       &quot;subs.asm&quot;
</PRE>
<H2>LIST/NOLIST</H2>
<P>The LIST and NOLIST directives can be used to alternately turn the output to
the list file on (LIST) or off (NOLIST).  The formats are:</P>
<PRE>    .LIST
    .NOLIST
</PRE>
<H2>LOCALLABELCHAR</H2>
<P>The LOCALLABELCHAR directive can be used to override the default &quot;_&quot;
as the label prefix indicating a local label.  For example, to change the prefix
to &quot;?&quot; do this:</P>
<PRE>    [<I>label</I>]   .LOCALLABELCHAR &quot;?&quot;</PRE>
<P>Be careful to use only characters that are not operators for expression
evaluation. To do so causes ambiguity for the expression evaluator.  Some safe
characters are &quot;?&quot;, &quot;{&quot;, and &quot;}&quot;.</P>
<H2>LSFIRST/MSFIRST</H2>
<P>The LSFIRST and MSFIRST directives determine the byte order rule to be
employed for the WORD directive.  The default (whether correct or not) for all
TASM versions is the least significant byte first (LSFIRST).  The following
illustrates its effect:</P>
<PRE>    0000  34 12    .word $1234
    0002           .msfirst
    0002  12 34    .word $1234
    0004           .lsfirst
    0004  34 12    .word $1234
</PRE>
<H2>MODULE</H2>
<P>The MODULE directive defines the scope of local labels.  The format is:</P>
<PRE>    [<I>label</I>]   .MODULE <I>label</I></PRE>
<P>Here is an example:</P>
<PRE>          .MODULE module_x
          lda regx
          jne _skip
          dec
   _skip  rts
          .MODULE module_y
          lda regy
          jne _skip
          dec
   _skip  rts
</PRE>
<P>In the above example, the local label<I> _skip</I> is reused without harm
since the two usages are in separate modules.   See also section LOCALLABELCHAR
directive.</P>
<H2>ORG</H2>
<P>The ORG directive provides the means to set the Instruction Pointer (a.k.a.
Program Counter) to the desired value.  The format is:</P>
<PRE>    [<I>label</I>] .ORG    <I>expr</I></PRE>
<P>The <I>label</I> is optional.  The Instruction pointer is assigned the
value of the <I>expr</I>.  For example, to generate code starting at address
1000H, the following could be done:</P>
<PRE>    start   .ORG    1000H</PRE>
<P>The expression (<I>expr</I>) may contain references to the current
Instruction Pointer, thus allowing various manipulations to be done.  For
example, to align the Instruction Pointer on the next 256 byte boundary, the
following could be done:</P>
<PRE>    .ORG  (($ + 0FFH) &amp; 0FF00H)</PRE>
<P>ORG can also be used to reserve space without assigning values:</P>
<PRE>    .ORG    $+8</PRE>
<P>An alternate form of ORG is '*=' or '$='. Thus the following two examples
are exactly equivalent to the previous example:</P>
<PRE>    *=*+8
    $=$+8
</PRE>
<H2>PAGE/NOPAGE</H2>
<P>The PAGE/NOPAGE directives can be used to alternately turn the paging mode
on (PAGE) or off (NOPAGE).  If paging is in effect, then every sixty lines of
output will be followed by a Top of Form character and a two line header
containing page number, filename, and the title.  The format is:</P>
<PRE>    
    .PAGE
    .NOPAGE</PRE>
<P>The number of lines per page can be set with the '-p' command line option.</P>
<H2>SET</H2>
<P>The SET directive allows the value of an existing label to be changed. The
format is:</P>
<PRE>    <I>label</I>   .SET    <I>expr</I></PRE>
<P>The use of the SET directive should be avoided since changing the value of a
label can sometimes cause phase errors between pass 1 and pass 2 of the
assembly.</P>
<H2>SYM/AVSYM</H2>
<P>These directives can be used to cause a symbol table file to be generated. 
The format is:</P>
<PRE>    .SYM    [&quot;symbol_filename&quot;]
    .AVSYM  [&quot;symbol_filename&quot;]
</PRE>
<P>For example:</P>
<PRE>    .SYM       &quot;symbol.map&quot;
    .SYM       
    .AVSYM     &quot;prog.sym&quot;
    .AVSYM
</PRE>
<P>The two directives are similar, but result in a different format of the
symbol table file. The format of the SYM file is one line per symbol, each
symbol starts in the first column and is followed by white space and then four
hexadecimal digits representing the value of the symbol. The following
illustrates the format:</P>
<PRE>    label1         FFFE
    label2         FFFF
    label3         1000
</PRE>
<P>The AVSYM directive is provided to generate symbol tables compatible with
the Avocet 8051 simulator.  The format is similar, but each line is prefixed by
an 'AS' and each symbol value is prefixed by a segment indicator:</P>
<PRE>    AS     start          C:1000
    AS     read_byte      C:1245
    AS     write_byte     C:1280
    AS     low_nib_mask   N:000F
    AS     buffer         X:0080
</PRE>
<P>The segment prefixes are determined by the most recent segment directive
invoked (see BSEG/CSEG/DSEG/NSEG/XSEG directives).</P>
<H2>TEXT</H2>
<P>This directive allows an ASCII string to be used to assign values to a
sequence of locations starting at the current Instruction Pointer.  The format
is:</P>
<PRE>    [<I>label</I>] .TEXT   &quot;string&quot;
</PRE>
<P>The ASCII value of each character in string is taken and assigned to the
next sequential location.  Some escape sequences are supported as follows:</P>
<TABLE BORDER="BORDER">
<TR>
<TD ALIGN="CENTER" VALIGN="Top"><STRONG>Escape Sequence </STRONG></TD>
<TD ALIGN="Left" VALIGN="Top"><STRONG>Description </STRONG></TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top"><TT>\n </TT></TD>
<TD ALIGN="Left" VALIGN="Top">Line Feed </TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top"><TT>\r </TT></TD>
<TD ALIGN="Left" VALIGN="Top">Carriage return </TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top"><TT>\b </TT></TD>
<TD ALIGN="Left" VALIGN="Top">Backspace </TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top"><TT>\t </TT></TD>
<TD ALIGN="Left" VALIGN="Top">Tab </TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top"><TT>\f </TT></TD>
<TD ALIGN="Left" VALIGN="Top">Formfeed </TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top"><TT>\\ </TT></TD>
<TD ALIGN="Left" VALIGN="Top">Backslash </TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top"><TT>\&quot; </TT></TD>
<TD ALIGN="Left" VALIGN="Top">Quote </TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="Top"><TT>\000 </TT></TD>
<TD ALIGN="Left" VALIGN="Top">Octal value of character </TD></TR></TABLE>
<P>Here are some examples:</P>
<PRE>    message1   .TEXT   &quot;Disk I/O error&quot;
    message2   .text   &quot;Enter file name &quot;
               .text   &quot;abcdefg\n\r&quot;
               .text   &quot;I said \&quot;NO\&quot;&quot;
</PRE>
<H2>TITLE</H2>
<P>The TITLE directive allows the user to define a title string that appears at
the top of each page of the list file (assuming the PAGE mode is on).  The
format is:</P>
<PRE>    [<I>label</I>]    .TITLE  &quot;<I>string</I>&quot;</PRE>
<P>The <I>string</I> should not exceed 80 characters. Here are some examples:</P>
<PRE>    .TITLE  &quot;Controller version 1.1&quot;
    .title  &quot;This is the title of the assembly&quot;
    .title  &quot;&quot;
</PRE>
<H2>WORD</H2>
<P>The WORD directive allows a value assignment to the next two bytes pointed
to by the current Instruction Pointer. The format is:</P>
<PRE>    [<I>label</I>] .WORD <I>expr</I> [,<I>expr</I>...]</PRE>
<P>The least significant byte of expr is put at the current Instruction 
Pointer with the most significant byte at the next sequential location (unless
the MSFIRST directive has been invoked).  Here are some examples:</P>
<PRE>    data_table     .WORD   (data_table + 1)
                   .word   $1234
                   .Word   (('x' - 'a')  &lt;&lt; 2)
                   .Word  12, 55, 32
</PRE>
<HR>
<H1><A NAME="OBJECT FILE FORMATS">OBJECT FILE FORMATS</A></H1>
<H2>Intel Hex Object Format</H2>
<P>This is the default object file format.  This format is line oriented and
uses only printable ASCII characters except for the carriage return/line feed at
the end of each line.  The format is symbolically represented as:</P>
<P>:<I>NN AAAA RR HH CC CRLF</I></P>
<P>Where:</P>
<TABLE>
<TR>
<TD ALIGN="Left" VALIGN="Top">
<P><B><I>:</I></B></P> 
</TD>
<TD ALIGN="Left" VALIGN="Top">
<P>Record Start Character (colon)</P>
</TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">
<P><B><I>NN</I></B></P>
</TD>
<TD ALIGN="Left" VALIGN="Top">
<P>Byte Count (2 hex digits)</P>
</TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">
<P><B><I>AAAA</I></B></P>
</TD>
<TD ALIGN="Left" VALIGN="Top">
<P>Address of first byte (4 hex digits)</P>
</TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">
<P><B><I>RR</I></B></P>
</TD>
<TD ALIGN="Left" VALIGN="Top">
<P>Record Type (<B>00</B> except for last record which is <B>01</B>)</P>
</TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">
<P><B><I>HH</I></B></P>
</TD>
<TD ALIGN="Left" VALIGN="Top">
<P>Data Bytes (a pair of hex digits for each byte of data in the record)</P>
</TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">
<P><B><I>CC</I></B></P>
</TD>
<TD ALIGN="Left" VALIGN="Top">
<P>Check Sum (2 hex digits)</P>
</TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">
<P><B><I>CRLF</I></B></P>
</TD>
<TD ALIGN="Left" VALIGN="Top">
<P>Line Terminator (CR/LF for DOS, LF for LINUX)</P>
</TD></TR></TABLE>
<P>The last line of the file will be a record conforming to the above format
with a byte count of zero.</P>
<P>The checksum is defined as:</P>
<P><I>  sum = byte_count+address_hi+address_lo+record_type+(sum of all data
bytes)</I>
<BR><I>  checksum =  ((-sum) &amp; ffh)</I></P>
<P>Here is a sample listing file followed by the resulting object file:</P>
<PRE>0001   0000             
0002   1000             	.org   $1000
0003   1000 010203040506	.byte  1, 2, 3, 4, 5, 6, 7, 8
0003   1006 0708
0004   1008 090A0B0C0D0E	.byte  9,10,11,12,13,14,15,16
0004   100E 0F10
0005   1010 111213141516	.byte 17,18,19,20,21,22,23,24,25,26
0005   1016 1718191A
0006   101A             	.end
</PRE>
<PRE>    :181000000102030405060708090A0B0C0D0E0F101112131415161718AC
    :02101800191AA3
    :00000001FF
</PRE>
<H2>Intel Hex Word Address Object Format</H2>
<P>This format is identical to the <B>Intel Hex Object Format</B> except that
the address for each line of object code is divided by two thus converting it to
a word  address (16 bit word).  All other fields are identical.  </P>
<P>Here is an example:</P>
<PRE> :180800000102030405060708090A0B0C0D0E0F101112131415161718AC
:02080C00191AA3
:00000001FF
</PRE>
<H2>MOS Technology Hex Object Format</H2>
<P>This format is line oriented and uses only printable ASCII characters except
for the carriage return/line feed at the end of each line.  Each line in the
file is of the following format:</P>
<P>:<I>NN AAAA HH CC CRLF</I></P>
<P>Where:</P>
<TABLE>
<TR>
<TD ALIGN="Left" VALIGN="Top">
<P><B><I>;</I></B></P> 
</TD>
<TD ALIGN="Left" VALIGN="Top">
<P>Record Start Character (semicolon)</P>
</TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">
<P><B><I>NN</I></B></P>
</TD>
<TD ALIGN="Left" VALIGN="Top">
<P>Byte Count (2 hex digits)</P>
</TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">
<P><B><I>AAAA</I></B></P>
</TD>
<TD ALIGN="Left" VALIGN="Top">
<P>Address of first byte (4 hex digits)</P>
</TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">
<P><B><I>HH</I></B></P>
</TD>
<TD ALIGN="Left" VALIGN="Top">
<P>Data Bytes (a pair of hex digits for each byte of data in the record)</P>
</TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">
<P><B><I>CCCC</I></B></P>
</TD>
<TD ALIGN="Left" VALIGN="Top">
<P>Check Sum (4 hex digits)</P>
</TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">
<P><B><I>CRLF</I></B></P>
</TD>
<TD ALIGN="Left" VALIGN="Top">
<P>Line Terminator (CR/LF for DOS, LF for LINUX)</P>
</TD></TR></TABLE>
<P>The last line of the file will be a record conforming to the above format
with a byte count of zero.</P>
<P>The checksum is defined as:</P>
<P><I>  sum =byte_count+address_hi+address_lo+record_type+(sum of all data
bytes)<BR>   checksum =  (sum &amp; ffffh)</I></P>
<P>Here is a sample object file:</P>
<PRE>;1810000102030405060708090A0B0C0D0E0F1011121314151617180154
;021018191A005D
;00
</PRE>
<H2>Motorola Hex Object Format</H2>
<P>This format is line oriented and uses only printable ASCII characters except
for the carriage return/line feed at the end of each line.  The format is
symbolically represented as:</P>
<P><I>S1 NN AAAA HH CCCC CRLF</I></P>
<P>Where:</P>
<TABLE>
<TR>
<TD ALIGN="Left" VALIGN="Top">
<P><B><I>S1</I></B></P> 
</TD>
<TD ALIGN="Left" VALIGN="Top">
<P>Record Start tag </P>
</TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">
<P><B><I>NN</I></B></P>
</TD>
<TD ALIGN="Left" VALIGN="Top">
<P>Byte Count (2 hex digits) (data byte count + 3)</P>
</TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">
<P><B><I>AAAA</I></B></P>
</TD>
<TD ALIGN="Left" VALIGN="Top">
<P>Address of first byte (4 hex digits)</P>
</TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">
<P><B><I>HH</I></B></P>
</TD>
<TD ALIGN="Left" VALIGN="Top">
<P>Data Bytes (a pair of hex digits for each byte of data in the record)</P>
</TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">
<P><B><I>CC</I></B></P>
</TD>
<TD ALIGN="Left" VALIGN="Top">
<P>Check Sum (2 hex digits)</P>
</TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">
<P><B><I>CRLF</I></B></P>
</TD>
<TD ALIGN="Left" VALIGN="Top">
<P>Line Terminator (CR/LF for DOS, LF for LINUX)</P>
</TD></TR></TABLE>
<P>The checksum is defined as:</P>
<P><I>  sum = byte_count+address_hi+address_lo+(sum of all data bytes)</I>
<BR><I>  checksum =  ((~sum) &amp; ffh)</I></P>
<P>Here is a sample file:</P>
<PRE>S11B10000102030405060708090A0B0C0D0E0F101112131415161718A8
S1051018191A9F
S9030000FC
</PRE>
<P>The last line of the file will be a record with a byte count of zero and a
tag of S9.  The address field will be 0000 unless and address was provided with
the END directive in which case it will appear in the address field.</P>
<H2>Binary Object Format.</H2>
<P>This file format is essentially a memory image of the object code without
address, checksum or format description information.</P>
<P>Note that when this object format is selected (-b option),  the -c option is
forced. This is done so that no ambiguity results from the lack of address
information in the file. Without the -c option, discontinuous blocks of object
code would appear contiguous.</P>
<HR>
<H1><A NAME="LISTING FILE FORMAT">LISTING FILE FORMAT</A></H1>
<P>Each line of source code generates one  (or more) lines of output in the
listing file.  The fields of the output line are as follows:</P>
<OL>
<LI> Current source file line number (4 decimal digits).
</LI>
<LI>  An optional '+' appears if this is an 'INCLUDE' file. (One '+' for each
level of INCLUDE invoked).
</LI>
<LI> Current Instruction Pointer (4 hex digits).  An optional '~' follows the
Instruction Pointer if the line of source code is not being assembled because of
an IFDEF, IFNDEF, or IF directive.
</LI>
<LI> Resulting code/data generated from this source line (two hex digits per
byte, each byte separated by a space, up to six bytes per line).
</LI>
<LI> The source line exactly as it appears in the source file.
</LI></OL>
<P>If paging is enabled (by either the '-p' option flag or the .PAGE directive)
some additional fields will be inserted into the listing file every 60 lines. 
These fields are:</P>
<OL>
<LI>  Top of Form (form feed).
</LI>
<LI>  Assembler identifier (e.g. &quot;TASM 6502 Assembler&quot;).
</LI>
<LI>  Initial source file name.
</LI>
<LI>  Page number.
</LI>
<LI>  Title.
</LI></OL>
<P>If errors are encountered, then error messages will be interspersed in the
listing.  TASM  outputs error messages proceeding the offending  line.  The
following example illustrates the format:</P>
<PRE>    0001   0000             label1  .equ  40h
    0002   0000             label2  .equ  44h
    0003   0000 
    0004   1000             start:  .org  1000h
    0005   1000 E6 40               inc   label1
    0006   1002 E6 44               inc   label2
    tt.asm line 0007: Label not found: (label3)
    0007   1004 EE 00 00            inc   label3
    0008   1007 4C 00 10            jmp   start
    0009   100A                     .end  
    0010   100A                            
    tasm: Number of errors = 1
</PRE>
<HR>
<H1><A NAME="PROM PROGRAMMING">PROM PROGRAMMING</A></H1>
<P>A wide variety of PROM programming equipment is available that can use
object code in one or more of the formats supported by TASM.  Here are some
notes concerning the generation of code to be programmed into PROMs:</P>
<H2>PRESET MEMORY</H2>
<P>It is often desirable to have all bytes in the PROM programmed even if not
explicitly assigned a value in the source code (e.g. the bytes are skipped over
with a .ORG statement).  This can be accomplished by using the <I>-c</I>
(contiguous block) and the <I>-f</I> (fill) command line option flags.  The
<I>-c</I> will ensure that every byte from the lowest byte assigned a value to
the highest byte assigned a value will be in the object file with no gaps. The
<I>-f</I> flag will assign the specified value to all bytes before the assembly
begins so that when the object file is written, all bytes not assigned a value
in the source code will have a known value.  As an example, the following
command line will generate object code in the default Intel Hex format with all
bytes not assigned a value in the source set to EA (hex, 6502 NOP instruction):</P>
<PRE>    tasm -65 -c -fEA test.asm</PRE>
<H2>CONTIGUOUS BLOCKS</H2>
<P>To ensure that TASM generates object code to cover the full address range of
the target PROM, put a .ORG statement at the end of the source file set to the
last address desired.  For example, to generate code to be put in a 2716 EPROM
(2 Kbytes) from hex address $1000 to $17ff, do something like this in the source
file:</P>
<PRE>    ;start of the file
        .ORG    $1000
    ;rest of the source code follows
    source code
    ;end of the source code
        .ORG    $17ff
        .BYTE   0
        .END
</PRE>
<P>Now, to invoke TASM to generate the code in the binary format with all
unassigned bytes set to 00 (6502 BRK instruction), do the following:</P>
<PRE>tasm -65 -b -f00 test.asm</PRE>
<P>Note that -b forces the -c option.</P>
<HR>
<H1><A NAME="ERROR MESSAGES">ERROR MESSAGES</A></H1>
<H2>Error Message Format</H2>
<P>TASM error messages take the following general form:</P>
<PRE>    <I>filename </I>line<I> line_number</I>: <I>error_message</I></PRE>
<P>For example:</P>
<PRE>    main.asm line 0032: Duplicate label (start)</PRE>
<P>This format is compatible with the Brief editor (from Borland
International).  Brief provides the ability to run assemblies from within the
editor.  Upon completion of the assembly, Brief will parse the error messages
and jump to each offending line in the source file allowing the user to make
corrective edits.</P>
<P>To use this feature, it is necessary to configure a Brief environment
variable to specify the assembly command associated with source files that end
in .asm:</P>
<PRE>    SET BCASM = &quot;tasm %s.asm&quot;</PRE>
<P>TASM also needs to know the proper table to use.  It can be added above, or
the TASMOPTS environment variable can be used separately:</P>
<PRE>    SET TASMOPTS=-65</PRE>
<H2>ERROR MESSAGE DESCRIPTIONS</H2>
<DL>
<DT><STRONG><FONT SIZE="+1">Binary operator where value expected</FONT></STRONG></DT>
<DD>Two binary operators in a row indicate a missing value.</DD>
<DT><STRONG><FONT SIZE="+1">Branch off of current 2K page</FONT></STRONG></DT>
<DD>An instruction is attempting to branch to a location not within the current
2K byte page.</DD>
<DT><STRONG><FONT SIZE="+1">Branch off of current page</FONT></STRONG></DT>
<DD>An instruction is attempting to branch to a location not within the current
256 byte page.</DD>
<DT><STRONG><FONT SIZE="+1">Cannot malloc for label storage</FONT></STRONG></DT>
<DD>Insufficient memory to store more labels.  See <STRONG>LIMITATIONS</STRONG>.</DD>
<DT><STRONG><FONT SIZE="+1">Duplicate label</FONT></STRONG></DT>
<DD>The label for the current line has already been assigned a value. 
Duplicate label checks are optionally enabled by the <I>-a</I> option.</DD>
<DT><STRONG><FONT SIZE="+1">File name too short</FONT></STRONG></DT>
<DD>A file name on the command line is fewer than 3 characters.  A two
character file name may be valid, of course, but it is detected as an error to
prevent a garbled option flag from being taken as a source file, which in turn
can result in the true source file being taken as the object file.  Since the
object file is truncated at startup time, the source file could be clobbered.</DD>
<DT><STRONG><FONT SIZE="+1">Forward reference in equate</FONT></STRONG></DT>
<DD>An EQU directive  is using a  label on the right hand side that has not yet
been defined.</DD>
<DT><STRONG><FONT SIZE="+1">Heap overflow on label definition</FONT></STRONG></DT>
<DD>TASM was unable to allocate memory to store the label.</DD>
<DT><STRONG><FONT SIZE="+1">Imbalanced conditional.</FONT></STRONG></DT>
<DD>An end-of-file was encountered at which time the level of descent in
conditional directives was different from when the file was entered. 
Conditional directives include IF, IFDEF, and IFNDEF.</DD>
<DT><STRONG><FONT SIZE="+1">Invalid Object file type.</FONT></STRONG></DT>
<DD>An object file type was requested by the -g command line option that is not
valid. See section on Option g - Object File Format.</DD>
<DT><STRONG><FONT SIZE="+1">Invalid operand.</FONT></STRONG></DT>
<DD>No indirection for this instruction.  The first character of an operand was
a left parenthesis for an instruction that does not explicitly specify that as
the format.  Some micros use the parenthesis as an indicator of indirection, but
putting a layer of parenthesis around an expression is always a valid thing to
do (as far as the expression evaluator is concerned).  The test for this case is
only done if the <I>-a4</I> option is selected.  See section on <B>ASSEMBLY
CONTROL</B>.</DD>
<DT><STRONG><FONT SIZE="+1">Invalid token where value expected.</FONT></STRONG></DT>
<DD>Two binary operators in a row are not allowed.</DD>
<DT><STRONG><FONT SIZE="+1">Label too long.</FONT></STRONG></DT>
<DD>Labels are limited to 31 characters.</DD>
<DT><STRONG><FONT SIZE="+1">Label value misaligned</FONT></STRONG></DT>
<DD>The value of a label appears to have a different value on the second pass
then it was computed to have on the first pass.  This is generally due to Zero
Page Addressing mode problems with the 6502 version of TASM.  Labels that are
used in operands for statements that could utilize Zero Page addressing mode
should always be defined before used as an operand.</DD>
<DT><STRONG><FONT SIZE="+1">Label not found</FONT></STRONG></DT>
<DD>A label used in an expression was not found in the current label table.</DD>
<DT><STRONG><FONT SIZE="+1">Label must pre-exist for SET.</FONT></STRONG></DT>
<DD>The SET directive can only be applied to an existing label.</DD>
<DT><STRONG><FONT SIZE="+1">Label table overflow</FONT></STRONG></DT>
<DD>To many labels have been encountered.</DD>
<DT><STRONG><FONT SIZE="+1">List file open error                      </FONT></STRONG></DT>
<DD>TASM was not able to open the specified list file.</DD>
<DT><STRONG><FONT SIZE="+1">Macro expansion too long.                 </FONT></STRONG></DT>
<DD>The expansion of a macro resulted in a line that exceeded the maximum
length.</DD>
<DT><STRONG><FONT SIZE="+1">Max number of nested conditionals exceeded</FONT></STRONG></DT>
<DD>Too many levels of IF, IFDEF, or IFNDEF.</DD>
<DT><STRONG><FONT SIZE="+1">Maximum number of args exceeded</FONT></STRONG></DT>
<DD>Too many macro arguments.</DD>
<DT><STRONG><FONT SIZE="+1">Maximum number of macros exceeded         </FONT></STRONG></DT>
<DD>Too many macros (DEFINEs) have been encountered.</DD>
<DT><STRONG><FONT SIZE="+1">No END directive before EOF</FONT></STRONG></DT>
<DD>The source file did not have an END directive in it. This is not fatal, but
may cause the last object file record to be lost.</DD>
<DT><STRONG><FONT SIZE="+1">No files specified</FONT></STRONG></DT>
<DD>TASM was invoked with no source file specified.</DD>
<DT><STRONG><FONT SIZE="+1">No such label</FONT></STRONG></DT>
<DD>A SET directive was encountered for a label not yet defined.  The value of
labels that are modified by the SET directive must already exist.</DD>
<DT><STRONG><FONT SIZE="+1">No terminating quote</FONT></STRONG></DT>
<DD>A double quote was used at the start of a a text string but was not used at
the end of the string.</DD>
<DT><STRONG><FONT SIZE="+1">No indirection for this instruction.      </FONT></STRONG></DT>
<DD>A parenthesis was found around the operand expression.  This may indicate
an attempt to use indirection  where it  is inappropriate.</DD>
<DT><STRONG><FONT SIZE="+1">Non-unary operator at start of expression </FONT></STRONG></DT>
<DD>A binary operator (such as '*') was found at the beginning of an
expression. Some micros use '*' as an indirection operator. Since it is also a
legitimate operator in an expression, some ambiguity can arise. If a particular
instruction/addressing mode does not allow indirection, and a '*' is placed in
front of the associated expression, the assembler will assume this error.  See
the  <I>-a8</I> option of ASSEMBLY CONTROL.</DD>
<DT><STRONG><FONT SIZE="+1">Object file open error</FONT></STRONG></DT>
<DD>TASM was not able to open the specified object file.</DD>
<DT><STRONG><FONT SIZE="+1">Range of argument exceeded</FONT></STRONG></DT>
<DD>The value of an argument exceeds the valid range for the current
instruction and addressing mode.</DD>
<DT><STRONG><FONT SIZE="+1">Range of relative branch exceeded</FONT></STRONG></DT>
<DD>A branch instruction exceeds the maximum range.</DD>
<DT><STRONG><FONT SIZE="+1">Source file open error</FONT></STRONG></DT>
<DD>TASM was not able to open the specified source file.</DD>
<DT><STRONG><FONT SIZE="+1">Unrecognized directive</FONT></STRONG></DT>
<DD>A statement starting with a '.' or '#' has a mnemonic that is not defined
as a directive.</DD>
<DT><STRONG><FONT SIZE="+1">Unrecognized instruction                 </FONT></STRONG></DT>
<DD>A statement has an opcode mnemonic that is not defined.</DD>
<DT><STRONG><FONT SIZE="+1">Unrecognized argument</FONT></STRONG></DT>
<DD>A statement has an operand format that is not defined.</DD>
<DT><STRONG><FONT SIZE="+1">Unknown token</FONT></STRONG></DT>
<DD>Unexpected characters were encountered while parsing an expression.</DD>
<DT><STRONG><FONT SIZE="+1">Unused data in MS byte of argument</FONT></STRONG></DT>
<DD>An instruction or directive used the least significant byte of an argument
and left the most significant byte unused, but it was non-zero.</DD>
<DT><STRONG><FONT SIZE="+1">Unknown option Flag.</FONT></STRONG></DT>
<DD>Invalid option flag has been specified on the command line. invoke TASM
with nothing on the command line to see a list of valid options.</DD></DL>
<H1><A NAME="LIMITATIONS">LIMITATIONS</A></H1>
<TABLE BORDER="BORDER">
<TR>
<TD ALIGN="Left" VALIGN="Top">Maximum number of labels </TD>
<TD ALIGN="Left" VALIGN="Top">15000 </TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">Maximum length of labels </TD>
<TD ALIGN="Left" VALIGN="Top">32 characters </TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">Maximum address space </TD>
<TD ALIGN="Left" VALIGN="Top">64 Kbytes (65536 bytes) </TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">Maximum number of nested INCLUDES</TD>
<TD ALIGN="Left" VALIGN="Top">4 </TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">Maximum length of TITLE string </TD>
<TD ALIGN="Left" VALIGN="Top">79 characters </TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">Maximum source line length </TD>
<TD ALIGN="Left" VALIGN="Top">255 characters </TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">Maximum length after macro expansion </TD>
<TD ALIGN="Left" VALIGN="Top">255 characters </TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">Maximum length of expressions </TD>
<TD ALIGN="Left" VALIGN="Top">255 characters </TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">Maximum length of pathnames </TD>
<TD ALIGN="Left" VALIGN="Top">79 characters </TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">Maximum length of command line </TD>
<TD ALIGN="Left" VALIGN="Top">127 characters </TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">Maximum number of instructions (per table) </TD>
<TD ALIGN="Left" VALIGN="Top">1200 </TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">Maximum number of macros </TD>
<TD ALIGN="Left" VALIGN="Top">1000 </TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">Maximum number of macro arguments </TD>
<TD ALIGN="Left" VALIGN="Top">10 </TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">Maximum length of macro argument </TD>
<TD ALIGN="Left" VALIGN="Top">16 characters </TD></TR>
<TR>
<TD ALIGN="Left" VALIGN="Top">Memory requirements </TD>
<TD ALIGN="Left" VALIGN="Top">512K </TD></TR></TABLE>
<H2>Other Limitations</H2>
<OL>
<LI> The 8048 version of TASM does not check for use of memory beyond any
reasonable bounds (e.g. an 8048 has a maximum address space of 4 Kbytes but TASM
will let you pretend that you have 64 Kbytes).
</LI>
<LI> Expression evaluation has no operator precedence in effect which can make
for unexpected results if not explicitly grouped with parenthesis.
</LI>
<LI> First page of listing file will not show a user defined title  (defined
via TITLE directive).</LI></OL>
<HR></BODY></HTML>
