;	NAM	SWTBUG
;*	VERSION 1.00

;	OPT	PAG
;****************************************************
;*REPLACEMENT FOR MIKBUG ROM
;*FOR SWTPC 6800 COMPUTER SYSTEM
;*COPYRIGHT 1977
;*SOUTHWEST TECHNICAL PROD. CORP.
;*AUGUST, 1977
;****************************************************


	ORG	$A000
IRQ	RMB	2	;IRQ POINTER
BEGA	RMB	2	;BEGINNING ADDR PNCH
ENDA	RMB	2	;ENDING ADDR PNCH
NMI	RMB	2	;NMI INTERRUPT VECTOR
SP	RMB	1	;S HIGH
	RMB	1	;S LOW
PORADD	RMB	2	;PORT ADDRESS
PORECH	RMB	1	;ECHO ON/OFF FLAG
XHI	RMB	1	;XREG HIGH
XLOW	RMB	1	;XREG LOW
CKSM	RMB	1	;CHECKSUM
XTEMP	RMB	2	;X-REG TEMP STGE
SWIJMP	RMB	2	;SWI JUMP VECTOR
TW	EQU	$A044	;TEMPORARY STORAGE
TEMP	EQU	$A046	;TEMPORARY STORAGE
BYTECT	EQU	$A047		;BYTECT AND MCONT TEMP.
CTLPOR	EQU	$8004		;CONTROL PORT ADDRESS
PROM	EQU	$C000	;JUMP TO PROM ADDRESS
BKPT	RMB	2	;BREAKPOINT ADDRESS
BKLST	RMB	1	;BREAKPOINT DATA

	ORG	$A042
STACK	RMB	1	;SWTBUG STACK

	ORG	$E000

;*I/O INTERRUPT SEQUENCE
IRQV	LDX	IRQ
	JMP	0,X

;*JUMP TO USER PROGRAM
JUMP	BSR	BADDR
	JMP	0,X

CURSOR	FCB	$10,$16,4	;CT-1024 CURSOR CONTROL
;*ASCII LOADING ROUTINE
LOAD	JSR	RDON	;READER ON, DIS ECHO, GET P#
LOAD3	BSR	INCH
	CMP A	#'S'
	BNE	LOAD3	;1ST CHAR NOT S
	BSR	INCH	;READ CHAR
	CMP A	#'9'
	BEQ	LOAD21
	CMP A	#'1'
	BNE	LOAD3	;2ND CHAR NOT 1
	CLR	CKSM	;ZERO CHECKSUM
	BSR	BYTE	;READ BYTE
	SUB A	#2
	STA A	BYTECT ;BYTE COUNT
;*BUILD ADDRESS
	BSR	BADDR
;*STORE DATA
LOAD11	BSR	BYTE
	DEC	BYTECT
	BEQ	LOAD15	;ZERO BYTE COUNT
	STA A	0,X	;STORE DATA
	CMP A	0,X	;DATA STORED?
	BNE	LOAD19
	INX
	BRA	LOAD11
LOAD15	INC	CKSM
	BEQ	LOAD3
LOAD19	LDA A	#'?'
	BSR	OUTCH
LOAD21	JMP	RDOFF1

;*BUILD ADDRESS
BADDR	BSR	BYTE	;READ 2 FRAMES
	STA A	XHI
	BSR	BYTE
	STA A	XLOW
	LDX	XHI	;LOAD IXR WITH NUMBER
	RTS

;*INPUT BYTE (TWO FRAMES)
BYTE	BSR	INHEX	;GET HEX CHAR
BYTE1	ASL A
	ASL A
	ASL A
	ASL A
	TAB
	BSR	INHEX
	ABA
	TAB
	ADD B	CKSM
	STA B	CKSM
	RTS

OUTHL	LSR A		;OUT HEX LEFT BCD DIGIT
	LSR A
	LSR A
	LSR A
OUTHR	AND A	#$F	;OUT HEX RIGHT BCD DIGIT
	ADD A	#$30
	CMP A	#$39
	BLS	OUTCH
	ADD A	#$7

;*OUTPUT ONE CHAR
OUTCH	JMP	OUTEEE
INCH	JMP	INEEE

;*PRINT DATA POINTED TO BY X REG
PDATA2	BSR	OUTCH
	INX
PDATA1	LDA A	0,X
	CMP A	#4
	BNE	PDATA2
	RTS	;STOP	ON HEX 04

C1	JMP	SWTCTL

;*MEMORY EXAMINE AND CHANGE
CHANGE	BSR	BADDR
CHA51	LDX	#MCL
	BSR	PDATA1	;C/R L/F
	LDX	#XHI
	BSR	OUT4HS	;PRINT ADDRESS
	LDX	XHI
	BSR	OUT2HS	;PRINT OLD DATA
	BSR	OUTS	;OUTPUT SPACE
ANOTH	BSR	INCH	;INPUT CHAR
	CMP A	#$20
	BEQ	ANOTH
	CMP A	#$D
	BEQ	C1
	CMP A	#'^'	;UP ARROW?
	BRA	AL3	;BRANCH FOR ADJUSTMENT
	NOP
;*INPUT HEX CHARACTER
INHEX	BSR	INCH
INHEX1	SUB A	#$30
	BMI	C3
	CMP A	#$9
	BLE	IN1HG
	CMP A	#$11
	BMI	C3	;NOT HEX
	CMP A	#$16
	BGT	C3	;NOT HEX
	SUB A	#7
IN1HG	RTS

OUT2H		LDA A	0,X	;OUTPUT 2 HEX CHAR
OUT2HA	BSR	OUTHL	 ;OUT LEFT HEX CHAR
	LDA A	0,X
	INX
	BRA	OUTHR	; OUTPUT RIGHT HEX CHAR

OUT4HS	BSR	OUT2H	 ;OUTPUT 4 HEX CHAR + SPACE
OUT2HS	BSR	OUT2H	 ;OUTPUT 2 HEX CHAR + SPACE

OUTS	LDA A	#$20	;SPACE
	BRA	OUTCH		;(BSR & TRS))

;*ENTER POWER ON SEQUENCE
START	LDS	#STACK
	BRA	AL1	;BRANCH FOR ADDRESS COMPATIBIL

;********************************************
;*PART OF MEMORY EXAMINE AND CHANGE
AL3	BNE	SK1
	DEX
	DEX
	STX	XHI
	BRA	CHA51
SK1	STX	XHI
	BRA	AL4

EOE3	BRA	CONTRL	;BRANCH FOR MIKBUG EQUIV. CONT

AL4	CMP A	#$30
	BCS	CHA51
	CMP A	#$46
	BHI	CHA51
	BSR	INHEX1
	JSR	BYTE1
	DEX
	STA A	0,X	;CHANGE MEMORY
	CMP A	0,X
	BEQ	CHA51		;DID CHANGE
	JMP	LOAD19	;DIDN'T CHANGE
C3	LDS	SP
	BRA	SWTCTL
;**************************************************

;*CONTINUE POWER UP SEQUENCE
AL1	STS	SP	;INIT TARGET STACK PTR.
	LDA A	#$FF
	JSR	SWISET
;*CONFIGURE FOR PIA AND SEE IF OK
	LDX	#CTLPOR
	JSR	PIAINI	;INIT PIA
	LDA A	0,X
	CMP A	2,X
	BRA	AL2

	BRA	PRINT		;BRA FOR BILOAD

AL2	BNE	CONTRL

;*INITIALIZE AS ACIA
	LDA A	#3	;ACIA MASTER RESET
	STA A	0,X
	LDA A	#$11
	STA A	0,X
	BRA	CONTRL

;*ENTER FROM SOFTWARE INTERRUPT
SF0	NOP
SFE1	STS	SP	;SAVE TARGETS STACK POINTER
;*DECREMENT P COUNTER
	TSX
	TST	6,X
	BNE	*+4
	DEC	5,X
	DEC	6,X
;*PRINT CONTENTS OF STACK.
PRINT	LDX	#MCL
	JSR	PDATA1
	LDX	SP
	INX
	BSR	OUT2HS	;COND CODES
	BSR	OUT2HS	;ACC B
	BSR	OUT2HS	;ACC A
	BSR	OUT4HS	;IXR
	BSR	OUT4HS	;PGM COUNTER
	LDX	#SP
	JSR	OUT4HS	;STACK POINTER
SWTCTL	LDX	SWIJMP
	CPX	#SF0
	BEQ	CONTR1

CONTRL	LDS	#STACK	;SET CONTRL STACK POINTER
	LDX	#CTLPOR	;RESET TO CONTROL PORT
	STX	PORADD
	CLR	PORECH	;TURN ECHO ON
	BSR	SAVGET	;GET PORT # AND TYPE
	BEQ	POF1
	JSR	PIAECH	;SET PIA ECHO ON IF MP-C INTER
POF1	JSR	PNCHOF	;TURN PUNCH OFF
	JSR	RDOFF		;TURN READER OFF
CONTR1	LDX	#MCLOFF
	JSR	PDATA1	;PRINT DATA STRING
	BSR	INEEE		;READ COMMAND CHARACTER

;*COMMAND LOOKUP ROUTINE
LOOK	LDX	#TABLE
OVER	CMP A	0,X
	BNE	SK3
	JSR	OUTS	;SKIP SPACE
	LDX	1,X
	JMP	0,X
SK3	INX
	INX
	INX
	CPX	#TABEND+3
	BNE	OVER
SWTL1	BRA	SWTCTL

;*SOFTWARE INTERRUPT ENTRY POINT
SFE	LDX	SWIJMP	;JUMP TO VECTORED SOFTWARE INT
	JMP	0,X

S9	FCB	'S','9',4	;END OF TAPE

;***************************************************
MTAPE1	FCB	$D,$A,$15,0,0,0,'S','1',4	;PUNCH FORMAT

MCLOFF	FCB	$13	;READER OFF
MCL	FCB	$D,$A,$15,0,0,0,'$',4

EIA5	BRA	BILD	;BINARY LOADER INPUT
;***************************************************


;*NMI SEQUENCE
NMIV	LDX	NMI	;GET NMI VECTOR
	JMP	0,X

INEEE	BRA	INEEE1

;*BYTE SEARCH ROUTINE
SEARCH	JSR	BADDR	;GET TOP ADDRESS
	STX	ENDA
	JSR	BADDR	;GET BOTTOM ADDRESS
	JSR	BYTE	;GET BYTE TO SEARCH FOR
	TAB
OVE	LDA A	0,X
	STX	XHI
	CBA
	BEQ	PNT
	BRA	INCR1
PNT	LDX	#MCL
	JSR	PDATA1
	LDX	#XHI
	BRA	SKP0
;***************************************************

;*GO TO USER PROGRAM ROUTINE
GOTO	RTI
OUTEEE	BRA	OUTEE1



;*SAVE IXR AND LOAD IXR WITH CORRECT
;*PORT NUMBER AND TEST FOR TYPE
SAVGET	STX	XTEMP	;STORE INDEX REGISTER
GETPT1	LDX	PORADD
ISACIA	PSH B
	LDA B	1,X
	CMP B	3,X
	PUL B
	RTS
;***************************************************

;*CONTINUATION OF SEARCH ROUTINE
SKP0	JSR	OUT4HS
	LDX	XHI
INCR1	CPX	ENDA
	BEQ	SWTL1
	INX
	BRA	OVE

INEEE1	BSR	INCH8	;INPUT 8 BIT CHARACTER
	AND A	#%01111111	;GET RID OF PARITY BIT
	RTS

BILD	INS	;FIX UP STACK WHEN USING
	INS	;BINARY LOADER ON SWTPC TAPES
	INS

;*INPUT ONE CHAR INTO ACC B
INCH8	PSH B		;SAVE ACC B
	BSR	SAVGET	;SAVE IXR, GET PORT# AND TYPE
	BNE	IN1	;INPUT FROM PIA IF NOT
	LDA A	#$15	;RECONFIG FOR 8 BIT, 1 SB
	STA A	0,X
ACIAIN	LDA A	0,X
	ASR A
	BCC	ACIAIN	;NOT READY
	LDA A	1,X		;LOAD CHAR
	LDA B	PORECH
	BEQ	ACIOUT	;ECHO
	BRA	RES	;DON'T ECHO

;*OUTPUT ONE CHARACTER
OUTEE1	PSH B		;SAVE ACC B
	BSR	SAVGET
	BNE	IOUT

ACIOUT	LDA B	#$11
	STA B	0,X
ACIOU1	LDA B	0,X
	ASR B
	ASR B
	BCC	ACIOU1	;ACIA NOT READY
	STA A	1,X	;OUTPUT CHARACTER
RES	PUL B		;RESTORE ACC B
	LDX	XTEMP
	RTS

;*PIA INPUT ROUTINE
IN1	LDA A	0,X	;LOOK FOR START BIT
	BMI	IN1
	BSR	DDL	;DELAY HALF BIT TIME
	LDA B	#4	;SET DEL FOR FULL BIT TIME
	STA B	2,X
	ASL B		;SET UP CNTR WITH 8
IN3	BSR	DEL	;WAIT ONE CHAR TIME
	SEC
	ROL	0,X
	ROR A
	DEC B
	BNE	IN3
	BSR	DEL	;WAIT FOR STOP BIT
	LDA B	PORECH	;IS ECHO DESIRED?
	BEQ	IOUT2	;ECHO
	BRA	RES	;RESTORE IXR,ACCB
;*PIA OUTPUT ROUTINE
IOUT	BSR	DDL1	;DELAY ONE HALF BIT TIME
	LDA B	#$A	;SET UP COUNTER
	DEC	0,X	;SET START BIT
	BSR	DE	;START TIMER
OUT1	BSR	DEL	;DELAY ONE BIT TIME
	STA A	0,X	;PUT OUT ONE DATA BIT
	SEC
	ROR A		;SHIFT IN NEXT BIT
	DEC B		;DECREMENT COUNTER
	BNE	OUT1	;TEST FOR 0
IOUT2	LDA B	2,X	;TEST FOR STOP BITS
	ASL B		;SHIFT	BIT TO SIGN
	BPL	RES	;BRA FOR 1 STOP BIT
	BSR	DEL	;DELAY FOR STOP BITS
	BRA	RES
DEL	TST	2,X	;IS TIME UP
	BPL	DEL
DE	INC	2,X	;RESET TIMER
	DEC	2,X
	RTS

DDL	CLR	2,X	;HALF BIT DELAY
DDL1	BSR	DE
	BRA	DEL


;*OPTIONAL PORT ROUTINE
OPTL	BSR	INEEE1
	TAB
	CLR	PORADD+1	;SET I/O ADDRESS FOR $8000
	LDX	PORADD
	BSR	PIAINI	;INITIALIZE PIA
	BSR	PIAECH	;SET ECHO
	LDX	#TABLE1	;P, L OR E
	TBA
	JMP	OVER	;LOOK AT TABLE FOR E, L OR P

PIAECH	LDA A	#$34	;SET DDR
	STA A	3,X
	STA A	2,X
NOOPT	RTS

;*PIA INITIALIZATION ROUTINE
PIAINI	INC	0,X	;SET DDR
	LDA A	#$7
	STA A	1,X
	INC	0,X
	STA A	2,X
	RTS

;*MINIFLOPPY DISK BOOT
DISK	CLR	$8014
	BSR	DELAY
	LDA B	#$0B
	BSR	RETT2
LOOP1	LDA B	4,X
	BIT B	#1
	BNE	LOOP1
	CLR	6,X
	BSR	RETURN
	LDA B	#$9C
	BSR	RETT2
	LDX	#$2400
LOOP2	BIT B	#2
	BEQ	LOOP3
	LDA A	$801B
	STA A	0,X
	INX
LOOP3	LDA B	$8018
	BIT B	#1
	BNE	LOOP2
	JMP	$2400
RETT2	STA B	4,X
RETURN	BSR	RETT1
RETT1	RTS

;*GENERAL PURPOSE DELAY LOOP
DELAY	LDX	#$FFFF
DELAY1	DEX
	CPX	#$8014	;STOP AT 8014
DUM	BNE	DELAY1
	RTS


;*CLRAR SCREEN FOR CT-1024 TYPE TERMINALS
CLEAR	LDX	#CURSOR
	JSR	PDATA1
	BSR	DELAY1	;DELAY
RDOFF1	JSR	RDOFF
	BRA	C4

;*BREAKPOINT ENTERING ROUTINE
BREAK	LDX	#SF0
	CPX	SWIJMP	;BREAKPOINTS ALREADY IN USE?
	BEQ	INUSE
	INX
BREAK0	BSR	STO1
	JSR	BADDR
	STX	BKPT
	LDA A	0,X
	STA A	BKLST
	LDA A	#$3F
	STA A	0,X
	LDX	#SF0
	BSR	STO1
	JMP	CONTR1
INUSE	LDX	BKPT
	LDA A	BKLST
	STA A	0,X
	LDX	#SFE1
	BRA	BREAK0

SWISET	STA A	STACK+1	;FIX POWER UP INTERRUPT
	LDX	SWIJMP
	CPX	#SF0
	BEQ	STORTN
STO	LDX	#SFE1
STO1	STX	SWIJMP
STORTN	RTS

PUNCH1	BSR	PUNCH
	BRA	POFC4

;*FORMAT END OF TAPE WITH PGM. CTR. AND S9
PNCHS9	LDX	#$A049
	STX	ENDA
	DEX
	BSR	PUNCH2
	LDX	#S9
PDAT	JSR	PDATA1
POFC4	BSR	PNCHOF
	BSR	DELAY
C4	JMP	CONTRL

RDON	COM	PORECH	;DISABLE ECHO FOR ACIA
	LDA A	#$11	;RON CHAR.
	LDA B	#$20	;STROBE CHAR
	BSR	STROBE
	JSR	ISACIA	;CHECK TO SEE IF PIA
	BEQ	RTNN
	LDA A	#$3C	;DISABLE PIA ECHO IF PIA
	STA A	3,X
RTNN	RTS

RDOFF	LDA A	#$13	;TURN READER OFF
	LDA B	#$10
	BRA	STROBE

PNCHON	LDA A	#$12
	LDA B	#4
	BRA	STROBE

PNCHOF	LDA A	#$14
	LDA B	#$8

;*PIA STROBING ROUTINE FOR PUNCH/READ ON/OFF
STROBE	JSR	OUTCH
	JSR	GETPT1
	BEQ	RTN1
	LDA A	#2
	ORA B	#1
	BSR	STR2
	BSR	STR1
	LDA A	#2
	LDA B	#1
	STA B	0,X
	BSR	STR2
STR1	LDA A	#6
STR2	STA A	1,X
	STA B	0,X
RTN1	RTS

;*PUNCH FROM BEGINNING ADDRESS (BEGA) THRU
;*ENDING ADDRESS (ENDA)
PUNCH	LDX	BEGA
PUNCH2	STX	TW
	BSR	PNCHON
PUN11	LDA A	ENDA+1
	SUB A	TW+1
	LDA B	ENDA
	SBC B	TW
	BNE	PUN22
	CMP A	#16
	BCS	PUN23
PUN22	LDA A	#15
PUN23	ADD A	#4
	STA A	BYTECT
	SUB A	#3
	STA A	TEMP
;*PUNCH C/R L/F NULLS S1
	LDX	#MTAPE1
	JSR	PDATA1
	CLR B
;*PUNCH FRAME COUNT
	LDX	#BYTECT
	BSR	PUNT2	;PUNCH 2 HEX CHARACTERS
;*PUNCH ADDRESS
	LDX	#TW
	BSR	PUNT2
	BSR	PUNT2
;*PUNCH DATA
	LDX	TW
PUN32	BSR	PUNT2		;PUNCH ONE BYTE
	DEC	TEMP
	BNE	PUN32
	STX	TW
	COM B
	PSH B
	TSX
	BSR	PUNT2		;PUNCH CHECKSUM
	PUL B		;RESTORE	STACK
	LDX	TW
	DEX
	CPX	ENDA
	BNE	PUN11
RTN5	RTS

;*PUNCH 2 HEX CHAR, UPDATE CHECKSUM
PUNT2	ADD B	0,X
	JMP	OUT2H	;OUTPUT 2 HEX CHAR AND RTS

;*COMMAND TABLE
TABLE	FCB	'G'	;GOTO
	FDB	GOTO
	FCB	'Z'	;GOTO PROM
	FDB	PROM
	FCB	'M'	;MEMORY EXAM AND CHANGE
	FDB	CHANGE
	FCB	'F'	;BYTE SEARCH
	FDB	SEARCH
	FCB	'R'	;REGISTER DUMP
	FDB	PRINT
	FCB	'J'	;JUMP
	FDB	JUMP
	FCB	'C'	;CLEAR SCREEN
	FDB	CLEAR
	FCB	'D'	;DISK BOOT
	FDB	DISK
	FCB	'B'	;BREAKPOINT
	FDB	BREAK
	FCB	'O'	;OPTIONAL PORT
	FDB	OPTL
TABLE1	FCB	'P'	;ASCII PUNCH
	FDB	PUNCH1
	FCB	'L'	;ASCII LOAD
	FDB	LOAD
TABEND	FCB	'E'	;END OF TAPE
	FDB	PNCHS9

	ORG	$E3F8
	FDB	IRQV	;IRQ VECTOR
	FDB	SFE	;SOFTWARE INTERRUPT
	FDB	NMIV	;NMI VECTOR
	FDB	START	;RESTART VECTOR

;*	ORG	$A048
;*	FDB	START
	END

