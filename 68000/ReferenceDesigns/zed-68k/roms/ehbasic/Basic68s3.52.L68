00000596 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 29/06/2020 10:28:35

00000000                             1  *************************************************************************************
00000000                             2  *                                                       *
00000000                             3  *   Enhanced BASIC for the Motorola MC680xx                         *
00000000                             4  *                                                       *
00000000                             5  *   This version for the EASy68k editor/simulator.                      *
00000000                             6  *   Includes new simulator graphics commands 2002/3/4/5/6/7             *
00000000                             7  *                                                       *
00000000                             8  *************************************************************************************
00000000                             9  *                                                       *
00000000                            10  *   Copyright(C) 2002-12 by Lee Davison. This program may be freely distributed *
00000000                            11  *   for personal use only. All commercial rights are reserved.              *
00000000                            12  *                                                       *
00000000                            13  *   More 68000 and other projects can be found on my website at ..          *
00000000                            14  *                                                       *
00000000                            15  *    http://mycorner.no-ip.org/index.html                           *
00000000                            16  *                                                       *
00000000                            17  *   mail : leeedavison@googlemail.com                               *
00000000                            18  *                                                       *
00000000                            19  *************************************************************************************
00000000                            20  
00000000                            21  * EASy68k extensions Ver 2.33
00000000                            22  
00000000                            23  * Version 3.xx replaces the fixed RAM addressing from previous versions with a RAM
00000000                            24  * pointer in a3. this means that this could now be run as a task on a multitasking
00000000                            25  * system where memory resources may change.
00000000                            26  
00000000                            27  * Ver 3.52
00000000                            28  
00000000                            29  * Ver 3.52 stops USING$() from reading beyond the end of the format string
00000000                            30  * Ver 3.51 fixes the UCASE$() and LCASE$() functions for null strings
00000000                            31  * Ver 3.50 uniary minus in concatenate generates a type mismatch error
00000000                            32  * Ver 3.49 doesn't tokenise 'DEF' or 'DEC' within a hex value
00000000                            33  * Ver 3.48 allows scientific notation underflow in the USING$() function
00000000                            34  * Ver 3.47 traps the use of array elements as the FOR loop variable
00000000                            35  * Ver 3.46 updates function and function variable handling
00000000                            36  
00000000                            37  *************************************************************************************
00000000                            38  *
00000000                            39  * Ver 3.45 makes the handling of non existant variables consistent and gives the
00000000                            40  * option of not returning an error for a non existant variable. If this is the
00000000                            41  * behaviour you want just change novar to some non zero value
00000000                            42  
00000000  =00000000                 43  novar       EQU 0               * non existant variables cause errors
00000000                            44  
00000000                            45  
00000000                            46  *************************************************************************************
00000000                            47  
00000000                            48  * Ver 3.44 adds overflow indication to the USING$() function
00000000                            49  * Ver 3.43 removes an undocumented feature of concatenating null strings
00000000                            50  * Ver 3.42 reimplements backspace so that characters are overwritten with [SPACE]
00000000                            51  * Ver 3.41 removes undocumented features of the USING$() function
00000000                            52  * Ver 3.40 adds the USING$() function
00000000                            53  * Ver 3.33 adds the file requester to LOAD and SAVE
00000000                            54  * Ver 3.32 adds the optional ELSE clause to IF .. THEN
00000000                            55  
00000000                            56  *************************************************************************************
00000000                            57  
00000000                            58  * Version 3.25 adds the option to change the behaviour of INPUT so that a null
00000000                            59  * response does not cause a program break. If this is the behaviour you want just
00000000                            60  * change nobrk to some non zero value.
00000000                            61  
00000000  =00000000                 62  nobrk       EQU 0               * null response to INPUT causes a break
00000000                            63  
00000000                            64  
00000000                            65  *************************************************************************************
00000000                            66  
00000000                            67      OPT CRE
00000000                            68  
00000000                            69      INCLUDE "Basic68k3.41.inc"
00000000                            70  
00000000                            71  
00000000=                           72      OFFSET  0           * start of RAM
00000000=                           73  
00000000=                           74  ram_strt    ds.l    $100            * allow 1K for the stack, this should be plenty
00000400=                           75                          * for any BASIC program that doesn't do something
00000400=                           76                          * silly, it could even be much less.
00000400=                           77  ram_base
00000400=                           78  LAB_WARM    ds.w    1           * BASIC warm start entry point
00000402=                           79  Wrmjpv  ds.l    1           * BASIC warm start jump vector
00000406=                           80  
00000406=                           81  Usrjmp  ds.w    1           * USR function JMP address
00000408=                           82  Usrjpv  ds.l    1           * USR function JMP vector
0000040C=                           83  
0000040C=                           84  
0000040C=                           85  V_INPT  ds.w    1           * non halting scan input device entry point
0000040E=                           86  V_INPTv ds.l    1           * non halting scan input device jump vector
00000412=                           87  
00000412=                           88  V_OUTP  ds.w    1           * send byte to output device entry point
00000414=                           89  V_OUTPv ds.l    1           * send byte to output device jump vector
00000418=                           90  
00000418=                           91  V_LOAD  ds.w    1           * load BASIC program entry point
0000041A=                           92  V_LOADv ds.l    1           * load BASIC program jump vector
0000041E=                           93  
0000041E=                           94  V_SAVE  ds.w    1           * save BASIC program entry point
00000420=                           95  V_SAVEv ds.l    1           * save BASIC program jump vector
00000424=                           96  
00000424=                           97  V_CTLC  ds.w    1           * save CTRL-C check entry point
00000426=                           98  V_CTLCv ds.l    1           * save CTRL-C check jump vector
0000042A=                           99  
0000042A=                          100  Itemp       ds.l    1           * temporary integer (for GOTO etc)
0000042E=                          101  
0000042E=                          102  Smeml       ds.l    1           * start of memory       (start of program)
00000432=                          103  
00000432=                          104  
00000432=                          105  Sfncl       ds.l    1           * start of functions    (end of Program)
00000436=                          106  
00000436=                          107  
00000436=                          108  Svarl       ds.l    1           * start of variables    (end of functions)
0000043A=                          109  
0000043A=                          110  
0000043A=                          111  Sstrl       ds.l    1           * start of strings  (end of variables)
0000043E=                          112  
0000043E=                          113  
0000043E=                          114  Sarryl  ds.l    1           * start of arrays       (end of strings)
00000442=                          115  
00000442=                          116  
00000442=                          117  Earryl  ds.l    1           * end of arrays     (start of free mem)
00000446=                          118  Sstorl  ds.l    1           * string storage        (moving down)
0000044A=                          119  Ememl       ds.l    1           * end of memory     (upper bound of RAM)
0000044E=                          120  Sutill  ds.l    1           * string utility ptr
00000452=                          121  Clinel  ds.l    1           * current line      (Basic line number)
00000456=                          122  Blinel  ds.l    1           * break line        (Basic line number)
0000045A=                          123  
0000045A=                          124  Cpntrl  ds.l    1           * continue pointer
0000045E=                          125  Dlinel  ds.l    1           * current DATA line
00000462=                          126  Dptrl       ds.l    1           * DATA pointer
00000466=                          127  Rdptrl  ds.l    1           * read pointer
0000046A=                          128  Varname ds.l    1           * current var name
0000046E=                          129  Cvaral  ds.l    1           * current var address
00000472=                          130  Lvarpl  ds.l    1           * variable pointer for LET and FOR/NEXT
00000476=                          131  
00000476=                          132  des_sk_e    ds.l    6           * descriptor stack end address
0000048E=                          133  des_sk                  * descriptor stack start address
0000048E=                          134                          * use a4 for the descriptor pointer
0000048E=                          135          ds.w    1           
00000490=                          136  Ibuffs  ds.l    $40         * start of input buffer
00000590=                          137  Ibuffe
00000590=                          138                          * end of input buffer
00000590=                          139  
00000590=                          140  FAC1_m  ds.l    1           * FAC1 mantissa1
00000594=                          141  FAC1_e  ds.w    1           * FAC1 exponent
00000596= =00000595                142  FAC1_s  EQU FAC1_e+1        * FAC1 sign (b7)
00000596=                          143          ds.w    1           
00000598=                          144  
00000598=                          145  FAC2_m  ds.l    1           * FAC2 mantissa1
0000059C=                          146  FAC2_e  ds.l    1           * FAC2 exponent
000005A0= =0000059D                147  FAC2_s  EQU FAC2_e+1        * FAC2 sign (b7)
000005A0= =0000059E                148  FAC_sc  EQU FAC2_e+2        * FAC sign comparison, Acc#1 vs #2
000005A0= =0000059F                149  flag        EQU FAC2_e+3        * flag byte for divide routine
000005A0=                          150  
000005A0=                          151  PRNlword    ds.l    1           * PRNG seed long word
000005A4=                          152  
000005A4=                          153  ut1_pl  ds.l    1           * utility pointer 1
000005A8=                          154  
000005A8=                          155  Asptl       ds.l    1           * array size/pointer
000005AC=                          156  Astrtl  ds.l    1           * array start pointer
000005B0=                          157  
000005B0= =000005AC                158  numexp  EQU Astrtl      * string to float number exponent count
000005B0= =000005AD                159  expcnt  EQU Astrtl+1        * string to float exponent count
000005B0=                          160  
000005B0= =000005AF                161  expneg  EQU Astrtl+3        * string to float eval exponent -ve flag
000005B0=                          162  
000005B0=                          163  func_l  ds.l    1           * function pointer
000005B4=                          164  
000005B4=                          165  
000005B4=                          166                          * these two need to be a word aligned pair !
000005B4=                          167  Defdim  ds.w    1           * default DIM flag
000005B6= =000005B4                168  cosout  EQU Defdim      * flag which CORDIC output (re-use byte)
000005B6= =000005B5                169  Dtypef  EQU Defdim+1        * data type flag, $80=string, $40=integer, $00=float
000005B6=                          170  
000005B6=                          171  
000005B6=                          172  Binss       ds.l    4           * number to bin string start (32 chrs)
000005C6=                          173  
000005C6=                          174  Decss       ds.l    1           * number to decimal string start (16 chrs)
000005CA=                          175          ds.w    1           *
000005CC=                          176  Usdss       ds.w    1           * unsigned decimal string start (10 chrs)
000005CE=                          177  
000005CE=                          178  Hexss       ds.l    2           * number to hex string start (8 chrs)
000005D6=                          179  
000005D6=                          180  BHsend  ds.w    1           * bin/decimal/hex string end
000005D8=                          181  
000005D8=                          182  
000005D8=                          183  prstk       ds.b    1           * stacked function index
000005D9=                          184  
000005D9=                          185  tpower  ds.b    1           * remember CORDIC power
000005DA=                          186  
000005DA=                          187  Asrch       ds.b    1           * scan-between-quotes flag, alt search character
000005DB=                          188  
000005DB=                          189  Dimcnt  ds.b    1           * # of dimensions
000005DC=                          190  
000005DC=                          191  Breakf  ds.b    1           * break flag, $00=END else=break
000005DD=                          192  Oquote  ds.b    1           * open quote flag (Flag: DATA; LIST; memory)
000005DE=                          193  Gclctd  ds.b    1           * garbage collected flag
000005DF=                          194  Sufnxf  ds.b    1           * subscript/FNX flag, 1xxx xxx = FN(0xxx xxx)
000005E0=                          195  Imode       ds.b    1           * input mode flag, $00=INPUT, $98=READ
000005E1=                          196  
000005E1=                          197  Cflag       ds.b    1           * comparison evaluation flag
000005E2=                          198  
000005E2=                          199  TabSiz  ds.b    1           * TAB step size
000005E3=                          200  
000005E3=                          201  comp_f  ds.b    1           * compare function flag, bits 0,1 and 2 used
000005E4=                          202                          * bit 2 set if >
000005E4=                          203                          * bit 1 set if =
000005E4=                          204                          * bit 0 set if <
000005E4=                          205  
000005E4=                          206  Nullct  ds.b    1           * nulls output after each line
000005E5=                          207  TPos        ds.b    1           * BASIC terminal position byte
000005E6=                          208  TWidth  ds.b    1           * BASIC terminal width byte
000005E7=                          209  Iclim       ds.b    1           * input column limit
000005E8=                          210  ccflag  ds.b    1           * CTRL-C check flag
000005E9=                          211  ccbyte  ds.b    1           * CTRL-C last received byte
000005EA=                          212  ccnull  ds.b    1           * CTRL-C last received byte 'life' timer
000005EB=                          213  
000005EB=                          214  
000005EB=                          215  file_byte   ds.b    1           * load/save data byte
000005EC=                          216  file_id ds.l    1           * load/save file ID
000005F0=                          217  
000005F0= 0000                     218          dc.w    0           * dummy even value and zero pad byte
000005F2=                          219  
000005F2=                          220  prg_strt
000005F2=                          221  
00000000                           222      ORG *
00000000                           223  
00000000  =00080000                224  ram_addr    EQU $80000      * RAM start address
00000000  =00080000                225  ram_size    EQU $80000      * RAM size
00000000                           226  
00000000                           227  -------------------- end include --------------------
00000000                           228                              * RAM offset definitions
00000000                           229  
00000400                           230      ORG     $000400         * past the vectors in a real system
00000400                           231  
00000400                           232  *************************************************************************************
00000400                           233  *
00000400                           234  * the following code is simulator specific, change to suit your system
00000400                           235  
00000400                           236  * output character to the console from register d0.b
00000400                           237  
00000400                           238  VEC_OUT
00000400  48E7 C000                239      MOVEM.l d0-d1,-(sp)         * save d0, d1
00000404  1200                     240      MOVE.b  d0,d1               * copy character
00000406  7006                     241      MOVEQ       #6,d0               * character out
00000408  4E4F                     242      TRAP        #15             * do I/O function
0000040A  4CDF 0003                243      MOVEM.l (sp)+,d0-d1         * restore d0, d1
0000040E  4E75                     244      RTS
00000410                           245  
00000410                           246  
00000410                           247  *************************************************************************************
00000410                           248  *
00000410                           249  * input a character from the console into register d0
00000410                           250  * else return Cb=0 if there's no character available
00000410                           251  
00000410                           252  VEC_IN
00000410  2F01                     253      MOVE.l  d1,-(sp)            * save d1
00000412  7007                     254      MOVEQ       #7,d0               * get the status
00000414  4E4F                     255      TRAP        #15             * do I/O function
00000416                           256  
00000416  1001                     257      MOVE.b  d1,d0               * copy the returned status
00000418  6606                     258      BNE.s       RETCHR          * if a character is waiting go get it
0000041A                           259  
0000041A  221F                     260      MOVE.l  (sp)+,d1            * else restore d1
0000041C  4A00                     261      TST.b       d0              * set the z flag
0000041E                           262  *   ANDI.b  #$FE,CCR            * clear the carry, flag we got no byte
0000041E                           263  *                           * done by the TST.b
0000041E  4E75                     264      RTS
00000420                           265  
00000420                           266  RETCHR
00000420  7005                     267      MOVEQ       #5,d0               * get byte form the keyboard
00000422  4E4F                     268      TRAP        #15             * do I/O function
00000424                           269  
00000424  1001                     270      MOVE.b  d1,d0               * copy the returned byte
00000426  221F                     271      MOVE.l  (sp)+,d1            * restore d1
00000428  4A00                     272      TST.b       d0              * set the z flag on the received byte
0000042A  003C 0001                273      ORI.b       #1,CCR          * set the carry, flag we got a byte
0000042E  4E75                     274      RTS
00000430                           275  
00000430                           276  
00000430                           277  *************************************************************************************
00000430                           278  *
00000430                           279  * LOAD routine for the Easy68k simulator
00000430                           280  
00000430                           281  VEC_LD
00000430  43FA 00CA                282      LEA     load_title(pc),a1       * set the LOAD request title string pointer
00000434  6100 0064                283      BSR     get_filename        * get the filename from the line or the request
00000438                           284  
00000438  6700 0274                285      BEQ     LAB_FCER            * if null do function call error then warm start
0000043C                           286  
0000043C  303C 0033                287      MOVE        #51,d0          * open existing file
00000440  4E4F                     288      TRAP        #15             * do I/O function
00000442                           289  
00000442  4A40                     290      TST.w       d0              * test load result
00000444  6610                     291      BNE.s       LOAD_exit           * if error clear up and exit
00000446                           292  
00000446  2741 05EC                293      MOVE.l  d1,file_id(a3)      * save the file ID
0000044A                           294  
0000044A  43FA 0012                295      LEA     LOAD_in(pc),a1      * get byte from file vector
0000044E  2749 040E                296      MOVE.l  a1,V_INPTv(a3)      * set the input vector
00000452  6000 02A4                297      BRA     LAB_127D            * now we just wait for Basic command, no "Ready"
00000456                           298  
00000456                           299  LOAD_exit
00000456  6100 0516                300      BSR     LAB_147A            * go do "CLEAR"
0000045A  6000 028E                301      BRA     LAB_1274            * BASIC warm start entry, go wait for Basic
0000045E                           302                              * command
0000045E                           303  
0000045E                           304  * input character to register d0 from file
0000045E                           305  
0000045E                           306  LOAD_in
0000045E  48E7 6040                307      MOVEM.l d1-d2/a1,-(sp)      * save d1, d2 & a1
00000462  222B 05EC                308      MOVE.l  file_id(a3),d1      * get file ID back
00000466  43EB 05EB                309      LEA     file_byte(a3),a1        * point to byte buffer
0000046A  7401                     310      MOVEQ       #1,d2               * set count for one byte
0000046C  7035                     311      MOVEQ       #53,d0          * read from file
0000046E  4E4F                     312      TRAP        #15             * do I/O function
00000470                           313  
00000470  4A40                     314      TST.w       d0              * test status
00000472  660C                     315      BNE.s       LOAD_eof            * branch if byte read failed
00000474                           316  
00000474  1011                     317      MOVE.b  (a1),d0         * get byte
00000476  4CDF 0206                318      MOVEM.l (sp)+,d1-d2/a1      * restore d1, d2 & a1
0000047A  003C 0001                319      ORI.b       #1,CCR          * set carry, flag we got a byte
0000047E  4E75                     320      RTS
00000480                           321                              * got an error on read so restore the input
00000480                           322                              * vector and tidy up
00000480                           323  LOAD_eof
00000480  7032                     324      MOVEQ       #50,d0          * close all files
00000482  4E4F                     325      TRAP        #15             * do I/O function
00000484                           326  
00000484  43FA FF8A                327      LEA     VEC_IN(pc),a1       * get byte from input device vector
00000488  2749 040E                328      MOVE.l  a1,V_INPTv(a3)      * set input vector
0000048C  7000                     329      MOVEQ       #0,d0               * clear byte
0000048E  4CDF 0206                330      MOVEM.l (sp)+,d1-d2/a1      * restore d1, d2 & a1
00000492  6100 04DA                331      BSR     LAB_147A            * do CLEAR, erase variables/functions and
00000496                           332                              * flush stacks
00000496  6000 0252                333      BRA     LAB_1274            * BASIC warm start entry, go wait for Basic
0000049A                           334                              * command
0000049A                           335  
0000049A                           336  
0000049A                           337  *************************************************************************************
0000049A                           338  *
0000049A                           339  * get the filename from the line or from the filename requester
0000049A                           340  *
0000049A                           341  * if the name is null, "", or there is nothing following then the requester is used
0000049A                           342  * to get a filename else the filename is got from the line. if the requester is used
0000049A                           343  * the name buffer is allocated in string space and is always null terminated before
0000049A                           344  * it is passed to the file requester
0000049A                           345  
0000049A                           346  get_filename
0000049A  6740                     347      BEQ.s       get_name            * if no following go use the requester
0000049C                           348  
0000049C                           349  get_file
0000049C  2F09                     350      MOVE.l  a1,-(sp)            * save the title string pointer
0000049E  534D                     351      SUBQ.w  #1,a5               * decrement the execute pointer
000004A0  6100 0E0A                352      BSR     LAB_GVAL            * get value from line
000004A4  225F                     353      MOVEA.l (sp)+,a1            * restore the title string pointer
000004A6  4A2B 05B5                354      TST.b       Dtypef(a3)          * test the data type flag
000004AA  6A00 01E2                355      BPL     LAB_TMER            * if not string type do type mismatch error
000004AE                           356  
000004AE  246B 0590                357      MOVEA.l FAC1_m(a3),a2       * get the descriptor pointer
000004B2  322A 0004                358      MOVE.w  4(a2),d1            * get the string length
000004B6  6724                     359      BEQ.s       get_name            * if null go use the file requester
000004B8                           360  
000004B8  2252                     361      MOVEA.l (a2),a1         * get the string pointer
000004BA  3001                     362      MOVE.w  d1,d0               * copy the string length
000004BC  5241                     363      ADDQ.w  #1,d1               * increment the string length
000004BE  6100 14BC                364      BSR     LAB_2115            * make space d1 bytes long
000004C2                           365  
000004C2  11BC 0000 0000           366      MOVE.b  #$00,(a0,d0.w)      * null terminate the new string
000004C8  5340                     367      SUBQ.w  #1,d0               * decrement the string length
000004CA                           368  name_copy
000004CA  11B1 0000 0000           369      MOVE.b  (a1,d0.w),(a0,d0.w) * copy a file name byte
000004D0  51C8 FFF8                370      DBF     d0,name_copy        * loop while more to do
000004D4                           371  
000004D4  2248                     372      MOVEA.l a0,a1               * copy the new, terminated, file name pointer
000004D6                           373  
000004D6  204A                     374      MOVEA.l a2,a0               * copy the old filename descriptor pointer
000004D8  6000 1636                375      BRA     LAB_22B6            * pop string off descriptor stack or from memory
000004DC                           376                              * returns with d0 = length, a0 = pointer
000004DC                           377  
000004DC                           378  * get a name with the file requester
000004DC                           379  
000004DC                           380  get_name
000004DC  2F0B                     381      MOVE.l  a3,-(sp)            * save the variables base pointer
000004DE  323C 0100                382      MOVE.w  #$100,d1            * enough space for the request filename
000004E2  6100 1498                383      BSR     LAB_2115            * make space d1 bytes long
000004E6  2648                     384      MOVEA.l a0,a3               * copy the file name buffer pointer
000004E8  45FA 0026                385      LEA     file_list(pc),a2        * set the file types list pointer
000004EC  7200                     386      MOVEQ       #0,d1               * file open
000004EE  1681                     387      MOVE.b  d1,(a3)         * ensure initial null file name
000004F0  703A                     388      MOVEQ       #58,d0          * file I/O
000004F2  4E4F                     389      TRAP        #15
000004F4                           390  
000004F4  224B                     391      MOVEA.l a3,a1               * copy the file name pointer
000004F6  265F                     392      MOVEA.l (sp)+,a3            * restore the variables pointer
000004F8  4A81                     393      TST.l       d1              * did the user hit open
000004FA  4E75                     394      RTS
000004FC                           395  
000004FC                           396  
000004FC                           397  load_title
000004FC= 4C 4F 41 44 20 66 ...    398      dc.b    'LOAD file',0           * LOAD file title string
00000506                           399  
00000506                           400  save_title
00000506= 53 41 56 45 20 66 ...    401      dc.b    'SAVE file',0           * SAVE file title string
00000510                           402  
00000510                           403  file_list
00000510= 2A 2E 62 61 73 00        404      dc.b    '*.bas',0               * file type list
00000516                           405      ds.w    0                   * ensure even
00000516                           406  
00000516                           407  
00000516                           408  *************************************************************************************
00000516                           409  *
00000516                           410  * SAVE routine for the Easy68k simulator
00000516                           411  
00000516                           412  VEC_SV
00000516  43FA FFEE                413      LEA     save_title(pc),a1       * set the SAVE request title string pointer
0000051A  487A 000E                414      PEA     SAVE_RTN(pc)        * set the return point
0000051E  67BC                     415      BEQ.s       get_name            * if no following go use the file requester
00000520                           416  
00000520  B03C 002C                417      CMP.b       #',',d0         * compare the following byte with ","
00000524  6600 FF76                418      BNE     get_file            * if not "," get the filename from the line
00000528                           419  
00000528  67B2                     420      BEQ.s       get_name            * else go use the file requester
0000052A                           421  
0000052A                           422  SAVE_RTN
0000052A  6700 0182                423      BEQ     LAB_FCER            * if null do function call error then warm start
0000052E                           424  
0000052E  2248                     425      MOVEA.l a0,a1               * copy filename pointer
00000530  303C 0034                426      MOVE        #52,d0          * open new file
00000534  4E4F                     427      TRAP        #15             * do I/O function
00000536                           428  
00000536  4A40                     429      TST.w       d0              * test save result
00000538  6600 0174                430      BNE     LAB_FCER            * if error do function call error, warm start
0000053C                           431  
0000053C  2741 05EC                432      MOVE.l  d1,file_id(a3)      * save file ID
00000540                           433  
00000540  2F2B 0414                434      MOVE.l  V_OUTPv(a3),-(sp)       * save the output vector
00000544  43FA 0036                435      LEA     SAVE_OUT(pc),a1     * send byte to file vector
00000548  2749 0414                436      MOVE.l  a1,V_OUTPv(a3)      * change the output vector
0000054C                           437  
0000054C  1F2B 05E6                438      MOVE.b  TWidth(a3),-(sp)        * save the current line length
00000550  177C 0000 05E6           439      MOVE.b  #$00,TWidth(a3)     * set infinite length line for save
00000556                           440  
00000556  6100 0DA8                441      BSR     LAB_GBYT            * get next BASIC byte
0000055A  6700 000E                442      BEQ     SAVE_bas            * if no following go do SAVE
0000055E                           443  
0000055E  B03C 002C                444      CMP.b       #',',d0         * else compare with ","
00000562  6600 0156                445      BNE     LAB_SNER            * if not "," so go do syntax error/warm start
00000566                           446  
00000566  6100 0D96                447      BSR     LAB_IGBY            * increment & scan memory
0000056A                           448  SAVE_bas
0000056A  6100 0442                449      BSR     LAB_LIST            * go do list (line numbers applicable)
0000056E  175F 05E6                450      MOVE.b  (sp)+,TWidth(a3)        * restore the line length
00000572                           451  
00000572  275F 0414                452      MOVE.l  (sp)+,V_OUTPv(a3)       * restore the output vector
00000576  7032                     453      MOVEQ       #50,d0          * close all files
00000578  4E4F                     454      TRAP        #15             * do I/O function
0000057A                           455  
0000057A  4E75                     456      RTS
0000057C                           457  
0000057C                           458  
0000057C                           459  * output character to file from register d0
0000057C                           460  
0000057C                           461  SAVE_OUT
0000057C  48E7 E040                462      MOVEM.l d0-d2/a1,-(sp)      * save d0, d1, d2 & a1
00000580  222B 05EC                463      MOVE.l  file_id(a3),d1      * get file ID back
00000584  43EB 05EB                464      LEA     file_byte(a3),a1        * point to byte buffer
00000588  1280                     465      MOVE.b  d0,(a1)         * save byte
0000058A  7401                     466      MOVEQ       #1,d2               * set byte count
0000058C  7036                     467      MOVEQ       #54,d0          * write to file
0000058E  4E4F                     468      TRAP        #15             * do I/O function
00000590                           469  
00000590  4CDF 0207                470      MOVEM.l (sp)+,d0-d2/a1      * restore d0, d1, d2 & a1
00000594  4E75                     471      RTS
00000596                           472  
00000596                           473  
00000596                           474  *************************************************************************************
00000596                           475  *
00000596                           476  * turn off simulator key echo
00000596                           477  
00000596                           478  code_start
00000596  700C                     479      MOVEQ       #12,d0          * keyboard echo
00000598  7200                     480      MOVEQ       #0,d1               * turn off echo
0000059A  4E4F                     481      TRAP        #15             * do I/O function
0000059C                           482  
0000059C                           483  * to tell EhBASIC where and how much RAM it has pass the address in a0 and the size
0000059C                           484  * in d0. these values are at the end of the .inc file
0000059C                           485  
0000059C  207C 00080000            486      MOVEA.l #ram_addr,a0        * tell BASIC where RAM starts
000005A2  203C 00080000            487      MOVE.l  #ram_size,d0        * tell BASIC how big RAM is
000005A8                           488  
000005A8                           489  * end of simulator specific code
000005A8                           490  
000005A8                           491  
000005A8                           492  ****************************************************************************************
000005A8                           493  ****************************************************************************************
000005A8                           494  ****************************************************************************************
000005A8                           495  ****************************************************************************************
000005A8                           496  *
000005A8                           497  * Register use :- (must improve this !!)
000005A8                           498  *
000005A8                           499  *   a6 -    temp Bpntr              * temporary BASIC execute pointer
000005A8                           500  *   a5 -    Bpntr                   * BASIC execute (get byte) pointer
000005A8                           501  *   a4 -    des_sk              * descriptor stack pointer
000005A8                           502  *   a3 -    ram_strt                * start of RAM. all RAM references are offsets
000005A8                           503  *                           * from this value
000005A8                           504  *
000005A8                           505  
000005A8                           506  *************************************************************************************
000005A8                           507  *
000005A8                           508  * BASIC cold start entry point. assume entry with RAM address in a0 and RAM length
000005A8                           509  * in d0
000005A8                           510  
000005A8                           511  LAB_COLD
000005A8  B0BC 00004000            512      CMP.l       #$4000,d0           * compare size with 16k
000005AE  6C04                     513      BGE.s       LAB_sizok           * branch if >= 16k
000005B0                           514  
000005B0  7005                     515      MOVEQ       #5,d0               * error 5 - not enough RAM
000005B2  4E75                     516      RTS                     * just exit. this as stands will never execute
000005B4                           517                              * but could be used to exit to an OS
000005B4                           518  
000005B4                           519  LAB_sizok
000005B4  2648                     520      MOVEA.l a0,a3               * copy RAM base to a3
000005B6  D1C0                     521      ADDA.l  d0,a0               * a0 is top of RAM
000005B8  2748 044A                522      MOVE.l  a0,Ememl(a3)        * set end of mem
000005BC  4FEB 0400                523      LEA     ram_base(a3),sp     * set stack to RAM start + 1k
000005C0                           524  
000005C0  303C 4EF9                525      MOVE.w  #$4EF9,d0           * JMP opcode
000005C4  204F                     526      MOVEA.l sp,a0               * point to start of vector table
000005C6                           527  
000005C6  30C0                     528      MOVE.w  d0,(a0)+            * LAB_WARM
000005C8  43FA FFDE                529      LEA     LAB_COLD(pc),a1     * initial warm start vector
000005CC  20C9                     530      MOVE.l  a1,(a0)+            * set vector
000005CE                           531  
000005CE  30C0                     532      MOVE.w  d0,(a0)+            * Usrjmp
000005D0  43FA 00DC                533      LEA     LAB_FCER(pc),a1     * initial user function vector
000005D4                           534                              * "Function call" error
000005D4  20C9                     535      MOVE.l  a1,(a0)+            * set vector
000005D6                           536  
000005D6  30C0                     537      MOVE.w  d0,(a0)+            * V_INPT JMP opcode
000005D8  43FA FE36                538      LEA     VEC_IN(pc),a1       * get byte from input device vector
000005DC  20C9                     539      MOVE.l  a1,(a0)+            * set vector
000005DE                           540  
000005DE  30C0                     541      MOVE.w  d0,(a0)+            * V_OUTP JMP opcode
000005E0  43FA FE1E                542      LEA     VEC_OUT(pc),a1      * send byte to output device vector
000005E4  20C9                     543      MOVE.l  a1,(a0)+            * set vector
000005E6                           544  
000005E6  30C0                     545      MOVE.w  d0,(a0)+            * V_LOAD JMP opcode
000005E8  43FA FE46                546      LEA     VEC_LD(pc),a1       * load BASIC program vector
000005EC  20C9                     547      MOVE.l  a1,(a0)+            * set vector
000005EE                           548  
000005EE  30C0                     549      MOVE.w  d0,(a0)+            * V_SAVE JMP opcode
000005F0  43FA FF24                550      LEA     VEC_SV(pc),a1       * save BASIC program vector
000005F4  20C9                     551      MOVE.l  a1,(a0)+            * set vector
000005F6                           552  
000005F6  30C0                     553      MOVE.w  d0,(a0)+            * V_CTLC JMP opcode
000005F8  43FA 285E                554      LEA     VEC_CC(pc),a1       * save CTRL-C check vector
000005FC  20C9                     555      MOVE.l  a1,(a0)+            * set vector
000005FE                           556  
000005FE                           557  * set-up start values
000005FE                           558  
000005FE                           559  LAB_GMEM
000005FE  7000                     560      MOVEQ       #$00,d0         * clear d0
00000600  1740 05E4                561      MOVE.b  d0,Nullct(a3)       * default NULL count
00000604  1740 05E5                562      MOVE.b  d0,TPos(a3)         * clear terminal position
00000608  1740 05E8                563      MOVE.b  d0,ccflag(a3)       * allow CTRL-C check
0000060C  3740 05F0                564      MOVE.w  d0,prg_strt-2(a3)       * clear start word
00000610  3740 05D6                565      MOVE.w  d0,BHsend(a3)       * clear value to string end word
00000614                           566  
00000614  177C 0050 05E6           567      MOVE.b  #$50,TWidth(a3)     * default terminal width byte for simulator *##
0000061A                           568  *## MOVE.b  d0,TWidth(a3)       * default terminal width byte
0000061A                           569  
0000061A  177C 000E 05E2           570      MOVE.b  #$0E,TabSiz(a3)     * save default tab size = 14
00000620                           571  
00000620  177C 0038 05E7           572      MOVE.b  #$38,Iclim(a3)      * default limit for TAB = 14 for simulator *##
00000626                           573  *## MOVE.b  #$F2,Iclim(a3)      * default limit for TAB = 14
00000626                           574  
00000626  49EB 048E                575      LEA     des_sk(a3),a4       * set descriptor stack start
0000062A                           576  
0000062A  41EB 05F2                577      LEA     prg_strt(a3),a0     * get start of mem
0000062E  2748 042E                578      MOVE.l  a0,Smeml(a3)        * save start of mem
00000632                           579  
00000632  6100 0328                580      BSR     LAB_1463            * do "NEW" and "CLEAR"
00000636  6100 089E                581      BSR     LAB_CRLF            * print CR/LF
0000063A  202B 044A                582      MOVE.l  Ememl(a3),d0        * get end of mem
0000063E  90AB 042E                583      SUB.l       Smeml(a3),d0        * subtract start of mem
00000642                           584  
00000642  6100 1E0C                585      BSR     LAB_295E            * print d0 as unsigned integer (bytes free)
00000646  41FA 36C2                586      LEA     LAB_SMSG(pc),a0     * point to start message
0000064A  6100 08E8                587      BSR     LAB_18C3            * print null terminated string from memory
0000064E                           588  
0000064E  41FA 2C12                589      LEA     LAB_RSED(pc),a0     * get pointer to value
00000652  6100 1CA6                590      BSR     LAB_UFAC            * unpack memory (a0) into FAC1
00000656                           591  
00000656  41FA 0092                592      LEA     LAB_1274(pc),a0     * get warm start vector
0000065A  2748 0402                593      MOVE.l  a0,Wrmjpv(a3)       * set warm start vector
0000065E  6100 2212                594      BSR     LAB_RND         * initialise
00000662  4EEB 0400                595      JMP     LAB_WARM(a3)        * go do warm start
00000666                           596  
00000666                           597  
00000666                           598  *************************************************************************************
00000666                           599  *
00000666                           600  * do format error
00000666                           601  
00000666                           602  LAB_FOER
00000666  7E2C                     603      MOVEQ       #$2C,d7         * error code $2C "Format" error
00000668  6056                     604      BRA.s       LAB_XERR            * do error #d7, then warm start
0000066A                           605  
0000066A                           606  
0000066A                           607  *************************************************************************************
0000066A                           608  *
0000066A                           609  * do address error
0000066A                           610  
0000066A                           611  LAB_ADER
0000066A  7E2A                     612      MOVEQ       #$2A,d7         * error code $2A "Address" error
0000066C  6052                     613      BRA.s       LAB_XERR            * do error #d7, then warm start
0000066E                           614  
0000066E                           615  
0000066E                           616  *************************************************************************************
0000066E                           617  *
0000066E                           618  * do wrong dimensions error
0000066E                           619  
0000066E                           620  LAB_WDER
0000066E  7E28                     621      MOVEQ       #$28,d7         * error code $28 "Wrong dimensions" error
00000670  604E                     622      BRA.s       LAB_XERR            * do error #d7, then warm start
00000672                           623  
00000672                           624  
00000672                           625  *************************************************************************************
00000672                           626  *
00000672                           627  * do undimensioned array error
00000672                           628  
00000672                           629  LAB_UDER
00000672  7E26                     630      MOVEQ       #$26,d7         * error code $26 "undimensioned array" error
00000674  604A                     631      BRA.s       LAB_XERR            * do error #d7, then warm start
00000676                           632  
00000676                           633  
00000676                           634  *************************************************************************************
00000676                           635  *
00000676                           636  * do undefined variable error
00000676                           637  
00000676                           638  LAB_UVER
00000676                           639  
00000676                           640  * if you do want a non existant variable to return an error then leave the novar
00000676                           641  * value at the top of this file set to zero
00000676                           642  
00000676                 TRUE      643   ifeq   novar
00000676                           644  
00000676  7E24                     645      MOVEQ       #$24,d7         * error code $24 "undefined variable" error
00000678  6046                     646      BRA.s       LAB_XERR            * do error #d7, then warm start
0000067A                           647  
0000067A                           648   endc
0000067A                           649  
0000067A                           650  * if you want a non existant variable to return a null value then set the novar
0000067A                           651  * value at the top of this file to some non zero value
0000067A                           652  
0000067A                 FALSE     653   ifne   novar
0000067A                           654   endc
0000067A                           655  
0000067A                           656  
0000067A                           657  *************************************************************************************
0000067A                           658  *
0000067A                           659  * do loop without do error
0000067A                           660  
0000067A                           661  LAB_LDER
0000067A  7E22                     662      MOVEQ       #$22,d7         * error code $22 "LOOP without DO" error
0000067C  6042                     663      BRA.s       LAB_XERR            * do error #d7, then warm start
0000067E                           664  
0000067E                           665  
0000067E                           666  *************************************************************************************
0000067E                           667  *
0000067E                           668  * do undefined function error
0000067E                           669  
0000067E                           670  LAB_UFER
0000067E  7E20                     671      MOVEQ       #$20,d7         * error code $20 "Undefined function" error
00000680  603E                     672      BRA.s       LAB_XERR            * do error #d7, then warm start
00000682                           673  
00000682                           674  
00000682                           675  *************************************************************************************
00000682                           676  *
00000682                           677  * do can't continue error
00000682                           678  
00000682                           679  LAB_CCER
00000682  7E1E                     680      MOVEQ       #$1E,d7         * error code $1E "Can't continue" error
00000684  603A                     681      BRA.s       LAB_XERR            * do error #d7, then warm start
00000686                           682  
00000686                           683  
00000686                           684  *************************************************************************************
00000686                           685  *
00000686                           686  * do string too complex error
00000686                           687  
00000686                           688  LAB_SCER
00000686  7E1C                     689      MOVEQ       #$1C,d7         * error code $1C "String too complex" error
00000688  6036                     690      BRA.s       LAB_XERR            * do error #d7, then warm start
0000068A                           691  
0000068A                           692  
0000068A                           693  *************************************************************************************
0000068A                           694  *
0000068A                           695  * do string too long error
0000068A                           696  
0000068A                           697  LAB_SLER
0000068A  7E1A                     698      MOVEQ       #$1A,d7         * error code $1A "String too long" error
0000068C  6032                     699      BRA.s       LAB_XERR            * do error #d7, then warm start
0000068E                           700  
0000068E                           701  
0000068E                           702  *************************************************************************************
0000068E                           703  *
0000068E                           704  * do type missmatch error
0000068E                           705  
0000068E                           706  LAB_TMER
0000068E  7E18                     707      MOVEQ       #$18,d7         * error code $18 "Type mismatch" error
00000690  602E                     708      BRA.s       LAB_XERR            * do error #d7, then warm start
00000692                           709  
00000692                           710  
00000692                           711  *************************************************************************************
00000692                           712  *
00000692                           713  * do illegal direct error
00000692                           714  
00000692                           715  LAB_IDER
00000692  7E16                     716      MOVEQ       #$16,d7         * error code $16 "Illegal direct" error
00000694  602A                     717      BRA.s       LAB_XERR            * do error #d7, then warm start
00000696                           718  
00000696                           719  
00000696                           720  *************************************************************************************
00000696                           721  *
00000696                           722  * do divide by zero error
00000696                           723  
00000696                           724  LAB_DZER
00000696  7E14                     725      MOVEQ       #$14,d7         * error code $14 "Divide by zero" error
00000698  6026                     726      BRA.s       LAB_XERR            * do error #d7, then warm start
0000069A                           727  
0000069A                           728  
0000069A                           729  *************************************************************************************
0000069A                           730  *
0000069A                           731  * do double dimension error
0000069A                           732  
0000069A                           733  LAB_DDER
0000069A  7E12                     734      MOVEQ       #$12,d7         * error code $12 "Double dimension" error
0000069C  6022                     735      BRA.s       LAB_XERR            * do error #d7, then warm start
0000069E                           736  
0000069E                           737  
0000069E                           738  *************************************************************************************
0000069E                           739  *
0000069E                           740  * do array bounds error
0000069E                           741  
0000069E                           742  LAB_ABER
0000069E  7E10                     743      MOVEQ       #$10,d7         * error code $10 "Array bounds" error
000006A0  601E                     744      BRA.s       LAB_XERR            * do error #d7, then warm start
000006A2                           745  
000006A2                           746  
000006A2                           747  *************************************************************************************
000006A2                           748  *
000006A2                           749  * do undefine satement error
000006A2                           750  
000006A2                           751  LAB_USER
000006A2  7E0E                     752      MOVEQ       #$0E,d7         * error code $0E "Undefined statement" error
000006A4  601A                     753      BRA.s       LAB_XERR            * do error #d7, then warm start
000006A6                           754  
000006A6                           755  
000006A6                           756  *************************************************************************************
000006A6                           757  *
000006A6                           758  * do out of memory error
000006A6                           759  
000006A6                           760  LAB_OMER
000006A6  7E0C                     761      MOVEQ       #$0C,d7         * error code $0C "Out of memory" error
000006A8  6016                     762      BRA.s       LAB_XERR            * do error #d7, then warm start
000006AA                           763  
000006AA                           764  
000006AA                           765  *************************************************************************************
000006AA                           766  *
000006AA                           767  * do overflow error
000006AA                           768  
000006AA                           769  LAB_OFER
000006AA  7E0A                     770      MOVEQ       #$0A,d7         * error code $0A "Overflow" error
000006AC  6012                     771      BRA.s       LAB_XERR            * do error #d7, then warm start
000006AE                           772  
000006AE                           773  
000006AE                           774  *************************************************************************************
000006AE                           775  *
000006AE                           776  * do function call error
000006AE                           777  
000006AE                           778  LAB_FCER
000006AE  7E08                     779      MOVEQ       #$08,d7         * error code $08 "Function call" error
000006B0  600E                     780      BRA.s       LAB_XERR            * do error #d7, then warm start
000006B2                           781  
000006B2                           782  
000006B2                           783  *************************************************************************************
000006B2                           784  *
000006B2                           785  * do out of data error
000006B2                           786  
000006B2                           787  LAB_ODER
000006B2  7E06                     788      MOVEQ       #$06,d7         * error code $06 "Out of DATA" error
000006B4  600A                     789      BRA.s       LAB_XERR            * do error #d7, then warm start
000006B6                           790  
000006B6                           791  
000006B6                           792  *************************************************************************************
000006B6                           793  *
000006B6                           794  * do return without gosub error
000006B6                           795  
000006B6                           796  LAB_RGER
000006B6  7E04                     797      MOVEQ       #$04,d7         * error code $04 "RETURN without GOSUB" error
000006B8  6006                     798      BRA.s       LAB_XERR            * do error #d7, then warm start
000006BA                           799  
000006BA                           800  
000006BA                           801  *************************************************************************************
000006BA                           802  *
000006BA                           803  * do syntax error
000006BA                           804  
000006BA                           805  LAB_SNER
000006BA  7E02                     806      MOVEQ       #$02,d7         * error code $02 "Syntax" error
000006BC  6002                     807      BRA.s       LAB_XERR            * do error #d7, then warm start
000006BE                           808  
000006BE                           809  
000006BE                           810  *************************************************************************************
000006BE                           811  *
000006BE                           812  * do next without for error
000006BE                           813  
000006BE                           814  LAB_NFER
000006BE  7E00                     815      MOVEQ       #$00,d7         * error code $00 "NEXT without FOR" error
000006C0                           816  
000006C0                           817  
000006C0                           818  *************************************************************************************
000006C0                           819  *
000006C0                           820  * do error #d7, then warm start
000006C0                           821  
000006C0                           822  LAB_XERR
000006C0  6100 02D0                823      BSR     LAB_1491            * flush stack & clear continue flag
000006C4  6100 0810                824      BSR     LAB_CRLF            * print CR/LF
000006C8  43FA 3282                825      LEA     LAB_BAER(pc),a1     * start of error message pointer table
000006CC  3E31 7000                826      MOVE.w  (a1,d7.w),d7        * get error message offset
000006D0  41F1 7000                827      LEA     (a1,d7.w),a0        * get error message address
000006D4  6100 085E                828      BSR     LAB_18C3            * print null terminated string from memory
000006D8  41FA 35F3                829      LEA     LAB_EMSG(pc),a0     * point to " Error" message
000006DC                           830  LAB_1269
000006DC  6100 0856                831      BSR     LAB_18C3            * print null terminated string from memory
000006E0  202B 0452                832      MOVE.l  Clinel(a3),d0       * get current line
000006E4  6B04                     833      BMI.s       LAB_1274            * go do warm start if -ve # (was immediate mode)
000006E6                           834  
000006E6                           835                              * else print line number
000006E6  6100 1D5C                836      BSR     LAB_2953            * print " in line [LINE #]"
000006EA                           837  
000006EA                           838  * BASIC warm start entry point, wait for Basic command
000006EA                           839  
000006EA                           840  LAB_1274
000006EA  7210                     841      MOVEQ       #16,d1          * turn off double buffering
000006EC  705C                     842      MOVEQ       #92,d0          * set draw mode
000006EE  4E4F                     843      TRAP        #15             * do I/O function
000006F0                           844  
000006F0  41FA 360E                845      LEA     LAB_RMSG(pc),a0     * point to "Ready" message
000006F4  6100 083E                846      BSR     LAB_18C3            * go do print string
000006F8                           847  
000006F8                           848  * wait for Basic command (no "Ready")
000006F8                           849  
000006F8                           850  LAB_127D
000006F8  72FF                     851      MOVEQ       #-1,d1          * set to -1
000006FA  2741 0452                852      MOVE.l  d1,Clinel(a3)       * set current line #
000006FE  1741 05DC                853      MOVE.b  d1,Breakf(a3)       * set break flag
00000702  4BEB 0490                854      LEA     Ibuffs(a3),a5       * set BASIC execute pointer ready for new line
00000706                           855  LAB_127E
00000706  6100 00EC                856      BSR     LAB_1357            * call for BASIC input
0000070A  6100 0BF4                857      BSR     LAB_GBYT            * scan memory
0000070E  67F6                     858      BEQ.s       LAB_127E            * loop while null
00000710                           859  
00000710                           860  * got to interpret input line now ....
00000710                           861  
00000710  6508                     862      BCS.s       LAB_1295            * branch if numeric character, handle new
00000712                           863                              * BASIC line
00000712                           864  
00000712                           865                              * no line number so do immediate mode, a5
00000712                           866                              * points to the buffer start
00000712  6100 0156                867      BSR     LAB_13A6            * crunch keywords into Basic tokens
00000716                           868                              * crunch from (a5), output to (a0)
00000716                           869                              * returns ..
00000716                           870                              * d2 is length, d1 trashed, d0 trashed,
00000716                           871                              * a1 trashed
00000716  6000 03C4                872      BRA     LAB_15F6            * go scan & interpret code
0000071A                           873  
0000071A                           874  
0000071A                           875  *************************************************************************************
0000071A                           876  *
0000071A                           877  * handle a new BASIC line
0000071A                           878  
0000071A                           879  LAB_1295
0000071A  6100 063A                880      BSR     LAB_GFPN            * get fixed-point number into temp integer & d1
0000071E  6100 014A                881      BSR     LAB_13A6            * crunch keywords into Basic tokens
00000722                           882                              * crunch from (a5), output to (a0)
00000722                           883                              * returns .. d2 is length,
00000722                           884                              * d1 trashed, d0 trashed, a1 trashed
00000722  222B 042A                885      MOVE.l  Itemp(a3),d1        * get required line #
00000726  6100 0218                886      BSR     LAB_SSLN            * search BASIC for d1 line number
0000072A                           887                              * returns pointer in a0
0000072A  6532                     888      BCS.s       LAB_12E6            * branch if not found
0000072C                           889  
0000072C                           890                              * aroooogah! line # already exists! delete it
0000072C  2250                     891      MOVEA.l (a0),a1         * get start of block (next line pointer)
0000072E  202B 0432                892      MOVE.l  Sfncl(a3),d0        * get end of block (start of functions)
00000732  9089                     893      SUB.l       a1,d0               * subtract start of block ( = bytes to move)
00000734  E288                     894      LSR.l       #1,d0               * /2 (word move)
00000736  5380                     895      SUBQ.l  #1,d0               * adjust for DBF loop
00000738  4840                     896      SWAP        d0              * swap high word to low word
0000073A  2448                     897      MOVEA.l a0,a2               * copy destination
0000073C                           898  LAB_12AE
0000073C  4840                     899      SWAP        d0              * swap high word to low word
0000073E                           900  LAB_12B0
0000073E  34D9                     901      MOVE.w  (a1)+,(a2)+         * copy word
00000740  51C8 FFFC                902      DBF     d0,LAB_12B0         * decrement low count and loop until done
00000744                           903  
00000744  4840                     904      SWAP        d0              * swap high word to low word
00000746  51C8 FFF4                905      DBF     d0,LAB_12AE         * decrement high count and loop until done
0000074A                           906  
0000074A  274A 0432                907      MOVE.l  a2,Sfncl(a3)        * start of functions
0000074E  274A 0436                908      MOVE.l  a2,Svarl(a3)        * save start of variables
00000752  274A 043A                909      MOVE.l  a2,Sstrl(a3)        * start of strings
00000756  274A 043E                910      MOVE.l  a2,Sarryl(a3)       * save start of arrays
0000075A  274A 0442                911      MOVE.l  a2,Earryl(a3)       * save end of arrays
0000075E                           912  
0000075E                           913                              * got new line in buffer and no existing same #
0000075E                           914  LAB_12E6
0000075E  102B 0490                915      MOVE.b  Ibuffs(a3),d0       * get byte from start of input buffer
00000762  6764                     916      BEQ.s       LAB_1325            * if null line go do line chaining
00000764                           917  
00000764                           918                              * got new line and it isn't empty line
00000764  226B 0432                919      MOVEA.l Sfncl(a3),a1        * get start of functions (end of block to move)
00000768  45F1 2008                920      LEA     8(a1,d2),a2         * copy it, add line length and add room for
0000076C                           921                              * pointer and line number
0000076C                           922  
0000076C  274A 0432                923      MOVE.l  a2,Sfncl(a3)        * start of functions
00000770  274A 0436                924      MOVE.l  a2,Svarl(a3)        * save start of variables
00000774  274A 043A                925      MOVE.l  a2,Sstrl(a3)        * start of strings
00000778  274A 043E                926      MOVE.l  a2,Sarryl(a3)       * save start of arrays
0000077C  274A 0442                927      MOVE.l  a2,Earryl(a3)       * save end of arrays
00000780  276B 044A 0446           928      MOVE.l  Ememl(a3),Sstorl(a3)    * copy end of mem to start of strings, clear
00000786                           929                              * strings
00000786                           930  
00000786  2209                     931      MOVE.l  a1,d1               * copy end of block to move
00000788  9288                     932      SUB.l       a0,d1               * subtract start of block to move
0000078A  E289                     933      LSR.l       #1,d1               * /2 (word copy)
0000078C  5381                     934      SUBQ.l  #1,d1               * correct for loop end on -1
0000078E  4841                     935      SWAP        d1              * swap high word to low word
00000790                           936  LAB_12FF
00000790  4841                     937      SWAP        d1              * swap high word to low word
00000792                           938  LAB_1301
00000792  3521                     939      MOVE.w  -(a1),-(a2)         * decrement pointers and copy word
00000794  51C9 FFFC                940      DBF     d1,LAB_1301         * decrement & loop
00000798                           941  
00000798  4841                     942      SWAP        d1              * swap high word to low word
0000079A  51C9 FFF4                943      DBF     d1,LAB_12FF         * decrement high count and loop until done
0000079E                           944  
0000079E                           945  * space is opened up, now copy the crunched line from the input buffer into the space
0000079E                           946  
0000079E  43EB 0490                947      LEA     Ibuffs(a3),a1       * source is input buffer
000007A2  2448                     948      MOVEA.l a0,a2               * copy destination
000007A4  72FF                     949      MOVEQ       #-1,d1          * set to allow re-chaining
000007A6  24C1                     950      MOVE.l  d1,(a2)+            * set next line pointer (allow re-chaining)
000007A8  24EB 042A                951      MOVE.l  Itemp(a3),(a2)+     * save line number
000007AC  E24A                     952      LSR.w       #1,d2               * /2 (word copy)
000007AE  5342                     953      SUBQ.w  #1,d2               * correct for loop end on -1
000007B0                           954  LAB_1303
000007B0  34D9                     955      MOVE.w  (a1)+,(a2)+         * copy word
000007B2  51CA FFFC                956      DBF     d2,LAB_1303         * decrement & loop
000007B6                           957  
000007B6  6010                     958      BRA.s       LAB_1325            * go test for end of prog
000007B8                           959  
000007B8                           960  * rebuild chaining of Basic lines
000007B8                           961  
000007B8                           962  LAB_132E
000007B8  5048                     963      ADDQ.w  #8,a0               * point to first code byte of line, there is
000007BA                           964                              * always 1 byte + [EOL] as null entries are
000007BA                           965                              * deleted
000007BA                           966  LAB_1330
000007BA  4A18                     967      TST.b       (a0)+               * test byte 
000007BC  66FC                     968      BNE.s       LAB_1330            * loop if not [EOL]
000007BE                           969  
000007BE                           970                              * was [EOL] so get next line start
000007BE  3208                     971      MOVE.w  a0,d1               * past pad byte(s)
000007C0  0241 0001                972      ANDI.w  #1,d1               * mask odd bit
000007C4  D0C1                     973      ADD.w       d1,a0               * add back to ensure even
000007C6  2288                     974      MOVE.l  a0,(a1)         * save next line pointer to current line
000007C8                           975  LAB_1325
000007C8  2248                     976      MOVEA.l a0,a1               * copy pointer for this line
000007CA  4A90                     977      TST.l       (a0)                * test pointer to next line
000007CC  66EA                     978      BNE.s       LAB_132E            * not end of program yet so we must
000007CE                           979                              * go and fix the pointers
000007CE                           980  
000007CE  6100 0198                981      BSR     LAB_1477            * reset execution to start, clear variables
000007D2                           982                              * and flush stack
000007D2  6000 FF24                983      BRA     LAB_127D            * now we just wait for Basic command, no "Ready"
000007D6                           984  
000007D6                           985  
000007D6                           986  *************************************************************************************
000007D6                           987  *
000007D6                           988  * receive a line from the keyboard
000007D6                           989                              * character $08 as delete key, BACKSPACE on
000007D6                           990                              * standard keyboard
000007D6                           991  LAB_134B
000007D6  6100 0776                992      BSR     LAB_PRNA            * go print the character
000007DA  7020                     993      MOVEQ       #' ',d0         * load [SPACE]
000007DC  6100 0770                994      BSR     LAB_PRNA            * go print
000007E0  7008                     995      MOVEQ       #$08,d0         * load [BACKSPACE]
000007E2  6100 076A                996      BSR     LAB_PRNA            * go print
000007E6  5341                     997      SUBQ.w  #$01,d1         * decrement the buffer index (delete)
000007E8  6010                     998      BRA.s       LAB_1359            * re-enter loop
000007EA                           999  
000007EA                          1000  * print "? " and get BASIC input
000007EA                          1001  * return a0 pointing to the buffer start
000007EA                          1002  
000007EA                          1003  LAB_INLN
000007EA  6100 0760               1004      BSR     LAB_18E3            * print "?" character
000007EE  7020                    1005      MOVEQ       #' ',d0         * load " "
000007F0  6100 075C               1006      BSR     LAB_PRNA            * go print
000007F4                          1007  
000007F4                          1008  * call for BASIC input (main entry point)
000007F4                          1009  * return a0 pointing to the buffer start
000007F4                          1010  
000007F4                          1011  LAB_1357
000007F4  7200                    1012      MOVEQ       #$00,d1         * clear buffer index
000007F6  41EB 0490               1013      LEA     Ibuffs(a3),a0       * set buffer base pointer
000007FA                          1014  LAB_1359
000007FA  4EAB 040C               1015      JSR     V_INPT(a3)          * call scan input device
000007FE  64FA                    1016      BCC.s       LAB_1359            * loop if no byte
00000800                          1017  
00000800  67F8                    1018      BEQ.s       LAB_1359            * loop if null byte
00000802                          1019  
00000802  B03C 0007               1020      CMP.b       #$07,d0         * compare with [BELL]
00000806  6718                    1021      BEQ.s       LAB_1378            * branch if [BELL]
00000808                          1022  
00000808  B03C 000D               1023      CMP.b       #$0D,d0         * compare with [CR]
0000080C  6700 06C2               1024      BEQ     LAB_1866            * do CR/LF exit if [CR]
00000810                          1025  
00000810  4A41                    1026      TST.w       d1              * set flags on buffer index
00000812  6606                    1027      BNE.s       LAB_1374            * branch if not empty
00000814                          1028  
00000814                          1029  * the next two lines ignore any non printing character and [SPACE] if the input buffer
00000814                          1030  * is empty
00000814                          1031  
00000814  B03C 0020               1032      CMP.b       #' ',d0         * compare with [SP]+1
00000818  63E0                    1033      BLS.s       LAB_1359            * if < ignore character
0000081A                          1034  
0000081A                          1035  *## CMP.b       #' '+1,d0           * compare with [SP]+1
0000081A                          1036  *## BCS.s       LAB_1359            * if < ignore character
0000081A                          1037  
0000081A                          1038  LAB_1374
0000081A  B03C 0008               1039      CMP.b       #$08,d0         * compare with [BACKSPACE]
0000081E  67B6                    1040      BEQ.s       LAB_134B            * go delete last character
00000820                          1041  
00000820                          1042  LAB_1378
00000820  B27C 00FF               1043      CMP.w       #(Ibuffe-Ibuffs-1),d1   * compare character count with max-1
00000824  640C                    1044      BCC.s       LAB_138E            * skip store & do [BELL] if buffer full
00000826                          1045  
00000826  1180 1000               1046      MOVE.b  d0,(a0,d1.w)        * else store in buffer
0000082A  5241                    1047      ADDQ.w  #$01,d1         * increment index
0000082C                          1048  LAB_137F
0000082C  6100 0720               1049      BSR     LAB_PRNA            * go print the character
00000830  60C8                    1050      BRA.s       LAB_1359            * always loop for next character
00000832                          1051  
00000832                          1052  * announce buffer full
00000832                          1053  
00000832                          1054  LAB_138E
00000832  7007                    1055      MOVEQ       #$07,d0         * [BELL] character into d0
00000834  60F6                    1056      BRA.s       LAB_137F            * go print the [BELL] but ignore input character
00000836                          1057  
00000836                          1058  
00000836                          1059  *************************************************************************************
00000836                          1060  *
00000836                          1061  * copy a hex value without crunching
00000836                          1062  
00000836                          1063  LAB_1392
00000836  1180 2000               1064      MOVE.b  d0,(a0,d2.w)        * save the byte to the output
0000083A  5242                    1065      ADDQ.w  #1,d2               * increment the buffer save index
0000083C                          1066  
0000083C  5241                    1067      ADDQ.w  #1,d1               * increment the buffer read index
0000083E  1035 1000               1068      MOVE.b  (a5,d1.w),d0        * get a byte from the input buffer
00000842  6700 0094               1069      BEQ     LAB_13EC            * if [EOL] go save it without crunching
00000846                          1070  
00000846  B03C 0020               1071      CMP.b       #' ',d0         * compare the character with " "
0000084A  67EA                    1072      BEQ.s       LAB_1392            * if [SPACE] just go save it and get another
0000084C                          1073  
0000084C  B03C 0030               1074      CMP.b       #'0',d0         * compare the character with "0"
00000850  654A                    1075      BCS.s       LAB_13C6            * if < "0" quit the hex save loop
00000852                          1076  
00000852  B03C 0039               1077      CMP.b       #'9',d0         * compare with "9"
00000856  63DE                    1078      BLS.s       LAB_1392            * if it is "0" to "9" save it and get another
00000858                          1079  
00000858  7ADF                    1080      MOVEQ       #-33,d5         * mask xx0x xxxx, ASCII upper case
0000085A  CA00                    1081      AND.b       d0,d5               * mask the character
0000085C                          1082  
0000085C  BA3C 0041               1083      CMP.b       #'A',d5         * compare with "A"
00000860  6540                    1084      BCS.s       LAB_13CC            * if < "A" quit the hex save loop
00000862                          1085  
00000862  BA3C 0046               1086      CMP.b       #'F',d5         * compare with "F"
00000866  63CE                    1087      BLS.s       LAB_1392            * if it is "A" to "F" save it and get another
00000868                          1088  
00000868  6038                    1089      BRA.s       LAB_13CC            * else continue crunching
0000086A                          1090  
0000086A                          1091  * crunch keywords into Basic tokens
0000086A                          1092  * crunch from (a5), output to (a0)
0000086A                          1093  * returns ..
0000086A                          1094  * d4 trashed
0000086A                          1095  * d3 trashed
0000086A                          1096  * d2 is length
0000086A                          1097  * d1 trashed
0000086A                          1098  * d0 trashed
0000086A                          1099  * a1 trashed
0000086A                          1100  
0000086A                          1101  * this is the improved BASIC crunch routine and is 10 to 100 times faster than the
0000086A                          1102  * old list search
0000086A                          1103  
0000086A                          1104  LAB_13A6
0000086A  7200                    1105      MOVEQ       #0,d1               * clear the read index
0000086C  2401                    1106      MOVE.l  d1,d2               * clear the save index
0000086E  1741 05DD               1107      MOVE.b  d1,Oquote(a3)       * clear the open quote/DATA flag
00000872                          1108  LAB_13AC
00000872  7000                    1109      MOVEQ       #0,d0               * clear word
00000874  1035 1000               1110      MOVE.b  (a5,d1.w),d0        * get byte from input buffer
00000878  675E                    1111      BEQ.s       LAB_13EC            * if null save byte then continue crunching
0000087A                          1112  
0000087A  B03C 005F               1113      CMP.b       #'_',d0         * compare with "_"
0000087E  6458                    1114      BCC.s       LAB_13EC            * if >= "_" save byte then continue crunching
00000880                          1115  
00000880  B03C 003C               1116      CMP.b       #'<',d0         * compare with "<"
00000884  641C                    1117      BCC.s       LAB_13CC            * if >= "<" go crunch
00000886                          1118  
00000886  B03C 0030               1119      CMP.b       #'0',d0         * compare with "0"
0000088A  644C                    1120      BCC.s       LAB_13EC            * if >= "0" save byte then continue crunching
0000088C                          1121  
0000088C  1740 05DA               1122      MOVE.b  d0,Asrch(a3)        * save buffer byte as search character
00000890  B03C 0022               1123      CMP.b       #$22,d0         * is it quote character?
00000894  6776                    1124      BEQ.s       LAB_1410            * branch if so (copy quoted string)
00000896                          1125  
00000896  B03C 0024               1126      CMP.b       #'$',d0         * is it the hex value character?
0000089A  679A                    1127      BEQ.s       LAB_1392            * if so go copy a hex value
0000089C                          1128  
0000089C                          1129  LAB_13C6
0000089C  B03C 002A               1130      CMP.b       #'*',d0         * compare with "*"
000008A0  6536                    1131      BCS.s       LAB_13EC            * if <= "*" save byte then continue crunching
000008A2                          1132  
000008A2                          1133                              * crunch rest
000008A2                          1134  LAB_13CC
000008A2  082B 0006 05DD          1135      BTST.b  #6,Oquote(a3)       * test open quote/DATA token flag
000008A8  662E                    1136      BNE.s       LAB_13EC            * branch if b6 of Oquote set (was DATA)
000008AA                          1137                              * go save byte then continue crunching
000008AA                          1138  
000008AA  0400 002A               1139      SUB.b       #$2A,d0         * normalise byte
000008AE  D040                    1140      ADD.w       d0,d0               * *2 makes word offset (high byte=$00)
000008B0  43FA 2E60               1141      LEA     TAB_CHRT(pc),a1     * get keyword offset table address
000008B4  3031 0000               1142      MOVE.w  (a1,d0.w),d0        * get offset into keyword table
000008B8  6B6E                    1143      BMI.s       LAB_141F            * branch if no keywords for character
000008BA                          1144  
000008BA  43FA 3216               1145      LEA     TAB_STAR(pc),a1     * get keyword table address
000008BE  D2C0                    1146      ADDA.w  d0,a1               * add keyword offset
000008C0  76FF                    1147      MOVEQ       #-1,d3          * clear index
000008C2  3801                    1148      MOVE.w  d1,d4               * copy read index
000008C4                          1149  LAB_13D6
000008C4  5243                    1150      ADDQ.w  #1,d3               * increment table index
000008C6  1031 3000               1151      MOVE.b  (a1,d3.w),d0        * get byte from table
000008CA                          1152  LAB_13D8
000008CA  6B0A                    1153      BMI.s       LAB_13EA            * branch if is token, save token and continue
000008CC                          1154                              * crunching
000008CC                          1155  
000008CC  5244                    1156      ADDQ.w  #1,d4               * increment read index
000008CE  B035 4000               1157      CMP.b       (a5,d4.w),d0        * compare byte from input buffer
000008D2  67F0                    1158      BEQ.s       LAB_13D6            * loop if character match
000008D4                          1159  
000008D4  6040                    1160      BRA.s       LAB_1417            * branch if no match
000008D6                          1161  
000008D6                          1162  LAB_13EA
000008D6  3204                    1163      MOVE.w  d4,d1               * update read index
000008D8                          1164  LAB_13EC
000008D8  1180 2000               1165      MOVE.b  d0,(a0,d2.w)        * save byte to output
000008DC  5242                    1166      ADDQ.w  #1,d2               * increment buffer save index
000008DE  5241                    1167      ADDQ.w  #1,d1               * increment buffer read index
000008E0  4A00                    1168      TST.b       d0              * set flags
000008E2  674A                    1169      BEQ.s       LAB_142A            * branch if was null [EOL]
000008E4                          1170  
000008E4                          1171                              * d0 holds token or byte here
000008E4  0400 003A               1172      SUB.b       #$3A,d0         * subtract ":"
000008E8  6706                    1173      BEQ.s       LAB_13FF            * branch if it was ":" (is now $00)
000008EA                          1174  
000008EA                          1175                              * d0 now holds token-$3A
000008EA  B03C 0049               1176      CMP.b       #(TK_DATA-$3A),d0       * compare with DATA token - $3A
000008EE  6604                    1177      BNE.s       LAB_1401            * branch if not DATA
000008F0                          1178  
000008F0                          1179                              * token was : or DATA
000008F0                          1180  LAB_13FF
000008F0  1740 05DD               1181      MOVE.b  d0,Oquote(a3)       * save token-$3A ($00 for ":", TK_DATA-$3A for
000008F4                          1182                              * DATA)
000008F4                          1183  LAB_1401
000008F4  0400 0055               1184      SUB.b       #(TK_REM-$3A),d0        * subtract REM token offset
000008F8  6600 FF78               1185      BNE     LAB_13AC            * If wasn't REM then go crunch rest of line
000008FC                          1186  
000008FC  1740 05DA               1187      MOVE.b  d0,Asrch(a3)        * else was REM so set search for [EOL]
00000900                          1188  
00000900                          1189                              * loop for REM, "..." etc.
00000900                          1190  LAB_1408
00000900  1035 1000               1191      MOVE.b  (a5,d1.w),d0        * get byte from input buffer
00000904  67D2                    1192      BEQ.s       LAB_13EC            * branch if null [EOL]
00000906                          1193  
00000906  B02B 05DA               1194      CMP.b       Asrch(a3),d0        * compare with stored character
0000090A  67CC                    1195      BEQ.s       LAB_13EC            * branch if match (end quote, REM, :, or DATA)
0000090C                          1196  
0000090C                          1197                              * entry for copy string in quotes, don't crunch
0000090C                          1198  LAB_1410
0000090C  1180 2000               1199      MOVE.b  d0,(a0,d2.w)        * save byte to output
00000910  5242                    1200      ADDQ.w  #1,d2               * increment buffer save index
00000912  5241                    1201      ADDQ.w  #1,d1               * increment buffer read index
00000914  60EA                    1202      BRA.s       LAB_1408            * loop
00000916                          1203  
00000916                          1204  * not found keyword this go so find the end of this word in the table
00000916                          1205  
00000916                          1206  LAB_1417
00000916  3801                    1207      MOVE.w  d1,d4               * reset read pointer
00000918                          1208  LAB_141B
00000918  5243                    1209      ADDQ.w  #1,d3               * increment keyword table pointer, flag
0000091A                          1210                              * unchanged
0000091A  1031 3000               1211      MOVE.b  (a1,d3.w),d0        * get keyword table byte
0000091E  6AF8                    1212      BPL.s       LAB_141B            * if not end of keyword go do next byte
00000920                          1213  
00000920  5243                    1214      ADDQ.w  #1,d3               * increment keyword table pointer flag
00000922                          1215                              * unchanged
00000922  1031 3000               1216      MOVE.b  (a1,d3.w),d0        * get keyword table byte
00000926  66A2                    1217      BNE.s       LAB_13D8            * go test next word if not zero byte (table end)
00000928                          1218  
00000928                          1219                              * reached end of table with no match
00000928                          1220  LAB_141F
00000928  1035 1000               1221      MOVE.b  (a5,d1.w),d0        * restore byte from input buffer
0000092C  60AA                    1222      BRA.s       LAB_13EC            * go save byte in output and continue crunching
0000092E                          1223  
0000092E                          1224                              * reached [EOL]
0000092E                          1225  LAB_142A
0000092E  7000                    1226      MOVEQ       #0,d0               * ensure longword clear
00000930  0102                    1227      BTST        d0,d2               * test odd bit (fastest)
00000932  6706                    1228      BEQ.s       LAB_142C            * branch if no bytes to fill
00000934                          1229  
00000934  1180 2000               1230      MOVE.b  d0,(a0,d2.w)        * clear next byte
00000938  5242                    1231      ADDQ.w  #1,d2               * increment buffer save index
0000093A                          1232  LAB_142C
0000093A  2180 2000               1233      MOVE.l  d0,(a0,d2.w)        * clear next line pointer, EOT in immediate mode
0000093E  4E75                    1234      RTS
00000940                          1235  
00000940                          1236  
00000940                          1237  *************************************************************************************
00000940                          1238  *
00000940                          1239  * search Basic for d1 line number from start of mem
00000940                          1240  
00000940                          1241  LAB_SSLN
00000940  206B 042E               1242      MOVEA.l Smeml(a3),a0        * get start of program mem
00000944  6002                    1243      BRA.s       LAB_SCLN            * go search for required line from a0
00000946                          1244  
00000946                          1245  LAB_145F
00000946  2040                    1246      MOVEA.l d0,a0               * copy next line pointer
00000948                          1247  
00000948                          1248  * search Basic for d1 line number from a0
00000948                          1249  * returns Cb=0 if found
00000948                          1250  * returns a0 pointer to found or next higher (not found) line
00000948                          1251  
00000948                          1252  LAB_SCLN
00000948  2018                    1253      MOVE.l  (a0)+,d0            * get next line pointer and point to line #
0000094A  6708                    1254      BEQ.s       LAB_145E            * is end marker so we're done, do 'no line' exit
0000094C                          1255  
0000094C  B290                    1256      CMP.l       (a0),d1         * compare this line # with required line #
0000094E  6EF6                    1257      BGT.s       LAB_145F            * loop if required # > this #
00000950                          1258  
00000950  5948                    1259      SUBQ.w  #4,a0               * adjust pointer, flags not changed
00000952  4E75                    1260      RTS
00000954                          1261  
00000954                          1262  LAB_145E
00000954  5948                    1263      SUBQ.w  #4,a0               * adjust pointer, flags not changed
00000956  5380                    1264      SUBQ.l  #1,d0               * make end program found = -1, set carry
00000958  4E75                    1265      RTS
0000095A                          1266  
0000095A                          1267  
0000095A                          1268  *************************************************************************************
0000095A                          1269  *
0000095A                          1270  * perform NEW
0000095A                          1271  
0000095A                          1272  LAB_NEW
0000095A  664C                    1273      BNE.s       RTS_005         * exit if not end of statement (do syntax error)
0000095C                          1274  
0000095C                          1275  LAB_1463
0000095C  206B 042E               1276      MOVEA.l Smeml(a3),a0        * point to start of program memory
00000960  7000                    1277      MOVEQ       #0,d0               * clear longword
00000962  20C0                    1278      MOVE.l  d0,(a0)+            * clear first line, next line pointer
00000964  2748 0432               1279      MOVE.l  a0,Sfncl(a3)        * set start of functions
00000968                          1280  
00000968                          1281  * reset execution to start, clear variables and flush stack
00000968                          1282  
00000968                          1283  LAB_1477
00000968  2A6B 042E               1284      MOVEA.l Smeml(a3),a5        * reset BASIC execute pointer
0000096C  534D                    1285      SUBQ.w  #1,a5               * -1 (as end of previous line)
0000096E                          1286  
0000096E                          1287  * "CLEAR" command gets here
0000096E                          1288  
0000096E                          1289  LAB_147A
0000096E  276B 044A 0446          1290      MOVE.l  Ememl(a3),Sstorl(a3)    * save end of mem as bottom of string space
00000974  202B 0432               1291      MOVE.l  Sfncl(a3),d0        * get start of functions
00000978  2740 0436               1292      MOVE.l  d0,Svarl(a3)        * start of variables
0000097C  2740 043A               1293      MOVE.l  d0,Sstrl(a3)        * start of strings
00000980  2740 043E               1294      MOVE.l  d0,Sarryl(a3)       * set start of arrays
00000984  2740 0442               1295      MOVE.l  d0,Earryl(a3)       * set end of arrays
00000988  7000                    1296      MOVEQ       #0,d0               * set Zb
0000098A  1740 05EA               1297      MOVE.b  d0,ccnull(a3)       * clear get byte countdown
0000098E  6100 01CE               1298      BSR     LAB_RESTORE         * perform RESTORE command
00000992                          1299  
00000992                          1300  * flush stack & clear continue flag
00000992                          1301  
00000992                          1302  LAB_1491
00000992  49EB 048E               1303      LEA     des_sk(a3),a4       * reset descriptor stack pointer
00000996                          1304  
00000996  201F                    1305      MOVE.l  (sp)+,d0            * pull return address
00000998  4FEB 0400               1306      LEA     ram_base(a3),sp     * set stack to RAM start + 1k, flush stack
0000099C  2F00                    1307      MOVE.l  d0,-(sp)            * restore return address
0000099E                          1308  
0000099E  7000                    1309      MOVEQ       #0,d0               * clear longword
000009A0  2740 045A               1310      MOVE.l  d0,Cpntrl(a3)       * clear continue pointer
000009A4  1740 05DF               1311      MOVE.b  d0,Sufnxf(a3)       * clear subscript/FNX flag
000009A8                          1312  RTS_005
000009A8  4E75                    1313      RTS
000009AA                          1314  
000009AA                          1315  
000009AA                          1316  *************************************************************************************
000009AA                          1317  *
000009AA                          1318  * perform CLEAR
000009AA                          1319  
000009AA                          1320  LAB_CLEAR
000009AA  67C2                    1321      BEQ.s       LAB_147A            * if no following byte go do "CLEAR"
000009AC                          1322  
000009AC  4E75                    1323      RTS                     * was following byte (go do syntax error)
000009AE                          1324  
000009AE                          1325  
000009AE                          1326  *************************************************************************************
000009AE                          1327  *
000009AE                          1328  * perform LIST [n][-m]
000009AE                          1329  
000009AE                          1330  LAB_LIST
000009AE  6512                    1331      BCS.s       LAB_14BD            * branch if next character numeric (LIST n...)
000009B0                          1332  
000009B0  72FF                    1333      MOVEQ       #-1,d1          * set end to $FFFFFFFF
000009B2  2741 042A               1334      MOVE.l  d1,Itemp(a3)        * save to Itemp
000009B6                          1335  
000009B6  7200                    1336      MOVEQ       #0,d1               * set start to $00000000
000009B8  4A00                    1337      TST.b       d0              * test next byte
000009BA  670A                    1338      BEQ.s       LAB_14C0            * branch if next character [NULL] (LIST)
000009BC                          1339  
000009BC  B03C 00C0               1340      CMP.b       #TK_MINUS,d0        * compare with token for -
000009C0  66E6                    1341      BNE.s       RTS_005         * exit if not - (LIST -m)
000009C2                          1342  
000009C2                          1343                              * LIST [[n]-[m]] this sets the n, if present,
000009C2                          1344                              * as the start and end
000009C2                          1345  LAB_14BD
000009C2  6100 0392               1346      BSR     LAB_GFPN            * get fixed-point number into temp integer & d1
000009C6                          1347  LAB_14C0
000009C6  6100 FF78               1348      BSR     LAB_SSLN            * search BASIC for d1 line number
000009CA                          1349                              * (pointer in a0)
000009CA  6100 0934               1350      BSR     LAB_GBYT            * scan memory
000009CE  6716                    1351      BEQ.s       LAB_14D4            * branch if no more characters
000009D0                          1352  
000009D0                          1353                              * this bit checks the - is present
000009D0  B03C 00C0               1354      CMP.b       #TK_MINUS,d0        * compare with token for -
000009D4  66D2                    1355      BNE.s       RTS_005         * return if not "-" (will be Syntax error)
000009D6                          1356  
000009D6  72FF                    1357      MOVEQ       #-1,d1          * set end to $FFFFFFFF
000009D8  2741 042A               1358      MOVE.l  d1,Itemp(a3)        * save Itemp
000009DC                          1359  
000009DC                          1360                              * LIST [n]-[m] the - was there so see if
000009DC                          1361                              * there is an m to set as the end value
000009DC  6100 0920               1362      BSR     LAB_IGBY            * increment & scan memory
000009E0  6704                    1363      BEQ.s       LAB_14D4            * branch if was [NULL] (LIST n-)
000009E2                          1364  
000009E2  6100 0372               1365      BSR     LAB_GFPN            * get fixed-point number into temp integer & d1
000009E6                          1366  LAB_14D4
000009E6  177C 0000 05DD          1367      MOVE.b  #$00,Oquote(a3)     * clear open quote flag
000009EC  6100 04E8               1368      BSR     LAB_CRLF            * print CR/LF
000009F0  2018                    1369      MOVE.l  (a0)+,d0            * get next line pointer
000009F2  67B4                    1370      BEQ.s       RTS_005         * if null all done so exit
000009F4                          1371  
000009F4  2240                    1372      MOVEA.l d0,a1               * copy next line pointer
000009F6  6100 012C               1373      BSR     LAB_1629            * do CRTL-C check vector
000009FA                          1374  
000009FA  2018                    1375      MOVE.l  (a0)+,d0            * get this line #
000009FC  B0AB 042A               1376      CMP.l       Itemp(a3),d0        * compare end line # with this line #
00000A00  62A6                    1377      BHI.s       RTS_005         * if this line greater all done so exit
00000A02                          1378  
00000A02                          1379  LAB_14E2
00000A02  48E7 00C0               1380      MOVEM.l a0-a1,-(sp)         * save registers
00000A06  6100 1A48               1381      BSR     LAB_295E            * print d0 as unsigned integer
00000A0A  4CDF 0300               1382      MOVEM.l (sp)+,a0-a1         * restore registers
00000A0E  7020                    1383      MOVEQ       #$20,d0         * space is the next character
00000A10                          1384  LAB_150C
00000A10  6100 053C               1385      BSR     LAB_PRNA            * go print the character
00000A14  B03C 0022               1386      CMP.b       #$22,d0         * was it " character
00000A18  6606                    1387      BNE.s       LAB_1519            * branch if not
00000A1A                          1388  
00000A1A                          1389                              * we're either entering or leaving quotes
00000A1A  0A2B 00FF 05DD          1390      EOR.b       #$FF,Oquote(a3)     * toggle open quote flag
00000A20                          1391  LAB_1519
00000A20  1018                    1392      MOVE.b  (a0)+,d0            * get byte and increment pointer
00000A22  6608                    1393      BNE.s       LAB_152E            * branch if not [EOL] (go print)
00000A24                          1394  
00000A24                          1395                              * was [EOL]
00000A24  2049                    1396      MOVEA.l a1,a0               * copy next line pointer
00000A26  2008                    1397      MOVE.l  a0,d0               * copy to set flags
00000A28  66BC                    1398      BNE.s       LAB_14D4            * go do next line if not [EOT]
00000A2A                          1399  
00000A2A  4E75                    1400      RTS
00000A2C                          1401  
00000A2C                          1402  LAB_152E
00000A2C  6AE2                    1403      BPL.s       LAB_150C            * just go print it if not token byte
00000A2E                          1404  
00000A2E                          1405                              * else it was a token byte so maybe uncrunch it
00000A2E  4A2B 05DD               1406      TST.b       Oquote(a3)          * test the open quote flag
00000A32  6BDC                    1407      BMI.s       LAB_150C            * just go print character if open quote set
00000A34                          1408  
00000A34                          1409                              * else uncrunch BASIC token
00000A34  45FA 2D46               1410      LEA     LAB_KEYT(pc),a2     * get keyword table address
00000A38  727F                    1411      MOVEQ       #$7F,d1         * mask into d1
00000A3A  C200                    1412      AND.b       d0,d1               * copy and mask token
00000A3C  E549                    1413      LSL.w       #2,d1               * *4
00000A3E  45F2 1000               1414      LEA     (a2,d1.w),a2        * get keyword entry address
00000A42  101A                    1415      MOVE.b  (a2)+,d0            * get byte from keyword table
00000A44  6100 0508               1416      BSR     LAB_PRNA            * go print the first character
00000A48  7200                    1417      MOVEQ       #0,d1               * clear d1
00000A4A  121A                    1418      MOVE.b  (a2)+,d1            * get remaining length byte from keyword table
00000A4C  6BD2                    1419      BMI.s       LAB_1519            * if -ve done so go get next byte
00000A4E                          1420  
00000A4E  3012                    1421      MOVE.w  (a2),d0         * get offset to rest
00000A50  45FA 3080               1422      LEA     TAB_STAR(pc),a2     * get keyword table address
00000A54  45F2 0000               1423      LEA     (a2,d0.w),a2        * get address of rest
00000A58                          1424  LAB_1540
00000A58  101A                    1425      MOVE.b  (a2)+,d0            * get byte from keyword table
00000A5A  6100 04F2               1426      BSR     LAB_PRNA            * go print the character
00000A5E  51C9 FFF8               1427      DBF     d1,LAB_1540         * decrement and loop if more to do
00000A62                          1428  
00000A62  60BC                    1429      BRA.s       LAB_1519            * go get next byte
00000A64                          1430  
00000A64                          1431  
00000A64                          1432  *************************************************************************************
00000A64                          1433  *
00000A64                          1434  * perform FOR
00000A64                          1435  
00000A64                          1436  LAB_FOR
00000A64  6100 0390               1437      BSR     LAB_LET         * go do LET
00000A68                          1438  
00000A68  202B 0472               1439      MOVE.l  Lvarpl(a3),d0       * get the loop variable pointer
00000A6C  B0AB 043A               1440      CMP.l       Sstrl(a3),d0        * compare it with the end of vars memory
00000A70  6C00 FC1C               1441      BGE     LAB_TMER            * if greater go do type mismatch error
00000A74                          1442  
00000A74                          1443  * test for not less than the start of variables memory if needed
00000A74                          1444  *
00000A74                          1445  *   CMP.l       Svarl(a3),d0        * compare it with the start of variables memory
00000A74                          1446  *   BLT     LAB_TMER            * if not variables memory do type mismatch error
00000A74                          1447  
00000A74                          1448  *   MOVEQ       #28,d0          * we need 28 bytes !
00000A74                          1449  *   BSR.s       LAB_1212            * check room on stack for d0 bytes
00000A74  6100 0214               1450      BSR     LAB_SNBS            * scan for next BASIC statement ([:] or [EOL])
00000A78                          1451                              * returns a0 as pointer to [:] or [EOL]
00000A78  2E88                    1452      MOVE.l  a0,(sp)         * push onto stack (and dump the return address)
00000A7A  2F2B 0452               1453      MOVE.l  Clinel(a3),-(sp)        * push current line onto stack
00000A7E                          1454  
00000A7E  70B7                    1455      MOVEQ       #TK_TO-$100,d0      * set "TO" token
00000A80  6100 0874               1456      BSR     LAB_SCCA            * scan for CHR$(d0) else syntax error/warm start
00000A84  6100 0702               1457      BSR     LAB_CTNM            * check if source is numeric, else type mismatch
00000A88  1F2B 05B5               1458      MOVE.b  Dtypef(a3),-(sp)        * push the FOR variable data type onto stack
00000A8C  6100 06F8               1459      BSR     LAB_EVNM            * evaluate expression and check is numeric else
00000A90                          1460                              * do type mismatch
00000A90                          1461  
00000A90  2F2B 0590               1462      MOVE.l  FAC1_m(a3),-(sp)        * push TO value mantissa
00000A94  3F2B 0594               1463      MOVE.w  FAC1_e(a3),-(sp)        * push TO value exponent and sign
00000A98                          1464  
00000A98  277C 80000000 0590      1465      MOVE.l  #$80000000,FAC1_m(a3)   * set default STEP size mantissa
00000AA0  377C 8100 0594          1466      MOVE.w  #$8100,FAC1_e(a3)       * set default STEP size exponent and sign
00000AA6                          1467  
00000AA6  6100 0858               1468      BSR     LAB_GBYT            * scan memory
00000AAA  B03C 00BC               1469      CMP.b       #TK_STEP,d0         * compare with STEP token
00000AAE  6608                    1470      BNE.s       LAB_15B3            * jump if not "STEP"
00000AB0                          1471  
00000AB0                          1472                              * was STEP token so ....
00000AB0  6100 084C               1473      BSR     LAB_IGBY            * increment & scan memory
00000AB4  6100 06D0               1474      BSR     LAB_EVNM            * evaluate expression & check is numeric
00000AB8                          1475                              * else do type mismatch
00000AB8                          1476  LAB_15B3
00000AB8  2F2B 0590               1477      MOVE.l  FAC1_m(a3),-(sp)        * push STEP value mantissa
00000ABC  3F2B 0594               1478      MOVE.w  FAC1_e(a3),-(sp)        * push STEP value exponent and sign
00000AC0                          1479  
00000AC0  2F2B 0472               1480      MOVE.l  Lvarpl(a3),-(sp)        * push variable pointer for FOR/NEXT
00000AC4  3F3C 0081               1481      MOVE.w  #TK_FOR,-(sp)       * push FOR token on stack
00000AC8                          1482  
00000AC8  6018                    1483      BRA.s       LAB_15C2            * go do interpreter inner loop
00000ACA                          1484  
00000ACA                          1485  LAB_15DC                        * have reached [EOL]+1
00000ACA  300D                    1486      MOVE.w  a5,d0               * copy BASIC execute pointer
00000ACC  C07C 0001               1487      AND.w       #1,d0               * and make line start address even
00000AD0  DAC0                    1488      ADD.w       d0,a5               * add to BASIC execute pointer
00000AD2  201D                    1489      MOVE.l  (a5)+,d0            * get next line pointer
00000AD4  6700 FC14               1490      BEQ     LAB_1274            * if null go to immediate mode, no "BREAK"
00000AD8                          1491                              * message (was immediate or [EOT] marker)
00000AD8                          1492  
00000AD8  275D 0452               1493      MOVE.l  (a5)+,Clinel(a3)        * save (new) current line #
00000ADC                          1494  LAB_15F6
00000ADC  6100 0822               1495      BSR     LAB_GBYT            * get BASIC byte
00000AE0  611A                    1496      BSR.s       LAB_15FF            * go interpret BASIC code from (a5)
00000AE2                          1497  
00000AE2                          1498  * interpreter inner loop (re)entry point
00000AE2                          1499  
00000AE2                          1500  LAB_15C2
00000AE2  6140                    1501      BSR.s       LAB_1629            * do CRTL-C check vector
00000AE4  4A2B 0452               1502      TST.b       Clinel(a3)          * test current line #, is -ve for immediate mode
00000AE8  6B04                    1503      BMI.s       LAB_15D1            * branch if immediate mode
00000AEA                          1504  
00000AEA  274D 045A               1505      MOVE.l  a5,Cpntrl(a3)       * save BASIC execute pointer as continue pointer
00000AEE                          1506  LAB_15D1
00000AEE  101D                    1507      MOVE.b  (a5)+,d0            * get this byte & increment pointer
00000AF0  67D8                    1508      BEQ.s       LAB_15DC            * loop if [EOL]
00000AF2                          1509  
00000AF2  B03C 003A               1510      CMP.b       #$3A,d0         * compare with ":"
00000AF6  67E4                    1511      BEQ.s       LAB_15F6            * loop if was statement separator
00000AF8                          1512  
00000AF8  6000 FBC0               1513      BRA     LAB_SNER            * else syntax error, then warm start
00000AFC                          1514  
00000AFC                          1515  
00000AFC                          1516  *************************************************************************************
00000AFC                          1517  *
00000AFC                          1518  * interpret BASIC code from (a5)
00000AFC                          1519  
00000AFC                          1520  LAB_15FF
00000AFC  6700 008C               1521      BEQ     RTS_006         * exit if zero [EOL]
00000B00                          1522  
00000B00                          1523  LAB_1602
00000B00  0A00 0080               1524      EORI.b  #$80,d0         * normalise token
00000B04  6B00 02F0               1525      BMI     LAB_LET         * if not token, go do implied LET
00000B08                          1526  
00000B08  B03C 0035               1527      CMP.b       #(TK_TAB-$80),d0        * compare normalised token with TAB
00000B0C  6400 FBAC               1528      BCC     LAB_SNER            * branch if d0>=TAB, syntax error/warm start
00000B10                          1529                              * only tokens before TAB can start a statement
00000B10                          1530  
00000B10  4880                    1531      EXT.w       d0              * byte to word (clear high byte)
00000B12  D040                    1532      ADD.w       d0,d0               * *2
00000B14  41FA 2AA2               1533      LEA     LAB_CTBL(pc),a0     * get vector table base address
00000B18  3030 0000               1534      MOVE.w  (a0,d0.w),d0        * get offset to vector
00000B1C  4870 0000               1535      PEA     (a0,d0.w)           * push vector
00000B20  6000 07DC               1536      BRA     LAB_IGBY            * get following byte & execute vector
00000B24                          1537  
00000B24                          1538  
00000B24                          1539  *************************************************************************************
00000B24                          1540  *
00000B24                          1541  * CTRL-C check jump. this is called as a subroutine but exits back via a jump if a
00000B24                          1542  * key press is detected.
00000B24                          1543  
00000B24                          1544  LAB_1629
00000B24  4EEB 0424               1545      JMP     V_CTLC(a3)          * ctrl c check vector
00000B28                          1546  
00000B28                          1547  * if there was a key press it gets back here .....
00000B28                          1548  
00000B28                          1549  LAB_1636
00000B28  B03C 0003               1550      CMP.b       #$03,d0         * compare with CTRL-C
00000B2C  670C                    1551      BEQ.s       LAB_163B            * STOP if was CTRL-C
00000B2E                          1552  
00000B2E                          1553  LAB_1639
00000B2E  4E75                    1554      RTS
00000B30                          1555  
00000B30                          1556  
00000B30                          1557  *************************************************************************************
00000B30                          1558  *
00000B30                          1559  * perform END
00000B30                          1560  
00000B30                          1561  LAB_END
00000B30  66FC                    1562      BNE.s       LAB_1639            * exit if something follows STOP
00000B32  177C 0000 05DC          1563      MOVE.b  #0,Breakf(a3)       * clear break flag, indicate program end
00000B38                          1564  
00000B38                          1565  
00000B38                          1566  *************************************************************************************
00000B38                          1567  *
00000B38                          1568  * perform STOP
00000B38                          1569  
00000B38                          1570  LAB_STOP
00000B38  66F4                    1571      BNE.s       LAB_1639            * exit if something follows STOP
00000B3A                          1572  
00000B3A                          1573  LAB_163B
00000B3A  43EB 0590               1574      LEA     Ibuffe(a3),a1       * get buffer end
00000B3E  BBC9                    1575      CMPA.l  a1,a5               * compare execute address with buffer end
00000B40  650A                    1576      BCS.s       LAB_164F            * branch if BASIC pointer is in buffer
00000B42                          1577                              * can't continue in immediate mode
00000B42                          1578  
00000B42                          1579                              * else...
00000B42  274D 045A               1580      MOVE.l  a5,Cpntrl(a3)       * save BASIC execute pointer as continue pointer
00000B46                          1581  LAB_1647
00000B46  276B 0452 0456          1582      MOVE.l  Clinel(a3),Blinel(a3)   * save break line
00000B4C                          1583  LAB_164F
00000B4C  584F                    1584      ADDQ.w  #4,sp               * dump return address, don't return to execute
00000B4E                          1585                              * loop
00000B4E  102B 05DC               1586      MOVE.b  Breakf(a3),d0       * get break flag
00000B52  6700 FB96               1587      BEQ     LAB_1274            * go do warm start if was program end
00000B56                          1588  
00000B56  41FA 316D               1589      LEA     LAB_BMSG(pc),a0     * point to "Break"
00000B5A  6000 FB80               1590      BRA     LAB_1269            * print "Break" and do warm start
00000B5E                          1591  
00000B5E                          1592  
00000B5E                          1593  *************************************************************************************
00000B5E                          1594  *
00000B5E                          1595  * perform RESTORE
00000B5E                          1596  
00000B5E                          1597  LAB_RESTORE
00000B5E  206B 042E               1598      MOVEA.l Smeml(a3),a0        * copy start of memory
00000B62  6720                    1599      BEQ.s       LAB_1624            * branch if next character null (RESTORE)
00000B64                          1600  
00000B64  6100 01F0               1601      BSR     LAB_GFPN            * get fixed-point number into temp integer & d1
00000B68  B2AB 0452               1602      CMP.l       Clinel(a3),d1       * compare current line # with required line #
00000B6C  630E                    1603      BLS.s       LAB_GSCH            * branch if >= (start search from beginning)
00000B6E                          1604  
00000B6E  204D                    1605      MOVEA.l a5,a0               * copy BASIC execute pointer
00000B70                          1606  LAB_RESs
00000B70  4A18                    1607      TST.b       (a0)+               * test next byte & increment pointer
00000B72  66FC                    1608      BNE.s       LAB_RESs            * loop if not EOL
00000B74                          1609  
00000B74  3008                    1610      MOVE.w  a0,d0               * copy pointer
00000B76  C07C 0001               1611      AND.w       #1,d0               * mask odd bit
00000B7A  D0C0                    1612      ADD.w       d0,a0               * add pointer
00000B7C                          1613                              * search for line in Itemp from (a0)
00000B7C                          1614  LAB_GSCH
00000B7C  6100 FDCA               1615      BSR     LAB_SCLN            * search for d1 line number from a0
00000B80                          1616                              * returns Cb=0 if found
00000B80  6500 FB20               1617      BCS     LAB_USER            * go do "Undefined statement" error if not found
00000B84                          1618  
00000B84                          1619  LAB_1624
00000B84  4A20                    1620      TST.b       -(a0)               * decrement pointer (faster)
00000B86  2748 0462               1621      MOVE.l  a0,Dptrl(a3)        * save DATA pointer
00000B8A                          1622  RTS_006
00000B8A  4E75                    1623      RTS
00000B8C                          1624  
00000B8C                          1625  
00000B8C                          1626  *************************************************************************************
00000B8C                          1627  *
00000B8C                          1628  * perform NULL
00000B8C                          1629  
00000B8C                          1630  LAB_NULL
00000B8C  6100 10E2               1631      BSR     LAB_GTBY            * get byte parameter, result in d0 and Itemp
00000B90  1740 05E4               1632      MOVE.b  d0,Nullct(a3)       * save new NULL count
00000B94  4E75                    1633      RTS
00000B96                          1634  
00000B96                          1635  
00000B96                          1636  *************************************************************************************
00000B96                          1637  *
00000B96                          1638  * perform CONT
00000B96                          1639  
00000B96                          1640  LAB_CONT
00000B96  6600 FB22               1641      BNE     LAB_SNER            * if following byte exit to do syntax error
00000B9A                          1642  
00000B9A  4A2B 0452               1643      TST.b       Clinel(a3)          * test current line #, is -ve for immediate mode
00000B9E  6A00 FAE2               1644      BPL     LAB_CCER            * if running go do can't continue error
00000BA2                          1645  
00000BA2  202B 045A               1646      MOVE.l  Cpntrl(a3),d0       * get continue pointer
00000BA6  6700 FADA               1647      BEQ     LAB_CCER            * go do can't continue error if we can't
00000BAA                          1648  
00000BAA                          1649                              * we can continue so ...
00000BAA  2A40                    1650      MOVEA.l d0,a5               * save continue pointer as BASIC execute pointer
00000BAC  276B 0456 0452          1651      MOVE.l  Blinel(a3),Clinel(a3)   * set break line as current line
00000BB2  4E75                    1652      RTS
00000BB4                          1653  
00000BB4                          1654  
00000BB4                          1655  *************************************************************************************
00000BB4                          1656  *
00000BB4                          1657  * perform RUN
00000BB4                          1658  
00000BB4                          1659  LAB_RUN
00000BB4  660C                    1660      BNE.s       LAB_RUNn            * if following byte do RUN n
00000BB6                          1661  
00000BB6  6100 FDB0               1662      BSR     LAB_1477            * execution to start, clear vars & flush stack
00000BBA  274D 045A               1663      MOVE.l  a5,Cpntrl(a3)       * save as continue pointer
00000BBE  6000 FF22               1664      BRA     LAB_15C2            * go do interpreter inner loop
00000BC2                          1665                              * (can't RTS, we flushed the stack!)
00000BC2                          1666  
00000BC2                          1667  LAB_RUNn
00000BC2  6100 FDAA               1668      BSR     LAB_147A            * go do "CLEAR"
00000BC6  601C                    1669      BRA.s       LAB_16B0            * get n and do GOTO n
00000BC8                          1670  
00000BC8                          1671  
00000BC8                          1672  *************************************************************************************
00000BC8                          1673  *
00000BC8                          1674  * perform DO
00000BC8                          1675  
00000BC8                          1676  LAB_DO
00000BC8                          1677  *   MOVE.l  #$05,d0         * need 5 bytes for DO 
00000BC8                          1678  *   BSR.s       LAB_1212            * check room on stack for A bytes
00000BC8  2F0D                    1679      MOVE.l  a5,-(sp)            * push BASIC execute pointer on stack
00000BCA  2F2B 0452               1680      MOVE.l  Clinel(a3),-(sp)        * push current line on stack
00000BCE  3F3C 009C               1681      MOVE.w  #TK_DO,-(sp)        * push token for DO on stack
00000BD2  487A FF0E               1682      PEA     LAB_15C2(pc)        * set return address
00000BD6  6000 0728               1683      BRA     LAB_GBYT            * scan memory and return to interpreter inner
00000BDA                          1684                              * loop
00000BDA                          1685  
00000BDA                          1686  
00000BDA                          1687  *************************************************************************************
00000BDA                          1688  *
00000BDA                          1689  * perform GOSUB
00000BDA                          1690  
00000BDA                          1691  LAB_GOSUB
00000BDA                          1692  *   MOVE.l  #10,d0          * need 10 bytes for GOSUB 
00000BDA                          1693  *   BSR.s       LAB_1212            * check room on stack for d0 bytes
00000BDA  2F0D                    1694      MOVE.l  a5,-(sp)            * push BASIC execute pointer
00000BDC  2F2B 0452               1695      MOVE.l  Clinel(a3),-(sp)        * push current line
00000BE0  3F3C 008D               1696      MOVE.w  #TK_GOSUB,-(sp)     * push token for GOSUB
00000BE4                          1697  LAB_16B0
00000BE4  6100 071A               1698      BSR     LAB_GBYT            * scan memory
00000BE8  487A FEF8               1699      PEA     LAB_15C2(pc)        * return to interpreter inner loop after GOTO n
00000BEC                          1700  
00000BEC                          1701  * this PEA is needed because either we just cleared the stack and have nowhere to return
00000BEC                          1702  * to or, in the case of GOSUB, we have just dropped a load on the stack and the address
00000BEC                          1703  * we whould have returned to is buried. This burried return address will be unstacked by
00000BEC                          1704  * the corresponding RETURN command
00000BEC                          1705  
00000BEC                          1706  
00000BEC                          1707  *************************************************************************************
00000BEC                          1708  *
00000BEC                          1709  * perform GOTO
00000BEC                          1710  
00000BEC                          1711  LAB_GOTO
00000BEC  6100 0168               1712      BSR     LAB_GFPN            * get fixed-point number into temp integer & d1
00000BF0  206B 042E               1713      MOVEA.l Smeml(a3),a0        * get start of memory
00000BF4  B2AB 0452               1714      CMP.l       Clinel(a3),d1       * compare current line with wanted #
00000BF8  630E                    1715      BLS.s       LAB_16D0            * branch if current # => wanted #
00000BFA                          1716  
00000BFA  204D                    1717      MOVEA.l a5,a0               * copy BASIC execute pointer
00000BFC                          1718  LAB_GOTs
00000BFC  4A18                    1719      TST.b       (a0)+               * test next byte & increment pointer
00000BFE  66FC                    1720      BNE.s       LAB_GOTs            * loop if not EOL
00000C00                          1721  
00000C00  3008                    1722      MOVE.w  a0,d0               * past pad byte(s)
00000C02  C07C 0001               1723      AND.w       #1,d0               * mask odd bit
00000C06  D0C0                    1724      ADD.w       d0,a0               * add to pointer
00000C08                          1725  
00000C08                          1726  LAB_16D0
00000C08  6100 FD3E               1727      BSR     LAB_SCLN            * search for d1 line number from a0
00000C0C                          1728                              * returns Cb=0 if found
00000C0C  6500 FA94               1729      BCS     LAB_USER            * if carry set go do "Undefined statement" error
00000C10                          1730  
00000C10  2A48                    1731      MOVEA.l a0,a5               * copy to BASIC execute pointer
00000C12  534D                    1732      SUBQ.w  #1,a5               * decrement pointer
00000C14  274D 045A               1733      MOVE.l  a5,Cpntrl(a3)       * save as continue pointer
00000C18  4E75                    1734      RTS
00000C1A                          1735  
00000C1A                          1736  
00000C1A                          1737  *************************************************************************************
00000C1A                          1738  *
00000C1A                          1739  * perform LOOP
00000C1A                          1740  
00000C1A                          1741  LAB_LOOP
00000C1A  0C6F 009C 0004          1742      CMP.w       #TK_DO,4(sp)        * compare token on stack with DO token
00000C20  6600 FA58               1743      BNE     LAB_LDER            * branch if no matching DO
00000C24                          1744  
00000C24  1E00                    1745      MOVE.b  d0,d7               * copy following token (byte)
00000C26  672E                    1746      BEQ.s       LoopAlways          * if no following token loop forever
00000C28                          1747  
00000C28  BE3C 003A               1748      CMP.b       #':',d7         * compare with ":"
00000C2C  6728                    1749      BEQ.s       LoopAlways          * if no following token loop forever
00000C2E                          1750  
00000C2E  0407 00BD               1751      SUB.b       #TK_UNTIL,d7        * subtract token for UNTIL
00000C32  6708                    1752      BEQ.s       DoRest          * branch if was UNTIL
00000C34                          1753  
00000C34  5307                    1754      SUBQ.b  #1,d7               * decrement result
00000C36  6600 FA82               1755      BNE     LAB_SNER            * if not WHILE go do syntax error & warm start
00000C3A                          1756                              * only if the token was WHILE will this fail
00000C3A                          1757  
00000C3A  7EFF                    1758      MOVEQ       #-1,d7          * set invert result longword
00000C3C                          1759  DoRest
00000C3C  6100 06C0               1760      BSR     LAB_IGBY            * increment & scan memory
00000C40  6100 055C               1761      BSR     LAB_EVEX            * evaluate expression
00000C44  4A2B 0594               1762      TST.b       FAC1_e(a3)          * test FAC1 exponent
00000C48  6706                    1763      BEQ.s       DoCmp               * if = 0 go do straight compare
00000C4A                          1764  
00000C4A  177C 00FF 0594          1765      MOVE.b  #$FF,FAC1_e(a3)     * else set all bits
00000C50                          1766  DoCmp
00000C50  BF2B 0594               1767      EOR.b       d7,FAC1_e(a3)       * EOR with invert byte
00000C54  6614                    1768      BNE.s       LoopDone            * if <> 0 clear stack & back to interpreter loop
00000C56                          1769  
00000C56                          1770                              * loop condition wasn't met so do it again
00000C56                          1771  LoopAlways
00000C56  276F 0006 0452          1772      MOVE.l  6(sp),Clinel(a3)        * copy DO current line
00000C5C  2A6F 000A               1773      MOVE.l  10(sp),a5           * save BASIC execute pointer
00000C60                          1774  
00000C60  41FA FE80               1775      LEA     LAB_15C2(pc),a0     * get return address
00000C64  2E88                    1776      MOVE.l  a0,(sp)         * dump the call to this routine and set the
00000C66                          1777                              * return address
00000C66  6000 0698               1778      BRA     LAB_GBYT            * scan memory and return to interpreter inner
00000C6A                          1779                              * loop
00000C6A                          1780  
00000C6A                          1781                              * clear stack & back to interpreter loop
00000C6A                          1782  LoopDone
00000C6A  4FEF 000E               1783      LEA     14(sp),sp           * dump structure and call from stack
00000C6E  6014                    1784      BRA.s       LAB_DATA            * go perform DATA (find : or [EOL])
00000C70                          1785  
00000C70                          1786  
00000C70                          1787  *************************************************************************************
00000C70                          1788  *
00000C70                          1789  * perform RETURN
00000C70                          1790  
00000C70                          1791  LAB_RETURN
00000C70  6616                    1792      BNE.s       RTS_007         * exit if following token to allow syntax error
00000C72                          1793  
00000C72  0C6F 008D 0004          1794      CMP.w       #TK_GOSUB,4(sp)     * compare token from stack with GOSUB
00000C78  6600 FA3C               1795      BNE     LAB_RGER            * do RETURN without GOSUB error if no matching
00000C7C                          1796                              * GOSUB
00000C7C                          1797  
00000C7C  5C4F                    1798      ADDQ.w  #6,sp               * dump calling address & token
00000C7E  275F 0452               1799      MOVE.l  (sp)+,Clinel(a3)        * pull current line
00000C82  2A5F                    1800      MOVE.l  (sp)+,a5            * pull BASIC execute pointer
00000C84                          1801                              * now do perform "DATA" statement as we could be
00000C84                          1802                              * returning into the middle of an ON <var> GOSUB
00000C84                          1803                              * n,m,p,q line (the return address used by the
00000C84                          1804                              * DATA statement is the one pushed before the
00000C84                          1805                              * GOSUB was executed!)
00000C84                          1806  
00000C84                          1807  
00000C84                          1808  *************************************************************************************
00000C84                          1809  *
00000C84                          1810  * perform DATA
00000C84                          1811  
00000C84                          1812  LAB_DATA
00000C84  6104                    1813      BSR.s       LAB_SNBS            * scan for next BASIC statement ([:] or [EOL])
00000C86                          1814                              * returns a0 as pointer to [:] or [EOL]
00000C86  2A48                    1815      MOVEA.l a0,a5               * skip rest of statement
00000C88                          1816  RTS_007
00000C88  4E75                    1817      RTS
00000C8A                          1818  
00000C8A                          1819  
00000C8A                          1820  *************************************************************************************
00000C8A                          1821  *
00000C8A                          1822  * scan for next BASIC statement ([:] or [EOL])
00000C8A                          1823  * returns a0 as pointer to [:] or [EOL]
00000C8A                          1824  
00000C8A                          1825  LAB_SNBS
00000C8A  204D                    1826      MOVEA.l a5,a0               * copy BASIC execute pointer
00000C8C  7222                    1827      MOVEQ       #$22,d1         * set string quote character
00000C8E  743A                    1828      MOVEQ       #$3A,d2         * set look for character = ":"
00000C90  6008                    1829      BRA.s       LAB_172D            * go do search
00000C92                          1830  
00000C92                          1831  LAB_172C
00000C92  B400                    1832      CMP.b       d0,d2               * compare with ":"
00000C94  6708                    1833      BEQ.s       RTS_007a            * exit if found
00000C96                          1834  
00000C96  B200                    1835      CMP.b       d0,d1               * compare with '"'
00000C98  670C                    1836      BEQ.s       LAB_1725            * if found go search for [EOL]
00000C9A                          1837  
00000C9A                          1838  LAB_172D
00000C9A  1018                    1839      MOVE.b  (a0)+,d0            * get next byte
00000C9C  66F4                    1840      BNE.s       LAB_172C            * loop if not null [EOL]
00000C9E                          1841  
00000C9E                          1842  RTS_007a
00000C9E  5348                    1843      SUBQ.w  #1,a0               * correct pointer
00000CA0  4E75                    1844      RTS
00000CA2                          1845  
00000CA2                          1846  LAB_1723
00000CA2  B200                    1847      CMP.b       d0,d1               * compare with '"'
00000CA4  67F4                    1848      BEQ.s       LAB_172D            * if found go search for ":" or [EOL]
00000CA6                          1849  
00000CA6                          1850  LAB_1725
00000CA6  1018                    1851      MOVE.b  (a0)+,d0            * get next byte
00000CA8  66F8                    1852      BNE.s       LAB_1723            * loop if not null [EOL]
00000CAA                          1853  
00000CAA  60F2                    1854      BRA.s       RTS_007a            * correct pointer & return
00000CAC                          1855  
00000CAC                          1856  
00000CAC                          1857  *************************************************************************************
00000CAC                          1858  *
00000CAC                          1859  * perform IF
00000CAC                          1860  
00000CAC                          1861  LAB_IF
00000CAC  6100 04F0               1862      BSR     LAB_EVEX            * evaluate expression
00000CB0  6100 064E               1863      BSR     LAB_GBYT            * scan memory
00000CB4  B03C 00BA               1864      CMP.b       #TK_THEN,d0         * compare with THEN token
00000CB8  6714                    1865      BEQ.s       LAB_174B            * if it was THEN then continue
00000CBA                          1866  
00000CBA                          1867                              * wasn't IF .. THEN so must be IF .. GOTO
00000CBA  B03C 0089               1868      CMP.b       #TK_GOTO,d0         * compare with GOTO token
00000CBE  6600 F9FA               1869      BNE     LAB_SNER            * if not GOTO token do syntax error/warm start
00000CC2                          1870  
00000CC2                          1871                              * was GOTO so check for GOTO <n>
00000CC2  204D                    1872      MOVE.l  a5,a0               * save the execute pointer
00000CC4  6100 0638               1873      BSR     LAB_IGBY            * scan memory, test for a numeric character
00000CC8  2A48                    1874      MOVE.l  a0,a5               * restore the execute pointer
00000CCA  6400 F9EE               1875      BCC     LAB_SNER            * if not numeric do syntax error/warm start
00000CCE                          1876  
00000CCE                          1877  LAB_174B
00000CCE  102B 0594               1878      MOVE.b  FAC1_e(a3),d0       * get FAC1 exponent
00000CD2  671E                    1879      BEQ.s       LAB_174E            * if result was zero go look for an ELSE
00000CD4                          1880  
00000CD4  6100 0628               1881      BSR     LAB_IGBY            * increment & scan memory
00000CD8  6500 FF12               1882      BCS     LAB_GOTO            * if numeric do GOTO n
00000CDC                          1883                              * a GOTO <n> will never return to the IF
00000CDC                          1884                              * statement so there is no need to return
00000CDC                          1885                              * to this code
00000CDC                          1886  
00000CDC  B03C 008E               1887      CMP.b       #TK_RETURN,d0       * compare with RETURN token
00000CE0  6700 FE1E               1888      BEQ     LAB_1602            * if RETURN then interpret BASIC code from (a5)
00000CE4                          1889                              * and don't return here
00000CE4                          1890  
00000CE4  6100 FE16               1891      BSR     LAB_15FF            * else interpret BASIC code from (a5)
00000CE8                          1892  
00000CE8                          1893  * the IF was executed and there may be a following ELSE so the code needs to return
00000CE8                          1894  * here to check and ignore the ELSE if present
00000CE8                          1895  
00000CE8  1015                    1896      MOVE.b  (a5),d0         * get the next basic byte
00000CEA  B03C 00B6               1897      CMP.b       #TK_ELSE,d0         * compare it with the token for ELSE
00000CEE  6794                    1898      BEQ     LAB_DATA            * if ELSE ignore the following statement
00000CF0                          1899  
00000CF0                          1900  * there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
00000CF0                          1901  * following ELSE will, correctly, cause a syntax error
00000CF0                          1902  
00000CF0  4E75                    1903      RTS                     * else return to interpreter inner loop
00000CF2                          1904  
00000CF2                          1905  * perform ELSE after IF
00000CF2                          1906  
00000CF2                          1907  LAB_174E
00000CF2  101D                    1908      MOVE.b  (a5)+,d0            * faster increment past THEN
00000CF4  76B6                    1909      MOVEQ       #TK_ELSE,d3         * set search for ELSE token
00000CF6  788B                    1910      MOVEQ       #TK_IF,d4           * set search for IF token
00000CF8  7A00                    1911      MOVEQ       #0,d5               * clear the nesting depth
00000CFA                          1912  LAB_1750
00000CFA  101D                    1913      MOVE.b  (a5)+,d0            * get next BASIC byte & increment ptr
00000CFC  6720                    1914      BEQ.s       LAB_1754            * if EOL correct the pointer and return
00000CFE                          1915  
00000CFE  B004                    1916      CMP.b       d4,d0               * compare with "IF" token
00000D00  6604                    1917      BNE.s       LAB_1752            * skip if not nested IF
00000D02                          1918  
00000D02  5245                    1919      ADDQ.w  #1,d5               * else increment the nesting depth ..
00000D04  60F4                    1920      BRA.s       LAB_1750            * .. and continue looking
00000D06                          1921  
00000D06                          1922  LAB_1752
00000D06  B003                    1923      CMP.b       d3,d0               * compare with ELSE token
00000D08  66F0                    1924      BNE.s       LAB_1750            * if not ELSE continue looking
00000D0A                          1925  
00000D0A                          1926  LAB_1756
00000D0A  51CD FFEE               1927      DBF     d5,LAB_1750         * loop if still nested
00000D0E                          1928  
00000D0E                          1929  * found the matching ELSE, now do <{n|statement}>
00000D0E                          1930  
00000D0E  6100 05F0               1931      BSR     LAB_GBYT            * scan memory
00000D12  6500 FED8               1932      BCS     LAB_GOTO            * if numeric do GOTO n
00000D16                          1933                              * code will return to the interpreter loop
00000D16                          1934                              * at the tail end of the GOTO <n>
00000D16                          1935  
00000D16  6000 FDE4               1936      BRA     LAB_15FF            * else interpret BASIC code from (a5)
00000D1A                          1937                              * code will return to the interpreter loop
00000D1A                          1938                              * at the tail end of the <statement>
00000D1A                          1939  
00000D1A                          1940  
00000D1A                          1941  *************************************************************************************
00000D1A                          1942  *
00000D1A                          1943  * perform REM, skip (rest of) line
00000D1A                          1944  
00000D1A                          1945  LAB_REM
00000D1A  4A1D                    1946      TST.b       (a5)+               * test byte & increment pointer
00000D1C  66FC                    1947      BNE.s       LAB_REM         * loop if not EOL
00000D1E                          1948  
00000D1E                          1949  LAB_1754
00000D1E  534D                    1950      SUBQ.w  #1,a5               * correct the execute pointer
00000D20  4E75                    1951      RTS
00000D22                          1952  
00000D22                          1953  
00000D22                          1954  *************************************************************************************
00000D22                          1955  *
00000D22                          1956  * perform ON
00000D22                          1957  
00000D22                          1958  LAB_ON
00000D22  6100 0F4C               1959      BSR     LAB_GTBY            * get byte parameter, result in d0 and Itemp
00000D26  1400                    1960      MOVE.b  d0,d2               * copy byte
00000D28  6100 05D6               1961      BSR     LAB_GBYT            * restore BASIC byte
00000D2C  3F00                    1962      MOVE.w  d0,-(sp)            * push GOTO/GOSUB token
00000D2E  B03C 008D               1963      CMP.b       #TK_GOSUB,d0        * compare with GOSUB token
00000D32  6708                    1964      BEQ.s       LAB_176C            * branch if GOSUB
00000D34                          1965  
00000D34  B03C 0089               1966      CMP.b       #TK_GOTO,d0         * compare with GOTO token
00000D38  6600 F980               1967      BNE     LAB_SNER            * if not GOTO do syntax error, then warm start
00000D3C                          1968  
00000D3C                          1969  * next character was GOTO or GOSUB
00000D3C                          1970  
00000D3C                          1971  LAB_176C
00000D3C  5302                    1972      SUBQ.b  #1,d2               * decrement index (byte value)
00000D3E  6606                    1973      BNE.s       LAB_1773            * branch if not zero
00000D40                          1974  
00000D40  301F                    1975      MOVE.w  (sp)+,d0            * pull GOTO/GOSUB token
00000D42  6000 FDBC               1976      BRA     LAB_1602            * go execute it
00000D46                          1977  
00000D46                          1978  LAB_1773
00000D46  6100 05B6               1979      BSR     LAB_IGBY            * increment & scan memory
00000D4A  610A                    1980      BSR.s       LAB_GFPN            * get fixed-point number into temp integer & d1
00000D4C                          1981                              * (skip this n)
00000D4C  B03C 002C               1982      CMP.b       #$2C,d0         * compare next character with ","
00000D50  67EA                    1983      BEQ.s       LAB_176C            * loop if ","
00000D52                          1984  
00000D52  301F                    1985      MOVE.w  (sp)+,d0            * pull GOTO/GOSUB token (run out of options)
00000D54  4E75                    1986      RTS                     * and exit
00000D56                          1987  
00000D56                          1988  
00000D56                          1989  *************************************************************************************
00000D56                          1990  *
00000D56                          1991  * get fixed-point number into temp integer & d1
00000D56                          1992  * interpret number from (a5), leave (a5) pointing to byte after #
00000D56                          1993  
00000D56                          1994  LAB_GFPN
00000D56  7200                    1995      MOVEQ       #$00,d1         * clear integer register
00000D58  2001                    1996      MOVE.l  d1,d0               * clear d0
00000D5A  6100 05A4               1997      BSR     LAB_GBYT            * scan memory, Cb=1 if "0"-"9", & get byte
00000D5E  642E                    1998      BCC.s       LAB_1786            * return if carry clear, chr was not "0"-"9"
00000D60                          1999  
00000D60  2F02                    2000      MOVE.l  d2,-(sp)            * save d2
00000D62                          2001  LAB_1785
00000D62  2401                    2002      MOVE.l  d1,d2               * copy integer register
00000D64  D281                    2003      ADD.l       d1,d1               * *2
00000D66  6500 F952               2004      BCS     LAB_SNER            * if overflow do syntax error, then warm start
00000D6A                          2005  
00000D6A  D281                    2006      ADD.l       d1,d1               * *4
00000D6C  6500 F94C               2007      BCS     LAB_SNER            * if overflow do syntax error, then warm start
00000D70                          2008  
00000D70  D282                    2009      ADD.l       d2,d1               * *1 + *4
00000D72  6500 F946               2010      BCS     LAB_SNER            * if overflow do syntax error, then warm start
00000D76                          2011  
00000D76  D281                    2012      ADD.l       d1,d1               * *10
00000D78  6500 F940               2013      BCS     LAB_SNER            * if overflow do syntax error, then warm start
00000D7C                          2014  
00000D7C  0400 0030               2015      SUB.b       #$30,d0         * subtract $30 from byte
00000D80  D280                    2016      ADD.l       d0,d1               * add to integer register, the top 24 bits are
00000D82                          2017                              * always clear
00000D82  6900 F936               2018      BVS     LAB_SNER            * if overflow do syntax error, then warm start
00000D86                          2019                              * this makes the maximum line number 2147483647
00000D86  6100 0576               2020      BSR     LAB_IGBY            * increment & scan memory
00000D8A  65D6                    2021      BCS.s       LAB_1785            * loop for next character if "0"-"9"
00000D8C                          2022  
00000D8C  241F                    2023      MOVE.l  (sp)+,d2            * restore d2
00000D8E                          2024  LAB_1786
00000D8E  2741 042A               2025      MOVE.l  d1,Itemp(a3)        * save Itemp
00000D92  4E75                    2026      RTS
00000D94                          2027  
00000D94                          2028  
00000D94                          2029  *************************************************************************************
00000D94                          2030  *
00000D94                          2031  * perform DEC
00000D94                          2032  
00000D94                          2033  LAB_DEC
00000D94  3F3C 8180               2034      MOVE.w  #$8180,-(sp)        * set -1 sign/exponent
00000D98  600A                    2035      BRA.s       LAB_17B7            * go do DEC
00000D9A                          2036  
00000D9A                          2037  
00000D9A                          2038  *************************************************************************************
00000D9A                          2039  *
00000D9A                          2040  * perform INC
00000D9A                          2041  
00000D9A                          2042  LAB_INC
00000D9A  3F3C 8100               2043      MOVE.w  #$8100,-(sp)        * set 1 sign/exponent
00000D9E  6004                    2044      BRA.s       LAB_17B7            * go do INC
00000DA0                          2045  
00000DA0                          2046                              * was "," so another INCR variable to do
00000DA0                          2047  LAB_17B8
00000DA0  6100 055C               2048      BSR     LAB_IGBY            * increment and scan memory
00000DA4                          2049  LAB_17B7
00000DA4  6100 0770               2050      BSR     LAB_GVAR            * get variable address in a0
00000DA8                          2051  
00000DA8                          2052  * if you want a non existant variable to return a null value then set the novar
00000DA8                          2053  * value at the top of this file to some non zero value
00000DA8                          2054  
00000DA8                 FALSE    2055   ifne   novar
00000DA8                          2056   endc
00000DA8                          2057  
00000DA8  4A2B 05B5               2058      TST.b       Dtypef(a3)          * test data type, $80=string, $40=integer,
00000DAC                          2059                              * $00=float
00000DAC  6B00 F8E0               2060      BMI     LAB_TMER            * if string do "Type mismatch" error/warm start
00000DB0                          2061  
00000DB0  6636                    2062      BNE.s       LAB_INCI            * go do integer INC/DEC
00000DB2                          2063  
00000DB2  2748 0472               2064      MOVE.l  a0,Lvarpl(a3)       * save var address
00000DB6  6100 1542               2065      BSR     LAB_UFAC            * unpack memory (a0) into FAC1
00000DBA  277C 80000000 0598      2066      MOVE.l  #$80000000,FAC2_m(a3)   * set FAC2 mantissa for 1
00000DC2  3017                    2067      MOVE.w  (sp),d0         * move exponent & sign to d0
00000DC4  3740 059C               2068      MOVE.w  d0,FAC2_e(a3)       * move exponent & sign to FAC2
00000DC8  176B 0595 059E          2069      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * make sign compare = FAC1 sign
00000DCE  B12B 059E               2070      EOR.b       d0,FAC_sc(a3)       * make sign compare (FAC1_s EOR FAC2_s)
00000DD2  6100 1242               2071      BSR     LAB_ADD         * add FAC2 to FAC1
00000DD6  6100 153E               2072      BSR     LAB_PFAC            * pack FAC1 into variable (Lvarpl)
00000DDA                          2073  LAB_INCT
00000DDA  6100 0524               2074      BSR     LAB_GBYT            * scan memory
00000DDE  0C00 002C               2075      CMPI.b  #$2C,d0         * compare with ","
00000DE2  67BC                    2076      BEQ.s       LAB_17B8            * continue if "," (another variable to do)
00000DE4                          2077  
00000DE4  544F                    2078      ADDQ.w  #2,sp               * else dump sign & exponent
00000DE6  4E75                    2079      RTS
00000DE8                          2080  
00000DE8                          2081  LAB_INCI
00000DE8  4A2F 0001               2082      TST.b       1(sp)               * test sign
00000DEC  6604                    2083      BNE.s       LAB_DECI            * branch if DEC
00000DEE                          2084  
00000DEE  5290                    2085      ADDQ.l  #1,(a0)         * increment variable
00000DF0  60E8                    2086      BRA.s       LAB_INCT            * go scan for more
00000DF2                          2087  
00000DF2                          2088  LAB_DECI
00000DF2  5390                    2089      SUBQ.l  #1,(a0)         * decrement variable
00000DF4  60E4                    2090      BRA.s       LAB_INCT            * go scan for more
00000DF6                          2091  
00000DF6                          2092  
00000DF6                          2093  *************************************************************************************
00000DF6                          2094  *
00000DF6                          2095  * perform LET
00000DF6                          2096  
00000DF6                          2097  LAB_LET
00000DF6  6100 071A               2098      BSR     LAB_SVAR            * search for or create a variable
00000DFA                          2099                              * return the variable address in a0
00000DFA  2748 0472               2100      MOVE.l  a0,Lvarpl(a3)       * save variable address
00000DFE  1F2B 05B5               2101      MOVE.b  Dtypef(a3),-(sp)        * push var data type, $80=string, $40=integer,
00000E02                          2102                              * $00=float
00000E02  70CA                    2103      MOVEQ       #TK_EQUAL-$100,d0       * get = token
00000E04  6100 04F0               2104      BSR     LAB_SCCA            * scan for CHR$(d0), else do syntax error/warm
00000E08                          2105                              * start
00000E08  6100 0394               2106      BSR     LAB_EVEX            * evaluate expression
00000E0C  102B 05B5               2107      MOVE.b  Dtypef(a3),d0       * copy expression data type
00000E10  175F 05B5               2108      MOVE.b  (sp)+,Dtypef(a3)        * pop variable data type
00000E14  E318                    2109      ROL.b       #1,d0               * set carry if expression type = string
00000E16  6100 0372               2110      BSR     LAB_CKTM            * type match check, set C for string
00000E1A  6700 14FA               2111      BEQ     LAB_PFAC            * if number pack FAC1 into variable Lvarpl & RET
00000E1E                          2112  
00000E1E                          2113  * string LET
00000E1E                          2114  
00000E1E                          2115  LAB_17D5
00000E1E  246B 0472               2116      MOVEA.l Lvarpl(a3),a2       * get pointer to variable
00000E22                          2117  LAB_17D6
00000E22  206B 0590               2118      MOVEA.l FAC1_m(a3),a0       * get descriptor pointer
00000E26  2250                    2119      MOVEA.l (a0),a1         * get string pointer
00000E28  B3EB 0446               2120      CMP.l       Sstorl(a3),a1       * compare string memory start with string
00000E2C                          2121                              * pointer
00000E2C  6516                    2122      BCS.s       LAB_1811            * if it was in program memory assign the value
00000E2E                          2123                              * and exit
00000E2E                          2124  
00000E2E  B1EB 0432               2125      CMPA.l  Sfncl(a3),a0        * compare functions start with descriptor
00000E32                          2126                              * pointer
00000E32  6510                    2127      BCS.s       LAB_1811            * branch if >= (string is on stack)
00000E34                          2128  
00000E34                          2129                              * string is variable$ make space and copy string
00000E34                          2130  LAB_1810
00000E34  7200                    2131      MOVEQ       #0,d1               * clear length
00000E36  3228 0004               2132      MOVE.w  4(a0),d1            * get string length
00000E3A  2050                    2133      MOVEA.l (a0),a0         * get string pointer
00000E3C  6100 0B0C               2134      BSR     LAB_20C9            * copy string
00000E40  206B 0590               2135      MOVEA.l FAC1_m(a3),a0       * get descriptor pointer back
00000E44                          2136                              * clean stack & assign value to string variable
00000E44                          2137  LAB_1811
00000E44  B9C8                    2138      CMPA.l  a0,a4               * is string on the descriptor stack
00000E46  6602                    2139      BNE.s       LAB_1813            * skip pop if not
00000E48                          2140  
00000E48  5C4C                    2141      ADDQ.w  #$06,a4         * else update stack pointer
00000E4A                          2142  LAB_1813
00000E4A  24D8                    2143      MOVE.l  (a0)+,(a2)+         * save pointer to variable
00000E4C  3490                    2144      MOVE.w  (a0),(a2)           * save length to variable
00000E4E                          2145  RTS_008
00000E4E  4E75                    2146      RTS
00000E50                          2147  
00000E50                          2148  
00000E50                          2149  *************************************************************************************
00000E50                          2150  *
00000E50                          2151  * perform GET
00000E50                          2152  
00000E50                          2153  LAB_GET
00000E50  6100 06C0               2154      BSR     LAB_SVAR            * search for or create a variable
00000E54                          2155                              * return the variable address in a0
00000E54  2748 0472               2156      MOVE.l  a0,Lvarpl(a3)       * save variable address as GET variable
00000E58  4A2B 05B5               2157      TST.b       Dtypef(a3)          * test data type, $80=string, $40=integer,
00000E5C                          2158                              * $00=float
00000E5C  6B0C                    2159      BMI.s       LAB_GETS            * go get string character
00000E5E                          2160  
00000E5E                          2161                              * was numeric get
00000E5E  6100 201E               2162      BSR     INGET               * get input byte
00000E62  6100 09C2               2163      BSR     LAB_1FD0            * convert d0 to unsigned byte in FAC1
00000E66  6000 14AE               2164      BRA     LAB_PFAC            * pack FAC1 into variable (Lvarpl) & return
00000E6A                          2165  
00000E6A                          2166  LAB_GETS
00000E6A  7200                    2167      MOVEQ       #$00,d1         * assume no byte
00000E6C  2041                    2168      MOVE.l  d1,a0               * assume null string
00000E6E  6100 200E               2169      BSR     INGET               * get input byte
00000E72  6408                    2170      BCC.s       LAB_NoSt            * branch if no byte received
00000E74                          2171  
00000E74  7201                    2172      MOVEQ       #$01,d1         * string is single byte
00000E76  6100 0B04               2173      BSR     LAB_2115            * make string space d1 bytes long
00000E7A                          2174                              * return a0 = pointer, other registers unchanged
00000E7A                          2175  
00000E7A  1080                    2176      MOVE.b  d0,(a0)         * save byte in string (byte IS string!)
00000E7C                          2177  LAB_NoSt
00000E7C  6100 0AE4               2178      BSR     LAB_RTST            * push string on descriptor stack
00000E80                          2179                              * a0 = pointer, d1 = length
00000E80                          2180  
00000E80  609C                    2181      BRA.s       LAB_17D5            * do string LET & return
00000E82                          2182  
00000E82                          2183  
00000E82                          2184  *************************************************************************************
00000E82                          2185  *
00000E82                          2186  * PRINT
00000E82                          2187  
00000E82                          2188  LAB_1829
00000E82  6100 00B4               2189      BSR     LAB_18C6            * print string from stack
00000E86                          2190  LAB_182C
00000E86  6100 0478               2191      BSR     LAB_GBYT            * scan memory
00000E8A                          2192  
00000E8A                          2193  * perform PRINT
00000E8A                          2194  
00000E8A                          2195  LAB_PRINT
00000E8A  674A                    2196      BEQ.s       LAB_CRLF            * if nothing following just print CR/LF
00000E8C                          2197  
00000E8C                          2198  LAB_1831
00000E8C  B03C 00B5               2199      CMP.b       #TK_TAB,d0          * compare with TAB( token
00000E90  6764                    2200      BEQ.s       LAB_18A2            * go do TAB/SPC
00000E92                          2201  
00000E92  B03C 00B9               2202      CMP.b       #TK_SPC,d0          * compare with SPC( token
00000E96  675E                    2203      BEQ.s       LAB_18A2            * go do TAB/SPC
00000E98                          2204  
00000E98  B03C 002C               2205      CMP.b       #',',d0         * compare with ","
00000E9C  6740                    2206      BEQ.s       LAB_188B            * go do move to next TAB mark
00000E9E                          2207  
00000E9E  B03C 003B               2208      CMP.b       #';',d0         * compare with ";"
00000EA2  6700 0086               2209      BEQ     LAB_18BD            * if ";" continue with PRINT processing
00000EA6                          2210  
00000EA6  6100 02F6               2211      BSR     LAB_EVEX            * evaluate expression
00000EAA  4A2B 05B5               2212      TST.b       Dtypef(a3)          * test data type, $80=string, $40=integer,
00000EAE                          2213                              * $00=float
00000EAE  6BD2                    2214      BMI.s       LAB_1829            * branch if string
00000EB0                          2215  
00000EB0                          2216  ** replace the two lines above with this code
00000EB0                          2217  
00000EB0                          2218  **  MOVE.b  Dtypef(a3),d0       * get data type flag, $80=string, $00=numeric
00000EB0                          2219  **  BMI.s       LAB_1829            * branch if string
00000EB0                          2220  
00000EB0  6100 15E4               2221      BSR     LAB_2970            * convert FAC1 to string
00000EB4  6100 0A66               2222      BSR     LAB_20AE            * print " terminated string to FAC1 stack
00000EB8                          2223  
00000EB8                          2224  * don't check fit if terminal width byte is zero
00000EB8                          2225  
00000EB8  7000                    2226      MOVEQ       #0,d0               * clear d0
00000EBA  102B 05E6               2227      MOVE.b  TWidth(a3),d0       * get terminal width byte
00000EBE  670C                    2228      BEQ.s       LAB_185E            * skip check if zero
00000EC0                          2229  
00000EC0  902C 0007               2230      SUB.b       7(a4),d0            * subtract string length
00000EC4  902B 05E5               2231      SUB.b       TPos(a3),d0         * subtract terminal position
00000EC8  6402                    2232      BCC.s       LAB_185E            * branch if less than terminal width
00000ECA                          2233  
00000ECA  610A                    2234      BSR.s       LAB_CRLF            * else print CR/LF
00000ECC                          2235  LAB_185E
00000ECC  616A                    2236      BSR.s       LAB_18C6            * print string from stack
00000ECE  60B6                    2237      BRA.s       LAB_182C            * always go continue processing line
00000ED0                          2238  
00000ED0                          2239  
00000ED0                          2240  *************************************************************************************
00000ED0                          2241  *
00000ED0                          2242  * CR/LF return to BASIC from BASIC input handler
00000ED0                          2243  * leaves a0 pointing to the buffer start
00000ED0                          2244  
00000ED0                          2245  LAB_1866
00000ED0  11BC 0000 1000          2246      MOVE.b  #$00,(a0,d1.w)      * null terminate input
00000ED6                          2247  
00000ED6                          2248  * print CR/LF
00000ED6                          2249  
00000ED6                          2250  LAB_CRLF
00000ED6  700D                    2251      MOVEQ       #$0D,d0         * load [CR]
00000ED8  6174                    2252      BSR.s       LAB_PRNA            * go print the character
00000EDA  700A                    2253      MOVEQ       #$0A,d0         * load [LF]
00000EDC  6070                    2254      BRA.s       LAB_PRNA            * go print the character & return
00000EDE                          2255  
00000EDE                          2256  LAB_188B
00000EDE  142B 05E5               2257      MOVE.b  TPos(a3),d2         * get terminal position
00000EE2  B42B 05E7               2258      CMP.b       Iclim(a3),d2        * compare with input column limit
00000EE6  6504                    2259      BCS.s       LAB_1898            * branch if less than Iclim
00000EE8                          2260  
00000EE8  61EC                    2261      BSR.s       LAB_CRLF            * else print CR/LF (next line)
00000EEA  603E                    2262      BRA.s       LAB_18BD            * continue with PRINT processing
00000EEC                          2263  
00000EEC                          2264  LAB_1898
00000EEC  942B 05E2               2265      SUB.b       TabSiz(a3),d2       * subtract TAB size
00000EF0  64FA                    2266      BCC.s       LAB_1898            * loop if result was >= 0
00000EF2                          2267  
00000EF2  4402                    2268      NEG.b       d2              * twos complement it
00000EF4  6022                    2269      BRA.s       LAB_18B7            * print d2 spaces
00000EF6                          2270  
00000EF6                          2271                              * do TAB/SPC
00000EF6                          2272  LAB_18A2
00000EF6  3F00                    2273      MOVE.w  d0,-(sp)            * save token
00000EF8  6100 0D72               2274      BSR     LAB_SGBY            * increment and get byte, result in d0 and Itemp
00000EFC  3400                    2275      MOVE.w  d0,d2               * copy byte
00000EFE  6100 0400               2276      BSR     LAB_GBYT            * get basic byte back
00000F02  B03C 0029               2277      CMP.b       #$29,d0         * is next character ")"
00000F06  6600 F7B2               2278      BNE     LAB_SNER            * if not do syntax error, then warm start
00000F0A                          2279  
00000F0A  301F                    2280      MOVE.w  (sp)+,d0            * get token back
00000F0C  B03C 00B5               2281      CMP.b       #TK_TAB,d0          * was it TAB ?
00000F10  6606                    2282      BNE.s       LAB_18B7            * branch if not (was SPC)
00000F12                          2283  
00000F12                          2284                              * calculate TAB offset
00000F12  942B 05E5               2285      SUB.b       TPos(a3),d2         * subtract terminal position
00000F16  6312                    2286      BLS.s       LAB_18BD            * branch if result was <= 0
00000F18                          2287                              * can't TAB backwards or already there
00000F18                          2288  
00000F18                          2289                              * print d2.b spaces
00000F18                          2290  LAB_18B7
00000F18  7000                    2291      MOVEQ       #0,d0               * clear longword
00000F1A  5300                    2292      SUBQ.b  #1,d0               * make d0 = $FF
00000F1C  C480                    2293      AND.l       d0,d2               * mask for byte only
00000F1E  670A                    2294      BEQ.s       LAB_18BD            * branch if zero
00000F20                          2295  
00000F20  7020                    2296      MOVEQ       #$20,d0         * load " "
00000F22  5302                    2297      SUBQ.b  #1,d2               * adjust for DBF loop
00000F24                          2298  LAB_18B8
00000F24  6128                    2299      BSR.s       LAB_PRNA            * go print
00000F26  51CA FFFC               2300      DBF     d2,LAB_18B8         * decrement count and loop if not all done
00000F2A                          2301  
00000F2A                          2302                              * continue with PRINT processing
00000F2A                          2303  LAB_18BD
00000F2A  6100 03D2               2304      BSR     LAB_IGBY            * increment & scan memory
00000F2E  6600 FF5C               2305      BNE     LAB_1831            * if byte continue executing PRINT
00000F32                          2306  
00000F32  4E75                    2307      RTS                     * exit if nothing more to print
00000F34                          2308  
00000F34                          2309  
00000F34                          2310  *************************************************************************************
00000F34                          2311  *
00000F34                          2312  * print null terminated string from a0
00000F34                          2313  
00000F34                          2314  LAB_18C3
00000F34  6100 09E6               2315      BSR     LAB_20AE            * print terminated string to FAC1/stack
00000F38                          2316  
00000F38                          2317  * print string from stack
00000F38                          2318  
00000F38                          2319  LAB_18C6
00000F38  6100 0BD6               2320      BSR     LAB_22B6            * pop string off descriptor stack or from memory
00000F3C                          2321                              * returns with d0 = length, a0 = pointer
00000F3C  670C                    2322      BEQ.s       RTS_009         * exit (RTS) if null string
00000F3E                          2323  
00000F3E  3200                    2324      MOVE.w  d0,d1               * copy length & set Z flag
00000F40  5341                    2325      SUBQ.w  #1,d1               * -1 for BF loop
00000F42                          2326  LAB_18CD
00000F42  1018                    2327      MOVE.b  (a0)+,d0            * get byte from string
00000F44  6108                    2328      BSR.s       LAB_PRNA            * go print the character
00000F46  51C9 FFFA               2329      DBF     d1,LAB_18CD         * decrement count and loop if not done yet
00000F4A                          2330  
00000F4A                          2331  RTS_009
00000F4A  4E75                    2332      RTS
00000F4C                          2333  
00000F4C                          2334  
00000F4C                          2335  *************************************************************************************
00000F4C                          2336  *
00000F4C                          2337  * print "?" character
00000F4C                          2338  
00000F4C                          2339  LAB_18E3
00000F4C  703F                    2340      MOVEQ       #$3F,d0         * load "?" character
00000F4E                          2341  
00000F4E                          2342  
00000F4E                          2343  *************************************************************************************
00000F4E                          2344  *
00000F4E                          2345  * print character in d0, includes the null handler and infinite line length code
00000F4E                          2346  * changes no registers
00000F4E                          2347  
00000F4E                          2348  LAB_PRNA
00000F4E  2F01                    2349      MOVE.l  d1,-(sp)            * save d1
00000F50  B03C 0020               2350      CMP.b       #$20,d0         * compare with " "
00000F54  6528                    2351      BCS.s       LAB_18F9            * branch if less, non printing character
00000F56                          2352  
00000F56                          2353                              * don't check fit if terminal width byte is zero
00000F56  122B 05E6               2354      MOVE.b  TWidth(a3),d1       * get terminal width
00000F5A  6610                    2355      BNE.s       LAB_18F0            * branch if not zero (not infinite length)
00000F5C                          2356  
00000F5C                          2357                              * is "infinite line" so check TAB position
00000F5C  122B 05E5               2358      MOVE.b  TPos(a3),d1         * get position
00000F60  922B 05E2               2359      SUB.b       TabSiz(a3),d1       * subtract TAB size
00000F64  6614                    2360      BNE.s       LAB_18F7            * skip reset if different
00000F66                          2361  
00000F66  1741 05E5               2362      MOVE.b  d1,TPos(a3)         * else reset position
00000F6A  600E                    2363      BRA.s       LAB_18F7            * go print character
00000F6C                          2364  
00000F6C                          2365  LAB_18F0
00000F6C  B22B 05E5               2366      CMP.b       TPos(a3),d1         * compare with terminal character position
00000F70  6608                    2367      BNE.s       LAB_18F7            * branch if not at end of line
00000F72                          2368  
00000F72  2F00                    2369      MOVE.l  d0,-(sp)            * save d0
00000F74  6100 FF60               2370      BSR     LAB_CRLF            * else print CR/LF
00000F78  201F                    2371      MOVE.l  (sp)+,d0            * restore d0
00000F7A                          2372  LAB_18F7
00000F7A  522B 05E5               2373      ADDQ.b  #$01,TPos(a3)       * increment terminal position
00000F7E                          2374  LAB_18F9
00000F7E  4EAB 0412               2375      JSR     V_OUTP(a3)          * output byte via output vector
00000F82  B03C 000D               2376      CMP.b       #$0D,d0         * compare with [CR]
00000F86  6618                    2377      BNE.s       LAB_188A            * branch if not [CR]
00000F88                          2378  
00000F88                          2379                              * else print nullct nulls after the [CR]
00000F88  7200                    2380      MOVEQ       #$00,d1         * clear d1
00000F8A  122B 05E4               2381      MOVE.b  Nullct(a3),d1       * get null count
00000F8E  670C                    2382      BEQ.s       LAB_1886            * branch if no nulls
00000F90                          2383  
00000F90  7000                    2384      MOVEQ       #$00,d0         * load [NULL]
00000F92                          2385  LAB_1880
00000F92  4EAB 0412               2386      JSR     V_OUTP(a3)          * go print the character
00000F96  51C9 FFFA               2387      DBF     d1,LAB_1880         * decrement count and loop if not all done
00000F9A                          2388  
00000F9A  700D                    2389      MOVEQ       #$0D,d0         * restore the character
00000F9C                          2390  LAB_1886
00000F9C  1741 05E5               2391      MOVE.b  d1,TPos(a3)         * clear terminal position
00000FA0                          2392  LAB_188A
00000FA0  221F                    2393      MOVE.l  (sp)+,d1            * restore d1
00000FA2  4E75                    2394      RTS
00000FA4                          2395  
00000FA4                          2396  
00000FA4                          2397  *************************************************************************************
00000FA4                          2398  *
00000FA4                          2399  * handle bad input data
00000FA4                          2400  
00000FA4                          2401  LAB_1904
00000FA4  2A5F                    2402      MOVEA.l (sp)+,a5            * restore execute pointer
00000FA6  4A2B 05E0               2403      TST.b       Imode(a3)           * test input mode flag, $00=INPUT, $98=READ
00000FAA  6A0A                    2404      BPL.s       LAB_1913            * branch if INPUT (go do redo)
00000FAC                          2405  
00000FAC  276B 045E 0452          2406      MOVE.l  Dlinel(a3),Clinel(a3)   * save DATA line as current line
00000FB2  6000 F6DA               2407      BRA     LAB_TMER            * do type mismatch error, then warm start
00000FB6                          2408  
00000FB6                          2409                              * mode was INPUT
00000FB6                          2410  LAB_1913
00000FB6  41FA 2D36               2411      LEA     LAB_REDO(pc),a0     * point to redo message
00000FBA  6100 FF78               2412      BSR     LAB_18C3            * print null terminated string from memory
00000FBE  2A6B 045A               2413      MOVEA.l Cpntrl(a3),a5       * save continue pointer as BASIC execute pointer
00000FC2  4E75                    2414      RTS
00000FC4                          2415  
00000FC4                          2416  
00000FC4                          2417  *************************************************************************************
00000FC4                          2418  *
00000FC4                          2419  * perform INPUT
00000FC4                          2420  
00000FC4                          2421  LAB_INPUT
00000FC4  6100 0868               2422      BSR     LAB_CKRN            * check not direct (back here if ok)
00000FC8  B03C 0022               2423      CMP.b       #'"',d0         * compare the next byte with open quote
00000FCC  660E                    2424      BNE.s       LAB_1934            * if no prompt string just go get the input
00000FCE                          2425  
00000FCE  6100 0306               2426      BSR     LAB_1BC1            * print "..." string
00000FD2  703B                    2427      MOVEQ       #';',d0         * set the search character to ";"
00000FD4  6100 0320               2428      BSR     LAB_SCCA            * scan for CHR$(d0), else do syntax error/warm
00000FD8                          2429                              * start
00000FD8  6100 FF5E               2430      BSR     LAB_18C6            * print string from Sutill/Sutilh
00000FDC                          2431                              * finished the prompt, now read the data
00000FDC                          2432  LAB_1934
00000FDC  6100 F80C               2433      BSR     LAB_INLN            * print "? " and get BASIC input
00000FE0                          2434                              * return a0 pointing to the buffer start
00000FE0  7000                    2435      MOVEQ       #0,d0               * flag INPUT
00000FE2                          2436  
00000FE2                          2437  * if you don't want a null response to INPUT to break the program then set the nobrk
00000FE2                          2438  * value at the top of this file to some non zero value
00000FE2                          2439  
00000FE2                 FALSE    2440   ifne   nobrk
00000FE2                          2441   endc
00000FE2                          2442  
00000FE2                          2443  * if you do want a null response to INPUT to break the program then leave the nobrk
00000FE2                          2444  * value at the top of this file set to zero
00000FE2                          2445  
00000FE2                 TRUE     2446   ifeq   nobrk
00000FE2                          2447  
00000FE2  4A10                    2448      TST.b       (a0)                * test first byte from buffer
00000FE4  660A                    2449      BNE.s       LAB_1953            * branch if not null input
00000FE6                          2450  
00000FE6  6000 FB5E               2451      BRA     LAB_1647            * else go do BREAK exit
00000FEA                          2452  
00000FEA                          2453   endc
00000FEA                          2454  
00000FEA                          2455  
00000FEA                          2456  *************************************************************************************
00000FEA                          2457  *
00000FEA                          2458  * perform READ
00000FEA                          2459  
00000FEA                          2460  LAB_READ
00000FEA  206B 0462               2461      MOVEA.l Dptrl(a3),a0        * get the DATA pointer
00000FEE  7098                    2462      MOVEQ       #$98-$100,d0        * flag READ
00000FF0                          2463  LAB_1953
00000FF0  1740 05E0               2464      MOVE.b  d0,Imode(a3)        * set input mode flag, $00=INPUT, $98=READ
00000FF4  2748 0466               2465      MOVE.l  a0,Rdptrl(a3)       * save READ pointer
00000FF8                          2466  
00000FF8                          2467                              * READ or INPUT the next variable from list
00000FF8                          2468  LAB_195B
00000FF8  6100 0518               2469      BSR     LAB_SVAR            * search for or create a variable
00000FFC                          2470                              * return the variable address in a0
00000FFC  2748 0472               2471      MOVE.l  a0,Lvarpl(a3)       * save variable address as LET variable
00001000  2F0D                    2472      MOVE.l  a5,-(sp)            * save BASIC execute pointer
00001002                          2473  LAB_1961
00001002  2A6B 0466               2474      MOVEA.l Rdptrl(a3),a5       * set READ pointer as BASIC execute pointer
00001006  6100 02F8               2475      BSR     LAB_GBYT            * scan memory
0000100A  661E                    2476      BNE.s       LAB_1986            * if not null go get the value
0000100C                          2477  
0000100C                          2478                              * the pointer was to a null entry
0000100C  4A2B 05E0               2479      TST.b       Imode(a3)           * test input mode flag, $00=INPUT, $98=READ
00001010  6B72                    2480      BMI.s       LAB_19DD            * branch if READ (go find the next statement)
00001012                          2481  
00001012                          2482                              * else the mode was INPUT so get more
00001012  6100 FF38               2483      BSR     LAB_18E3            * print a "?" character
00001016  6100 F7D2               2484      BSR     LAB_INLN            * print "? " and get BASIC input
0000101A                          2485                              * return a0 pointing to the buffer start
0000101A                          2486  
0000101A                          2487  * if you don't want a null response to INPUT to break the program then set the nobrk
0000101A                          2488  * value at the top of this file to some non zero value
0000101A                          2489  
0000101A                 FALSE    2490   ifne   nobrk
0000101A                          2491   endc
0000101A                          2492  
0000101A                          2493  * if you do want a null response to INPUT to break the program then leave the nobrk
0000101A                          2494  * value at the top of this file set to zero
0000101A                          2495  
0000101A                 TRUE     2496   ifeq   nobrk
0000101A                          2497  
0000101A  4A10                    2498      TST.b       (a0)                * test the first byte from the buffer
0000101C  6604                    2499      BNE.s       LAB_1984            * if not null input go handle it
0000101E                          2500  
0000101E  6000 FB26               2501      BRA     LAB_1647            * else go do the BREAK exit
00001022                          2502  
00001022                          2503  LAB_1984
00001022  2A48                    2504      MOVEA.l a0,a5               * set the execute pointer to the buffer
00001024  534D                    2505      SUBQ.w  #1,a5               * decrement the execute pointer
00001026                          2506  
00001026                          2507   endc
00001026                          2508  
00001026                          2509  LAB_1985
00001026  6100 02D6               2510      BSR     LAB_IGBY            * increment & scan memory
0000102A                          2511  LAB_1986
0000102A  4A2B 05B5               2512      TST.b       Dtypef(a3)          * test data type, $80=string, $40=integer,
0000102E                          2513                              * $00=float
0000102E  6A20                    2514      BPL.s       LAB_19B0            * branch if numeric
00001030                          2515  
00001030                          2516                              * else get string
00001030  1400                    2517      MOVE.b  d0,d2               * save search character
00001032  B03C 0022               2518      CMP.b       #$22,d0         * was it " ?
00001036  6706                    2519      BEQ.s       LAB_1999            * branch if so
00001038                          2520  
00001038  743A                    2521      MOVEQ       #':',d2         * set new search character
0000103A  702C                    2522      MOVEQ       #',',d0         * other search character is ","
0000103C  534D                    2523      SUBQ.w  #1,a5               * decrement BASIC execute pointer
0000103E                          2524  LAB_1999
0000103E  524D                    2525      ADDQ.w  #1,a5               * increment BASIC execute pointer
00001040  1600                    2526      MOVE.b  d0,d3               * set second search character
00001042  204D                    2527      MOVEA.l a5,a0               * BASIC execute pointer is source
00001044                          2528  
00001044  6100 08DA               2529      BSR     LAB_20B4            * print d2/d3 terminated string to FAC1 stack
00001048                          2530                              * d2 = Srchc, d3 = Asrch, a0 is source
00001048  2A4A                    2531      MOVEA.l a2,a5               * copy end of string to BASIC execute pointer
0000104A  6100 FDD2               2532      BSR     LAB_17D5            * go do string LET
0000104E  6010                    2533      BRA.s       LAB_19B6            * go check string terminator
00001050                          2534  
00001050                          2535                              * get numeric INPUT
00001050                          2536  LAB_19B0
00001050  1F2B 05B5               2537      MOVE.b  Dtypef(a3),-(sp)        * save variable data type
00001054  6100 1FD2               2538      BSR     LAB_2887            * get FAC1 from string
00001058  175F 05B5               2539      MOVE.b  (sp)+,Dtypef(a3)        * restore variable data type
0000105C  6100 12B8               2540      BSR     LAB_PFAC            * pack FAC1 into (Lvarpl)
00001060                          2541  LAB_19B6
00001060  6100 029E               2542      BSR     LAB_GBYT            * scan memory
00001064  670A                    2543      BEQ.s       LAB_19C2            * branch if null (last entry)
00001066                          2544  
00001066  B03C 002C               2545      CMP.b       #',',d0         * else compare with ","
0000106A  6600 FF38               2546      BNE     LAB_1904            * if not "," go handle bad input data
0000106E                          2547  
0000106E  524D                    2548      ADDQ.w  #1,a5               * else was "," so point to next chr
00001070                          2549                              * got good input data
00001070                          2550  LAB_19C2
00001070  274D 0466               2551      MOVE.l  a5,Rdptrl(a3)       * save the read pointer for now
00001074  2A5F                    2552      MOVEA.l (sp)+,a5            * restore the execute pointer
00001076  6100 0288               2553      BSR     LAB_GBYT            * scan the memory
0000107A  6736                    2554      BEQ.s       LAB_1A03            * if null go do extra ignored message
0000107C                          2555  
0000107C  487A FF7A               2556      PEA     LAB_195B(pc)        * set return address
00001080  6000 0272               2557      BRA     LAB_1C01            * scan for "," else do syntax error/warm start
00001084                          2558                              * then go INPUT next variable from list
00001084                          2559  
00001084                          2560                              * find next DATA statement or do "Out of Data"
00001084                          2561                              * error
00001084                          2562  LAB_19DD
00001084  6100 FC04               2563      BSR     LAB_SNBS            * scan for next BASIC statement ([:] or [EOL])
00001088                          2564                              * returns a0 as pointer to [:] or [EOL]
00001088  2A48                    2565      MOVEA.l a0,a5               * add index, now = pointer to [EOL]/[EOS]
0000108A  524D                    2566      ADDQ.w  #1,a5               * pointer to next character
0000108C  B03C 003A               2567      CMP.b       #':',d0         * was it statement end?
00001090  6712                    2568      BEQ.s       LAB_19F6            * branch if [:]
00001092                          2569  
00001092                          2570                              * was [EOL] so find next line
00001092                          2571  
00001092  320D                    2572      MOVE.w  a5,d1               * past pad byte(s)
00001094  C27C 0001               2573      AND.w       #1,d1               * mask odd bit
00001098  DAC1                    2574      ADD.w       d1,a5               * add pointer
0000109A  241D                    2575      MOVE.l  (a5)+,d2            * get next line pointer
0000109C  6700 F614               2576      BEQ     LAB_ODER            * branch if end of program
000010A0                          2577  
000010A0  275D 045E               2578      MOVE.l  (a5)+,Dlinel(a3)        * save current DATA line
000010A4                          2579  LAB_19F6
000010A4  6100 025A               2580      BSR     LAB_GBYT            * scan memory
000010A8  B03C 0083               2581      CMP.b       #TK_DATA,d0         * compare with "DATA" token
000010AC  6700 FF78               2582      BEQ     LAB_1985            * was "DATA" so go do next READ
000010B0                          2583  
000010B0  60D2                    2584      BRA.s       LAB_19DD            * go find next statement if not "DATA"
000010B2                          2585  
000010B2                          2586  * end of INPUT/READ routine
000010B2                          2587  
000010B2                          2588  LAB_1A03
000010B2  206B 0466               2589      MOVEA.l Rdptrl(a3),a0       * get temp READ pointer
000010B6  4A2B 05E0               2590      TST.b       Imode(a3)           * get input mode flag, $00=INPUT, $98=READ
000010BA  6A06                    2591      BPL.s       LAB_1A0E            * branch if INPUT
000010BC                          2592  
000010BC  2748 0462               2593      MOVE.l  a0,Dptrl(a3)        * else save temp READ pointer as DATA pointer
000010C0  4E75                    2594      RTS
000010C2                          2595  
000010C2                          2596                              * we were getting INPUT
000010C2                          2597  LAB_1A0E
000010C2  4A10                    2598      TST.b       (a0)                * test next byte
000010C4  6602                    2599      BNE.s       LAB_1A1B            * error if not end of INPUT
000010C6                          2600  
000010C6  4E75                    2601      RTS
000010C8                          2602                              * user typed too much
000010C8                          2603  LAB_1A1B
000010C8  41FA 2C14               2604      LEA     LAB_IMSG(pc),a0     * point to extra ignored message
000010CC  6000 FE66               2605      BRA     LAB_18C3            * print null terminated string from memory & RTS
000010D0                          2606  
000010D0                          2607  
000010D0                          2608  *************************************************************************************
000010D0                          2609  *
000010D0                          2610  * perform NEXT
000010D0                          2611  
000010D0                          2612  LAB_NEXT
000010D0  6610                    2613      BNE.s       LAB_1A46            * branch if NEXT var
000010D2                          2614  
000010D2  584F                    2615      ADDQ.w  #4,sp               * back past return address
000010D4  0C57 0081               2616      CMP.w       #TK_FOR,(sp)        * is FOR token on stack?
000010D8  6600 F5E4               2617      BNE     LAB_NFER            * if not do NEXT without FOR err/warm start
000010DC                          2618  
000010DC  206F 0002               2619      MOVEA.l 2(sp),a0            * get stacked FOR variable pointer
000010E0  601C                    2620      BRA.s       LAB_11BD            * branch always (no variable to search for)
000010E2                          2621  
000010E2                          2622  * NEXT var
000010E2                          2623  
000010E2                          2624  LAB_1A46
000010E2  6100 0432               2625      BSR     LAB_GVAR            * get variable address in a0
000010E6  584F                    2626      ADDQ.w  #4,sp               * back past return address
000010E8  303C 0081               2627      MOVE.w  #TK_FOR,d0          * set for FOR token
000010EC  721C                    2628      MOVEQ       #$1C,d1         * set for FOR use size
000010EE  6002                    2629      BRA.s       LAB_11A6            * enter loop for next variable search
000010F0                          2630  
000010F0                          2631  LAB_11A5
000010F0  DFC1                    2632      ADDA.l  d1,sp               * add FOR stack use size
000010F2                          2633  LAB_11A6
000010F2  B057                    2634      CMP.w       (sp),d0         * is FOR token on stack?
000010F4  6600 F5C8               2635      BNE     LAB_NFER            * if not found do NEXT without FOR error and
000010F8                          2636                              * warm start
000010F8                          2637  
000010F8                          2638                              * was FOR token
000010F8  B1EF 0002               2639      CMPA.l  2(sp),a0            * compare var pointer with stacked var pointer
000010FC  66F2                    2640      BNE.s       LAB_11A5            * loop if no match found
000010FE                          2641  
000010FE                          2642  LAB_11BD
000010FE  376F 0006 059C          2643      MOVE.w  6(sp),FAC2_e(a3)        * get STEP value exponent and sign
00001104  276F 0008 0598          2644      MOVE.l  8(sp),FAC2_m(a3)        * get STEP value mantissa
0000110A                          2645  
0000110A  176F 0012 05B5          2646      MOVE.b  18(sp),Dtypef(a3)       * restore FOR variable data type
00001110  6100 021C               2647      BSR     LAB_1C19            * check type and unpack (a0)
00001114                          2648  
00001114  176B 059D 059E          2649      MOVE.b  FAC2_s(a3),FAC_sc(a3)   * save FAC2 sign as sign compare
0000111A  102B 0595               2650      MOVE.b  FAC1_s(a3),d0       * get FAC1 sign
0000111E  B12B 059E               2651      EOR.b       d0,FAC_sc(a3)       * EOR to create sign compare
00001122                          2652  
00001122  2748 0472               2653      MOVE.l  a0,Lvarpl(a3)       * save variable pointer
00001126  6100 0EEE               2654      BSR     LAB_ADD         * add STEP value to FOR variable
0000112A  176F 0012 05B5          2655      MOVE.b  18(sp),Dtypef(a3)       * restore FOR variable data type (again)
00001130  6100 11E4               2656      BSR     LAB_PFAC            * pack FAC1 into FOR variable (Lvarpl)
00001134                          2657  
00001134  376F 000C 059C          2658      MOVE.w  12(sp),FAC2_e(a3)       * get TO value exponent and sign
0000113A  276F 000E 0598          2659      MOVE.l  14(sp),FAC2_m(a3)       * get TO value mantissa
00001140                          2660  
00001140  176B 059D 059E          2661      MOVE.b  FAC2_s(a3),FAC_sc(a3)   * save FAC2 sign as sign compare
00001146  102B 0595               2662      MOVE.b  FAC1_s(a3),d0       * get FAC1 sign
0000114A  B12B 059E               2663      EOR.b       d0,FAC_sc(a3)       * EOR to create sign compare
0000114E                          2664  
0000114E  6100 1270               2665      BSR     LAB_27FA            * compare FAC1 with FAC2 (TO value)
00001152                          2666                              * returns d0=+1 if FAC1 > FAC2
00001152                          2667                              * returns d0= 0 if FAC1 = FAC2
00001152                          2668                              * returns d0=-1 if FAC1 < FAC2
00001152                          2669  
00001152  322F 0006               2670      MOVE.w  6(sp),d1            * get STEP value exponent and sign
00001156  B141                    2671      EOR.w       d0,d1               * EOR compare result with STEP exponent and sign
00001158                          2672  
00001158  4A00                    2673      TST.b       d0              * test for =
0000115A  6704                    2674      BEQ.s       LAB_1A90            * branch if = (loop INcomplete)
0000115C                          2675  
0000115C  4A01                    2676      TST.b       d1              * test result
0000115E  6A0E                    2677      BPL.s       LAB_1A9B            * branch if > (loop complete)
00001160                          2678  
00001160                          2679                              * loop back and do it all again
00001160                          2680  LAB_1A90
00001160  276F 0014 0452          2681      MOVE.l  20(sp),Clinel(a3)       * reset current line
00001166  2A6F 0018               2682      MOVE.l  24(sp),a5           * reset BASIC execute pointer
0000116A  6000 F976               2683      BRA     LAB_15C2            * go do interpreter inner loop
0000116E                          2684  
0000116E                          2685                              * loop complete so carry on
0000116E                          2686  LAB_1A9B
0000116E  DEFC 001C               2687      ADDA.w  #28,sp          * add 28 to dump FOR structure
00001172  6100 018C               2688      BSR     LAB_GBYT            * scan memory
00001176  B03C 002C               2689      CMP.b       #$2C,d0         * compare with ","
0000117A  6600 F966               2690      BNE     LAB_15C2            * if not "," go do interpreter inner loop
0000117E                          2691  
0000117E                          2692                              * was "," so another NEXT variable to do
0000117E  6100 017E               2693      BSR     LAB_IGBY            * else increment & scan memory
00001182  6100 FF5E               2694      BSR     LAB_1A46            * do NEXT (var)
00001186                          2695  
00001186                          2696  
00001186                          2697  *************************************************************************************
00001186                          2698  *
00001186                          2699  * evaluate expression & check is numeric, else do type mismatch
00001186                          2700  
00001186                          2701  LAB_EVNM
00001186  6116                    2702      BSR.s       LAB_EVEX            * evaluate expression
00001188                          2703  
00001188                          2704  
00001188                          2705  *************************************************************************************
00001188                          2706  *
00001188                          2707  * check if source is numeric, else do type mismatch
00001188                          2708  
00001188                          2709  LAB_CTNM
00001188  B040                    2710      CMP.w       d0,d0               * required type is numeric so clear carry
0000118A                          2711  
0000118A                          2712  
0000118A                          2713  *************************************************************************************
0000118A                          2714  *
0000118A                          2715  * type match check, set C for string, clear C for numeric
0000118A                          2716  
0000118A                          2717  LAB_CKTM
0000118A  082B 0007 05B5          2718      BTST.b  #7,Dtypef(a3)       * test data type flag, don't change carry
00001190  6606                    2719      BNE.s       LAB_1ABA            * branch if data type is string
00001192                          2720  
00001192                          2721                              * else data type was numeric
00001192  6500 F4FA               2722      BCS     LAB_TMER            * if required type is string do type mismatch
00001196                          2723                              * error
00001196                          2724  
00001196  4E75                    2725      RTS
00001198                          2726                              * data type was string, now check required type
00001198                          2727  LAB_1ABA
00001198  6400 F4F4               2728      BCC     LAB_TMER            * if required type is numeric do type mismatch
0000119C                          2729                              * error
0000119C  4E75                    2730      RTS
0000119E                          2731  
0000119E                          2732  
0000119E                          2733  *************************************************************************************
0000119E                          2734  *
0000119E                          2735  * this routine evaluates any type of expression. first it pushes an end marker so
0000119E                          2736  * it knows when the expression has been evaluated, this is a precedence value of zero.
0000119E                          2737  * next the first value is evaluated, this can be an in line value, either numeric or
0000119E                          2738  * string, a variable or array element of any type, a function or even an expression
0000119E                          2739  * in parenthesis. this value is kept in FAC_1
0000119E                          2740  * after the value is evaluated a test is made on the next BASIC program byte, if it
0000119E                          2741  * is a comparrison operator i.e. "<", "=" or ">", then the corresponding bit is set
0000119E                          2742  * in the comparison evaluation flag. this test loops until no more comparrison operators
0000119E                          2743  * are found or more than one of any type is found. in the last case an error is generated
0000119E                          2744  
0000119E                          2745  * evaluate expression
0000119E                          2746  
0000119E                          2747  LAB_EVEX
0000119E  534D                    2748      SUBQ.w  #1,a5               * decrement BASIC execute pointer
000011A0                          2749  LAB_EVEZ
000011A0  7200                    2750      MOVEQ       #0,d1               * clear precedence word
000011A2  1741 05B5               2751      MOVE.b  d1,Dtypef(a3)       * clear the data type, $80=string, $40=integer,
000011A6                          2752                              * $00=float
000011A6  601C                    2753      BRA.s       LAB_1ACD            * enter loop
000011A8                          2754  
000011A8                          2755  * get vector, set up operator then continue evaluation
000011A8                          2756  
000011A8                          2757  LAB_1B43                        *
000011A8  41FA 2518               2758      LEA     LAB_OPPT(pc),a0     * point to operator vector table
000011AC  3030 1002               2759      MOVE.w  2(a0,d1.w),d0       * get vector offset
000011B0  4870 0000               2760      PEA     (a0,d0.w)           * push vector
000011B4                          2761  
000011B4  2F2B 0590               2762      MOVE.l  FAC1_m(a3),-(sp)        * push FAC1 mantissa
000011B8  3F2B 0594               2763      MOVE.w  FAC1_e(a3),-(sp)        * push sign and exponent
000011BC  1F2B 05E3               2764      MOVE.b  comp_f(a3),-(sp)        * push comparison evaluation flag
000011C0                          2765  
000011C0  3230 1000               2766      MOVE.w  (a0,d1.w),d1        * get precedence value
000011C4                          2767  LAB_1ACD
000011C4  3F01                    2768      MOVE.w  d1,-(sp)            * push precedence value
000011C6  6100 00E4               2769      BSR     LAB_GVAL            * get value from line
000011CA  177C 0000 05E3          2770      MOVE.b  #$00,comp_f(a3)     * clear compare function flag
000011D0                          2771  LAB_1ADB
000011D0  6100 012E               2772      BSR     LAB_GBYT            * scan memory
000011D4                          2773  LAB_1ADE
000011D4  0400 00C9               2774      SUB.b       #TK_GT,d0           * subtract token for > (lowest compare function)
000011D8  652A                    2775      BCS.s       LAB_1AFA            * branch if < TK_GT
000011DA                          2776  
000011DA  B03C 0003               2777      CMP.b       #$03,d0         * compare with ">" to "<" tokens
000011DE  650A                    2778      BCS.s       LAB_1AE0            * branch if <= TK_SGN (is compare function)
000011E0                          2779  
000011E0  4A2B 05E3               2780      TST.b       comp_f(a3)          * test compare function flag
000011E4  6660                    2781      BNE.s       LAB_1B2A            * branch if compare function
000011E6                          2782  
000011E6  6000 0086               2783      BRA     LAB_1B78            * go do functions
000011EA                          2784  
000011EA                          2785                              * was token for > = or < (d0 = 0, 1 or 2)
000011EA                          2786  LAB_1AE0
000011EA  7201                    2787      MOVEQ       #1,d1               * set to 0000 0001
000011EC  E121                    2788      ASL.b       d0,d1               * 1 if >, 2 if =, 4 if <
000011EE  102B 05E3               2789      MOVE.b  comp_f(a3),d0       * copy old compare function flag
000011F2  B32B 05E3               2790      EOR.b       d1,comp_f(a3)       * EOR in this compare function bit
000011F6  B02B 05E3               2791      CMP.b       comp_f(a3),d0       * compare old with new compare function flag
000011FA  6400 F4BE               2792      BCC     LAB_SNER            * if new <= old comp_f do syntax error and warm
000011FE                          2793                              * start, there was more than one <, = or >
000011FE  6100 00FE               2794      BSR     LAB_IGBY            * increment & scan memory
00001202  60D0                    2795      BRA.s       LAB_1ADE            * go do next character
00001204                          2796  
00001204                          2797                              * token is < ">" or > "<" tokens
00001204                          2798  LAB_1AFA
00001204  4A2B 05E3               2799      TST.b       comp_f(a3)          * test compare function flag
00001208  663C                    2800      BNE.s       LAB_1B2A            * branch if compare function
0000120A                          2801  
0000120A                          2802                              * was < TK_GT so is operator or lower
0000120A  0600 000A               2803      ADD.b   #(TK_GT-TK_PLUS),d0     * add # of operators (+ - * / ^ AND OR EOR)
0000120E  645E                    2804      BCC.s       LAB_1B78            * branch if < + operator
00001210                          2805  
00001210  6608                    2806      BNE.s       LAB_1B0B            * branch if not + token
00001212                          2807  
00001212  4A2B 05B5               2808      TST.b       Dtypef(a3)          * test data type, $80=string, $40=integer,
00001216                          2809                              * $00=float
00001216  6B00 0884               2810      BMI     LAB_224D            * type is string & token was +
0000121A                          2811  
0000121A                          2812  LAB_1B0B
0000121A  7200                    2813      MOVEQ       #0,d1               * clear longword
0000121C  D000                    2814      ADD.b       d0,d0               * *2
0000121E  D000                    2815      ADD.b       d0,d0               * *4
00001220  1200                    2816      MOVE.b  d0,d1               * copy to index
00001222                          2817  LAB_1B13
00001222  301F                    2818      MOVE.w  (sp)+,d0            * pull previous precedence
00001224  41FA 249C               2819      LEA     LAB_OPPT(pc),a0     * set pointer to operator table
00001228  B070 1000               2820      CMP.w       (a0,d1.w),d0        * compare with this opperator precedence
0000122C  6446                    2821      BCC.s       LAB_1B7D            * branch if previous precedence (d0) >=
0000122E                          2822  
0000122E  6100 FF58               2823      BSR     LAB_CTNM            * check if source is numeric, else type mismatch
00001232                          2824  LAB_1B1C
00001232  3F00                    2825      MOVE.w  d0,-(sp)            * save precedence
00001234                          2826  LAB_1B1D
00001234  6100 FF72               2827      BSR     LAB_1B43            * get vector, set-up operator and continue
00001238                          2828                              * evaluation
00001238  301F                    2829      MOVE.w  (sp)+,d0            * restore precedence
0000123A  222B 05D8               2830      MOVE.l  prstk(a3),d1        * get stacked function pointer
0000123E  6A22                    2831      BPL.s       LAB_1B3C            * branch if stacked values
00001240                          2832  
00001240  3000                    2833      MOVE.w  d0,d0               * copy precedence (set flags)
00001242  672E                    2834      BEQ.s       LAB_1B7B            * exit if done
00001244                          2835  
00001244  603C                    2836      BRA.s       LAB_1B86            * else pop FAC2 & return (do function)
00001246                          2837  
00001246                          2838                              * was compare function (< = >)
00001246                          2839  LAB_1B2A
00001246  102B 05B5               2840      MOVE.b  Dtypef(a3),d0       * get data type flag
0000124A  122B 05E3               2841      MOVE.b  comp_f(a3),d1       * get compare function flag
0000124E  D000                    2842      ADD.b       d0,d0               * string bit flag into X bit
00001250  D301                    2843      ADDX.b  d1,d1               * shift compare function flag
00001252                          2844  
00001252  177C 0000 05B5          2845      MOVE.b  #0,Dtypef(a3)       * clear data type flag, $00=float
00001258  1741 05E3               2846      MOVE.b  d1,comp_f(a3)       * save new compare function flag
0000125C  534D                    2847      SUBQ.w  #1,a5               * decrement BASIC execute pointer
0000125E  7230                    2848      MOVEQ       #(TK_LT-TK_PLUS)*4,d1   * set offset to last operator entry
00001260  60C0                    2849      BRA.s       LAB_1B13            * branch always
00001262                          2850  
00001262                          2851  LAB_1B3C
00001262  41FA 245E               2852      LEA     LAB_OPPT(pc),a0     * point to function vector table
00001266  B070 1000               2853      CMP.w       (a0,d1.w),d0        * compare with this opperator precedence
0000126A  6416                    2854      BCC.s       LAB_1B86            * branch if d0 >=, pop FAC2 & return
0000126C                          2855  
0000126C  60C4                    2856      BRA.s       LAB_1B1C            * branch always
0000126E                          2857  
0000126E                          2858  * do functions
0000126E                          2859  
0000126E                          2860  LAB_1B78
0000126E  72FF                    2861      MOVEQ       #-1,d1          * flag all done
00001270  301F                    2862      MOVE.w  (sp)+,d0            * pull precedence word
00001272                          2863  LAB_1B7B
00001272  6732                    2864      BEQ.s       LAB_1B9D            * exit if done
00001274                          2865  
00001274                          2866  LAB_1B7D
00001274  B07C 0064               2867      CMP.w       #$64,d0         * compare previous precedence with $64
00001278  6704                    2868      BEQ.s       LAB_1B84            * branch if was $64 (< function can be string)
0000127A                          2869  
0000127A  6100 FF0C               2870      BSR     LAB_CTNM            * check if source is numeric, else type mismatch
0000127E                          2871  LAB_1B84
0000127E  2741 05D8               2872      MOVE.l  d1,prstk(a3)        * save current operator index
00001282                          2873  
00001282                          2874                              * pop FAC2 & return
00001282                          2875  LAB_1B86
00001282  101F                    2876      MOVE.b  (sp)+,d0            * pop comparison evaluation flag
00001284  1200                    2877      MOVE.b  d0,d1               * copy comparison evaluation flag
00001286  E208                    2878      LSR.b       #1,d0               * shift out comparison evaluation lowest bit
00001288  1740 05E1               2879      MOVE.b  d0,Cflag(a3)        * save comparison evaluation flag
0000128C  375F 059C               2880      MOVE.w  (sp)+,FAC2_e(a3)        * pop exponent and sign
00001290  275F 0598               2881      MOVE.l  (sp)+,FAC2_m(a3)        * pop mantissa
00001294  176B 059D 059E          2882      MOVE.b  FAC2_s(a3),FAC_sc(a3)   * copy FAC2 sign
0000129A  102B 0595               2883      MOVE.b  FAC1_s(a3),d0       * get FAC1 sign
0000129E  B12B 059E               2884      EOR.b       d0,FAC_sc(a3)       * EOR FAC1 sign and set sign compare
000012A2                          2885  
000012A2  E209                    2886      LSR.b       #1,d1               * type bit into X and C
000012A4  4E75                    2887      RTS
000012A6                          2888  
000012A6                          2889  LAB_1B9D
000012A6  102B 0594               2890      MOVE.b  FAC1_e(a3),d0       * get FAC1 exponent
000012AA  4E75                    2891      RTS
000012AC                          2892  
000012AC                          2893  
000012AC                          2894  *************************************************************************************
000012AC                          2895  *
000012AC                          2896  * get a value from the BASIC line
000012AC                          2897  
000012AC                          2898  LAB_GVAL
000012AC  6150                    2899      BSR.s       LAB_IGBY            * increment & scan memory
000012AE  6500 1D78               2900      BCS     LAB_2887            * if numeric get FAC1 from string & return
000012B2                          2901  
000012B2  4A00                    2902      TST.b       d0              * test byte
000012B4  6B00 008E               2903      BMI     LAB_1BD0            * if -ve go test token values
000012B8                          2904  
000012B8                          2905                              * else it is either a string, number, variable
000012B8                          2906                              * or (<expr>)
000012B8  B03C 0024               2907      CMP.b       #'$',d0         * compare with "$"
000012BC  6700 1D6A               2908      BEQ     LAB_2887            * if "$" get hex number from string & return
000012C0                          2909  
000012C0  B03C 0025               2910      CMP.b       #'%',d0         * else compare with "%"
000012C4  6700 1D62               2911      BEQ     LAB_2887            * if "%" get binary number from string & return
000012C8                          2912  
000012C8  B03C 002E               2913      CMP.b       #$2E,d0         * compare with "."
000012CC  6700 1D5A               2914      BEQ     LAB_2887            * if so get FAC1 from string and return
000012D0                          2915                              * (e.g. .123)
000012D0                          2916  
000012D0                          2917                              * wasn't a number so ...
000012D0  B03C 0022               2918      CMP.b       #$22,d0         * compare with "
000012D4  660C                    2919      BNE.s       LAB_1BF3            * if not open quote then it must be a variable
000012D6                          2920                              * or an open bracket
000012D6                          2921  
000012D6                          2922                              * was open quote so get the enclosed string
000012D6                          2923  
000012D6                          2924  * print "..." string to string stack
000012D6                          2925  
000012D6                          2926  LAB_1BC1
000012D6  101D                    2927      MOVE.b  (a5)+,d0            * increment BASIC execute pointer (past ")
000012D8                          2928                              * fastest/shortest method
000012D8  204D                    2929      MOVEA.l a5,a0               * copy BASIC execute pointer (string start)
000012DA  6100 0640               2930      BSR     LAB_20AE            * print " terminated string to stack
000012DE  2A4A                    2931      MOVEA.l a2,a5               * restore BASIC execute pointer from temp
000012E0  4E75                    2932      RTS
000012E2                          2933  
000012E2                          2934  * get value from line .. continued
000012E2                          2935                              * wasn't any sort of number so ...
000012E2                          2936  LAB_1BF3
000012E2  B03C 0028               2937      CMP.b       #'(',d0         * compare with "("
000012E6  6642                    2938      BNE.s       LAB_1C18            * if not "(" get (var) and return value in FAC1
000012E8                          2939                              * and $ flag
000012E8                          2940  
000012E8                          2941  
000012E8                          2942  *************************************************************************************
000012E8                          2943  *
000012E8                          2944  * evaluate expression within parentheses
000012E8                          2945  
000012E8                          2946  LAB_1BF7
000012E8  6100 FEB6               2947      BSR     LAB_EVEZ            * evaluate expression (no decrement)
000012EC                          2948  
000012EC                          2949  
000012EC                          2950  *************************************************************************************
000012EC                          2951  *
000012EC                          2952  * all the 'scan for' routines return the character after the sought character
000012EC                          2953  
000012EC                          2954  * scan for ")", else do syntax error, then warm start
000012EC                          2955  
000012EC                          2956  LAB_1BFB
000012EC  7029                    2957      MOVEQ       #$29,d0         * load d0 with ")"
000012EE  6006                    2958      BRA.s       LAB_SCCA
000012F0                          2959  
000012F0                          2960  
000012F0                          2961  *************************************************************************************
000012F0                          2962  *
000012F0                          2963  * scan for "," and get byte, else do Syntax error then warm start
000012F0                          2964  
000012F0                          2965  LAB_SCGB
000012F0  487A 097E               2966      PEA     LAB_GTBY(pc)        * return address is to get byte parameter
000012F4                          2967  
000012F4                          2968  
000012F4                          2969  *************************************************************************************
000012F4                          2970  *
000012F4                          2971  * scan for ",", else do syntax error, then warm start
000012F4                          2972  
000012F4                          2973  LAB_1C01
000012F4  702C                    2974      MOVEQ       #$2C,d0         * load d0 with ","
000012F6                          2975  
000012F6                          2976  
000012F6                          2977  *************************************************************************************
000012F6                          2978  *
000012F6                          2979  * scan for CHR$(d0) , else do syntax error, then warm start
000012F6                          2980  
000012F6                          2981  LAB_SCCA
000012F6  B01D                    2982      CMP.b       (a5)+,d0            * check next byte is = d0
000012F8  6706                    2983      BEQ.s       LAB_GBYT            * if so go get next
000012FA                          2984  
000012FA  6000 F3BE               2985      BRA     LAB_SNER            * else do syntax error/warm start
000012FE                          2986  
000012FE                          2987  
000012FE                          2988  *************************************************************************************
000012FE                          2989  *
000012FE                          2990  * BASIC increment and scan memory routine
000012FE                          2991  
000012FE                          2992  LAB_IGBY
000012FE  101D                    2993      MOVE.b  (a5)+,d0            * get byte & increment pointer
00001300                          2994  
00001300                          2995  * scan memory routine, exit with Cb = 1 if numeric character
00001300                          2996  * also skips any spaces encountered
00001300                          2997  
00001300                          2998  LAB_GBYT
00001300  1015                    2999      MOVE.b  (a5),d0         * get byte
00001302                          3000  
00001302  B03C 0020               3001      CMP.b       #$20,d0         * compare with " "
00001306  67F6                    3002      BEQ.s       LAB_IGBY            * if " " go do next
00001308                          3003  
00001308                          3004  * test current BASIC byte, exit with Cb = 1 if numeric character
00001308                          3005  
00001308  B03C 00B6               3006      CMP.b       #TK_ELSE,d0         * compare with the token for ELSE
0000130C  640C                    3007      BCC.s       RTS_001         * exit if >= (not numeric, carry clear)
0000130E                          3008  
0000130E  B03C 003A               3009      CMP.b       #$3A,d0         * compare with ":"
00001312  6406                    3010      BCC.s       RTS_001         * exit if >= (not numeric, carry clear)
00001314                          3011  
00001314  7CD0                    3012      MOVEQ       #$D0,d6         * set -"0"
00001316  D006                    3013      ADD.b       d6,d0               * add -"0"
00001318  9006                    3014      SUB.b       d6,d0               * subtract -"0"
0000131A                          3015  RTS_001                     * carry set if byte = "0"-"9"
0000131A  4E75                    3016      RTS
0000131C                          3017  
0000131C                          3018  
0000131C                          3019  *************************************************************************************
0000131C                          3020  *
0000131C                          3021  * set-up for - operator
0000131C                          3022  
0000131C                          3023  LAB_1C11
0000131C  6100 FE6A               3024      BSR     LAB_CTNM            * check if source is numeric, else type mismatch
00001320  7228                    3025      MOVEQ   #(TK_GT-TK_PLUS)*4,d1       * set offset from base to - operator
00001322                          3026  LAB_1C13
00001322  4FEF 0004               3027      LEA     4(sp),sp            * dump GVAL return address
00001326  6000 FF0C               3028      BRA     LAB_1B1D            * continue evaluating expression
0000132A                          3029  
0000132A                          3030  
0000132A                          3031  *************************************************************************************
0000132A                          3032  *
0000132A                          3033  * variable name set-up
0000132A                          3034  * get (var), return value in FAC_1 & data type flag
0000132A                          3035  
0000132A                          3036  LAB_1C18
0000132A  6100 01EA               3037      BSR     LAB_GVAR            * get variable address in a0
0000132E                          3038  
0000132E                          3039  * if you want a non existant variable to return a null value then set the novar
0000132E                          3040  * value at the top of this file to some non zero value
0000132E                          3041  
0000132E                 FALSE    3042   ifne   novar
0000132E                          3043   endc
0000132E                          3044  
0000132E                          3045  * return existing variable value
0000132E                          3046  
0000132E                          3047  LAB_1C19
0000132E  4A2B 05B5               3048      TST.b       Dtypef(a3)          * test data type, $80=string, $40=integer,
00001332                          3049                              * $00=float
00001332  6700 0FC6               3050      BEQ     LAB_UFAC            * if float unpack memory (a0) into FAC1 and
00001336                          3051                              * return
00001336                          3052  
00001336  6A06                    3053      BPL.s       LAB_1C1A            * if integer unpack memory (a0) into FAC1
00001338                          3054                              * and return
00001338                          3055  
00001338  2748 0590               3056      MOVE.l  a0,FAC1_m(a3)       * else save descriptor pointer in FAC1
0000133C  4E75                    3057      RTS
0000133E                          3058  
0000133E                          3059  LAB_1C1A
0000133E  2010                    3060      MOVE.l  (a0),d0         * get integer value
00001340  6000 04C4               3061      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & return
00001344                          3062  
00001344                          3063  
00001344                          3064  *************************************************************************************
00001344                          3065  *
00001344                          3066  * get value from line .. continued
00001344                          3067  * do tokens
00001344                          3068  
00001344                          3069  LAB_1BD0
00001344  B03C 00C0               3070      CMP.b       #TK_MINUS,d0        * compare with token for -
00001348  67D2                    3071      BEQ.s       LAB_1C11            * branch if - token (do set-up for - operator)
0000134A                          3072  
0000134A                          3073                              * wasn't -123 so ...
0000134A  B03C 00BF               3074      CMP.b       #TK_PLUS,d0         * compare with token for +
0000134E  6700 FF5C               3075      BEQ     LAB_GVAL            * branch if + token (+n = n so ignore leading +)
00001352                          3076  
00001352  B03C 00BB               3077      CMP.b       #TK_NOT,d0          * compare with token for NOT
00001356  6606                    3078      BNE.s       LAB_1BE7            * branch if not token for NOT
00001358                          3079  
00001358                          3080                              * was NOT token
00001358  323C 002C               3081      MOVE.w  #(TK_EQUAL-TK_PLUS)*4,d1    * offset to NOT function
0000135C  60C4                    3082      BRA.s       LAB_1C13            * do set-up for function then execute
0000135E                          3083  
0000135E                          3084                              * wasn't +, - or NOT so ...
0000135E                          3085  LAB_1BE7
0000135E  B03C 00B8               3086      CMP.b       #TK_FN,d0           * compare with token for FN
00001362  6700 051C               3087      BEQ     LAB_201E            * if FN go evaluate FNx
00001366                          3088  
00001366  B03C 00A6               3089      CMP.b       #TK_POINT,d0        * compare with token for POINT
0000136A  6700 0AAC               3090      BEQ     LAB_FPOINT          * if POINT go evaluate POINT(x,y)
0000136E                          3091  
0000136E                          3092                              * wasn't +, -, NOT or FN so ...
0000136E  0400 00CC               3093      SUB.b       #TK_SGN,d0          * compare with token for SGN & normalise
00001372  6500 F346               3094      BCS     LAB_SNER            * if < SGN token then do syntax error
00001376                          3095  
00001376                          3096  * get value from line .. continued
00001376                          3097  * only functions left so set up function references
00001376                          3098  
00001376                          3099  * new for V2.0+ this replaces a lot of IF .. THEN .. ELSEIF .. THEN .. that was needed
00001376                          3100  * to process function calls. now the function vector is computed and pushed on the stack
00001376                          3101  * and the preprocess offset is read. if the preprocess offset is non zero then the vector
00001376                          3102  * is calculated and the routine called, if not this routine just does RTS. whichever
00001376                          3103  * happens the RTS at the end of this routine, or the preprocess routine calls, the
00001376                          3104  * function code
00001376                          3105  
00001376                          3106  * this also removes some less than elegant code that was used to bypass type checking
00001376                          3107  * for functions that returned strings
00001376                          3108  
00001376  C07C 007F               3109      AND.w       #$7F,d0         * mask byte
0000137A  D040                    3110      ADD.w       d0,d0               * *2 (2 bytes per function offset)
0000137C                          3111  
0000137C  41FA 22F4               3112      LEA     LAB_FTBL(pc),a0     * pointer to functions vector table
00001380  3230 0000               3113      MOVE.w  (a0,d0.w),d1        * get function vector offset
00001384  4870 1000               3114      PEA     (a0,d1.w)           * push function vector
00001388                          3115  
00001388  41FA 2298               3116      LEA     LAB_FTPP(pc),a0     * pointer to functions preprocess vector table
0000138C  3030 0000               3117      MOVE.w  (a0,d0.w),d0        * get function preprocess vector offset
00001390  6712                    3118      BEQ.s       LAB_1C2A            * no preprocess vector so go do function
00001392                          3119  
00001392  41F0 0000               3120      LEA     (a0,d0.w),a0        * get function preprocess vector
00001396  4ED0                    3121      JMP     (a0)                * go do preprocess routine then function
00001398                          3122  
00001398                          3123  
00001398                          3124  *************************************************************************************
00001398                          3125  *
00001398                          3126  * process string expression in parenthesis
00001398                          3127  
00001398                          3128  LAB_PPFS
00001398  6100 FF4E               3129      BSR     LAB_1BF7            * process expression in parenthesis
0000139C  4A2B 05B5               3130      TST.b       Dtypef(a3)          * test data type
000013A0  6A00 F2EC               3131      BPL     LAB_TMER            * if numeric do Type missmatch Error/warm start
000013A4                          3132  
000013A4                          3133  LAB_1C2A
000013A4  4E75                    3134      RTS                     * else do function
000013A6                          3135  
000013A6                          3136  
000013A6                          3137  *************************************************************************************
000013A6                          3138  *
000013A6                          3139  * process numeric expression in parenthesis
000013A6                          3140  
000013A6                          3141  LAB_PPFN
000013A6  6100 FF40               3142      BSR     LAB_1BF7            * process expression in parenthesis
000013AA  4A2B 05B5               3143      TST.b       Dtypef(a3)          * test data type
000013AE  6B00 F2DE               3144      BMI     LAB_TMER            * if string do Type missmatch Error/warm start
000013B2                          3145  
000013B2  4E75                    3146      RTS                     * else do function
000013B4                          3147  
000013B4                          3148  
000013B4                          3149  *************************************************************************************
000013B4                          3150  *
000013B4                          3151  * set numeric data type and increment BASIC execute pointer
000013B4                          3152  
000013B4                          3153  LAB_PPBI
000013B4  177C 0000 05B5          3154      MOVE.b  #$00,Dtypef(a3)     * clear data type flag, $00=float
000013BA  101D                    3155      MOVE.b  (a5)+,d0            * get next BASIC byte
000013BC  4E75                    3156      RTS                     * do function
000013BE                          3157  
000013BE                          3158  
000013BE                          3159  *************************************************************************************
000013BE                          3160  *
000013BE                          3161  * process string for LEFT$, RIGHT$ or MID$
000013BE                          3162  
000013BE                          3163  LAB_LRMS
000013BE  6100 FDE0               3164      BSR     LAB_EVEZ            * evaluate (should be string) expression
000013C2  4A2B 05B5               3165      TST.b       Dtypef(a3)          * test data type flag
000013C6  6A00 F2C6               3166      BPL     LAB_TMER            * if type is not string do type mismatch error
000013CA                          3167  
000013CA  141D                    3168      MOVE.b  (a5)+,d2            * get BASIC byte
000013CC  B43C 002C               3169      CMP.b       #',',d2         * compare with comma
000013D0  6600 F2E8               3170      BNE     LAB_SNER            * if not "," go do syntax Error/warm start
000013D4                          3171  
000013D4  2F2B 0590               3172      MOVE.l  FAC1_m(a3),-(sp)        * save descriptor pointer
000013D8  6100 08AA               3173      BSR     LAB_GTWO            * get word parameter, result in d0 and Itemp
000013DC  205F                    3174      MOVEA.l (sp)+,a0            * restore descriptor pointer
000013DE  4E75                    3175      RTS                     * do function
000013E0                          3176  
000013E0                          3177  
000013E0                          3178  *************************************************************************************
000013E0                          3179  *
000013E0                          3180  * process numeric expression(s) for BIN$ or HEX$
000013E0                          3181  
000013E0                          3182  LAB_BHSS
000013E0  6100 FDBE               3183      BSR     LAB_EVEZ            * evaluate expression (no decrement)
000013E4  4A2B 05B5               3184      TST.b       Dtypef(a3)          * test data type
000013E8  6B00 F2A4               3185      BMI     LAB_TMER            * if string do Type missmatch Error/warm start
000013EC                          3186  
000013EC  6100 0FFE               3187      BSR     LAB_2831            * convert FAC1 floating to fixed
000013F0                          3188                              * result in d0 and Itemp
000013F0  7200                    3189      MOVEQ       #0,d1               * set default to no leading "0"s
000013F2  141D                    3190      MOVE.b  (a5)+,d2            * get BASIC byte
000013F4  B43C 002C               3191      CMP.b       #',',d2         * compare with comma
000013F8  660C                    3192      BNE.s       LAB_BHCB            * if not "," go check close bracket
000013FA                          3193  
000013FA  2F00                    3194      MOVE.l  d0,-(sp)            * copy number to stack
000013FC  6100 0872               3195      BSR     LAB_GTBY            * get byte value
00001400  2200                    3196      MOVE.l  d0,d1               * copy leading 0s #
00001402  201F                    3197      MOVE.l  (sp)+,d0            * restore number from stack
00001404  141D                    3198      MOVE.b  (a5)+,d2            * get BASIC byte
00001406                          3199  LAB_BHCB
00001406  B43C 0029               3200      CMP.b       #')',d2         * compare with close bracket
0000140A  6600 F2AE               3201      BNE     LAB_SNER            * if not ")" do Syntax Error/warm start
0000140E                          3202  
0000140E  4E75                    3203      RTS                     * go do function
00001410                          3204  
00001410                          3205  
00001410                          3206  *************************************************************************************
00001410                          3207  *
00001410                          3208  * perform EOR
00001410                          3209  
00001410                          3210  LAB_EOR
00001410  6116                    3211      BSR.s       GetFirst            * get two values for OR, AND or EOR
00001412                          3212                              * first in d0, and Itemp, second in d2
00001412  B580                    3213      EOR.l       d2,d0               * EOR values
00001414  6000 03F0               3214      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & RET
00001418                          3215  
00001418                          3216  
00001418                          3217  *************************************************************************************
00001418                          3218  *
00001418                          3219  * perform OR
00001418                          3220  
00001418                          3221  LAB_OR
00001418  610E                    3222      BSR.s       GetFirst            * get two values for OR, AND or EOR
0000141A                          3223                              * first in d0, and Itemp, second in d2
0000141A  8082                    3224      OR.l        d2,d0               * do OR
0000141C  6000 03E8               3225      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & RET
00001420                          3226  
00001420                          3227  
00001420                          3228  *************************************************************************************
00001420                          3229  *
00001420                          3230  * perform AND
00001420                          3231  
00001420                          3232  LAB_AND
00001420  6106                    3233      BSR.s       GetFirst            * get two values for OR, AND or EOR
00001422                          3234                              * first in d0, and Itemp, second in d2
00001422  C082                    3235      AND.l       d2,d0               * do AND
00001424  6000 03E0               3236      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & RET
00001428                          3237  
00001428                          3238  
00001428                          3239  *************************************************************************************
00001428                          3240  *
00001428                          3241  * get two values for OR, AND, EOR
00001428                          3242  * first in d0, second in d2
00001428                          3243  
00001428                          3244  GetFirst
00001428  6100 0228               3245      BSR     LAB_EVIR            * evaluate integer expression (no sign check)
0000142C                          3246                              * result in d0 and Itemp
0000142C  2400                    3247      MOVE.l  d0,d2               * copy second value
0000142E  6100 0F24               3248      BSR     LAB_279B            * copy FAC2 to FAC1, get first value in
00001432                          3249                              * expression
00001432  6000 021E               3250      BRA     LAB_EVIR            * evaluate integer expression (no sign check)
00001436                          3251                              * result in d0 and Itemp & return
00001436                          3252  
00001436                          3253  
00001436                          3254  *************************************************************************************
00001436                          3255  *
00001436                          3256  * perform NOT
00001436                          3257  
00001436                          3258  LAB_EQUAL
00001436  6100 021A               3259      BSR     LAB_EVIR            * evaluate integer expression (no sign check)
0000143A                          3260                              * result in d0 and Itemp
0000143A  4680                    3261      NOT.l       d0              * bitwise invert
0000143C  6000 03C8               3262      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & RET
00001440                          3263  
00001440                          3264  
00001440                          3265  *************************************************************************************
00001440                          3266  *
00001440                          3267  * perform comparisons
00001440                          3268  * do < compare
00001440                          3269  
00001440                          3270  LAB_LTHAN
00001440  6100 FD48               3271      BSR     LAB_CKTM            * type match check, set C for string
00001444  6506                    3272      BCS.s       LAB_1CAE            * branch if string
00001446                          3273  
00001446                          3274                              * do numeric < compare
00001446  6100 0F78               3275      BSR     LAB_27FA            * compare FAC1 with FAC2
0000144A                          3276                              * returns d0=+1 if FAC1 > FAC2
0000144A                          3277                              * returns d0= 0 if FAC1 = FAC2
0000144A                          3278                              * returns d0=-1 if FAC1 < FAC2
0000144A  6042                    3279      BRA.s       LAB_1CF2            * process result
0000144C                          3280  
0000144C                          3281                              * do string < compare
0000144C                          3282  LAB_1CAE
0000144C  177C 0000 05B5          3283      MOVE.b  #$00,Dtypef(a3)     * clear data type, $80=string, $40=integer,
00001452                          3284                              * $00=float
00001452  6100 06BC               3285      BSR     LAB_22B6            * pop string off descriptor stack, or from top
00001456                          3286                              * of string space returns d0 = length,
00001456                          3287                              * a0 = pointer
00001456  2248                    3288      MOVEA.l a0,a1               * copy string 2 pointer
00001458  2200                    3289      MOVE.l  d0,d1               * copy string 2 length
0000145A  206B 0598               3290      MOVEA.l FAC2_m(a3),a0       * get string 1 descriptor pointer
0000145E  6100 06B4               3291      BSR     LAB_22BA            * pop (a0) descriptor, returns with ..
00001462                          3292                              * d0 = length, a0 = pointer
00001462  2400                    3293      MOVE.l  d0,d2               * copy length
00001464  6604                    3294      BNE.s       LAB_1CB5            * branch if not null string
00001466                          3295  
00001466  4A81                    3296      TST.l       d1              * test if string 2 is null also
00001468  6724                    3297      BEQ.s       LAB_1CF2            * if so do string 1 = string 2
0000146A                          3298  
0000146A                          3299  LAB_1CB5
0000146A  9481                    3300      SUB.l       d1,d2               * subtract string 2 length
0000146C  670C                    3301      BEQ.s       LAB_1CD5            * branch if strings = length
0000146E                          3302  
0000146E  6504                    3303      BCS.s       LAB_1CD4            * branch if string 1 < string 2
00001470                          3304  
00001470  70FF                    3305      MOVEQ       #-1,d0          * set for string 1 > string 2
00001472  6008                    3306      BRA.s       LAB_1CD6            * go do character comapare
00001474                          3307  
00001474                          3308  LAB_1CD4
00001474  2200                    3309      MOVE.l  d0,d1               * string 1 length is compare length
00001476  7001                    3310      MOVEQ       #1,d0               * and set for string 1 < string 2
00001478  6002                    3311      BRA.s       LAB_1CD6            * go do character comapare
0000147A                          3312  
0000147A                          3313  LAB_1CD5
0000147A  2002                    3314      MOVE.l  d2,d0               * set for string 1 = string 2
0000147C                          3315  LAB_1CD6
0000147C  5381                    3316      SUBQ.l  #1,d1               * adjust length for DBcc loop
0000147E                          3317  
0000147E                          3318                              * d1 is length to compare, d0 is <=> for length
0000147E                          3319                              * a0 is string 1 pointer, a1 is string 2 pointer
0000147E                          3320  LAB_1CE6
0000147E  B308                    3321      CMPM.b  (a0)+,(a1)+         * compare string bytes (1 with 2)
00001480  56C9 FFFC               3322      DBNE        d1,LAB_1CE6         * loop if same and not end yet
00001484                          3323  
00001484  6708                    3324      BEQ.s       LAB_1CF2            * if = to here, then go use length compare
00001486                          3325  
00001486  6404                    3326      BCC.s       LAB_1CDB            * else branch if string 1 > string 2
00001488                          3327  
00001488  70FF                    3328      MOVEQ       #-1,d0          * else set for string 1 < string 2
0000148A  6002                    3329      BRA.s       LAB_1CF2            * go set result
0000148C                          3330  
0000148C                          3331  LAB_1CDB
0000148C  7001                    3332      MOVEQ       #1,d0               * and set for string 1 > string 2
0000148E                          3333  
0000148E                          3334  LAB_1CF2
0000148E  5200                    3335      ADDQ.b  #1,d0               * make result 0, 1 or 2
00001490  1200                    3336      MOVE.b  d0,d1               * copy to d1
00001492  7001                    3337      MOVEQ       #1,d0               * set d0 longword
00001494  E338                    3338      ROL.b       d1,d0               * make 1, 2 or 4 (result = flag bit)
00001496  C02B 05E1               3339      AND.b       Cflag(a3),d0        * AND with comparison evaluation flag
0000149A  6700 0F0C               3340      BEQ     LAB_27DB            * exit if not a wanted result (i.e. false)
0000149E                          3341  
0000149E  70FF                    3342      MOVEQ       #-1,d0          * else set -1 (true)
000014A0  6000 0F06               3343      BRA     LAB_27DB            * save d0 as integer & return
000014A4                          3344  
000014A4                          3345  
000014A4                          3346  LAB_1CFE
000014A4  6100 FE4E               3347      BSR     LAB_1C01            * scan for ",", else do syntax error/warm start
000014A8                          3348  
000014A8                          3349  
000014A8                          3350  *************************************************************************************
000014A8                          3351  *
000014A8                          3352  * perform DIM
000014A8                          3353  
000014A8                          3354  LAB_DIM
000014A8  72FF                    3355      MOVEQ       #-1,d1          * set "DIM" flag
000014AA  6170                    3356      BSR.s       LAB_1D10            * search for variable
000014AC  6100 FE52               3357      BSR     LAB_GBYT            * scan memory
000014B0  66F2                    3358      BNE.s       LAB_1CFE            * loop and scan for "," if not null
000014B2                          3359  
000014B2  4E75                    3360      RTS
000014B4                          3361  
000014B4                          3362  
000014B4                          3363  *************************************************************************************
000014B4                          3364  *
000014B4                          3365  * perform << (left shift)
000014B4                          3366  
000014B4                          3367  LAB_LSHIFT
000014B4  612E                    3368      BSR.s       GetPair         * get an integer and byte pair
000014B6                          3369                              * byte is in d2, integer is in d0 and Itemp
000014B6  6708                    3370      BEQ.s       NoShift         * branch if byte zero
000014B8                          3371  
000014B8  B43C 0020               3372      CMP.b       #$20,d2         * compare bit count with 32d
000014BC  6420                    3373      BCC.s       TooBig          * branch if >=
000014BE                          3374  
000014BE  E5A0                    3375      ASL.l       d2,d0               * shift longword
000014C0                          3376  NoShift
000014C0  6000 0344               3377      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & RET
000014C4                          3378  
000014C4                          3379  
000014C4                          3380  *************************************************************************************
000014C4                          3381  *
000014C4                          3382  * perform >> (right shift)
000014C4                          3383  
000014C4                          3384  LAB_RSHIFT
000014C4  611E                    3385      BSR.s       GetPair         * get an integer and byte pair
000014C6                          3386                              * byte is in d2, integer is in d0 and Itemp
000014C6  67F8                    3387      BEQ.s       NoShift         * branch if byte zero
000014C8                          3388  
000014C8  B43C 0020               3389      CMP.b       #$20,d2         * compare bit count with 32d
000014CC  650A                    3390      BCS.s       Not2Big         * branch if >= (return shift)
000014CE                          3391  
000014CE  4A80                    3392      TST.l       d0              * test sign bit
000014D0  6A0C                    3393      BPL.s       TooBig          * branch if +ve
000014D2                          3394  
000014D2  70FF                    3395      MOVEQ       #-1,d0          * set longword
000014D4  6000 0330               3396      BRA     LAB_AYFC            * convert d0 to longword in FAC1 & RET
000014D8                          3397  
000014D8                          3398  Not2Big
000014D8  E4A0                    3399      ASR.l       d2,d0               * shift longword
000014DA  6000 032A               3400      BRA     LAB_AYFC            * convert d0 to longword in FAC1 & RET
000014DE                          3401  
000014DE                          3402  TooBig
000014DE  7000                    3403      MOVEQ       #0,d0               * clear longword
000014E0  6000 0324               3404      BRA     LAB_AYFC            * convert d0 to longword in FAC1 & RET
000014E4                          3405  
000014E4                          3406  
000014E4                          3407  *************************************************************************************
000014E4                          3408  *
000014E4                          3409  * get an integer and byte pair
000014E4                          3410  * byte is in d2, integer is in d0 and Itemp
000014E4                          3411  
000014E4                          3412  GetPair
000014E4  6100 078E               3413      BSR     LAB_EVBY            * evaluate byte expression, result in d0 and
000014E8                          3414                              * Itemp
000014E8  1400                    3415      MOVE.b  d0,d2               * save it
000014EA  6100 0E68               3416      BSR     LAB_279B            * copy FAC2 to FAC1, get first value in
000014EE                          3417                              * expression
000014EE  6100 0162               3418      BSR     LAB_EVIR            * evaluate integer expression (no sign check)
000014F2                          3419                              * result in d0 and Itemp
000014F2  4A02                    3420      TST.b       d2              * test byte value
000014F4  4E75                    3421      RTS
000014F6                          3422  
000014F6                          3423  
000014F6                          3424  *************************************************************************************
000014F6                          3425  *
000014F6                          3426  * check alpha, return C=0 if<"A" or >"Z" or <"a" to "z">
000014F6                          3427  
000014F6                          3428  LAB_CASC
000014F6  B03C 0061               3429      CMP.b       #$61,d0         * compare with "a"
000014FA  6410                    3430      BCC.s       LAB_1D83            * if >="a" go check =<"z"
000014FC                          3431  
000014FC                          3432  
000014FC                          3433  *************************************************************************************
000014FC                          3434  *
000014FC                          3435  * check alpha upper case, return C=0 if<"A" or >"Z"
000014FC                          3436  
000014FC                          3437  LAB_CAUC
000014FC  B03C 0041               3438      CMP.b       #$41,d0         * compare with "A"
00001500  6404                    3439      BCC.s       LAB_1D8A            * if >="A" go check =<"Z"
00001502                          3440  
00001502  8040                    3441      OR      d0,d0               * make C=0
00001504  4E75                    3442      RTS
00001506                          3443  
00001506                          3444  LAB_1D8A
00001506  B03C 005B               3445      CMP.b       #$5B,d0         * compare with "Z"+1
0000150A                          3446                              * carry set if byte<="Z"
0000150A  4E75                    3447      RTS
0000150C                          3448  
0000150C                          3449  LAB_1D83
0000150C  B03C 007B               3450      CMP.b       #$7B,d0         * compare with "z"+1
00001510                          3451                              * carry set if byte<="z"
00001510  4E75                    3452      RTS
00001512                          3453  
00001512                          3454  
00001512                          3455  *************************************************************************************
00001512                          3456  *
00001512                          3457  * search for or create variable. this is used to automatically create a variable if
00001512                          3458  * it is not found. any routines that need to create the variable call LAB_GVAR via
00001512                          3459  * this point and error generation is supressed and the variable will be created
00001512                          3460  *
00001512                          3461  * return pointer to variable in Cvaral and a0
00001512                          3462  * set data type to variable type
00001512                          3463  
00001512                          3464  LAB_SVAR
00001512  6102                    3465      BSR.s       LAB_GVAR            * search for variable
00001514                          3466  LAB_FVAR
00001514  4E75                    3467      RTS
00001516                          3468  
00001516                          3469  
00001516                          3470  *************************************************************************************
00001516                          3471  *
00001516                          3472  * search for variable. if this routine is called from anywhere but the above call and
00001516                          3473  * the variable searched for does not exist then an error will be returned
00001516                          3474  *
00001516                          3475  * DIM flag is in d1.b
00001516                          3476  * return pointer to variable in Cvaral and a0
00001516                          3477  * set data type to variable type
00001516                          3478  
00001516                          3479  LAB_GVAR
00001516  7200                    3480      MOVEQ       #$00,d1         * set DIM flag = $00
00001518  6100 FDE6               3481      BSR     LAB_GBYT            * scan memory (1st character)
0000151C                          3482  LAB_1D10
0000151C  1741 05B4               3483      MOVE.b  d1,Defdim(a3)       * save DIM flag
00001520                          3484  
00001520                          3485  * search for FN name entry point
00001520                          3486  
00001520                          3487  LAB_1D12
00001520  61D4                    3488      BSR.s       LAB_CASC            * check byte, return C=0 if<"A" or >"Z"
00001522  6400 F196               3489      BCC     LAB_SNER            * if not syntax error, then warm start
00001526                          3490  
00001526                          3491                              * is variable name so ...
00001526  7200                    3492      MOVEQ       #$0,d1          * set index for name byte
00001528  41EB 046A               3493      LEA     Varname(a3),a0      * pointer to variable name
0000152C  2081                    3494      MOVE.l  d1,(a0)         * clear variable name
0000152E  1741 05B5               3495      MOVE.b  d1,Dtypef(a3)       * clear data type, $80=string, $40=integer,
00001532                          3496                              * $00=float
00001532                          3497  
00001532                          3498  LAB_1D2D
00001532  B27C 0004               3499      CMP.w       #$04,d1         * done all significant characters?
00001536  6406                    3500      BCC.s       LAB_1D2E            * if so go ignore any more
00001538                          3501  
00001538  1180 1000               3502      MOVE.b  d0,(a0,d1.w)        * save character
0000153C  5241                    3503      ADDQ.w  #1,d1               * increment index
0000153E                          3504  LAB_1D2E
0000153E  6100 FDBE               3505      BSR     LAB_IGBY            * increment & scan memory (next character)
00001542  65EE                    3506      BCS.s       LAB_1D2D            * branch if character = "0"-"9" (ok)
00001544                          3507  
00001544                          3508                              * character wasn't "0" to "9" so ...
00001544  61B0                    3509      BSR.s       LAB_CASC            * check byte, return C=0 if<"A" or >"Z"
00001546  65EA                    3510      BCS.s       LAB_1D2D            * branch if = "A"-"Z" (ok)
00001548                          3511  
00001548                          3512                              * check if string variable
00001548  B03C 0024               3513      CMP.b       #'$',d0         * compare with "$"
0000154C  660C                    3514      BNE.s       LAB_1D44            * branch if not string
0000154E                          3515  
0000154E                          3516                              * type is string
0000154E  002B 0080 046B          3517      OR.b        #$80,Varname+1(a3)  * set top bit of 2nd character, indicate string
00001554  6100 FDA8               3518      BSR     LAB_IGBY            * increment & scan memory
00001558  6010                    3519      BRA.s       LAB_1D45            * skip integer check
0000155A                          3520  
0000155A                          3521                              * check if integer variable
0000155A                          3522  LAB_1D44
0000155A  B03C 0026               3523      CMP.b       #'&',d0         * compare with "&"
0000155E  660A                    3524      BNE.s       LAB_1D45            * branch if not integer
00001560                          3525  
00001560                          3526                              * type is integer
00001560  002B 0080 046C          3527      OR.b        #$80,Varname+2(a3)  * set top bit of 3rd character, indicate integer
00001566  6100 FD96               3528      BSR     LAB_IGBY            * increment & scan memory
0000156A                          3529  
0000156A                          3530  * after we have determined the variable type we need to determine
0000156A                          3531  * if it's an array of type
0000156A                          3532  
0000156A                          3533                              * gets here with character after var name in d0
0000156A                          3534  LAB_1D45
0000156A  4A2B 05DF               3535      TST.b       Sufnxf(a3)          * test function name flag
0000156E  670E                    3536      BEQ.s       LAB_1D48            * branch if not FN or FN variable
00001570                          3537  
00001570  6A14                    3538      BPL.s       LAB_1D49            * branch if FN variable
00001572                          3539  
00001572                          3540                              * else was FN name
00001572  202B 046A               3541      MOVE.l  Varname(a3),d0      * get whole function name
00001576  7208                    3542      MOVEQ       #8,d1               * set step to next function size -4
00001578  41EB 0432               3543      LEA     Sfncl(a3),a0        * get pointer to start of functions
0000157C  601C                    3544      BRA.s       LAB_1D4B            * go find function
0000157E                          3545  
0000157E                          3546  LAB_1D48
0000157E  0400 0028               3547      SUB.b       #'(',d0         * subtract "("
00001582  6700 00F4               3548      BEQ     LAB_1E17            * if "(" go find, or make, array
00001586                          3549  
00001586                          3550  * either find or create var
00001586                          3551  * var name (1st four characters only!) is in Varname
00001586                          3552  
00001586                          3553                              * variable name wasn't var( .. so look for
00001586                          3554                              * plain variable
00001586                          3555  LAB_1D49
00001586  202B 046A               3556      MOVE.l  Varname(a3),d0      * get whole variable name
0000158A                          3557  LAB_1D4A
0000158A  7204                    3558      MOVEQ       #4,d1               * set step to next variable size -4
0000158C  41EB 0436               3559      LEA     Svarl(a3),a0        * get pointer to start of variables
00001590                          3560  
00001590  0800 0017               3561      BTST.l  #23,d0          * test if string name
00001594  6704                    3562      BEQ.s       LAB_1D4B            * branch if not
00001596                          3563  
00001596  5441                    3564      ADDQ.w  #2,d1               * 6 bytes per string entry
00001598  5848                    3565      ADDQ.w  #(Sstrl-Svarl),a0       * move to string area
0000159A                          3566  
0000159A                          3567  LAB_1D4B
0000159A  2268 0004               3568      MOVEA.l 4(a0),a1            * get end address
0000159E  2050                    3569      MOVEA.l (a0),a0         * get start address
000015A0  6006                    3570      BRA.s       LAB_1D5E            * enter loop at exit check
000015A2                          3571  
000015A2                          3572  LAB_1D5D
000015A2  B098                    3573      CMP.l       (a0)+,d0            * compare this variable with name
000015A4  6776                    3574      BEQ.s       LAB_1DD7            * branch if match (found var)
000015A6                          3575  
000015A6  D1C1                    3576      ADDA.l  d1,a0               * add offset to next variable
000015A8                          3577  LAB_1D5E
000015A8  B1C9                    3578      CMPA.l  a1,a0               * compare address with variable space end
000015AA  66F6                    3579      BNE.s       LAB_1D5D            * if not end go check next
000015AC                          3580  
000015AC  4A2B 05DF               3581      TST.b       Sufnxf(a3)          * is it a function or function variable
000015B0  660A                    3582      BNE.s       LAB_1D94            * if was go do DEF or function variable
000015B2                          3583  
000015B2                          3584                              * reached end of variable mem without match
000015B2                          3585                              * ... so create new variable, possibly
000015B2                          3586  
000015B2  45FA FF60               3587      LEA     LAB_FVAR(pc),a2     * get the address of the create if doesn't
000015B6                          3588                              * exist call to LAB_GVAR
000015B6  B5D7                    3589      CMPA.l  (sp),a2         * compare the return address with expected
000015B8  6600 F0BC               3590      BNE     LAB_UVER            * if not create go do error or return null
000015BC                          3591  
000015BC                          3592  * this will only branch if the call to LAB_GVAR wasn't from LAB_SVAR
000015BC                          3593  
000015BC                          3594  LAB_1D94
000015BC  082B 0000 05DF          3595      BTST.b  #0,Sufnxf(a3)       * test function search flag
000015C2  6600 F0BA               3596      BNE     LAB_UFER            * if not doing DEF then go do undefined
000015C6                          3597                              * function error
000015C6                          3598  
000015C6                          3599                              * else create new variable/function
000015C6                          3600  LAB_1D98
000015C6  246B 0442               3601      MOVEA.l Earryl(a3),a2       * get end of block to move
000015CA  240A                    3602      MOVE.l  a2,d2               * copy end of block to move
000015CC  9489                    3603      SUB.l       a1,d2               * calculate block to move size
000015CE                          3604  
000015CE  204A                    3605      MOVEA.l a2,a0               * copy end of block to move
000015D0  5881                    3606      ADDQ.l  #4,d1               * space for one variable/function + name
000015D2  D5C1                    3607      ADDA.l  d1,a2               * add space for one variable/function
000015D4  274A 0442               3608      MOVE.l  a2,Earryl(a3)       * set new array mem end
000015D8  E28A                    3609      LSR.l       #1,d2               * /2 for word copy
000015DA  6712                    3610      BEQ.s       LAB_1DAF            * skip move if zero length block
000015DC                          3611  
000015DC  5382                    3612      SUBQ.l  #1,d2               * -1 for DFB loop
000015DE  4842                    3613      SWAP        d2              * swap high word to low word
000015E0                          3614  LAB_1DAC
000015E0  4842                    3615      SWAP        d2              * swap high word to low word
000015E2                          3616  LAB_1DAE
000015E2  3520                    3617      MOVE.w  -(a0),-(a2)         * copy word
000015E4  51CA FFFC               3618      DBF     d2,LAB_1DAE         * loop until done
000015E8                          3619  
000015E8  4842                    3620      SWAP        d2              * swap high word to low word
000015EA  51CA FFF4               3621      DBF     d2,LAB_1DAC         * decrement high count and loop until done
000015EE                          3622  
000015EE                          3623  * get here after creating either a function, variable or string
000015EE                          3624  * if function set variables start, string start, array start
000015EE                          3625  * if variable set string start, array start
000015EE                          3626  * if string set array start
000015EE                          3627  
000015EE                          3628  LAB_1DAF
000015EE  4A2B 05DF               3629      TST.b       Sufnxf(a3)          * was it function
000015F2  6B08                    3630      BMI.s       LAB_1DB0            * branch if was FN
000015F4                          3631  
000015F4  0800 0017               3632      BTST.l  #23,d0          * was it string
000015F8  660A                    3633      BNE.s       LAB_1DB2            * branch if string
000015FA                          3634  
000015FA  6004                    3635      BRA.s       LAB_1DB1            * branch if was plain variable
000015FC                          3636  
000015FC                          3637  LAB_1DB0
000015FC  D3AB 0436               3638      ADD.l       d1,Svarl(a3)        * set new variable memory start
00001600                          3639  LAB_1DB1
00001600  D3AB 043A               3640      ADD.l       d1,Sstrl(a3)        * set new start of strings
00001604                          3641  LAB_1DB2
00001604  D3AB 043E               3642      ADD.l       d1,Sarryl(a3)       * set new array memory start
00001608  20C0                    3643      MOVE.l  d0,(a0)+            * save variable/function name
0000160A  20BC 00000000           3644      MOVE.l  #$00,(a0)           * initialise variable
00001610  0800 0017               3645      BTST.l  #23,d0          * was it string
00001614  6706                    3646      BEQ.s       LAB_1DD7            * branch if not string
00001616                          3647  
00001616  317C 0000 0004          3648      MOVE.w  #$00,4(a0)          * else initialise string length
0000161C                          3649  
0000161C                          3650                              * found a match for var ((Vrschl) = ptr)
0000161C                          3651                              * found a match for var ((Vrschl) = ptr)
0000161C                          3652  LAB_1DD7
0000161C  2200                    3653      MOVE.l  d0,d1               * ........ $....... &....... ........
0000161E  D281                    3654      ADD.l       d1,d1               * .......$ .......& ........ .......0
00001620  4841                    3655      SWAP        d1              * ........ .......0 .......$ .......&
00001622  E219                    3656      ROR.b       #1,d1               * ........ .......0 .......$ &.......
00001624  E249                    3657      LSR.w       #1,d1               * ........ .......0 0....... $&......
00001626  C23C 00C0               3658      AND.b       #$C0,d1         * mask the type bits
0000162A  1741 05B5               3659      MOVE.b  d1,Dtypef(a3)       * save the data type
0000162E                          3660  
0000162E  177C 0000 05DF          3661      MOVE.b  #$00,Sufnxf(a3)     * clear FN flag byte
00001634                          3662  
00001634                          3663  * if you want a non existant variable to return a null value then set the novar
00001634                          3664  * value at the top of this file to some non zero value
00001634                          3665  
00001634                 FALSE    3666   ifne   novar
00001634                          3667   endc
00001634                          3668  
00001634  4E75                    3669      RTS
00001636                          3670  
00001636                          3671  
00001636                          3672  *************************************************************************************
00001636                          3673  *
00001636                          3674  * set-up array pointer, d0, to first element in array
00001636                          3675  * set d0 to (a0)+2*(Dimcnt)+$0A
00001636                          3676  
00001636                          3677  LAB_1DE6
00001636  7005                    3678      MOVEQ       #5,d0               * set d0 to 5 (*2 = 10, later)
00001638  D02B 05DB               3679      ADD.b       Dimcnt(a3),d0       * add # of dimensions (1, 2 or 3)
0000163C  D080                    3680      ADD.l       d0,d0               * *2 (bytes per dimension size)
0000163E  D088                    3681      ADD.l       a0,d0               * add array start pointer
00001640  4E75                    3682      RTS
00001642                          3683  
00001642                          3684  
00001642                          3685  *************************************************************************************
00001642                          3686  *
00001642                          3687  * evaluate unsigned integer expression
00001642                          3688  
00001642                          3689  LAB_EVIN
00001642  6100 FCBA               3690      BSR     LAB_IGBY            * increment & scan memory
00001646  6100 FB3E               3691      BSR     LAB_EVNM            * evaluate expression & check is numeric,
0000164A                          3692                              * else do type mismatch
0000164A                          3693  
0000164A                          3694  
0000164A                          3695  *************************************************************************************
0000164A                          3696  *
0000164A                          3697  * evaluate positive integer expression, result in d0 and Itemp
0000164A                          3698  
0000164A                          3699  LAB_EVPI
0000164A  4A2B 0595               3700      TST.b       FAC1_s(a3)          * test FAC1 sign (b7)
0000164E  6B00 F05E               3701      BMI     LAB_FCER            * do function call error if -ve
00001652                          3702  
00001652                          3703  
00001652                          3704  *************************************************************************************
00001652                          3705  *
00001652                          3706  * evaluate integer expression, no sign check
00001652                          3707  * result in d0 and Itemp, exit with flags set correctly
00001652                          3708  
00001652                          3709  LAB_EVIR
00001652  0C2B 00A0 0594          3710      CMPI.b  #$A0,FAC1_e(a3)     * compare exponent with exponent = 2^32 (n>2^31)
00001658  6500 0D92               3711      BCS     LAB_2831            * convert FAC1 floating to fixed
0000165C                          3712                              * result in d0 and Itemp
0000165C  6600 F050               3713      BNE     LAB_FCER            * if > do function call error, then warm start
00001660                          3714  
00001660  4A2B 0595               3715      TST.b       FAC1_s(a3)          * test sign of FAC1
00001664  6A00 0D86               3716      BPL     LAB_2831            * if +ve then ok
00001668                          3717  
00001668  202B 0590               3718      MOVE.l  FAC1_m(a3),d0       * get mantissa
0000166C  4480                    3719      NEG.l       d0              * do -d0
0000166E  6800 F03E               3720      BVC     LAB_FCER            * if not $80000000 do FC error, then warm start
00001672                          3721  
00001672  2740 042A               3722      MOVE.l  d0,Itemp(a3)        * else just set it
00001676  4E75                    3723      RTS
00001678                          3724  
00001678                          3725  
00001678                          3726  *************************************************************************************
00001678                          3727  *
00001678                          3728  * find or make array
00001678                          3729  
00001678                          3730  LAB_1E17
00001678  3F2B 05B4               3731      MOVE.w  Defdim(a3),-(sp)        * get DIM flag and data type flag (word in mem)
0000167C  7200                    3732      MOVEQ       #0,d1               * clear dimensions count
0000167E                          3733  
0000167E                          3734  * now get the array dimension(s) and stack it (them) before the data type and DIM flag
0000167E                          3735  
0000167E                          3736  LAB_1E1F
0000167E  3F01                    3737      MOVE.w  d1,-(sp)            * save dimensions count
00001680  2F2B 046A               3738      MOVE.l  Varname(a3),-(sp)       * save variable name
00001684  61BC                    3739      BSR.s       LAB_EVIN            * evaluate integer expression
00001686                          3740  
00001686  4840                    3741      SWAP        d0              * swap high word to low word
00001688  4A40                    3742      TST.w       d0              * test swapped high word
0000168A  6600 F012               3743      BNE     LAB_ABER            * if too big do array bounds error
0000168E                          3744  
0000168E  275F 046A               3745      MOVE.l  (sp)+,Varname(a3)       * restore variable name
00001692  321F                    3746      MOVE.w  (sp)+,d1            * restore dimensions count
00001694  301F                    3747      MOVE.w  (sp)+,d0            * restore DIM and data type flags
00001696  3F2B 042C               3748      MOVE.w  Itemp+2(a3),-(sp)       * stack this dimension size
0000169A  3F00                    3749      MOVE.w  d0,-(sp)            * save DIM and data type flags
0000169C  5241                    3750      ADDQ.w  #1,d1               * increment dimensions count
0000169E  6100 FC60               3751      BSR     LAB_GBYT            * scan memory
000016A2  B03C 002C               3752      CMP.b       #$2C,d0         * compare with ","
000016A6  67D6                    3753      BEQ.s       LAB_1E1F            * if found go do next dimension
000016A8                          3754  
000016A8  1741 05DB               3755      MOVE.b  d1,Dimcnt(a3)       * store dimensions count
000016AC  6100 FC3E               3756      BSR     LAB_1BFB            * scan for ")", else do syntax error/warm start
000016B0  375F 05B4               3757      MOVE.w  (sp)+,Defdim(a3)        * restore DIM and data type flags (word in mem)
000016B4  206B 043E               3758      MOVEA.l Sarryl(a3),a0       * get array mem start
000016B8                          3759  
000016B8                          3760  * now check to see if we are at the end of array memory (we would be if there were
000016B8                          3761  * no arrays).
000016B8                          3762  
000016B8                          3763  LAB_1E5C
000016B8  2748 05AC               3764      MOVE.l  a0,Astrtl(a3)       * save as array start pointer
000016BC  B1EB 0442               3765      CMPA.l  Earryl(a3),a0       * compare with array mem end
000016C0  672E                    3766      BEQ.s       LAB_1EA1            * go build array if not found
000016C2                          3767  
000016C2                          3768                              * search for array
000016C2  2010                    3769      MOVE.l  (a0),d0         * get this array name
000016C4  B0AB 046A               3770      CMP.l       Varname(a3),d0      * compare with array name
000016C8  670A                    3771      BEQ.s       LAB_1E8D            * array found so branch
000016CA                          3772  
000016CA                          3773                              * no match
000016CA  2068 0004               3774      MOVEA.l 4(a0),a0            * get this array size
000016CE  D1EB 05AC               3775      ADDA.l  Astrtl(a3),a0       * add to array start pointer
000016D2  60E4                    3776      BRA.s       LAB_1E5C            * go check next array
000016D4                          3777  
000016D4                          3778                              * found array, are we trying to dimension it?
000016D4                          3779  LAB_1E8D
000016D4  4A2B 05B4               3780      TST.b       Defdim(a3)          * are we trying to dimension it?
000016D8  6600 EFC0               3781      BNE     LAB_DDER            * if so do double dimension error/warm start
000016DC                          3782  
000016DC                          3783  * found the array and we're not dimensioning it so we must find an element in it
000016DC                          3784  
000016DC  6100 FF58               3785      BSR     LAB_1DE6            * set data pointer, d0, to the first element
000016E0                          3786                              * in the array
000016E0  5048                    3787      ADDQ.w  #8,a0               * index to dimension count
000016E2  3018                    3788      MOVE.w  (a0)+,d0            * get no of dimensions
000016E4  B02B 05DB               3789      CMP.b       Dimcnt(a3),d0       * compare with dimensions count
000016E8  6700 0094               3790      BEQ     LAB_1F28            * found array so go get element
000016EC                          3791  
000016EC  6000 EF80               3792      BRA     LAB_WDER            * else wrong so do "Wrong dimensions" error
000016F0                          3793  
000016F0                          3794                              * array not found, so possibly build it
000016F0                          3795  LAB_1EA1
000016F0  4A2B 05B4               3796      TST.b       Defdim(a3)          * test the default DIM flag
000016F4  6700 EF7C               3797      BEQ     LAB_UDER            * if default flag is clear then we are not
000016F8                          3798                              * explicitly dimensioning an array so go
000016F8                          3799                              * do an "Undimensioned array" error
000016F8                          3800  
000016F8  6100 FF3C               3801      BSR     LAB_1DE6            * set data pointer, d0, to the first element
000016FC                          3802                              * in the array
000016FC  202B 046A               3803      MOVE.l  Varname(a3),d0      * get array name
00001700  20C0                    3804      MOVE.l  d0,(a0)+            * save array name
00001702  7204                    3805      MOVEQ       #4,d1               * set 4 bytes per element
00001704  0800 0017               3806      BTST.l  #23,d0          * test if string array
00001708  6702                    3807      BEQ.s       LAB_1EDF            * branch if not string
0000170A                          3808  
0000170A  7206                    3809      MOVEQ       #6,d1               * else 6 bytes per element
0000170C                          3810  LAB_1EDF
0000170C  2741 05A8               3811      MOVE.l  d1,Asptl(a3)        * set array data size (bytes per element)
00001710  122B 05DB               3812      MOVE.b  Dimcnt(a3),d1       * get dimensions count
00001714  5848                    3813      ADDQ.w  #4,a0               * skip the array size now (don't know it yet!)
00001716  30C1                    3814      MOVE.w  d1,(a0)+            * set array's dimensions count
00001718                          3815  
00001718                          3816  * now calculate the array data space size
00001718                          3817  
00001718                          3818  LAB_1EC0
00001718                          3819  
00001718                          3820  * If you want arrays to dimension themselves by default then comment out the test
00001718                          3821  * above and uncomment the next three code lines and the label LAB_1ED0
00001718                          3822  
00001718                          3823  *   MOVE.w  #$0A,d1         * set default dimension value, allow 0 to 9
00001718                          3824  *   TST.b       Defdim(a3)          * test default DIM flag
00001718                          3825  *   BNE.s       LAB_1ED0            * branch if b6 of Defdim is clear
00001718                          3826  
00001718  321F                    3827      MOVE.w  (sp)+,d1            * get dimension size
0000171A                          3828  *LAB_1ED0
0000171A  30C1                    3829      MOVE.w  d1,(a0)+            * save to array header
0000171C  6100 00AE               3830      BSR     LAB_1F7C            * do this dimension size+1 * array size
00001720                          3831                              * (d1+1)*(Asptl), result in d0
00001720  2740 05A8               3832      MOVE.l  d0,Asptl(a3)        * save array data size
00001724  532B 05DB               3833      SUBQ.b  #1,Dimcnt(a3)       * decrement dimensions count
00001728  66EE                    3834      BNE.s       LAB_1EC0            * loop while not = 0
0000172A                          3835  
0000172A  D1EB 05A8               3836      ADDA.l  Asptl(a3),a0        * add size to first element address
0000172E  6500 EF76               3837      BCS     LAB_OMER            * if overflow go do "Out of memory" error
00001732                          3838  
00001732  B1EB 0446               3839      CMPA.l  Sstorl(a3),a0       * compare with bottom of string memory
00001736  650C                    3840      BCS.s       LAB_1ED6            * branch if less (is ok)
00001738                          3841  
00001738  6100 028E               3842      BSR     LAB_GARB            * do garbage collection routine
0000173C  B1EB 0446               3843      CMPA.l  Sstorl(a3),a0       * compare with bottom of string memory
00001740  6400 EF64               3844      BCC     LAB_OMER            * if Sstorl <= a0 do "Out of memory"
00001744                          3845                              * error then warm start
00001744                          3846  
00001744                          3847  LAB_1ED6                        * ok exit, carry set
00001744  2748 0442               3848      MOVE.l  a0,Earryl(a3)       * save array mem end
00001748  7000                    3849      MOVEQ       #0,d0               * zero d0
0000174A  222B 05A8               3850      MOVE.l  Asptl(a3),d1        * get size in bytes
0000174E  E289                    3851      LSR.l       #1,d1               * /2 for word fill (may be odd # words)
00001750  5341                    3852      SUBQ.w  #1,d1               * adjust for DBF loop
00001752                          3853  LAB_1ED8
00001752  3100                    3854      MOVE.w  d0,-(a0)            * decrement pointer and clear word
00001754  51C9 FFFC               3855      DBF     d1,LAB_1ED8         * decrement & loop until low word done
00001758                          3856  
00001758  4841                    3857      SWAP        d1              * swap words
0000175A  4A41                    3858      TST.w       d1              * test high word
0000175C  6706                    3859      BEQ.s       LAB_1F07            * exit if done
0000175E                          3860  
0000175E  5341                    3861      SUBQ.w  #1,d1               * decrement low (high) word
00001760  4841                    3862      SWAP        d1              * swap back
00001762  60EE                    3863      BRA.s       LAB_1ED8            * go do a whole block
00001764                          3864  
00001764                          3865  * now we need to calculate the array size by doing Earryl - Astrtl
00001764                          3866  
00001764                          3867  LAB_1F07
00001764  206B 05AC               3868      MOVEA.l Astrtl(a3),a0       * get for calculation and as pointer
00001768  202B 0442               3869      MOVE.l  Earryl(a3),d0       * get array memory end
0000176C  9088                    3870      SUB.l       a0,d0               * calculate array size
0000176E  2140 0004               3871      MOVE.l  d0,4(a0)            * save size to array
00001772  4A2B 05B4               3872      TST.b       Defdim(a3)          * test default DIM flag
00001776  6652                    3873      BNE.s       RTS_011         * exit (RET) if this was a DIM command
00001778                          3874  
00001778                          3875                              * else, find element
00001778  5048                    3876      ADDQ.w  #8,a0               * index to dimension count
0000177A  3758 05DB               3877      MOVE.w  (a0)+,Dimcnt(a3)        * get array's dimension count
0000177E                          3878  
0000177E                          3879  * we have found, or built, the array. now we need to find the element
0000177E                          3880  
0000177E                          3881  LAB_1F28
0000177E  7000                    3882      MOVEQ       #0,d0               * clear first result
00001780  2740 05A8               3883      MOVE.l  d0,Asptl(a3)        * clear array data pointer
00001784                          3884  
00001784                          3885  * compare nth dimension bound (a0) with nth index (sp)+
00001784                          3886  * if greater do array bounds error
00001784                          3887  
00001784                          3888  LAB_1F2C
00001784  3218                    3889      MOVE.w  (a0)+,d1            * get nth dimension bound
00001786  B257                    3890      CMP.w       (sp),d1         * compare nth index with nth dimension bound
00001788  6500 EF14               3891      BCS     LAB_ABER            * if d1 less or = do array bounds error
0000178C                          3892  
0000178C                          3893  * now do pointer = pointer * nth dimension + nth index
0000178C                          3894  
0000178C  4A80                    3895      TST.l       d0              * test pointer
0000178E  6702                    3896      BEQ.s       LAB_1F5A            * skip multiply if last result = null
00001790                          3897  
00001790  613A                    3898      BSR.s       LAB_1F7C            * do this dimension size+1 * array size
00001792                          3899  LAB_1F5A
00001792  7200                    3900      MOVEQ       #0,d1               * clear longword
00001794  321F                    3901      MOVE.w  (sp)+,d1            * get nth dimension index
00001796  D081                    3902      ADD.l       d1,d0               * add index to size
00001798  2740 05A8               3903      MOVE.l  d0,Asptl(a3)        * save array data pointer
0000179C                          3904  
0000179C  532B 05DB               3905      SUBQ.b  #1,Dimcnt(a3)       * decrement dimensions count
000017A0  66E2                    3906      BNE.s       LAB_1F2C            * loop if dimensions still to do
000017A2                          3907  
000017A2  177C 0000 05B5          3908      MOVE.b  #0,Dtypef(a3)       * set data type to float
000017A8  7203                    3909      MOVEQ       #3,d1               * set for numeric array
000017AA  4A2B 046B               3910      TST.b       Varname+1(a3)       * test if string array
000017AE  6A0A                    3911      BPL.s       LAB_1F6A            * branch if not string
000017B0                          3912  
000017B0  7205                    3913      MOVEQ       #5,d1               * else set for string array
000017B2  177C 0080 05B5          3914      MOVE.b  #$80,Dtypef(a3)     * and set data type to string
000017B8  600C                    3915      BRA.s       LAB_1F6B            * skip integer test
000017BA                          3916  
000017BA                          3917  LAB_1F6A
000017BA  4A2B 046C               3918      TST.b       Varname+2(a3)       * test if integer array
000017BE  6A06                    3919      BPL.s       LAB_1F6B            * branch if not integer
000017C0                          3920  
000017C0  177C 0040 05B5          3921      MOVE.b  #$40,Dtypef(a3)     * else set data type to integer
000017C6                          3922  LAB_1F6B
000017C6  6104                    3923      BSR.s       LAB_1F7C            * do element size (d1) * array size (Asptl)
000017C8  D1C0                    3924      ADDA.l  d0,a0               * add array data start pointer
000017CA                          3925  RTS_011
000017CA  4E75                    3926      RTS
000017CC                          3927  
000017CC                          3928  
000017CC                          3929  *************************************************************************************
000017CC                          3930  *
000017CC                          3931  * do this dimension size (d1) * array data size (Asptl)
000017CC                          3932  
000017CC                          3933  * do a 16 x 32 bit multiply
000017CC                          3934  * d1 holds the 16 bit multiplier
000017CC                          3935  * Asptl holds the 32 bit multiplicand
000017CC                          3936  
000017CC                          3937  * d0    bbbb  bbbb
000017CC                          3938  * d1    0000  aaaa
000017CC                          3939  *   ----------
000017CC                          3940  * d0    rrrr  rrrr
000017CC                          3941  
000017CC                          3942  LAB_1F7C
000017CC  202B 05A8               3943      MOVE.l  Asptl(a3),d0        * get result
000017D0  2400                    3944      MOVE.l  d0,d2               * copy it
000017D2  4842                    3945      SWAP        d2              * shift high word to low word
000017D4  C0C1                    3946      MULU.w  d1,d0               * d1 * low word = low result
000017D6  C4C1                    3947      MULU.w  d1,d2               * d1 * high word = high result
000017D8  4842                    3948      SWAP        d2              * align words for test
000017DA  4A42                    3949      TST.w       d2              * must be zero
000017DC  6600 EEC8               3950      BNE     LAB_OMER            * if overflow go do "Out of memory" error
000017E0                          3951  
000017E0  D082                    3952      ADD.l       d2,d0               * calculate result
000017E2  6500 EEC2               3953      BCS     LAB_OMER            * if overflow go do "Out of memory" error
000017E6                          3954  
000017E6  D0AB 05A8               3955      ADD.l       Asptl(a3),d0        * add original
000017EA  6500 EEBA               3956      BCS     LAB_OMER            * if overflow go do "Out of memory" error
000017EE                          3957  
000017EE  4E75                    3958      RTS
000017F0                          3959  
000017F0                          3960  
000017F0                          3961  *************************************************************************************
000017F0                          3962  *
000017F0                          3963  * perform FRE()
000017F0                          3964  
000017F0                          3965  LAB_FRE
000017F0  4A2B 05B5               3966      TST.b       Dtypef(a3)          * test data type, $80=string, $40=integer,
000017F4                          3967                              * $00=float
000017F4  6A04                    3968      BPL.s       LAB_1FB4            * branch if numeric
000017F6                          3969  
000017F6  6100 0318               3970      BSR     LAB_22B6            * pop string off descriptor stack, or from
000017FA                          3971                              * top of string space, returns d0 = length,
000017FA                          3972                              * a0 = pointer
000017FA                          3973  
000017FA                          3974                              * FRE(n) was numeric so do this
000017FA                          3975  LAB_1FB4
000017FA  6100 01CC               3976      BSR     LAB_GARB            * go do garbage collection
000017FE  202B 0446               3977      MOVE.l  Sstorl(a3),d0       * get bottom of string space
00001802  90AB 0442               3978      SUB.l       Earryl(a3),d0       * subtract array mem end
00001806                          3979  
00001806                          3980  
00001806                          3981  *************************************************************************************
00001806                          3982  *
00001806                          3983  * convert d0 to signed longword in FAC1
00001806                          3984  
00001806                          3985  LAB_AYFC
00001806  177C 0000 05B5          3986      MOVE.b  #$00,Dtypef(a3)     * clear data type, $80=string, $40=integer,
0000180C                          3987                              * $00=float
0000180C  377C A000 0594          3988      MOVE.w  #$A000,FAC1_e(a3)       * set FAC1 exponent and clear sign (b7)
00001812  2740 0590               3989      MOVE.l  d0,FAC1_m(a3)       * save FAC1 mantissa
00001816  6A00 086E               3990      BPL     LAB_24D0            * convert if +ve
0000181A                          3991  
0000181A  003C 0001               3992      ORI.b       #1,CCR          * else set carry
0000181E  6000 0866               3993      BRA     LAB_24D0            * do +/- (carry is sign) & normalise FAC1
00001822                          3994  
00001822                          3995  
00001822                          3996  *************************************************************************************
00001822                          3997  *
00001822                          3998  * remember if the line length is zero (infinite line) then POS(n) will return
00001822                          3999  * position MOD tabsize
00001822                          4000  
00001822                          4001  * perform POS()
00001822                          4002  
00001822                          4003  LAB_POS
00001822  102B 05E5               4004      MOVE.b  TPos(a3),d0         * get terminal position
00001826                          4005  
00001826                          4006  * convert d0 to unsigned byte in FAC1
00001826                          4007  
00001826                          4008  LAB_1FD0
00001826  C0BC 000000FF           4009      AND.l       #$FF,d0         * clear high bits
0000182C  60D8                    4010      BRA.s       LAB_AYFC            * convert d0 to signed longword in FAC1 & RET
0000182E                          4011  
0000182E                          4012  * check not Direct (used by DEF and INPUT)
0000182E                          4013  
0000182E                          4014  LAB_CKRN
0000182E  4A2B 0452               4015      TST.b       Clinel(a3)          * test current line #
00001832  6B00 EE5E               4016      BMI     LAB_IDER            * if -ve go do illegal direct error then warm
00001836                          4017                              * start
00001836                          4018  
00001836  4E75                    4019      RTS                     * can continue so return
00001838                          4020  
00001838                          4021  
00001838                          4022  *************************************************************************************
00001838                          4023  *
00001838                          4024  * perform DEF
00001838                          4025  
00001838                          4026  LAB_DEF
00001838  70B8                    4027      MOVEQ       #TK_FN-$100,d0      * get FN token
0000183A  6100 FABA               4028      BSR     LAB_SCCA            * scan for CHR$(d0), else syntax error and
0000183E                          4029                              * warm start
0000183E                          4030                              * return character after d0
0000183E  177C 0080 05DF          4031      MOVE.b  #$80,Sufnxf(a3)     * set FN flag bit
00001844  6100 FCDA               4032      BSR     LAB_1D12            * get FN name
00001848  2748 05B0               4033      MOVE.l  a0,func_l(a3)       * save function pointer
0000184C                          4034  
0000184C  61E0                    4035      BSR.s       LAB_CKRN            * check not direct (back here if ok)
0000184E  0C1D 0028               4036      CMP.b       #$28,(a5)+          * check next byte is "(" and increment
00001852  6600 EE66               4037      BNE     LAB_SNER            * else do syntax error/warm start
00001856                          4038  
00001856  177C 007E 05DF          4039      MOVE.b  #$7E,Sufnxf(a3)     * set FN variable flag bits
0000185C  6100 FCB4               4040      BSR     LAB_SVAR            * search for or create a variable
00001860                          4041                              * return the variable address in a0
00001860  6100 FA8A               4042      BSR     LAB_1BFB            * scan for ")", else do syntax error/warm start
00001864  70CA                    4043      MOVEQ       #TK_EQUAL-$100,d0       * = token
00001866  6100 FA8E               4044      BSR     LAB_SCCA            * scan for CHR$(A), else syntax error/warm start
0000186A                          4045                              * return character after d0
0000186A  2F2B 046A               4046      MOVE.l  Varname(a3),-(sp)       * push current variable name
0000186E  2F0D                    4047      MOVE.l  a5,-(sp)            * push BASIC execute pointer
00001870  6100 F412               4048      BSR     LAB_DATA            * go perform DATA, find end of DEF FN statement
00001874  206B 05B0               4049      MOVEA.l func_l(a3),a0       * get the function pointer
00001878  209F                    4050      MOVE.l  (sp)+,(a0)          * save BASIC execute pointer to function
0000187A  215F 0004               4051      MOVE.l  (sp)+,4(a0)         * save current variable name to function
0000187E  4E75                    4052      RTS
00001880                          4053  
00001880                          4054  
00001880                          4055  *************************************************************************************
00001880                          4056  *
00001880                          4057  * evaluate FNx
00001880                          4058  
00001880                          4059  LAB_201E
00001880  177C 0081 05DF          4060      MOVE.b  #$81,Sufnxf(a3)     * set FN flag (find not create)
00001886  6100 FA76               4061      BSR     LAB_IGBY            * increment & scan memory
0000188A  6100 FC94               4062      BSR     LAB_1D12            * get FN name
0000188E  1F2B 05B5               4063      MOVE.b  Dtypef(a3),-(sp)        * push data type flag (function type)
00001892  2F08                    4064      MOVE.l  a0,-(sp)            * push function pointer
00001894  0C15 0028               4065      CMP.b       #$28,(a5)           * check next byte is "(", no increment
00001898  6600 EE20               4066      BNE     LAB_SNER            * else do syntax error/warm start
0000189C                          4067  
0000189C  6100 FA4A               4068      BSR     LAB_1BF7            * evaluate expression within parentheses
000018A0  205F                    4069      MOVEA.l (sp)+,a0            * pop function pointer
000018A2  2748 05B0               4070      MOVE.l  a0,func_l(a3)       * set function pointer
000018A6  1F2B 05B5               4071      MOVE.b  Dtypef(a3),-(sp)        * push data type flag (function expression type)
000018AA                          4072  
000018AA  2028 0004               4073      MOVE.l  4(a0),d0            * get function variable name
000018AE  6100 FCDA               4074      BSR     LAB_1D4A            * go find function variable (already created)
000018B2                          4075  
000018B2                          4076                              * now check type match for variable
000018B2  101F                    4077      MOVE.b  (sp)+,d0            * pop data type flag (function expression type)
000018B4  E318                    4078      ROL.b       #1,d0               * set carry if type = string
000018B6  6100 F8D2               4079      BSR     LAB_CKTM            * type match check, set C for string
000018BA                          4080  
000018BA                          4081                              * now stack the function variable value before
000018BA                          4082                              * use
000018BA  6712                    4083      BEQ.s       LAB_2043            * branch if not string
000018BC                          4084  
000018BC  43EB 0476               4085      LEA     des_sk_e(a3),a1     * get string stack pointer max+1
000018C0  B9C9                    4086      CMPA.l  a1,a4               * compare string stack pointer with max+1
000018C2  6700 EDC2               4087      BEQ     LAB_SCER            * if no space on the stack go do string too
000018C6                          4088                              * complex error
000018C6                          4089  
000018C6  3928 0004               4090      MOVE.w  4(a0),-(a4)         * string length on descriptor stack
000018CA  2910                    4091      MOVE.l  (a0),-(a4)          * string address on stack
000018CC  6002                    4092      BRA.s       LAB_204S            * skip var push
000018CE                          4093  
000018CE                          4094  LAB_2043
000018CE  2F10                    4095      MOVE.l  (a0),-(sp)          * push variable
000018D0                          4096  LAB_204S
000018D0  2F08                    4097      MOVE.l  a0,-(sp)            * push variable address
000018D2  1F2B 05B5               4098      MOVE.b  Dtypef(a3),-(sp)        * push variable data type
000018D6                          4099  
000018D6  6132                    4100      BSR.s       LAB_2045            * pack function expression value into (a0)
000018D8                          4101                              * (function variable)
000018D8  2F0D                    4102      MOVE.l  a5,-(sp)            * push BASIC execute pointer
000018DA  206B 05B0               4103      MOVEA.l func_l(a3),a0       * get function pointer
000018DE  2A50                    4104      MOVEA.l (a0),a5         * save function execute ptr as BASIC execute ptr
000018E0  6100 F8BC               4105      BSR     LAB_EVEX            * evaluate expression
000018E4  6100 FA1A               4106      BSR     LAB_GBYT            * scan memory
000018E8  6600 EDD0               4107      BNE     LAB_SNER            * if not [EOL] or [EOS] do syntax error then
000018EC                          4108                              * warm start
000018EC                          4109  
000018EC  2A5F                    4110      MOVE.l  (sp)+,a5            * restore BASIC execute pointer
000018EE                          4111  
000018EE                          4112  * restore variable from stack and test data type
000018EE                          4113  
000018EE  101F                    4114      MOVE.b  (sp)+,d0            * pull variable data type
000018F0  205F                    4115      MOVEA.l (sp)+,a0            * pull variable address
000018F2  4A00                    4116      TST.b       d0              * test variable data type
000018F4  6A08                    4117      BPL.s       LAB_204T            * branch if not string
000018F6                          4118  
000018F6  209C                    4119      MOVE.l  (a4)+,(a0)          * string address from descriptor stack
000018F8  315C 0004               4120      MOVE.w  (a4)+,4(a0)         * string length from descriptor stack
000018FC  6002                    4121      BRA.s       LAB_2044            * skip variable pull
000018FE                          4122  
000018FE                          4123  LAB_204T
000018FE  209F                    4124      MOVE.l  (sp)+,(a0)          * restore variable from stack
00001900                          4125  LAB_2044
00001900  101F                    4126      MOVE.b  (sp)+,d0            * pop data type flag (function type)
00001902  E318                    4127      ROL.b       #1,d0               * set carry if type = string
00001904  6100 F884               4128      BSR     LAB_CKTM            * type match check, set C for string
00001908  4E75                    4129      RTS
0000190A                          4130  
0000190A                          4131  LAB_2045
0000190A  4A2B 05B5               4132      TST.b       Dtypef(a3)          * test data type
0000190E  6A00 0A1E               4133      BPL     LAB_2778            * if numeric pack FAC1 into variable (a0) and
00001912                          4134                              * return
00001912                          4135  
00001912  2448                    4136      MOVEA.l a0,a2               * copy variable pointer
00001914  6000 F50C               4137      BRA     LAB_17D6            * go do string LET & return
00001918                          4138  
00001918                          4139  
00001918                          4140  
00001918                          4141  *************************************************************************************
00001918                          4142  *
00001918                          4143  * perform STR$()
00001918                          4144  
00001918                          4145  LAB_STRS
00001918  6100 0B7C               4146      BSR     LAB_2970            * convert FAC1 to string
0000191C                          4147  
0000191C                          4148  * scan, set up string
0000191C                          4149  * print " terminated string to FAC1 stack
0000191C                          4150  
0000191C                          4151  LAB_20AE
0000191C  7422                    4152      MOVEQ       #$22,d2         * set Srchc character (terminator 1)
0000191E  3602                    4153      MOVE.w  d2,d3               * set Asrch character (terminator 2)
00001920                          4154  
00001920                          4155  * print d2/d3 terminated string to FAC1 stack
00001920                          4156  * d2 = Srchc, d3 = Asrch, a0 is source
00001920                          4157  * a6 is temp
00001920                          4158  
00001920                          4159  LAB_20B4
00001920  7200                    4160      MOVEQ       #0,d1               * clear longword
00001922  5341                    4161      SUBQ.w  #1,d1               * set length to -1
00001924  2448                    4162      MOVEA.l a0,a2               * copy start to calculate end
00001926                          4163  LAB_20BE
00001926  5241                    4164      ADDQ.w  #1,d1               * increment length
00001928  1030 1000               4165      MOVE.b  (a0,d1.w),d0        * get byte from string
0000192C  6710                    4166      BEQ.s       LAB_20D0            * exit loop if null byte [EOS]
0000192E                          4167  
0000192E  B002                    4168      CMP.b       d2,d0               * compare with search character (terminator 1)
00001930  6704                    4169      BEQ.s       LAB_20CB            * branch if terminator
00001932                          4170  
00001932  B003                    4171      CMP.b       d3,d0               * compare with terminator 2
00001934  66F0                    4172      BNE.s       LAB_20BE            * loop if not terminator 2 (or null string)
00001936                          4173  
00001936                          4174  LAB_20CB
00001936  B03C 0022               4175      CMP.b       #$22,d0         * compare with "
0000193A  6602                    4176      BNE.s       LAB_20D0            * branch if not "
0000193C                          4177  
0000193C  524A                    4178      ADDQ.w  #1,a2               * else increment string start (skip " at end)
0000193E                          4179  LAB_20D0
0000193E  D5C1                    4180      ADDA.l  d1,a2               * add longowrd length to make string end+1
00001940                          4181  
00001940  B1CB                    4182      CMPA.l  a3,a0               * is string in ram
00001942  651E                    4183      BCS.s       LAB_RTST            * if not go push descriptor on stack & exit
00001944                          4184                              * (could be message string from ROM)
00001944                          4185  
00001944  B1EB 042E               4186      CMPA.l  Smeml(a3),a0        * is string in utility ram
00001948  6418                    4187      BCC.s       LAB_RTST            * if not go push descriptor on stack & exit
0000194A                          4188                              * (is in string or program space)
0000194A                          4189  
0000194A                          4190                              * (else) copy string to string memory
0000194A                          4191  LAB_20C9
0000194A  2248                    4192      MOVEA.l a0,a1               * copy descriptor pointer
0000194C  2001                    4193      MOVE.l  d1,d0               * copy longword length
0000194E  6604                    4194      BNE.s       LAB_20D8            * branch if not null string
00001950                          4195  
00001950  2041                    4196      MOVEA.l d1,a0               * make null pointer
00001952  600E                    4197      BRA.s       LAB_RTST            * go push descriptor on stack & exit
00001954                          4198  
00001954                          4199  LAB_20D8
00001954  6126                    4200      BSR.s       LAB_2115            * make string space d1 bytes long
00001956  D1C1                    4201      ADDA.l  d1,a0               * new string end
00001958  D3C1                    4202      ADDA.l  d1,a1               * old string end
0000195A  5340                    4203      SUBQ.w  #1,d0               * -1 for DBF loop
0000195C                          4204  LAB_20E0
0000195C  1121                    4205      MOVE.b  -(a1),-(a0)         * copy byte (source can be odd aligned)
0000195E  51C8 FFFC               4206      DBF     d0,LAB_20E0         * loop until done
00001962                          4207  
00001962                          4208  
00001962                          4209  
00001962                          4210  *************************************************************************************
00001962                          4211  *
00001962                          4212  * check for space on descriptor stack then ...
00001962                          4213  * put string address and length on descriptor stack & update stack pointers
00001962                          4214  * start is in a0, length is in d1
00001962                          4215  
00001962                          4216  LAB_RTST
00001962  43EB 0476               4217      LEA     des_sk_e(a3),a1     * get string stack pointer max+1
00001966  B9C9                    4218      CMPA.l  a1,a4               * compare string stack pointer with max+1
00001968  6700 ED1C               4219      BEQ     LAB_SCER            * if no space on string stack ..
0000196C                          4220                              * .. go do 'string too complex' error
0000196C                          4221  
0000196C                          4222                              * push string & update pointers
0000196C  3901                    4223      MOVE.w  d1,-(a4)            * string length on descriptor stack
0000196E  2908                    4224      MOVE.l  a0,-(a4)            * string address on stack
00001970  274C 0590               4225      MOVE.l  a4,FAC1_m(a3)       * string descriptor pointer in FAC1
00001974  177C 0080 05B5          4226      MOVE.b  #$80,Dtypef(a3)     * save data type flag, $80=string
0000197A  4E75                    4227      RTS
0000197C                          4228  
0000197C                          4229  
0000197C                          4230  *************************************************************************************
0000197C                          4231  *
0000197C                          4232  * build descriptor a0/d1
0000197C                          4233  * make space in string memory for string d1.w long
0000197C                          4234  * return pointer in a0/Sutill
0000197C                          4235  
0000197C                          4236  LAB_2115
0000197C  4A41                    4237      TST.w       d1              * test length
0000197E  672E                    4238      BEQ.s       LAB_2128            * branch if user wants null string
00001980                          4239  
00001980                          4240                              * make space for string d1 long
00001980  2F00                    4241      MOVE.l  d0,-(sp)            * save d0
00001982  7000                    4242      MOVEQ       #0,d0               * clear longword
00001984  1740 05DE               4243      MOVE.b  d0,Gclctd(a3)       * clear garbage collected flag (b7)
00001988  7001                    4244      MOVEQ       #1,d0               * +1 to possibly round up
0000198A  C041                    4245      AND.w       d1,d0               * mask odd bit
0000198C  D041                    4246      ADD.w       d1,d0               * ensure d0 is even length
0000198E  6404                    4247      BCC.s       LAB_2117            * branch if no overflow
00001990                          4248  
00001990  7001                    4249      MOVEQ       #1,d0               * set to allocate 65536 bytes
00001992  4840                    4250      SWAP        d0              * makes $00010000
00001994                          4251  LAB_2117
00001994  206B 0446               4252      MOVEA.l Sstorl(a3),a0       * get bottom of string space
00001998  91C0                    4253      SUBA.l  d0,a0               * subtract string length
0000199A  B1EB 0442               4254      CMPA.l  Earryl(a3),a0       * compare with top of array space
0000199E  6512                    4255      BCS.s       LAB_2137            * if less do out of memory error
000019A0                          4256  
000019A0  2748 0446               4257      MOVE.l  a0,Sstorl(a3)       * save bottom of string space
000019A4  2748 044E               4258      MOVE.l  a0,Sutill(a3)       * save string utility pointer
000019A8  201F                    4259      MOVE.l  (sp)+,d0            * restore d0
000019AA  4A41                    4260      TST.w       d1              * set flags on length
000019AC  4E75                    4261      RTS
000019AE                          4262  
000019AE                          4263  LAB_2128
000019AE  3041                    4264      MOVEA.w d1,a0               * make null pointer
000019B0  4E75                    4265      RTS
000019B2                          4266  
000019B2                          4267  LAB_2137
000019B2  4A2B 05DE               4268      TST.b       Gclctd(a3)          * get garbage collected flag
000019B6  6B00 ECEE               4269      BMI     LAB_OMER            * do "Out of memory" error, then warm start
000019BA                          4270  
000019BA  2F09                    4271      MOVE.l  a1,-(sp)            * save a1
000019BC  610A                    4272      BSR.s       LAB_GARB            * else go do garbage collection
000019BE  225F                    4273      MOVEA.l (sp)+,a1            * restore a1
000019C0  177C 0080 05DE          4274      MOVE.b  #$80,Gclctd(a3)     * set garbage collected flag
000019C6  60CC                    4275      BRA.s       LAB_2117            * go try again
000019C8                          4276  
000019C8                          4277  
000019C8                          4278  *************************************************************************************
000019C8                          4279  *
000019C8                          4280  * garbage collection routine
000019C8                          4281  
000019C8                          4282  LAB_GARB
000019C8  48E7 E0E0               4283      MOVEM.l d0-d2/a0-a2,-(sp)       * save registers
000019CC  276B 044A 0446          4284      MOVE.l  Ememl(a3),Sstorl(a3)    * start with no strings
000019D2                          4285  
000019D2                          4286                              * re-run routine from last ending
000019D2                          4287  LAB_214B
000019D2  222B 0442               4288      MOVE.l  Earryl(a3),d1       * set highest uncollected string so far
000019D6  7000                    4289      MOVEQ       #0,d0               * clear longword
000019D8  2240                    4290      MOVEA.l d0,a1               * clear string to move pointer
000019DA  206B 043A               4291      MOVEA.l Sstrl(a3),a0        * set pointer to start of strings
000019DE  41E8 0004               4292      LEA     4(a0),a0            * index to string pointer
000019E2  246B 043E               4293      MOVEA.l Sarryl(a3),a2       * set end pointer to start of arrays, end of
000019E6                          4294                              * strings
000019E6  6008                    4295      BRA.s       LAB_2176            * branch into loop at end loop test
000019E8                          4296  
000019E8                          4297  LAB_2161
000019E8  6100 0084               4298      BSR     LAB_2206            * test and set if this is the highest string
000019EC  41E8 000A               4299      LEA     10(a0),a0           * increment to next string
000019F0                          4300  LAB_2176
000019F0  B1CA                    4301      CMPA.l  a2,a0               * compare end of area with pointer
000019F2  65F4                    4302      BCS.s       LAB_2161            * go do next if not at end
000019F4                          4303  
000019F4                          4304  * done strings, now do arrays.
000019F4                          4305  
000019F4  41E8 FFFC               4306      LEA     -4(a0),a0           * decrement pointer to start of arrays
000019F8  246B 0442               4307      MOVEA.l Earryl(a3),a2       * set end pointer to end of arrays
000019FC  6024                    4308      BRA.s       LAB_218F            * branch into loop at end loop test
000019FE                          4309  
000019FE                          4310  LAB_217E
000019FE  2428 0004               4311      MOVE.l  4(a0),d2            * get array size
00001A02  D488                    4312      ADD.l       a0,d2               * makes start of next array
00001A04                          4313  
00001A04  2010                    4314      MOVE.l  (a0),d0         * get array name
00001A06  0800 0017               4315      BTST        #23,d0          * test string flag
00001A0A  6714                    4316      BEQ.s       LAB_218B            * branch if not string
00001A0C                          4317  
00001A0C  3028 0008               4318      MOVE.w  8(a0),d0            * get # of dimensions
00001A10  D040                    4319      ADD.w       d0,d0               * *2
00001A12  D0C0                    4320      ADDA.w  d0,a0               * add to skip dimension size(s)
00001A14  41E8 000A               4321      LEA     10(a0),a0           * increment to first element
00001A18                          4322  LAB_2183
00001A18  6154                    4323      BSR.s       LAB_2206            * test and set if this is the highest string
00001A1A  5C48                    4324      ADDQ.w  #6,a0               * increment to next element
00001A1C  B1C2                    4325      CMPA.l  d2,a0               * compare with start of next array
00001A1E  66F8                    4326      BNE.s       LAB_2183            * go do next if not at end of array
00001A20                          4327  
00001A20                          4328  LAB_218B
00001A20  2042                    4329      MOVEA.l d2,a0               * pointer to next array
00001A22                          4330  LAB_218F
00001A22  B5C8                    4331      CMPA.l  a0,a2               * compare pointer with array end
00001A24  66D8                    4332      BNE.s       LAB_217E            * go do next if not at end
00001A26                          4333  
00001A26                          4334  * done arrays and variables, now just the descriptor stack to do
00001A26                          4335  
00001A26  204C                    4336      MOVEA.l a4,a0               * get descriptor stack pointer
00001A28  45EB 048E               4337      LEA     des_sk(a3),a2       * set end pointer to end of stack
00001A2C  6006                    4338      BRA.s       LAB_21C4            * branch into loop at end loop test
00001A2E                          4339  
00001A2E                          4340  LAB_21C2
00001A2E  613E                    4341      BSR.s       LAB_2206            * test and set if this is the highest string
00001A30  41E8 0006               4342      LEA     6(a0),a0            * increment to next string
00001A34                          4343  LAB_21C4
00001A34  B5C8                    4344      CMPA.l  a0,a2               * compare pointer with stack end
00001A36  66F6                    4345      BNE.s       LAB_21C2            * go do next if not at end
00001A38                          4346  
00001A38                          4347  * descriptor search complete, now either exit or set-up and move string
00001A38                          4348  
00001A38  2009                    4349      MOVE.l  a1,d0               * set the flags (a1 is move string)
00001A3A  672C                    4350      BEQ.s       LAB_21D1            * go tidy up and exit if no move
00001A3C                          4351  
00001A3C  2051                    4352      MOVEA.l (a1),a0         * a0 is now string start
00001A3E  7200                    4353      MOVEQ       #0,d1               * clear d1
00001A40  3229 0004               4354      MOVE.w  4(a1),d1            * d1 is string length
00001A44  5281                    4355      ADDQ.l  #1,d1               * +1
00001A46  C23C 00FE               4356      AND.b       #$FE,d1         * make even length
00001A4A  D1C1                    4357      ADDA.l  d1,a0               * pointer is now to string end+1
00001A4C  246B 0446               4358      MOVEA.l Sstorl(a3),a2       * is destination end+1
00001A50  B1CA                    4359      CMPA.l  a2,a0               * does the string need moving
00001A52  670C                    4360      BEQ.s       LAB_2240            * branch if not
00001A54                          4361  
00001A54  E289                    4362      LSR.l       #1,d1               * word move so do /2
00001A56  5341                    4363      SUBQ.w  #1,d1               * -1 for DBF loop
00001A58                          4364  LAB_2216
00001A58  3520                    4365      MOVE.w  -(a0),-(a2)         * copy word
00001A5A  51C9 FFFC               4366      DBF     d1,LAB_2216         * loop until done
00001A5E                          4367  
00001A5E  228A                    4368      MOVE.l  a2,(a1)         * save new string start
00001A60                          4369  LAB_2240
00001A60  2751 0446               4370      MOVE.l  (a1),Sstorl(a3)     * string start is new string mem start
00001A64  6000 FF6C               4371      BRA     LAB_214B            * re-run routine from last ending
00001A68                          4372                              * (but don't collect this string)
00001A68                          4373  
00001A68                          4374  LAB_21D1
00001A68  4CDF 0707               4375      MOVEM.l (sp)+,d0-d2/a0-a2       * restore registers
00001A6C  4E75                    4376      RTS
00001A6E                          4377  
00001A6E                          4378  * test and set if this is the highest string
00001A6E                          4379  
00001A6E                          4380  LAB_2206
00001A6E  2010                    4381      MOVE.l  (a0),d0         * get this string pointer
00001A70  6728                    4382      BEQ.s       RTS_012         * exit if null string
00001A72                          4383  
00001A72  B280                    4384      CMP.l       d0,d1               * compare with highest uncollected string so far
00001A74  6424                    4385      BCC.s       RTS_012         * exit if <= with highest so far
00001A76                          4386  
00001A76  B0AB 0446               4387      CMP.l       Sstorl(a3),d0       * compare with bottom of string space
00001A7A  641E                    4388      BCC.s       RTS_012         * exit if >= bottom of string space
00001A7C                          4389  
00001A7C  70FF                    4390      MOVEQ       #-1,d0          * d0 = $FFFFFFFF
00001A7E  3028 0004               4391      MOVE.w  4(a0),d0            * d0 is string length
00001A82  4440                    4392      NEG.w       d0              * make -ve
00001A84  C03C 00FE               4393      AND.b       #$FE,d0         * make -ve even length
00001A88  D0AB 0446               4394      ADD.l       Sstorl(a3),d0       * add string store to -ve length
00001A8C  B090                    4395      CMP.l       (a0),d0         * compare with string address
00001A8E  6706                    4396      BEQ.s       LAB_2212            * if = go move string store pointer down
00001A90                          4397  
00001A90  2210                    4398      MOVE.l  (a0),d1         * highest = current
00001A92  2248                    4399      MOVEA.l a0,a1               * string to move = current
00001A94  4E75                    4400      RTS
00001A96                          4401  
00001A96                          4402  LAB_2212
00001A96  2740 0446               4403      MOVE.l  d0,Sstorl(a3)       * set new string store start
00001A9A                          4404  RTS_012
00001A9A  4E75                    4405      RTS
00001A9C                          4406  
00001A9C                          4407  
00001A9C                          4408  *************************************************************************************
00001A9C                          4409  *
00001A9C                          4410  * concatenate - add strings
00001A9C                          4411  * string descriptor 1 is in FAC1_m, string 2 is in line
00001A9C                          4412  
00001A9C                          4413  LAB_224D
00001A9C  487A F732               4414      PEA     LAB_1ADB(pc)        * continue evaluation after concatenate
00001AA0  2F2B 0590               4415      MOVE.l  FAC1_m(a3),-(sp)        * stack descriptor pointer for string 1
00001AA4                          4416  
00001AA4  6100 F806               4417      BSR     LAB_GVAL            * get value from line
00001AA8  4A2B 05B5               4418      TST.b       Dtypef(a3)          * test data type flag
00001AAC  6A00 EBE0               4419      BPL     LAB_TMER            * if type is not string do type mismatch error
00001AB0                          4420  
00001AB0  205F                    4421      MOVEA.l (sp)+,a0            * restore descriptor pointer for string 1
00001AB2                          4422  
00001AB2                          4423  *************************************************************************************
00001AB2                          4424  *
00001AB2                          4425  * concatenate
00001AB2                          4426  * string descriptor 1 is in a0, string descriptor 2 is in FAC1_m
00001AB2                          4427  
00001AB2                          4428  LAB_224E
00001AB2  226B 0590               4429      MOVEA.l FAC1_m(a3),a1       * copy descriptor pointer 2
00001AB6  3228 0004               4430      MOVE.w  4(a0),d1            * get length 1
00001ABA  D269 0004               4431      ADD.w       4(a1),d1            * add length 2
00001ABE  6500 EBCA               4432      BCS     LAB_SLER            * if overflow go do 'string too long' error
00001AC2                          4433  
00001AC2  2F08                    4434      MOVE.l  a0,-(sp)            * save descriptor pointer 1
00001AC4  6100 FEB6               4435      BSR     LAB_2115            * make space d1 bytes long
00001AC8  2748 0598               4436      MOVE.l  a0,FAC2_m(a3)       * save new string start pointer
00001ACC  2057                    4437      MOVEA.l (sp),a0         * copy descriptor pointer 1 from stack
00001ACE  3028 0004               4438      MOVE.w  4(a0),d0            * get length
00001AD2  2050                    4439      MOVEA.l (a0),a0         * get string pointer
00001AD4  6120                    4440      BSR.s       LAB_229E            * copy string d0 bytes long from a0 to Sutill
00001AD6                          4441                              * return with a0 = pointer, d1 = length
00001AD6                          4442  
00001AD6  206B 0590               4443      MOVEA.l FAC1_m(a3),a0       * get descriptor pointer for string 2
00001ADA  6138                    4444      BSR.s       LAB_22BA            * pop (a0) descriptor, returns with ..
00001ADC                          4445                              * a0 = pointer, d0 = length
00001ADC  6118                    4446      BSR.s       LAB_229E            * copy string d0 bytes long from a0 to Sutill
00001ADE                          4447                              * return with a0 = pointer, d1 = length
00001ADE                          4448  
00001ADE  205F                    4449      MOVEA.l (sp)+,a0            * get descriptor pointer for string 1
00001AE0  6132                    4450      BSR.s       LAB_22BA            * pop (a0) descriptor, returns with ..
00001AE2                          4451                              * d0 = length, a0 = pointer
00001AE2                          4452  
00001AE2  206B 0598               4453      MOVEA.l FAC2_m(a3),a0       * retreive result string pointer
00001AE6  2208                    4454      MOVE.l  a0,d1               * copy the result string pointer
00001AE8  6700 FE78               4455      BEQ     LAB_RTST            * if it is a null string just return it
00001AEC                          4456                              * a0 = pointer, d1 = length
00001AEC                          4457  
00001AEC  4481                    4458      NEG.l       d1              * else make the start pointer negative
00001AEE  D2AB 044E               4459      ADD.l       Sutill(a3),d1       * add the end pointert to give the length
00001AF2  6000 FE6E               4460      BRA     LAB_RTST            * push string on descriptor stack
00001AF6                          4461                              * a0 = pointer, d1 = length
00001AF6                          4462  
00001AF6                          4463  
00001AF6                          4464  *************************************************************************************
00001AF6                          4465  *
00001AF6                          4466  * copy string d0 bytes long from a0 to Sutill
00001AF6                          4467  * return with a0 = pointer, d1 = length
00001AF6                          4468  
00001AF6                          4469  LAB_229E
00001AF6  3200                    4470      MOVE.w  d0,d1               * copy and check length
00001AF8  6714                    4471      BEQ.s       RTS_013         * skip copy if null
00001AFA                          4472  
00001AFA  226B 044E               4473      MOVEA.l Sutill(a3),a1       * get destination pointer
00001AFE  2F09                    4474      MOVE.l  a1,-(sp)            * save destination string pointer
00001B00  5340                    4475      SUBQ.w  #1,d0               * subtract for DBF loop
00001B02                          4476  LAB_22A0
00001B02  12D8                    4477      MOVE.b  (a0)+,(a1)+         * copy byte
00001B04  51C8 FFFC               4478      DBF     d0,LAB_22A0         * loop if not done
00001B08                          4479  
00001B08  2749 044E               4480      MOVE.l  a1,Sutill(a3)       * update Sutill to end of copied string
00001B0C  205F                    4481      MOVEA.l (sp)+,a0            * restore destination string pointer
00001B0E                          4482  RTS_013
00001B0E  4E75                    4483      RTS
00001B10                          4484  
00001B10                          4485  
00001B10                          4486  *************************************************************************************
00001B10                          4487  *
00001B10                          4488  * pop string off descriptor stack, or from top of string space
00001B10                          4489  * returns with d0.l = length, a0 = pointer
00001B10                          4490  
00001B10                          4491  LAB_22B6
00001B10  206B 0590               4492      MOVEA.l FAC1_m(a3),a0       * get descriptor pointer
00001B14                          4493  
00001B14                          4494  
00001B14                          4495  *************************************************************************************
00001B14                          4496  *
00001B14                          4497  * pop (a0) descriptor off stack or from string space
00001B14                          4498  * returns with d0.l = length, a0 = pointer
00001B14                          4499  
00001B14                          4500  LAB_22BA
00001B14  48E7 4040               4501      MOVEM.l a1/d1,-(sp)         * save other regs
00001B18  B9C8                    4502      CMPA.l  a0,a4               * is string on the descriptor stack
00001B1A  6602                    4503      BNE.s       LAB_22BD            * skip pop if not
00001B1C                          4504  
00001B1C  5C4C                    4505      ADDQ.w  #$06,a4         * else update stack pointer
00001B1E                          4506  LAB_22BD
00001B1E  7000                    4507      MOVEQ       #0,d0               * clear string length longword
00001B20  2258                    4508      MOVEA.l (a0)+,a1            * get string address
00001B22  3018                    4509      MOVE.w  (a0)+,d0            * get string length
00001B24                          4510  
00001B24  B9C8                    4511      CMPA.l  a0,a4               * was it on the descriptor stack
00001B26  6610                    4512      BNE.s       LAB_22E6            * branch if it wasn't
00001B28                          4513  
00001B28  B3EB 0446               4514      CMPA.l  Sstorl(a3),a1       * compare string address with bottom of string
00001B2C                          4515                              * space
00001B2C  660A                    4516      BNE.s       LAB_22E6            * branch if <>
00001B2E                          4517  
00001B2E  7201                    4518      MOVEQ       #1,d1               * mask for odd bit
00001B30  C240                    4519      AND.w       d0,d1               * AND length
00001B32  D280                    4520      ADD.l       d0,d1               * make it fit word aligned length
00001B34                          4521  
00001B34  D3AB 0446               4522      ADD.l       d1,Sstorl(a3)       * add to bottom of string space
00001B38                          4523  LAB_22E6
00001B38  2049                    4524      MOVEA.l a1,a0               * copy to a0
00001B3A  4CDF 0202               4525      MOVEM.l (sp)+,a1/d1         * restore other regs
00001B3E  4A80                    4526      TST.l       d0              * set flags on length
00001B40  4E75                    4527      RTS
00001B42                          4528  
00001B42                          4529  
00001B42                          4530  *************************************************************************************
00001B42                          4531  *
00001B42                          4532  * perform CHR$()
00001B42                          4533  
00001B42                          4534  LAB_CHRS
00001B42  6100 0130               4535      BSR     LAB_EVBY            * evaluate byte expression, result in d0 and
00001B46                          4536                              * Itemp
00001B46  7201                    4537      MOVEQ       #1,d1               * string is single byte
00001B48  6100 FE32               4538      BSR     LAB_2115            * make string space d1 bytes long
00001B4C                          4539                              * return a0/Sutill = pointer, others unchanged
00001B4C  1080                    4540      MOVE.b  d0,(a0)         * save byte in string (byte IS string!)
00001B4E  6000 FE12               4541      BRA     LAB_RTST            * push string on descriptor stack
00001B52                          4542                              * a0 = pointer, d1 = length
00001B52                          4543  
00001B52                          4544  
00001B52                          4545  *************************************************************************************
00001B52                          4546  *
00001B52                          4547  * perform LEFT$()
00001B52                          4548  
00001B52                          4549  * enter with a0 is descriptor, d0 & Itemp is word 1
00001B52                          4550  
00001B52                          4551  LAB_LEFT
00001B52  C141                    4552      EXG     d0,d1               * word in d1
00001B54  6100 F796               4553      BSR     LAB_1BFB            * scan for ")", else do syntax error/warm start
00001B58                          4554  
00001B58  4A81                    4555      TST.l       d1              * test returned length
00001B5A  6722                    4556      BEQ.s       LAB_231C            * branch if null return
00001B5C                          4557  
00001B5C  7000                    4558      MOVEQ       #0,d0               * clear start offset
00001B5E  B268 0004               4559      CMP.w       4(a0),d1            * compare word parameter with string length
00001B62  651A                    4560      BCS.s       LAB_231C            * branch if string length > word parameter
00001B64                          4561  
00001B64  6014                    4562      BRA.s       LAB_2317            * go copy whole string
00001B66                          4563  
00001B66                          4564  
00001B66                          4565  *************************************************************************************
00001B66                          4566  *
00001B66                          4567  * perform RIGHT$()
00001B66                          4568  
00001B66                          4569  * enter with a0 is descriptor, d0 & Itemp is word 1
00001B66                          4570  
00001B66                          4571  LAB_RIGHT
00001B66  C141                    4572      EXG     d0,d1               * word in d1
00001B68  6100 F782               4573      BSR     LAB_1BFB            * scan for ")", else do syntax error/warm start
00001B6C                          4574  
00001B6C  4A81                    4575      TST.l       d1              * test returned length
00001B6E  670E                    4576      BEQ.s       LAB_231C            * branch if null return
00001B70                          4577  
00001B70  3028 0004               4578      MOVE.w  4(a0),d0            * get string length
00001B74  9081                    4579      SUB.l       d1,d0               * subtract word
00001B76  6406                    4580      BCC.s       LAB_231C            * branch if string length > word parameter
00001B78                          4581  
00001B78                          4582                              * else copy whole string
00001B78                          4583  LAB_2316
00001B78  7000                    4584      MOVEQ       #0,d0               * clear start offset
00001B7A                          4585  LAB_2317
00001B7A  3228 0004               4586      MOVE.w  4(a0),d1            * else make parameter = length
00001B7E                          4587  
00001B7E                          4588  * get here with ...
00001B7E                          4589  *   a0 - points to descriptor
00001B7E                          4590  *   d0 - is offset from string start
00001B7E                          4591  *   d1 - is required string length
00001B7E                          4592  
00001B7E                          4593  LAB_231C
00001B7E  2248                    4594      MOVEA.l a0,a1               * save string descriptor pointer
00001B80  6100 FDFA               4595      BSR     LAB_2115            * make string space d1 bytes long
00001B84                          4596                              * return a0/Sutill = pointer, others unchanged
00001B84  2049                    4597      MOVEA.l a1,a0               * restore string descriptor pointer
00001B86  2F00                    4598      MOVE.l  d0,-(sp)            * save start offset (longword)
00001B88  618A                    4599      BSR.s       LAB_22BA            * pop (a0) descriptor, returns with ..
00001B8A                          4600                              * d0 = length, a0 = pointer
00001B8A  D1DF                    4601      ADDA.l  (sp)+,a0            * adjust pointer to start of wanted string
00001B8C  3001                    4602      MOVE.w  d1,d0               * length to d0
00001B8E  6100 FF66               4603      BSR     LAB_229E            * store string d0 bytes long from (a0) to
00001B92                          4604                              * (Sutill) return with a0 = pointer,
00001B92                          4605                              * d1 = length
00001B92  6000 FDCE               4606      BRA     LAB_RTST            * push string on descriptor stack
00001B96                          4607                              * a0 = pointer, d1 = length
00001B96                          4608  
00001B96                          4609  
00001B96                          4610  *************************************************************************************
00001B96                          4611  *
00001B96                          4612  * perform MID$()
00001B96                          4613  
00001B96                          4614  * enter with a0 is descriptor, d0 & Itemp is word 1
00001B96                          4615  
00001B96                          4616  LAB_MIDS
00001B96  7E00                    4617      MOVEQ       #0,d7               * clear longword
00001B98  5347                    4618      SUBQ.w  #1,d7               * set default length = 65535
00001B9A  2F00                    4619      MOVE.l  d0,-(sp)            * save word 1
00001B9C  6100 F762               4620      BSR     LAB_GBYT            * scan memory
00001BA0  B03C 002C               4621      CMP.b       #',',d0         * was it ","
00001BA4  660C                    4622      BNE.s       LAB_2358            * branch if not "," (skip second byte get)
00001BA6                          4623  
00001BA6  101D                    4624      MOVE.b  (a5)+,d0            * increment pointer past ","
00001BA8  2F08                    4625      MOVE.l  a0,-(sp)            * save descriptor pointer
00001BAA  6100 00D8               4626      BSR     LAB_GTWO            * get word parameter, result in d0 and Itemp
00001BAE  205F                    4627      MOVEA.l (sp)+,a0            * restore descriptor pointer
00001BB0  2E00                    4628      MOVE.l  d0,d7               * copy length
00001BB2                          4629  LAB_2358
00001BB2  6100 F738               4630      BSR     LAB_1BFB            * scan for ")", else do syntax error then warm
00001BB6                          4631                              * start
00001BB6  201F                    4632      MOVE.l  (sp)+,d0            * restore word 1
00001BB8  7200                    4633      MOVEQ       #0,d1               * null length
00001BBA  5380                    4634      SUBQ.l  #1,d0               * decrement start index (word 1)
00001BBC  6B00 EAF0               4635      BMI     LAB_FCER            * if was null do function call error then warm
00001BC0                          4636                              * start
00001BC0                          4637  
00001BC0  B068 0004               4638      CMP.w       4(a0),d0            * compare string length with start index
00001BC4  64B8                    4639      BCC.s       LAB_231C            * if start not in string do null string (d1=0)
00001BC6                          4640  
00001BC6  2207                    4641      MOVE.l  d7,d1               * get length back
00001BC8  DE40                    4642      ADD.w       d0,d7               * d7 now = MID$() end
00001BCA  6506                    4643      BCS.s       LAB_2368            * already too long so do RIGHT$ equivalent
00001BCC                          4644  
00001BCC  BE68 0004               4645      CMP.w       4(a0),d7            * compare string length with start index+length
00001BD0  65AC                    4646      BCS.s       LAB_231C            * if end in string go do string
00001BD2                          4647  
00001BD2                          4648  LAB_2368
00001BD2  3228 0004               4649      MOVE.w  4(a0),d1            * get string length
00001BD6  9240                    4650      SUB.w       d0,d1               * subtract start offset
00001BD8  60A4                    4651      BRA.s       LAB_231C            * go do string (effectively RIGHT$)
00001BDA                          4652  
00001BDA                          4653  
00001BDA                          4654  *************************************************************************************
00001BDA                          4655  *
00001BDA                          4656  * perform LCASE$()
00001BDA                          4657  
00001BDA                          4658  LAB_LCASE
00001BDA  6100 FF34               4659      BSR     LAB_22B6            * pop string off descriptor stack or from memory
00001BDE                          4660                              * returns with d0 = length, a0 = pointer
00001BDE  2200                    4661      MOVE.l  d0,d1               * copy the string length
00001BE0  6756                    4662      BEQ.s       NoString            * if null go return a null string
00001BE2                          4663  
00001BE2                          4664  * else copy and change the string
00001BE2                          4665  
00001BE2  2248                    4666      MOVEA.l a0,a1               * copy the string address
00001BE4  6100 FD96               4667      BSR     LAB_2115            * make a string space d1 bytes long
00001BE8  D1C1                    4668      ADDA.l  d1,a0               * new string end
00001BEA  D3C1                    4669      ADDA.l  d1,a1               * old string end
00001BEC  3401                    4670      MOVE.w  d1,d2               * copy length for loop
00001BEE  5342                    4671      SUBQ.w  #1,d2               * -1 for DBF loop
00001BF0                          4672  LC_loop
00001BF0  1021                    4673      MOVE.b  -(a1),d0            * get byte from string
00001BF2                          4674  
00001BF2  B03C 005B               4675      CMP.b       #$5B,d0         * compare with "Z"+1
00001BF6  640A                    4676      BCC.s       NoUcase         * if > "Z" skip change
00001BF8                          4677  
00001BF8  B03C 0041               4678      CMP.b       #$41,d0         * compare with "A"
00001BFC  6504                    4679      BCS.s       NoUcase         * if < "A" skip change
00001BFE                          4680  
00001BFE  0000 0020               4681      ORI.b       #$20,d0         * convert upper case to lower case
00001C02                          4682  NoUcase
00001C02  1100                    4683      MOVE.b  d0,-(a0)            * copy upper case byte back to string
00001C04  51CA FFEA               4684      DBF     d2,LC_loop          * decrement and loop if not all done
00001C08                          4685  
00001C08  602E                    4686      BRA.s       NoString            * tidy up & exit (branch always)
00001C0A                          4687  
00001C0A                          4688  
00001C0A                          4689  *************************************************************************************
00001C0A                          4690  *
00001C0A                          4691  * perform UCASE$()
00001C0A                          4692  
00001C0A                          4693  LAB_UCASE
00001C0A  6100 FF04               4694      BSR     LAB_22B6            * pop string off descriptor stack or from memory
00001C0E                          4695                              * returns with d0 = length, a0 = pointer
00001C0E  2200                    4696      MOVE.l  d0,d1               * copy the string length
00001C10  6726                    4697      BEQ.s       NoString            * if null go return a null string
00001C12                          4698  
00001C12                          4699  * else copy and change the string
00001C12                          4700  
00001C12  2248                    4701      MOVEA.l a0,a1               * copy the string address
00001C14  6100 FD66               4702      BSR     LAB_2115            * make a string space d1 bytes long
00001C18  D1C1                    4703      ADDA.l  d1,a0               * new string end
00001C1A  D3C1                    4704      ADDA.l  d1,a1               * old string end
00001C1C  3401                    4705      MOVE.w  d1,d2               * copy length for loop
00001C1E  5342                    4706      SUBQ.w  #1,d2               * -1 for DBF loop
00001C20                          4707  UC_loop
00001C20  1021                    4708      MOVE.b  -(a1),d0            * get a byte from the string
00001C22                          4709  
00001C22  B03C 0061               4710      CMP.b       #$61,d0         * compare with "a"
00001C26  650A                    4711      BCS.s       NoLcase         * if < "a" skip change
00001C28                          4712  
00001C28  B03C 007B               4713      CMP.b       #$7B,d0         * compare with "z"+1
00001C2C  6404                    4714      BCC.s       NoLcase         * if > "z" skip change
00001C2E                          4715  
00001C2E  0200 00DF               4716      ANDI.b  #$DF,d0         * convert lower case to upper case
00001C32                          4717  NoLcase
00001C32  1100                    4718      MOVE.b  d0,-(a0)            * copy upper case byte back to string
00001C34  51CA FFEA               4719      DBF     d2,UC_loop          * decrement and loop if not all done
00001C38                          4720  
00001C38                          4721  NoString
00001C38  6000 FD28               4722      BRA     LAB_RTST            * push string on descriptor stack
00001C3C                          4723                              * a0 = pointer, d1 = length
00001C3C                          4724  
00001C3C                          4725  
00001C3C                          4726  *************************************************************************************
00001C3C                          4727  *
00001C3C                          4728  * perform SADD()
00001C3C                          4729  
00001C3C                          4730  LAB_SADD
00001C3C  101D                    4731      MOVE.b  (a5)+,d0            * increment pointer
00001C3E  6100 F8D6               4732      BSR     LAB_GVAR            * get variable address in a0
00001C42  6100 F6A8               4733      BSR     LAB_1BFB            * scan for ")", else do syntax error/warm start
00001C46  4A2B 05B5               4734      TST.b       Dtypef(a3)          * test data type flag
00001C4A  6A00 EA42               4735      BPL     LAB_TMER            * if numeric do Type missmatch Error
00001C4E                          4736  
00001C4E                          4737  * if you want a non existant variable to return a null value then set the novar
00001C4E                          4738  * value at the top of this file to some non zero value
00001C4E                          4739  
00001C4E                 FALSE    4740   ifne   novar
00001C4E                          4741   endc
00001C4E                          4742  
00001C4E  2010                    4743      MOVE.l  (a0),d0         * get string address
00001C50  6000 FBB4               4744      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & return
00001C54                          4745  
00001C54                          4746  
00001C54                          4747  *************************************************************************************
00001C54                          4748  *
00001C54                          4749  * perform LEN()
00001C54                          4750  
00001C54                          4751  LAB_LENS
00001C54  487A FBB0               4752      PEA     LAB_AYFC(pc)        * set return address to convert d0 to signed
00001C58                          4753                              * longword in FAC1
00001C58  6000 FEB6               4754      BRA     LAB_22B6            * pop string off descriptor stack or from memory
00001C5C                          4755                              * returns with d0 = length, a0 = pointer
00001C5C                          4756  
00001C5C                          4757  
00001C5C                          4758  *************************************************************************************
00001C5C                          4759  *
00001C5C                          4760  * perform ASC()
00001C5C                          4761  
00001C5C                          4762  LAB_ASC
00001C5C  6100 FEB2               4763      BSR     LAB_22B6            * pop string off descriptor stack or from memory
00001C60                          4764                              * returns with d0 = length, a0 = pointer
00001C60  4A40                    4765      TST.w       d0              * test length
00001C62  6700 EA4A               4766      BEQ     LAB_FCER            * if null do function call error then warm start
00001C66                          4767  
00001C66  1010                    4768      MOVE.b  (a0),d0         * get first character byte
00001C68  6000 FBBC               4769      BRA     LAB_1FD0            * convert d0 to unsigned byte in FAC1 & return
00001C6C                          4770  
00001C6C                          4771  
00001C6C                          4772  *************************************************************************************
00001C6C                          4773  *
00001C6C                          4774  * increment and get byte, result in d0 and Itemp
00001C6C                          4775  
00001C6C                          4776  LAB_SGBY
00001C6C  6100 F690               4777      BSR     LAB_IGBY            * increment & scan memory
00001C70                          4778  
00001C70                          4779  
00001C70                          4780  *************************************************************************************
00001C70                          4781  *
00001C70                          4782  * get byte parameter, result in d0 and Itemp
00001C70                          4783  
00001C70                          4784  LAB_GTBY
00001C70  6100 F514               4785      BSR     LAB_EVNM            * evaluate expression & check is numeric,
00001C74                          4786                              * else do type mismatch
00001C74                          4787  
00001C74                          4788  
00001C74                          4789  *************************************************************************************
00001C74                          4790  *
00001C74                          4791  * evaluate byte expression, result in d0 and Itemp
00001C74                          4792  
00001C74                          4793  LAB_EVBY
00001C74  6100 F9D4               4794      BSR     LAB_EVPI            * evaluate positive integer expression
00001C78                          4795                              * result in d0 and Itemp
00001C78  7280                    4796      MOVEQ       #$80,d1         * set mask/2
00001C7A  D281                    4797      ADD.l       d1,d1               * =$FFFFFF00
00001C7C  C280                    4798      AND.l       d0,d1               * check top 24 bits
00001C7E  6600 EA2E               4799      BNE     LAB_FCER            * if <> 0 do function call error/warm start
00001C82                          4800  
00001C82  4E75                    4801      RTS
00001C84                          4802  
00001C84                          4803  
00001C84                          4804  *************************************************************************************
00001C84                          4805  *
00001C84                          4806  * get word parameter, result in d0 and Itemp
00001C84                          4807  
00001C84                          4808  LAB_GTWO
00001C84  6100 F500               4809      BSR     LAB_EVNM            * evaluate expression & check is numeric,
00001C88                          4810                              * else do type mismatch
00001C88  6100 F9C0               4811      BSR     LAB_EVPI            * evaluate positive integer expression
00001C8C                          4812                              * result in d0 and Itemp
00001C8C  4840                    4813      SWAP        d0              * copy high word to low word
00001C8E  4A40                    4814      TST.w       d0              * set flags
00001C90  6600 EA1C               4815      BNE     LAB_FCER            * if <> 0 do function call error/warm start
00001C94                          4816  
00001C94  4840                    4817      SWAP        d0              * copy high word to low word
00001C96  4E75                    4818      RTS
00001C98                          4819  
00001C98                          4820  
00001C98                          4821  *************************************************************************************
00001C98                          4822  *
00001C98                          4823  * perform VAL()
00001C98                          4824  
00001C98                          4825  LAB_VAL
00001C98  6100 FE76               4826      BSR     LAB_22B6            * pop string off descriptor stack or from memory
00001C9C                          4827                              * returns with d0 = length, a0 = pointer
00001C9C  6722                    4828      BEQ.s       LAB_VALZ            * string was null so set result = $00
00001C9E                          4829                              * clear FAC1 exponent & sign & return
00001C9E                          4830  
00001C9E  2C4D                    4831      MOVEA.l a5,a6               * save BASIC execute pointer
00001CA0  2A48                    4832      MOVEA.l a0,a5               * copy string pointer to execute pointer
00001CA2  D1C0                    4833      ADDA.l  d0,a0               * string end+1
00001CA4  1010                    4834      MOVE.b  (a0),d0         * get byte from string+1
00001CA6  3F00                    4835      MOVE.w  d0,-(sp)            * save it
00001CA8  2F08                    4836      MOVE.l  a0,-(sp)            * save address
00001CAA  10BC 0000               4837      MOVE.b  #0,(a0)         * null terminate string
00001CAE  6100 F650               4838      BSR     LAB_GBYT            * scan memory
00001CB2  6100 1374               4839      BSR     LAB_2887            * get FAC1 from string
00001CB6  205F                    4840      MOVEA.l (sp)+,a0            * restore pointer
00001CB8  301F                    4841      MOVE.w  (sp)+,d0            * pop byte
00001CBA  1080                    4842      MOVE.b  d0,(a0)         * restore to memory
00001CBC  2A4E                    4843      MOVEA.l a6,a5               * restore BASIC execute pointer
00001CBE  4E75                    4844      RTS
00001CC0                          4845  
00001CC0                          4846  LAB_VALZ
00001CC0  3740 0594               4847      MOVE.w  d0,FAC1_e(a3)       * clear FAC1 exponent & sign
00001CC4  4E75                    4848      RTS
00001CC6                          4849  
00001CC6                          4850  
00001CC6                          4851  *************************************************************************************
00001CC6                          4852  *
00001CC6                          4853  * get two parameters for POKE or WAIT, first parameter in a0, second in d0
00001CC6                          4854  
00001CC6                          4855  LAB_GADB
00001CC6  6100 F4BE               4856      BSR     LAB_EVNM            * evaluate expression & check is numeric,
00001CCA                          4857                              * else do type mismatch
00001CCA  6100 F986               4858      BSR     LAB_EVIR            * evaluate integer expression
00001CCE                          4859                              * (does FC error not OF error if out of range)
00001CCE  2F00                    4860      MOVE.l  d0,-(sp)            * copy to stack
00001CD0  6100 F622               4861      BSR     LAB_1C01            * scan for ",", else do syntax error/warm start
00001CD4  619A                    4862      BSR.s       LAB_GTBY            * get byte parameter, result in d0 and Itemp
00001CD6  205F                    4863      MOVEA.l (sp)+,a0            * pull address
00001CD8  4E75                    4864      RTS
00001CDA                          4865  
00001CDA                          4866  
00001CDA                          4867  *************************************************************************************
00001CDA                          4868  *
00001CDA                          4869  * get two parameters for DOKE or WAITW, first parameter in a0, second in d0
00001CDA                          4870  
00001CDA                          4871  LAB_GADW
00001CDA  611E                    4872      BSR.s       LAB_GEAD            * get even address for word/long memory actions
00001CDC                          4873                              * address returned in d0 and on the stack
00001CDC  6100 F616               4874      BSR     LAB_1C01            * scan for ",", else do syntax error/warm start
00001CE0  6100 F4A4               4875      BSR     LAB_EVNM            * evaluate expression & check is numeric,
00001CE4                          4876                              * else do type mismatch
00001CE4  6100 F96C               4877      BSR     LAB_EVIR            * evaluate integer expression
00001CE8                          4878                              * result in d0 and Itemp
00001CE8  4840                    4879      SWAP        d0              * swap words
00001CEA  4A40                    4880      TST.w       d0              * test high word
00001CEC  6706                    4881      BEQ.s       LAB_XGADW           * exit if null
00001CEE                          4882  
00001CEE  5240                    4883      ADDQ.w  #1,d0               * increment word
00001CF0  6600 E9BC               4884      BNE     LAB_FCER            * if <> 0 do function call error/warm start
00001CF4                          4885  
00001CF4                          4886  LAB_XGADW
00001CF4  4840                    4887      SWAP        d0              * swap words back
00001CF6  205F                    4888      MOVEA.l (sp)+,a0            * pull address
00001CF8  4E75                    4889      RTS
00001CFA                          4890  
00001CFA                          4891  
00001CFA                          4892  *************************************************************************************
00001CFA                          4893  *
00001CFA                          4894  * get even address (for word or longword memory actions)
00001CFA                          4895  * address returned in d0 and on the stack
00001CFA                          4896  * does address error if the address is odd
00001CFA                          4897  
00001CFA                          4898  LAB_GEAD
00001CFA  6100 F48A               4899      BSR     LAB_EVNM            * evaluate expression & check is numeric,
00001CFE                          4900                              * else do type mismatch
00001CFE  6100 F952               4901      BSR     LAB_EVIR            * evaluate integer expression
00001D02                          4902                              * (does FC error not OF error if out of range)
00001D02  0800 0000               4903      BTST        #0,d0               * test low bit of longword
00001D06  6600 E962               4904      BNE     LAB_ADER            * if address is odd do address error/warm start
00001D0A                          4905  
00001D0A  2057                    4906      MOVEA.l (sp),a0         * copy return address
00001D0C  2E80                    4907      MOVE.l  d0,(sp)         * even address on stack
00001D0E  4ED0                    4908      JMP     (a0)                * effectively RTS
00001D10                          4909  
00001D10                          4910  
00001D10                          4911  *************************************************************************************
00001D10                          4912  *
00001D10                          4913  * perform PEEK()
00001D10                          4914  
00001D10                          4915  LAB_PEEK
00001D10  6100 F940               4916      BSR     LAB_EVIR            * evaluate integer expression
00001D14                          4917                              * (does FC error not OF error if out of range)
00001D14  2040                    4918      MOVEA.l d0,a0               * copy to address register
00001D16  1010                    4919      MOVE.b  (a0),d0         * get byte
00001D18  6000 FB0C               4920      BRA     LAB_1FD0            * convert d0 to unsigned byte in FAC1 & return
00001D1C                          4921  
00001D1C                          4922  
00001D1C                          4923  *************************************************************************************
00001D1C                          4924  *
00001D1C                          4925  * perform POKE
00001D1C                          4926  
00001D1C                          4927  LAB_POKE
00001D1C  61A8                    4928      BSR.s       LAB_GADB            * get two parameters for POKE or WAIT
00001D1E                          4929                              * first parameter in a0, second in d0
00001D1E  1080                    4930      MOVE.b  d0,(a0)         * put byte in memory
00001D20  4E75                    4931      RTS
00001D22                          4932  
00001D22                          4933  
00001D22                          4934  *************************************************************************************
00001D22                          4935  *
00001D22                          4936  * perform DEEK()
00001D22                          4937  
00001D22                          4938  LAB_DEEK
00001D22  6100 F92E               4939      BSR     LAB_EVIR            * evaluate integer expression
00001D26                          4940                              * (does FC error not OF error if out of range)
00001D26  E208                    4941      LSR.b       #1,d0               * shift bit 0 to carry
00001D28  6500 E940               4942      BCS     LAB_ADER            * if address is odd do address error/warm start
00001D2C                          4943  
00001D2C  D000                    4944      ADD.b       d0,d0               * shift byte back
00001D2E  C188                    4945      EXG     d0,a0               * copy to address register
00001D30  7000                    4946      MOVEQ       #0,d0               * clear top bits
00001D32  3010                    4947      MOVE.w  (a0),d0         * get word
00001D34  6000 FAD0               4948      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & return
00001D38                          4949  
00001D38                          4950  
00001D38                          4951  *************************************************************************************
00001D38                          4952  *
00001D38                          4953  * perform LEEK()
00001D38                          4954  
00001D38                          4955  LAB_LEEK
00001D38  6100 F918               4956      BSR     LAB_EVIR            * evaluate integer expression
00001D3C                          4957                              * (does FC error not OF error if out of range)
00001D3C  E208                    4958      LSR.b       #1,d0               * shift bit 0 to carry
00001D3E  6500 E92A               4959      BCS     LAB_ADER            * if address is odd do address error/warm start
00001D42                          4960  
00001D42  D000                    4961      ADD.b       d0,d0               * shift byte back
00001D44  C188                    4962      EXG     d0,a0               * copy to address register
00001D46  2010                    4963      MOVE.l  (a0),d0         * get longword
00001D48  6000 FABC               4964      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & return
00001D4C                          4965  
00001D4C                          4966  
00001D4C                          4967  *************************************************************************************
00001D4C                          4968  *
00001D4C                          4969  * perform DOKE
00001D4C                          4970  
00001D4C                          4971  LAB_DOKE
00001D4C  618C                    4972      BSR.s       LAB_GADW            * get two parameters for DOKE or WAIT
00001D4E                          4973                              * first parameter in a0, second in d0
00001D4E  3080                    4974      MOVE.w  d0,(a0)         * put word in memory
00001D50  4E75                    4975      RTS
00001D52                          4976  
00001D52                          4977  
00001D52                          4978  *************************************************************************************
00001D52                          4979  *
00001D52                          4980  * perform LOKE
00001D52                          4981  
00001D52                          4982  LAB_LOKE
00001D52  61A6                    4983      BSR.s       LAB_GEAD            * get even address for word/long memory actions
00001D54                          4984                              * address returned in d0 and on the stack
00001D54  6100 F59E               4985      BSR     LAB_1C01            * scan for ",", else do syntax error/warm start
00001D58  6100 F42C               4986      BSR     LAB_EVNM            * evaluate expression & check is numeric,
00001D5C                          4987                              * else do type mismatch
00001D5C  6100 F8F4               4988      BSR     LAB_EVIR            * evaluate integer value (no sign check)
00001D60  205F                    4989      MOVEA.l (sp)+,a0            * pull address
00001D62  2080                    4990      MOVE.l  d0,(a0)         * put longword in memory
00001D64                          4991  RTS_015
00001D64  4E75                    4992      RTS
00001D66                          4993  
00001D66                          4994  
00001D66                          4995  *************************************************************************************
00001D66                          4996  *
00001D66                          4997  * perform SWAP
00001D66                          4998  
00001D66                          4999  LAB_SWAP
00001D66  6100 F7AE               5000      BSR     LAB_GVAR            * get variable 1 address in a0
00001D6A  2F08                    5001      MOVE.l  a0,-(sp)            * save variable 1 address
00001D6C  182B 05B5               5002      MOVE.b  Dtypef(a3),d4       * copy variable 1 data type, $80=string,
00001D70                          5003                              * $40=inetger, $00=float
00001D70                          5004  
00001D70  6100 F582               5005      BSR     LAB_1C01            * scan for ",", else do syntax error/warm start
00001D74  6100 F7A0               5006      BSR     LAB_GVAR            * get variable 2 address in a0
00001D78  245F                    5007      MOVEA.l (sp)+,a2            * restore variable 1 address
00001D7A  B82B 05B5               5008      CMP.b       Dtypef(a3),d4       * compare variable 1 data type with variable 2
00001D7E                          5009                              * data type
00001D7E  6600 E90E               5010      BNE     LAB_TMER            * if not both the same type do "Type mismatch"
00001D82                          5011                              * error then warm start
00001D82                          5012  
00001D82                          5013  * if you do want a non existant variable to return an error then leave the novar
00001D82                          5014  * value at the top of this file set to zero
00001D82                          5015  
00001D82                 TRUE     5016   ifeq   novar
00001D82                          5017  
00001D82  2010                    5018      MOVE.l  (a0),d0         * get variable 2
00001D84  20D2                    5019      MOVE.l  (a2),(a0)+          * copy variable 1 to variable 2
00001D86  24C0                    5020      MOVE.l  d0,(a2)+            * save variable 2 to variable 1
00001D88                          5021  
00001D88  4A04                    5022      TST.b       d4              * check data type
00001D8A  6AD8                    5023      BPL.s       RTS_015         * exit if not string
00001D8C                          5024  
00001D8C  3010                    5025      MOVE.w  (a0),d0         * get string 2 length
00001D8E  3092                    5026      MOVE.w  (a2),(a0)           * copy string 1 length to string 2 length
00001D90  3480                    5027      MOVE.w  d0,(a2)         * save string 2 length to string 1 length
00001D92                          5028  
00001D92                          5029   endc
00001D92                          5030  
00001D92                          5031  
00001D92                          5032  * if you want a non existant variable to return a null value then set the novar
00001D92                          5033  * value at the top of this file to some non zero value
00001D92                          5034  
00001D92                 FALSE    5035   ifne   novar
00001D92                          5036                              * value get
00001D92                          5037                              * value get and the new value save
00001D92                          5038                              * new length save
00001D92                          5039                              * new value save
00001D92                          5040   endc
00001D92                          5041  
00001D92  4E75                    5042      RTS
00001D94                          5043  
00001D94                          5044  
00001D94                          5045  *************************************************************************************
00001D94                          5046  *
00001D94                          5047  * perform USR
00001D94                          5048  
00001D94                          5049  LAB_USR
00001D94  4EAB 0406               5050      JSR     Usrjmp(a3)          * do user vector
00001D98  6000 F552               5051      BRA     LAB_1BFB            * scan for ")", else do syntax error/warm start
00001D9C                          5052  
00001D9C                          5053  
00001D9C                          5054  *************************************************************************************
00001D9C                          5055  *
00001D9C                          5056  * perform LOAD
00001D9C                          5057  
00001D9C                          5058  LAB_LOAD
00001D9C  4EEB 0418               5059      JMP     V_LOAD(a3)          * do the load vector 
00001DA0                          5060  
00001DA0                          5061  
00001DA0                          5062  *************************************************************************************
00001DA0                          5063  *
00001DA0                          5064  * perform SAVE
00001DA0                          5065  
00001DA0                          5066  LAB_SAVE
00001DA0  4EEB 041E               5067      JMP     V_SAVE(a3)          * do the save vector
00001DA4                          5068  
00001DA4                          5069  
00001DA4                          5070  *************************************************************************************
00001DA4                          5071  *
00001DA4                          5072  * perform CALL
00001DA4                          5073  
00001DA4                          5074  LAB_CALL
00001DA4  487A F55A               5075      PEA     LAB_GBYT(pc)        * put return address on stack
00001DA8  6100 FF50               5076      BSR     LAB_GEAD            * get even address for word/long memory actions
00001DAC                          5077                              * address returned in d0 and on the stack
00001DAC  4E75                    5078      RTS                     * effectively calls the routine
00001DAE                          5079  
00001DAE                          5080  * if the called routine exits correctly then it will return via the get byte routine.
00001DAE                          5081  * this will then get the next byte for the interpreter and return
00001DAE                          5082  
00001DAE                          5083  
00001DAE                          5084  *************************************************************************************
00001DAE                          5085  *
00001DAE                          5086  * perform WAIT
00001DAE                          5087  
00001DAE                          5088  LAB_WAIT
00001DAE  6100 FF16               5089      BSR     LAB_GADB            * get two parameters for POKE or WAIT
00001DB2                          5090                              * first parameter in a0, second in d0
00001DB2  2F08                    5091      MOVE.l  a0,-(sp)            * save address
00001DB4  3F00                    5092      MOVE.w  d0,-(sp)            * save byte
00001DB6  7400                    5093      MOVEQ       #0,d2               * clear mask
00001DB8  6100 F546               5094      BSR     LAB_GBYT            * scan memory
00001DBC  6706                    5095      BEQ.s       LAB_2441            * skip if no third argument
00001DBE                          5096  
00001DBE  6100 F530               5097      BSR     LAB_SCGB            * scan for "," & get byte,
00001DC2                          5098                              * else do syntax error/warm start
00001DC2  2400                    5099      MOVE.l  d0,d2               * copy mask
00001DC4                          5100  LAB_2441
00001DC4  321F                    5101      MOVE.w  (sp)+,d1            * get byte
00001DC6  205F                    5102      MOVEA.l (sp)+,a0            * get address
00001DC8                          5103  LAB_2445
00001DC8  1010                    5104      MOVE.b  (a0),d0         * read memory byte
00001DCA  B500                    5105      EOR.b       d2,d0               * EOR with second argument (mask)
00001DCC  C001                    5106      AND.b       d1,d0               * AND with first argument (byte)
00001DCE  67F8                    5107      BEQ.s       LAB_2445            * loop if result is zero
00001DD0                          5108  
00001DD0  4E75                    5109      RTS
00001DD2                          5110  
00001DD2                          5111  *************************************************************************************
00001DD2                          5112  * EASy68k extension function                                        *
00001DD2                          5113  *************************************************************************************
00001DD2                          5114  *
00001DD2                          5115  * perform TI
00001DD2                          5116  
00001DD2                          5117  LAB_TI
00001DD2  7008                    5118      MOVEQ       #8,d0               * get time
00001DD4  4E4F                    5119      TRAP        #15             * do I/O function
00001DD6  2741 0590               5120      MOVE.l  d1,FAC1_m(a3)       * time (in 100ths seconds) into FAC1
00001DDA  377C A000 0594          5121      MOVE.w  #$A000,FAC1_e(a3)       * time exponent and sign
00001DE0  6000 02B0               5122      BRA     LAB_24D5            * normalise FAC1 & return
00001DE4                          5123  
00001DE4                          5124  
00001DE4                          5125  *************************************************************************************
00001DE4                          5126  *
00001DE4                          5127  * perform KEYS()
00001DE4                          5128  
00001DE4                          5129  LAB_KEYS
00001DE4  4A2B 05B5               5130      TST.b       Dtypef(a3)          * test data type, $80=string, $40=integer,
00001DE8                          5131                              * $00=float
00001DE8  6B12                    5132      BMI.s       LAB_KESS            * branch if string
00001DEA                          5133  
00001DEA  6100 F866               5134      BSR     LAB_EVIR            * evaluate integer expression (no sign check)
00001DEE                          5135                              * result in d0 and Itemp
00001DEE                          5136  LAB_KEZZ
00001DEE  2200                    5137      MOVE.l  d0,d1               * copy key value to parameter
00001DF0                          5138  LAB_KETT
00001DF0  103C 0013               5139      MOVE.b  #19,d0          * check for keypress
00001DF4  4E4F                    5140      TRAP        #15
00001DF6                          5141  
00001DF6  2001                    5142      MOVE.l  d1,d0               * copy result
00001DF8  6000 FA0C               5143      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & RET
00001DFC                          5144  
00001DFC                          5145  LAB_KESS
00001DFC  6100 FD12               5146      BSR     LAB_22B6            * pop string off descriptor stack or from memory
00001E00                          5147                              * returns with d0 = length, a0 = pointer
00001E00  67EC                    5148      BEQ     LAB_KEZZ            * return last key if null string
00001E02                          5149  
00001E02  B07C 0005               5150      CMP.w       #5,d0               * compare length with max+1
00001E06  6502                    5151      BCS.s       LAB_KKSS            * branch if <= 4
00001E08                          5152  
00001E08  7004                    5153      MOVEQ       #4,d0               * else make = 4
00001E0A                          5154  LAB_KKSS
00001E0A  7200                    5155      MOVEQ       #0,d1               * clear parameter
00001E0C  5340                    5156      SUBQ.w  #1,d0               * -1 for BF loop
00001E0E                          5157  LAB_KSSS
00001E0E  E181                    5158      ASL.l       #8,d1               * shift any previous characters along
00001E10  1218                    5159      MOVE.b  (a0)+,d1            * get byte from string
00001E12  51C8 FFFA               5160      DBF     d0,LAB_KSSS         * decrement count and loop if not done yet
00001E16                          5161  
00001E16  60D8                    5162      BRA.s       LAB_KETT            * go test the keys
00001E18                          5163  
00001E18                          5164  
00001E18                          5165  *************************************************************************************
00001E18                          5166  
00001E18                          5167  *************************************************************************************
00001E18                          5168  * EASy68k graphics extension function                               *
00001E18                          5169  *************************************************************************************
00001E18                          5170  *
00001E18                          5171  * perform POINT(X,Y) function
00001E18                          5172  
00001E18                          5173  LAB_FPOINT
00001E18  101D                    5174      MOVE.b  (a5)+,d0            * increment BASIC execute pointer
00001E1A                          5175                              * fastest/shortest method
00001E1A  7028                    5176      MOVEQ       #$28,d0         * load d0 with "("
00001E1C  6100 F4D8               5177      BSR     LAB_SCCA            * scan for "(", else do syntax error/warm start
00001E20  611A                    5178      BSR.s       LAB_GTSW            * get X co-ordinate
00001E22  2F00                    5179      MOVE.l  d0,-(sp)            * save X co-ordinate
00001E24  6100 F4CE               5180      BSR     LAB_1C01            * scan for "," else do syntax error/warm start
00001E28  6112                    5181      BSR.s       LAB_GTSW            * get Y co-ordinate
00001E2A  2F00                    5182      MOVE.l  d0,-(sp)            * save Y co-ordinate
00001E2C  6100 F4BE               5183      BSR     LAB_1BFB            * scan for ")", else do syntax error/warm start
00001E30  241F                    5184      MOVE.l  (sp)+,d2            * restore Y co-ordinate
00001E32  221F                    5185      MOVE.l  (sp)+,d1            * restore X co-ordinate
00001E34  7053                    5186      MOVEQ       #83,d0          * read pixel colour
00001E36  4E4F                    5187      TRAP        #15             * do I/O function
00001E38  6000 F9CC               5188      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & RET
00001E3C                          5189  
00001E3C                          5190  *************************************************************************************
00001E3C                          5191  * EASy68k graphics extension commands                               *
00001E3C                          5192  *************************************************************************************
00001E3C                          5193  
00001E3C                          5194  * get signed word parameter, result in d0 and Itemp
00001E3C                          5195  
00001E3C                          5196  LAB_GTSW
00001E3C  6100 F348               5197      BSR     LAB_EVNM            * evaluate expression & check is numeric,
00001E40                          5198                              * else do type mismatch
00001E40  6100 F810               5199      BSR     LAB_EVIR            * evaluate integer expression
00001E44                          5200                              * result in d0 and Itemp
00001E44                          5201  
00001E44                          5202  
00001E44                          5203  *************************************************************************************
00001E44                          5204  *
00001E44                          5205  * test signed word parameter in d0, must be -32769 < value < 32768
00001E44                          5206  
00001E44                          5207  LAB_EVSW
00001E44  4840                    5208      SWAP        d0              * copy high word to low word
00001E46  4A40                    5209      TST.w       d0              * set flags
00001E48  6700 0008               5210      BEQ     LAB_ISWD            * branch if -1 < value < 32768
00001E4C                          5211  
00001E4C  5240                    5212      ADDQ.w  #1,d0               * else check $FFFF
00001E4E  6600 E85E               5213      BNE     LAB_FCER            * if <> 0 do function call error/warm start
00001E52                          5214  
00001E52                          5215  LAB_ISWD
00001E52  4840                    5216      SWAP        d0              * copy high word to low word
00001E54  4E75                    5217      RTS
00001E56                          5218  
00001E56                          5219  
00001E56                          5220  *************************************************************************************
00001E56                          5221  *
00001E56                          5222  * get graphics parameters, return count in d1.w
00001E56                          5223  * numeric parameters are evaluated and stacked until the command end or an
00001E56                          5224  * error is detected. the parameters are all long integers
00001E56                          5225  
00001E56                          5226  LAB_GGPR
00001E56  7200                    5227      MOVEQ       #0,d1               * clear parameter count
00001E58                          5228  LAB_GGLP
00001E58  3F01                    5229      MOVE.w  d1,-(sp)            * save parameter count
00001E5A  6100 F32A               5230      BSR     LAB_EVNM            * evaluate expression & check is numeric,
00001E5E                          5231                              * else do type mismatch
00001E5E  6100 F7F2               5232      BSR     LAB_EVIR            * evaluate integer expression
00001E62                          5233                              * result in d0 and Itemp
00001E62  321F                    5234      MOVE.w  (sp)+,d1            * get parameter count
00001E64  2417                    5235      MOVE.l  (sp),d2         * copy return address
00001E66  2E80                    5236      MOVE.l  d0,(sp)         * save parameter
00001E68  2F02                    5237      MOVE.l  d2,-(sp)            * save return address
00001E6A  5241                    5238      ADDQ.w  #1,d1               * increment parameter count
00001E6C  6100 F492               5239      BSR     LAB_GBYT            * get BASIC byte
00001E70  6700 0010               5240      BEQ     LAB_GGEX            * no more parameters so exit
00001E74                          5241  
00001E74  B03C 002C               5242      CMP.b       #',',d0         * check next byte is ","
00001E78  6600 E840               5243      BNE     LAB_SNER            * do error if not
00001E7C                          5244  
00001E7C  6100 F480               5245      BSR     LAB_IGBY            * increment & scan memory
00001E80  60D6                    5246      BRA.s       LAB_GGLP            * go get next parameter
00001E82                          5247  
00001E82                          5248  LAB_GGEX
00001E82  4E75                    5249      RTS
00001E84                          5250  
00001E84                          5251  
00001E84                          5252  *************************************************************************************
00001E84                          5253  *
00001E84                          5254  * set line colour d0
00001E84                          5255  
00001E84                          5256  LAB_SLCO
00001E84  3F01                    5257      MOVE.w  d1,-(sp)            * save parameter count
00001E86  223C 00FFFFFF           5258      MOVE.l  #$FFFFFF,d1         * set mask
00001E8C  C280                    5259      AND.l       d0,d1               * and line colour
00001E8E  7050                    5260      MOVEQ       #80,d0          * set pen colour
00001E90  4E4F                    5261      TRAP        #15             * do I/O function
00001E92  321F                    5262      MOVE.w  (sp)+,d1            * get parameter count back
00001E94  4E75                    5263      RTS
00001E96                          5264  
00001E96                          5265  
00001E96                          5266  *************************************************************************************
00001E96                          5267  *
00001E96                          5268  * set fill colour d0
00001E96                          5269  
00001E96                          5270  LAB_SFCO
00001E96  3F01                    5271      MOVE.w  d1,-(sp)            * save parameter count
00001E98  223C 00FFFFFF           5272      MOVE.l  #$FFFFFF,d1         * set mask
00001E9E  C280                    5273      AND.l       d0,d1               * and line colour
00001EA0  7051                    5274      MOVEQ       #81,d0          * set pen colour
00001EA2  4E4F                    5275      TRAP        #15             * do I/O function
00001EA4  321F                    5276      MOVE.w  (sp)+,d1            * get parameter count back
00001EA6  4E75                    5277      RTS
00001EA8                          5278  
00001EA8                          5279  
00001EA8                          5280  *************************************************************************************
00001EA8                          5281  *
00001EA8                          5282  * perform LINE [[X1,Y1],X2,Y2][,][LINE_COLOUR]
00001EA8                          5283  
00001EA8                          5284  LAB_LINE
00001EA8  7055                    5285      MOVEQ       #85,d0          * default to draw line to X1,Y1
00001EAA  2F00                    5286      MOVE.l  d0,-(sp)            * set line type
00001EAC                          5287  
00001EAC  61A8                    5288      BSR     LAB_GGPR            * get graphics parameters, return count in d1.w
00001EAE  0801 0000               5289      BTST        #0,d1               * test parameter count
00001EB2  6700 000C               5290      BEQ     LAB_LNCO            * branch if no line colour parameter
00001EB6                          5291  
00001EB6  201F                    5292      MOVE.l  (sp)+,d0            * get line colour
00001EB8  61CA                    5293      BSR     LAB_SLCO            * go mask & set line colour
00001EBA  5341                    5294      SUBQ.w  #1,d1               * decrement parameter count
00001EBC  6700 00C0               5295      BEQ     LAB_SRTS            * exit if all done
00001EC0                          5296  
00001EC0                          5297                              * parameter count is always even here
00001EC0                          5298  LAB_LNCO
00001EC0  5541                    5299      SUBQ.w  #2,d1               * subtract 2 from parameter count
00001EC2  6700 00A4               5300      BEQ     LAB_S1XY            * go do line to X,Y if only two parameters left
00001EC6                          5301  
00001EC6  5541                    5302      SUBQ.w  #2,d1               * subtract 2 from parameter count
00001EC8  6600 E7F0               5303      BNE     LAB_SNER            * do error if there are other than two
00001ECC                          5304                              * parameters left
00001ECC                          5305  
00001ECC  7054                    5306      MOVEQ       #84,d0          * draw line from X1,Y1 to X2,Y2
00001ECE  3F40 0012               5307      MOVE.w  d0,$12(sp)          * set line type (write over line to X1,Y1 type)
00001ED2  6000 0084               5308      BRA     LAB_S2XY            * go pop X1,Y1,X2,Y2 and do line
00001ED6                          5309  
00001ED6                          5310  
00001ED6                          5311  *************************************************************************************
00001ED6                          5312  *
00001ED6                          5313  * perform MOVE X,Y
00001ED6                          5314  
00001ED6                          5315  LAB_MOVE
00001ED6  7056                    5316      MOVEQ       #86,d0          * move to x,y
00001ED8  2F00                    5317      MOVE.l  d0,-(sp)            * save pixel type
00001EDA                          5318  
00001EDA  6100 FF7A               5319      BSR     LAB_GGPR            * get graphics parameters, return count in d1.w
00001EDE  6032                    5320      BRA.s       LAB_PNCE            * go check only two parameters and do move
00001EE0                          5321  
00001EE0                          5322  
00001EE0                          5323  *************************************************************************************
00001EE0                          5324  *
00001EE0                          5325  * perform POINT [X,Y][,][LINE_COLOUR]
00001EE0                          5326  
00001EE0                          5327  LAB_POINT
00001EE0  7052                    5328      MOVEQ       #82,d0          * set point
00001EE2  6002                    5329      BRA.s       LAB_pixel           * go do pixel command
00001EE4                          5330  
00001EE4                          5331  
00001EE4                          5332  *************************************************************************************
00001EE4                          5333  *
00001EE4                          5334  * perform FILL [X,Y][,][FILL_COLOUR]
00001EE4                          5335  
00001EE4                          5336  LAB_FILL
00001EE4  7059                    5337      MOVEQ       #89,d0          * flood fill
00001EE6                          5338  *   BRA.s       LAB_pixel           * go do pixel command
00001EE6                          5339  
00001EE6                          5340  * do POINT or FILL pixel based commands
00001EE6                          5341  
00001EE6                          5342  LAB_pixel
00001EE6  2F00                    5343      MOVE.l  d0,-(sp)            * save pixel type
00001EE8                          5344  
00001EE8  6100 FF6C               5345      BSR     LAB_GGPR            * get graphics parameters, return count in d1.w
00001EEC  0801 0000               5346      BTST        #0,d1               * test parameter count
00001EF0  6700 0020               5347      BEQ     LAB_PNCE            * branch if no line colour parameter
00001EF4                          5348  
00001EF4  201F                    5349      MOVE.l  (sp)+,d0            * get line colour
00001EF6  3401                    5350      MOVE.w  d1,d2               * copy count
00001EF8  D442                    5351      ADD.w       d2,d2               * *2
00001EFA  D442                    5352      ADD.w       d2,d2               * *4
00001EFC  0837 0000 20FF          5353      BTST        #0,-1(sp,d2.w)      * test point or fill
00001F02  6704                    5354      BEQ.s       LAB_SELC            * branch if line
00001F04                          5355      
00001F04  6190                    5356      BSR     LAB_SFCO            * go mask & set fill colour
00001F06  6004                    5357      BRA.s       LAB_PNCO            * continue command
00001F08                          5358  
00001F08                          5359  LAB_SELC
00001F08  6100 FF7A               5360      BSR     LAB_SLCO            * go mask & set line colour
00001F0C                          5361  LAB_PNCO
00001F0C  5341                    5362      SUBQ.w  #1,d1               * decrement parameter count
00001F0E  6700 006E               5363      BEQ     LAB_SRTS            * exit if all done
00001F12                          5364  
00001F12                          5365  LAB_PNCE
00001F12  5541                    5366      SUBQ.w  #2,d1               * subtract 2 from parameter count
00001F14  6600 E7A4               5367      BNE     LAB_SNER            * do error if there were other than two
00001F18                          5368                              * parameters left
00001F18                          5369  
00001F18  6000 004E               5370      BRA     LAB_S1XY            * go pop X,Y and do pixel command
00001F1C                          5371  
00001F1C                          5372  
00001F1C                          5373  *************************************************************************************
00001F1C                          5374  *
00001F1C                          5375  * perform RECT [X1,Y1,X2,Y2][,][LINE_COLOUR[,FILL_COLOUR]]
00001F1C                          5376  
00001F1C                          5377  LAB_RECT
00001F1C  705A                    5378      MOVEQ       #90,d0          * draw unfilled rectangle
00001F1E  600A                    5379      BRA.s       LAB_shape           * go do shape
00001F20                          5380  
00001F20                          5381  
00001F20                          5382  *************************************************************************************
00001F20                          5383  *
00001F20                          5384  * perform RECTF [X1,Y1,X2,Y2][,][LINE_COLOUR[,FILL_COLOUR]]
00001F20                          5385  
00001F20                          5386  LAB_FRECT
00001F20  7057                    5387      MOVEQ       #87,d0          * draw filled rectangle
00001F22  6006                    5388      BRA.s       LAB_shape           * go do shape
00001F24                          5389  
00001F24                          5390  
00001F24                          5391  *************************************************************************************
00001F24                          5392  *
00001F24                          5393  * perform ELLIPSE [X1,Y1,X2,Y2][,][LINE_COLOUR[,FILL_COLOUR]]
00001F24                          5394  
00001F24                          5395  LAB_ELLIPSE
00001F24  705B                    5396      MOVEQ       #91,d0          * draw unfilled ellipse
00001F26  6002                    5397      BRA.s       LAB_shape           * go do shape
00001F28                          5398  
00001F28                          5399  
00001F28                          5400  *************************************************************************************
00001F28                          5401  *
00001F28                          5402  * perform ELLIPSEF [X1,Y1,X2,Y2][,][LINE_COLOUR[,FILL_COLOUR]]
00001F28                          5403  
00001F28                          5404  LAB_FELLIPSE
00001F28  7058                    5405      MOVEQ       #88,d0          * draw filled ellipse
00001F2A                          5406  *   BRA.s       LAB_shape           * go do shape
00001F2A                          5407  
00001F2A                          5408  * this is the routine that does all the hard work for all the shape commands
00001F2A                          5409  * the parameters are interpreted depending on their number. if there are four
00001F2A                          5410  * parameters then they must be X1, Y1, X2 and Y2. if there are less or more
00001F2A                          5411  * than four then LINE_COLOUR and/or FILL_COLOUR must be present
00001F2A                          5412  
00001F2A                          5413  LAB_shape
00001F2A  2F00                    5414      MOVE.l  d0,-(sp)            * save shape type
00001F2C                          5415  
00001F2C  6100 FF28               5416      BSR     LAB_GGPR            * get graphics parameters, return count in d1.w
00001F30  5941                    5417      SUBQ.w  #4,d1               * subtract 4 from parameter count
00001F32  6700 0024               5418      BEQ     LAB_S2XY            * branch if there were 4 parameters
00001F36                          5419  
00001F36                          5420  * less or more than four then LINE_COLOUR and/or FILL_COLOUR must be present
00001F36                          5421  
00001F36  0801 0000               5422      BTST        #0,d1               * test parameter count
00001F3A  6600 000A               5423      BNE     LAB_SNFC            * branch if no fill colour parameter
00001F3E                          5424  
00001F3E                          5425  * even number so LINE_COLOUR and FILL_COLOUR must be present
00001F3E                          5426  
00001F3E  201F                    5427      MOVE.l  (sp)+,d0            * get fill colour
00001F40  6100 FF54               5428      BSR     LAB_SFCO            * go mask & set fill colour
00001F44  5341                    5429      SUBQ.w  #1,d1               * decrement parameter count
00001F46                          5430  LAB_SNFC
00001F46  201F                    5431      MOVE.l  (sp)+,d0            * get line colour
00001F48  6100 FF3A               5432      BSR     LAB_SLCO            * go mask & set line colour
00001F4C  5641                    5433      ADDQ.w  #3,d1               * decrement parameter count and add 4
00001F4E  6700 002E               5434      BEQ     LAB_SRTS            * exit if no more parameters
00001F52                          5435  
00001F52                          5436  * if there are any parameters left then they must be X1, Y1, X2 and Y2
00001F52                          5437  * if there are less or more than four then something is wrong
00001F52                          5438  
00001F52  5941                    5439      SUBQ.w  #4,d1               * subtract 4 from parameter count
00001F54  6600 E764               5440      BNE     LAB_SNER            * do error if wasn't 4 parameters
00001F58                          5441  
00001F58                          5442  * pull four parameters and do graphics command
00001F58                          5443  
00001F58                          5444  LAB_S2XY
00001F58  201F                    5445      MOVE.l  (sp)+,d0            * get Y2 off stack
00001F5A  6100 FEE8               5446      BSR     LAB_EVSW            * evaluate signed word in d0
00001F5E  2800                    5447      MOVE.l  d0,d4               * copy Y2 parameter
00001F60                          5448  
00001F60  201F                    5449      MOVE.l  (sp)+,d0            * get X2 off stack
00001F62  6100 FEE0               5450      BSR     LAB_EVSW            * evaluate signed word in d0
00001F66  2600                    5451      MOVE.l  d0,d3               * copy X2 parameter
00001F68                          5452  
00001F68                          5453  * pull two parameters and do graphics command
00001F68                          5454  
00001F68                          5455  LAB_S1XY
00001F68  201F                    5456      MOVE.l  (sp)+,d0            * get Y1 off stack
00001F6A  6100 FED8               5457      BSR     LAB_EVSW            * evaluate signed word in d0
00001F6E  2400                    5458      MOVE.l  d0,d2               * copy Y1 parameter
00001F70                          5459  
00001F70  201F                    5460      MOVE.l  (sp)+,d0            * get X1 off stack
00001F72  6100 FED0               5461      BSR     LAB_EVSW            * evaluate signed word in d0
00001F76  2200                    5462      MOVE.l  d0,d1               * copy X1 parameter
00001F78                          5463  
00001F78  201F                    5464      MOVE.l  (sp)+,d0            * draw line, pixel or shape
00001F7A  4E4F                    5465      TRAP        #15             * do I/O function
00001F7C  4E75                    5466      RTS
00001F7E                          5467  
00001F7E                          5468  LAB_SRTS
00001F7E  201F                    5469      MOVE.l  (sp)+,d0            * dump command
00001F80  4E75                    5470      RTS
00001F82                          5471  
00001F82                          5472  
00001F82                          5473  *************************************************************************************
00001F82                          5474  *
00001F82                          5475  * perform MODE m
00001F82                          5476  
00001F82                          5477  LAB_MODE
00001F82  6100 FCEC               5478      BSR     LAB_GTBY            * get byte parameter, result in d0 and Itemp
00001F86  B03C 0012               5479      CMP.b       #$12,d0         * compare with max+1
00001F8A  6400 E722               5480      BCC     LAB_FCER            * if >= $10 go do function call error
00001F8E                          5481  
00001F8E  2200                    5482      MOVE.l  d0,d1               * copy it
00001F90  705C                    5483      MOVEQ       #92,d0          * set draw mode
00001F92  4E4F                    5484      TRAP        #15             * do I/O function
00001F94  4E75                    5485      RTS
00001F96                          5486  
00001F96                          5487  
00001F96                          5488  *************************************************************************************
00001F96                          5489  *
00001F96                          5490  * perform SIZE s
00001F96                          5491  
00001F96                          5492  LAB_SIZE
00001F96  6100 FCD8               5493      BSR     LAB_GTBY            * get byte parameter, result in d0 and Itemp
00001F9A  2200                    5494      MOVE.l  d0,d1               * copy it
00001F9C  705D                    5495      MOVEQ       #93,d0          * set pen width
00001F9E  4E4F                    5496      TRAP        #15             * do I/O function
00001FA0  4E75                    5497      RTS
00001FA2                          5498  
00001FA2                          5499  
00001FA2                          5500  *************************************************************************************
00001FA2                          5501  *
00001FA2                          5502  * perform CURSOR X,Y
00001FA2                          5503  
00001FA2                          5504  LAB_CURSOR
00001FA2  6100 FCCC               5505      BSR     LAB_GTBY            * get byte parameter, result in d0 and Itemp
00001FA6  B03C 0050               5506      CMP.b       #80,d0          * compare with max+1
00001FAA  6400 E702               5507      BCC     LAB_FCER            * if >= 80 go do function call error
00001FAE                          5508  
00001FAE  1740 05E5               5509      MOVE.b  d0,TPos(a3)         * set terminal position
00001FB2  E140                    5510      ASL.w       #8,d0               * shift to high byte of word
00001FB4  3F00                    5511      MOVE.w  d0,-(sp)            * save d0
00001FB6                          5512  
00001FB6  6100 F338               5513      BSR     LAB_SCGB            * scan for "," and get byte parameter, result
00001FBA                          5514                              * in d0 & Itemp
00001FBA                          5515  
00001FBA  B03C 0020               5516      CMP.b       #32,d0          * compare with max+1
00001FBE  6400 E6EE               5517      BCC     LAB_FCER            * if >= 32 go do function call error
00001FC2                          5518  
00001FC2  321F                    5519      MOVE.w  (sp)+,d1            * restore d1
00001FC4  8240                    5520      OR.w        d0,d1               * OR row into low byte
00001FC6                          5521  
00001FC6  700B                    5522      MOVEQ       #11,d0          * cursor position
00001FC8  4E4F                    5523      TRAP        #15             * do I/O function
00001FCA                          5524  
00001FCA  7000                    5525      MOVEQ       #0,d0               * set d0
00001FCC  D02B 05E5               5526      ADD.b       TPos(a3),d0         * get cursor x position
00001FD0  4A2B 05E6               5527      TST.b       TWidth(a3)          * test terminal width
00001FD4  660A                    5528      BNE.s       LAB_CRTS            * branch if not infinite line
00001FD6                          5529  
00001FD6                          5530  LAB_CDLP
00001FD6  902B 05E2               5531      SUB.b       TabSiz(a3),d0       * subtract tab size
00001FDA  64FA                    5532      BCC.s       LAB_CDLP            * loop while no borrow
00001FDC  D02B 05E2               5533      ADD.b       TabSiz(a3),d0       * add tab size back
00001FE0                          5534  LAB_CRTS
00001FE0  1740 05E5               5535      MOVE.b  d0,TPos(a3)         * set terminal position
00001FE4  4E75                    5536      RTS
00001FE6                          5537  
00001FE6                          5538  
00001FE6                          5539  *************************************************************************************
00001FE6                          5540  *
00001FE6                          5541  * perform BUFFER
00001FE6                          5542  
00001FE6                          5543  LAB_BUFFER
00001FE6  6600 E6D2               5544      BNE     LAB_SNER            * do syntax error if following byte
00001FEA                          5545  
00001FEA  705E                    5546      MOVEQ       #94,d0          * copy buffer to screen
00001FEC  4E4F                    5547      TRAP        #15             * do I/O function
00001FEE                          5548  
00001FEE  4E75                    5549      RTS
00001FF0                          5550  
00001FF0                          5551  
00001FF0                          5552  *************************************************************************************
00001FF0                          5553  *
00001FF0                          5554  * perform CLS
00001FF0                          5555  
00001FF0                          5556  LAB_CLS
00001FF0  6600 E6C8               5557      BNE     LAB_SNER            * do syntax error if following byte
00001FF4                          5558  
00001FF4  323C FF00               5559      MOVE.w  #$FF00,d1           * set for clear screen
00001FF8  1741 05E5               5560      MOVE.b  d1,TPos(a3)         * clear terminal position
00001FFC  700B                    5561      MOVEQ       #11,d0          * cursor position
00001FFE  4E4F                    5562      TRAP        #15             * do I/O function
00002000                          5563  
00002000  4E75                    5564      RTS
00002002                          5565  
00002002                          5566  
00002002                          5567  *************************************************************************************
00002002                          5568  * end of EASy68k graphics extension commands                            *
00002002                          5569  *************************************************************************************
00002002                          5570  
00002002                          5571  *************************************************************************************
00002002                          5572  *
00002002                          5573  * perform subtraction, FAC1 from FAC2
00002002                          5574  
00002002                          5575  LAB_SUBTRACT
00002002  0A2B 0080 0595          5576      EORI.b  #$80,FAC1_s(a3)     * complement FAC1 sign
00002008  176B 059D 059E          5577      MOVE.b  FAC2_s(a3),FAC_sc(a3)   * copy FAC2 sign byte
0000200E                          5578  
0000200E  102B 0595               5579      MOVE.b  FAC1_s(a3),d0       * get FAC1 sign byte
00002012  B12B 059E               5580      EOR.b       d0,FAC_sc(a3)       * EOR with FAC2 sign
00002016                          5581  
00002016                          5582  
00002016                          5583  *************************************************************************************
00002016                          5584  *
00002016                          5585  * add FAC2 to FAC1
00002016                          5586  
00002016                          5587  LAB_ADD
00002016  102B 0594               5588      MOVE.b  FAC1_e(a3),d0       * get exponent
0000201A  6700 0338               5589      BEQ     LAB_279B            * FAC1 was zero so copy FAC2 to FAC1 & return
0000201E                          5590  
0000201E                          5591                              * FAC1 is non zero
0000201E  41EB 0598               5592      LEA     FAC2_m(a3),a0       * set pointer1 to FAC2 mantissa
00002022  102B 059C               5593      MOVE.b  FAC2_e(a3),d0       * get FAC2 exponent
00002026  6746                    5594      BEQ.s       RTS_016         * exit if zero
00002028                          5595  
00002028  902B 0594               5596      SUB.b       FAC1_e(a3),d0       * subtract FAC1 exponent
0000202C  6722                    5597      BEQ.s       LAB_24A8            * branch if = (go add mantissa)
0000202E                          5598  
0000202E  650A                    5599      BCS.s       LAB_249C            * branch if FAC2 < FAC1
00002030                          5600  
00002030                          5601                              * FAC2 > FAC1
00002030  376B 059C 0594          5602      MOVE.w  FAC2_e(a3),FAC1_e(a3)   * copy sign and exponent of FAC2
00002036  4400                    5603      NEG.b       d0              * negate exponent difference (make diff -ve)
00002038  5148                    5604      SUBQ.w  #8,a0               * pointer1 to FAC1 
0000203A                          5605  LAB_249C
0000203A  4400                    5606      NEG.b       d0              * negate exponent difference (make diff +ve)
0000203C  2F01                    5607      MOVE.l  d1,-(sp)            * save d1
0000203E  B03C 0020               5608      CMP.b       #32,d0          * compare exponent diff with 32
00002042  6D04                    5609      BLT.s       LAB_2467            * branch if range >= 32
00002044                          5610  
00002044  7200                    5611      MOVEQ       #0,d1               * clear d1
00002046  6004                    5612      BRA.s       LAB_2468            * go clear smaller mantissa
00002048                          5613  
00002048                          5614  LAB_2467
00002048  2210                    5615      MOVE.l  (a0),d1         * get FACx mantissa
0000204A  E0A9                    5616      LSR.l       d0,d1               * shift d0 times right
0000204C                          5617  LAB_2468
0000204C  2081                    5618      MOVE.l  d1,(a0)         * save it back
0000204E  221F                    5619      MOVE.l  (sp)+,d1            * restore d1
00002050                          5620  
00002050                          5621                              * exponents are equal now do mantissa add or
00002050                          5622                              * subtract
00002050                          5623  LAB_24A8
00002050  4A2B 059E               5624      TST.b       FAC_sc(a3)          * test sign compare (FAC1 EOR FAC2)
00002054  6B1A                    5625      BMI.s       LAB_24F8            * if <> go do subtract
00002056                          5626  
00002056  202B 0598               5627      MOVE.l  FAC2_m(a3),d0       * get FAC2 mantissa
0000205A  D0AB 0590               5628      ADD.l       FAC1_m(a3),d0       * add FAC1 mantissa
0000205E  640A                    5629      BCC.s       LAB_24F7            * save and exit if no carry (FAC1 is normal)
00002060                          5630  
00002060  E290                    5631      ROXR.l  #1,d0               * else shift carry back into mantissa
00002062  522B 0594               5632      ADDQ.b  #1,FAC1_e(a3)       * increment FAC1 exponent
00002066  6500 E642               5633      BCS     LAB_OFER            * if carry do overflow error & warm start
0000206A                          5634  
0000206A                          5635  LAB_24F7
0000206A  2740 0590               5636      MOVE.l  d0,FAC1_m(a3)       * save mantissa
0000206E                          5637  RTS_016
0000206E  4E75                    5638      RTS
00002070                          5639                              * signs are different
00002070                          5640  LAB_24F8
00002070  43EB 0590               5641      LEA     FAC1_m(a3),a1       * pointer 2 to FAC1
00002074  B3C8                    5642      CMPA.l  a0,a1               * compare pointers
00002076  6602                    5643      BNE.s       LAB_24B4            * branch if <>
00002078                          5644  
00002078  5049                    5645      ADDQ.w  #8,a1               * else pointer2 to FAC2
0000207A                          5646  
0000207A                          5647                              * take smaller from bigger (take sign of bigger)
0000207A                          5648  LAB_24B4
0000207A  2011                    5649      MOVE.l  (a1),d0         * get larger mantissa
0000207C  2210                    5650      MOVE.l  (a0),d1         * get smaller mantissa
0000207E  2740 0590               5651      MOVE.l  d0,FAC1_m(a3)       * save larger mantissa
00002082  93AB 0590               5652      SUB.l       d1,FAC1_m(a3)       * subtract smaller
00002086                          5653  
00002086                          5654  
00002086                          5655  *************************************************************************************
00002086                          5656  *
00002086                          5657  * do +/- (carry is sign) & normalise FAC1
00002086                          5658  
00002086                          5659  LAB_24D0
00002086  640A                    5660      BCC.s       LAB_24D5            * branch if result is +ve
00002088                          5661  
00002088                          5662                              * erk! subtract is the wrong way round so
00002088                          5663                              * negate everything
00002088  0A2B 00FF 0595          5664      EORI.b  #$FF,FAC1_s(a3)     * complement FAC1 sign
0000208E  44AB 0590               5665      NEG.l       FAC1_m(a3)          * negate FAC1 mantissa
00002092                          5666  
00002092                          5667  
00002092                          5668  *************************************************************************************
00002092                          5669  *
00002092                          5670  * normalise FAC1
00002092                          5671  
00002092                          5672  LAB_24D5
00002092  202B 0590               5673      MOVE.l  FAC1_m(a3),d0       * get mantissa
00002096  6B2E                    5674      BMI.s       LAB_24DA            * mantissa is normal so just exit
00002098                          5675  
00002098  6606                    5676      BNE.s       LAB_24D9            * mantissa is not zero so go normalise FAC1
0000209A                          5677  
0000209A  3740 0594               5678      MOVE.w  d0,FAC1_e(a3)       * else make FAC1 = +zero
0000209E  4E75                    5679      RTS
000020A0                          5680  
000020A0                          5681  LAB_24D9
000020A0  2F01                    5682      MOVE.l  d1,-(sp)            * save d1
000020A2  2200                    5683      MOVE.l  d0,d1               * mantissa to d1
000020A4  7000                    5684      MOVEQ       #0,d0               * clear d0
000020A6  102B 0594               5685      MOVE.b  FAC1_e(a3),d0       * get exponent byte
000020AA  6714                    5686      BEQ.s       LAB_24D8            * if exponent is zero then clean up and exit
000020AC                          5687  LAB_24D6
000020AC  D281                    5688      ADD.l       d1,d1               * shift mantissa, ADD is quicker for a single
000020AE                          5689                              * shift
000020AE  5BC8 FFFC               5690      DBMI        d0,LAB_24D6         * decrement exponent and loop if mantissa and
000020B2                          5691                              * exponent +ve
000020B2                          5692  
000020B2  4A40                    5693      TST.w       d0              * test exponent
000020B4  670A                    5694      BEQ.s       LAB_24D8            * if exponent is zero make FAC1 zero
000020B6                          5695  
000020B6  6A02                    5696      BPL.s       LAB_24D7            * if exponent is >zero go save FAC1
000020B8                          5697  
000020B8  7001                    5698      MOVEQ       #1,d0               * else set for zero after correction
000020BA                          5699  LAB_24D7
000020BA  5300                    5700      SUBQ.b  #1,d0               * adjust exponent for loop
000020BC  2741 0590               5701      MOVE.l  d1,FAC1_m(a3)       * save normalised mantissa
000020C0                          5702  LAB_24D8
000020C0  221F                    5703      MOVE.l  (sp)+,d1            * restore d1
000020C2  1740 0594               5704      MOVE.b  d0,FAC1_e(a3)       * save corrected exponent
000020C6                          5705  LAB_24DA
000020C6  4E75                    5706      RTS
000020C8                          5707  
000020C8                          5708  
000020C8                          5709  *************************************************************************************
000020C8                          5710  *
000020C8                          5711  * perform LOG()
000020C8                          5712  
000020C8                          5713  LAB_LOG
000020C8  4A2B 0595               5714      TST.b       FAC1_s(a3)          * test sign
000020CC  6B00 E5E0               5715      BMI     LAB_FCER            * if -ve do function call error/warm start
000020D0                          5716  
000020D0  7E00                    5717      MOVEQ       #0,d7               * clear d7
000020D2  1747 059E               5718      MOVE.b  d7,FAC_sc(a3)       * clear sign compare
000020D6  1E2B 0594               5719      MOVE.b  FAC1_e(a3),d7       * get exponent
000020DA  6700 E5D2               5720      BEQ     LAB_FCER            * if 0 do function call error/warm start
000020DE                          5721  
000020DE  0487 00000081           5722      SUB.l       #$81,d7         * normalise exponent
000020E4  177C 0081 0594          5723      MOVE.b  #$81,FAC1_e(a3)     * force a value between 1 and 2
000020EA  2C2B 0590               5724      MOVE.l  FAC1_m(a3),d6       * copy mantissa
000020EE                          5725  
000020EE  277C 80000000 0598      5726      MOVE.l  #$80000000,FAC2_m(a3)   * set mantissa for 1
000020F6  377C 8100 059C          5727      MOVE.w  #$8100,FAC2_e(a3)       * set exponent for 1
000020FC  6100 FF18               5728      BSR     LAB_ADD         * find arg+1
00002100  7000                    5729      MOVEQ       #0,d0               * setup for calc skip
00002102  3740 059C               5730      MOVE.w  d0,FAC2_e(a3)       * set FAC1 for zero result
00002106  DC86                    5731      ADD.l       d6,d6               * shift 1 bit out
00002108  2746 0598               5732      MOVE.l  d6,FAC2_m(a3)       * put back FAC2
0000210C  6758                    5733      BEQ.s       LAB_LONN            * if 0 skip calculation
0000210E                          5734  
0000210E  377C 8000 059C          5735      MOVE.w  #$8000,FAC2_e(a3)       * set exponent for .5
00002114  6100 0130               5736      BSR     LAB_DIVIDE          * do (arg-1)/(arg+1)
00002118  4A2B 0594               5737      TST.b       FAC1_e(a3)          * test exponent
0000211C  6748                    5738      BEQ.s       LAB_LONN            * if 0 skip calculation
0000211E                          5739  
0000211E  122B 0594               5740      MOVE.b  FAC1_e(a3),d1       * get exponent
00002122  0401 0082               5741      SUB.b       #$82,d1         * normalise and two integer bits
00002126  4401                    5742      NEG.b       d1              * negate for shift
00002128                          5743  **  CMP.b       #$1F,d1         * will mantissa vanish?
00002128                          5744  **  BGT.s       LAB_dunno           * if so do ???
00002128                          5745  
00002128  202B 0590               5746      MOVE.l  FAC1_m(a3),d0       * get mantissa
0000212C  E2A8                    5747      LSR.l       d1,d0               * shift in two integer bits
0000212E                          5748  
0000212E                          5749  * d0 = arg
0000212E                          5750  * d0 = x, d1 = y
0000212E                          5751  * d2 = x1, d3 = y1
0000212E                          5752  * d4 = shift count
0000212E                          5753  * d5 = loop count
0000212E                          5754  * d6 = z
0000212E                          5755  * a0 = table pointer
0000212E                          5756  
0000212E  7C00                    5757      MOVEQ       #0,d6               * z = 0
00002130  223C 40000000           5758      MOVE.l  #1<<30,d1           * y = 1
00002136  41FA 1400               5759      LEA     TAB_HTHET(pc),a0        * get pointer to hyperbolic tangent table
0000213A  7A1E                    5760      MOVEQ       #30,d5          * loop 31 times
0000213C  7801                    5761      MOVEQ       #1,d4               * set shift count
0000213E  6006                    5762      BRA.s       LAB_LOCC            * entry point for loop
00002140                          5763  
00002140                          5764  LAB_LAAD
00002140  E8A2                    5765      ASR.l       d4,d2               * x1 >> i
00002142  9282                    5766      SUB.l       d2,d1               * y = y - x1
00002144  DC90                    5767      ADD.l       (a0),d6         * z = z + tanh(i)
00002146                          5768  LAB_LOCC
00002146  2400                    5769      MOVE.l  d0,d2               * x1 = x
00002148  2601                    5770      MOVE.l  d1,d3               * y1 = Y
0000214A  E8A3                    5771      ASR.l       d4,d3               * y1 >> i
0000214C  6402                    5772      BCC.s       LAB_LOLP
0000214E                          5773  
0000214E  5283                    5774      ADDQ.l  #1,d3
00002150                          5775  LAB_LOLP
00002150  9083                    5776      SUB.l       d3,d0               * x = x - y1
00002152  6AEC                    5777      BPL.s       LAB_LAAD            * branch if > 0
00002154                          5778  
00002154  2002                    5779      MOVE.l  d2,d0               * get x back
00002156  5848                    5780      ADDQ.w  #4,a0               * next entry
00002158  5284                    5781      ADDQ.l  #1,d4               * next i
0000215A  E28B                    5782      LSR.l       #1,d3               * /2
0000215C  6704                    5783      BEQ.s       LAB_LOCX            * branch y1 = 0
0000215E                          5784  
0000215E  51CD FFF0               5785      DBF     d5,LAB_LOLP         * decrement and loop if not done
00002162                          5786  
00002162                          5787                              * now sort out the result
00002162                          5788  LAB_LOCX
00002162  DC86                    5789      ADD.l       d6,d6               * *2
00002164  2006                    5790      MOVE.l  d6,d0               * setup for d7 = 0
00002166                          5791  LAB_LONN
00002166  2800                    5792      MOVE.l  d0,d4               * save cordic result
00002168  7A00                    5793      MOVEQ       #0,d5               * set default exponent sign
0000216A  4A87                    5794      TST.l       d7              * check original exponent sign
0000216C  6716                    5795      BEQ.s       LAB_LOXO            * branch if original was 0
0000216E                          5796  
0000216E  6A04                    5797      BPL.s       LAB_LOXP            * branch if was +ve
00002170                          5798  
00002170  4487                    5799      NEG.l       d7              * make original exponent +ve
00002172  7A80                    5800      MOVEQ       #$80-$100,d5        * make sign -ve
00002174                          5801  LAB_LOXP
00002174  1745 0595               5802      MOVE.b  d5,FAC1_s(a3)       * save original exponent sign
00002178  4847                    5803      SWAP        d7              * 16 bit shift
0000217A  E18F                    5804      LSL.l       #8,d7               * easy first part
0000217C  7A88                    5805      MOVEQ       #$88-$100,d5        * start with byte
0000217E                          5806  LAB_LONE
0000217E  5385                    5807      SUBQ.l  #1,d5               * decrement exponent
00002180  DE87                    5808      ADD.l       d7,d7               * shift mantissa
00002182  6AFA                    5809      BPL.s       LAB_LONE            * loop if not normal
00002184                          5810  
00002184                          5811  LAB_LOXO
00002184  2747 0590               5812      MOVE.l  d7,FAC1_m(a3)       * save original exponent as mantissa
00002188  1745 0594               5813      MOVE.b  d5,FAC1_e(a3)       * save exponent for this
0000218C  277C B17217F8 0598      5814      MOVE.l  #$B17217F8,FAC2_m(a3)   * LOG(2) mantissa
00002194  377C 8000 059C          5815      MOVE.w  #$8000,FAC2_e(a3)       * LOG(2) exponent & sign
0000219A  176B 0595 059E          5816      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * make sign compare = FAC1 sign
000021A0  6118                    5817      BSR.s       LAB_MULTIPLY        * do multiply
000021A2  2744 0598               5818      MOVE.l  d4,FAC2_m(a3)       * save cordic result
000021A6  6710                    5819      BEQ.s       LAB_LOWZ            * branch if zero
000021A8                          5820  
000021A8  377C 8200 059C          5821      MOVE.w  #$8200,FAC2_e(a3)       * set exponent & sign
000021AE  176B 0595 059E          5822      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * clear sign compare
000021B4  6100 FE60               5823      BSR     LAB_ADD         * and add for final result
000021B8                          5824  
000021B8                          5825  LAB_LOWZ
000021B8  4E75                    5826      RTS
000021BA                          5827  
000021BA                          5828  
000021BA                          5829  *************************************************************************************
000021BA                          5830  *
000021BA                          5831  * multiply FAC1 by FAC2
000021BA                          5832  
000021BA                          5833  LAB_MULTIPLY
000021BA  48E7 F800               5834      MOVEM.l d0-d4,-(sp)         * save registers
000021BE  4A2B 0594               5835      TST.b       FAC1_e(a3)          * test FAC1 exponent
000021C2  6776                    5836      BEQ.s       LAB_MUUF            * if exponent zero go make result zero
000021C4                          5837  
000021C4  102B 059C               5838      MOVE.b  FAC2_e(a3),d0       * get FAC2 exponent
000021C8  6770                    5839      BEQ.s       LAB_MUUF            * if exponent zero go make result zero
000021CA                          5840  
000021CA  176B 059E 0595          5841      MOVE.b  FAC_sc(a3),FAC1_s(a3)   * sign compare becomes sign
000021D0                          5842  
000021D0  D02B 0594               5843      ADD.b       FAC1_e(a3),d0       * multiply exponents by adding
000021D4  640A                    5844      BCC.s       LAB_MNOC            * branch if no carry
000021D6                          5845  
000021D6  0400 0080               5846      SUB.b       #$80,d0         * normalise result
000021DA  6400 E4CE               5847      BCC     LAB_OFER            * if no carry do overflow
000021DE                          5848  
000021DE  6006                    5849      BRA.s       LAB_MADD            * branch
000021E0                          5850  
000021E0                          5851                              * no carry for exponent add
000021E0                          5852  LAB_MNOC
000021E0  0400 0080               5853      SUB.b       #$80,d0         * normalise result
000021E4  6554                    5854      BCS.s       LAB_MUUF            * return zero if underflow
000021E6                          5855  
000021E6                          5856  LAB_MADD
000021E6  1740 0594               5857      MOVE.b  d0,FAC1_e(a3)       * save exponent
000021EA                          5858  
000021EA                          5859                              * d1 (FAC1) x d2 (FAC2)
000021EA  222B 0590               5860      MOVE.l  FAC1_m(a3),d1       * get FAC1 mantissa
000021EE  242B 0598               5861      MOVE.l  FAC2_m(a3),d2       * get FAC2 mantissa
000021F2                          5862  
000021F2  3801                    5863      MOVE.w  d1,d4               * copy low word FAC1
000021F4  2001                    5864      MOVE.l  d1,d0               * copy long word FAC1
000021F6  4840                    5865      SWAP        d0              * high word FAC1 to low word FAC1
000021F8  3600                    5866      MOVE.w  d0,d3               * copy high word FAC1
000021FA                          5867  
000021FA  C2C2                    5868      MULU        d2,d1               * low word FAC2 x low word FAC1
000021FC  C0C2                    5869      MULU        d2,d0               * low word FAC2 x high word FAC1
000021FE  4842                    5870      SWAP        d2              * high word FAC2 to low word FAC2
00002200  C8C2                    5871      MULU        d2,d4               * high word FAC2 x low word FAC1
00002202  C6C2                    5872      MULU        d2,d3               * high word FAC2 x high word FAC1
00002204                          5873  
00002204                          5874  * done multiply, now add partial products
00002204                          5875  
00002204                          5876  *           d1 =                    aaaa  ----  FAC2_L x FAC1_L
00002204                          5877  *           d0 =                bbbb  aaaa      FAC2_L x FAC1_H
00002204                          5878  *           d4 =                bbbb  aaaa      FAC2_H x FAC1_L
00002204                          5879  *           d3 =            cccc  bbbb          FAC2_H x FAC1_H
00002204                          5880  *           product =       mmmm  mmmm
00002204                          5881  
00002204  0681 00008000           5882      ADD.L       #$8000,d1           * round up lowest word
0000220A  4241                    5883      CLR.w       d1              * clear low word, don't need it
0000220C  4841                    5884      SWAP        d1              * align high word
0000220E  D280                    5885      ADD.l       d0,d1               * add FAC2_L x FAC1_H (can't be carry)
00002210                          5886  LAB_MUF1
00002210  D284                    5887      ADD.l       d4,d1               * now add intermediate (FAC2_H x FAC1_L)
00002212  6406                    5888      BCC.s       LAB_MUF2            * branch if no carry
00002214                          5889  
00002214  0683 00010000           5890      ADD.l       #$10000,d3          * else correct result
0000221A                          5891  LAB_MUF2
0000221A  0681 00008000           5892      ADD.l       #$8000,d1           * round up low word
00002220  4241                    5893      CLR.w       d1              * clear low word
00002222  4841                    5894      SWAP        d1              * align for final add
00002224  D283                    5895      ADD.l       d3,d1               * add FAC2_H x FAC1_H, result
00002226  6B08                    5896      BMI.s       LAB_MUF3            * branch if normalisation not needed
00002228                          5897  
00002228  D281                    5898      ADD.l       d1,d1               * shift mantissa
0000222A  532B 0594               5899      SUBQ.b  #1,FAC1_e(a3)       * adjust exponent
0000222E  670A                    5900      BEQ.s       LAB_MUUF            * branch if underflow
00002230                          5901  
00002230                          5902  LAB_MUF3
00002230  2741 0590               5903      MOVE.l  d1,FAC1_m(a3)       * save mantissa
00002234                          5904  LAB_MUEX
00002234  4CDF 001F               5905      MOVEM.l (sp)+,d0-d4         * restore registers
00002238  4E75                    5906      RTS
0000223A                          5907                              * either zero or underflow result
0000223A                          5908  LAB_MUUF
0000223A  7000                    5909      MOVEQ       #0,d0               * quick clear
0000223C  2740 0590               5910      MOVE.l  d0,FAC1_m(a3)       * clear mantissa
00002240  3740 0594               5911      MOVE.w  d0,FAC1_e(a3)       * clear sign and exponent
00002244  60EE                    5912      BRA.s       LAB_MUEX            * restore regs & exit
00002246                          5913  
00002246                          5914  
00002246                          5915  *************************************************************************************
00002246                          5916  *
00002246                          5917  * do FAC2/FAC1, result in FAC1
00002246                          5918  * fast hardware divide version
00002246                          5919  
00002246                          5920  LAB_DIVIDE
00002246  2F07                    5921      MOVE.l  d7,-(sp)            * save d7
00002248  7000                    5922      MOVEQ       #0,d0               * clear FAC2 exponent
0000224A  2400                    5923      MOVE.l  d0,d2               * clear FAC1 exponent
0000224C                          5924  
0000224C  142B 0594               5925      MOVE.b  FAC1_e(a3),d2       * get FAC1 exponent
00002250  6700 E444               5926      BEQ     LAB_DZER            * if zero go do /0 error
00002254                          5927  
00002254  102B 059C               5928      MOVE.b  FAC2_e(a3),d0       * get FAC2 exponent
00002258  6766                    5929      BEQ.s       LAB_DIV0            * if zero return zero
0000225A                          5930  
0000225A  9042                    5931      SUB.w       d2,d0               * get result exponent by subtracting
0000225C  0640 0080               5932      ADD.w       #$80,d0         * correct 16 bit exponent result
00002260                          5933  
00002260  176B 059E 0595          5934      MOVE.b  FAC_sc(a3),FAC1_s(a3)   * sign compare is result sign
00002266                          5935  
00002266                          5936  * now to do 32/32 bit mantissa divide
00002266                          5937  
00002266  422B 059F               5938      CLR.b       flag(a3)            * clear 'flag' byte
0000226A  262B 0590               5939      MOVE.l  FAC1_m(a3),d3       * get FAC1 mantissa
0000226E  282B 0598               5940      MOVE.l  FAC2_m(a3),d4       * get FAC2 mantissa
00002272  B883                    5941      CMP.l       d3,d4               * compare FAC2 with FAC1 mantissa
00002274  6744                    5942      BEQ.s       LAB_MAN1            * set mantissa result = 1 if equal
00002276                          5943  
00002276  6506                    5944      BCS.s       AC1gtAC2            * branch if FAC1 > FAC2
00002278                          5945  
00002278  9883                    5946      SUB.l       d3,d4               * subtract FAC1 from FAC2, result now must be <1
0000227A  562B 059F               5947      ADDQ.b  #3,flag(a3)         * FAC2>FAC1 so set 'flag' byte
0000227E                          5948  AC1gtAC2
0000227E  6146                    5949      BSR.s       LAB_32_16           * do 32/16 divide
00002280  4841                    5950      SWAP        d1              * move 16 bit result to high word
00002282  2802                    5951      MOVE.l  d2,d4               * copy remainder longword
00002284  6142                    5952      BSR.s       LAB_3216            * do 32/16 divide again (skip copy d4 to d2)
00002286  84C5                    5953      DIVU.w  d5,d2               * now divide remainder to make guard word
00002288  1E2B 059F               5954      MOVE.b  flag(a3),d7         * now normalise, get flag byte back
0000228C  6708                    5955      BEQ.s       LAB_DIVX            * skip add if null
0000228E                          5956  
0000228E                          5957  * else result was >1 so we need to add 1 to result mantissa and adjust exponent
0000228E                          5958  
0000228E  E20F                    5959      LSR.b       #1,d7               * shift 1 into eXtend
00002290  E291                    5960      ROXR.l  #1,d1               * shift extend result >>
00002292  E252                    5961      ROXR.w  #1,d2               * shift extend guard word >>
00002294  5200                    5962      ADDQ.b  #1,d0               * adjust exponent
00002296                          5963  
00002296                          5964  * now round result to 32 bits
00002296                          5965  
00002296                          5966  LAB_DIVX
00002296  D442                    5967      ADD.w       d2,d2               * guard bit into eXtend bit
00002298  6408                    5968      BCC.s       L_DIVRND            * branch if guard=0
0000229A                          5969  
0000229A  5281                    5970      ADDQ.l  #1,d1               * add guard to mantissa
0000229C  6404                    5971      BCC.s       L_DIVRND            * branch if no overflow
0000229E                          5972  
0000229E                          5973  LAB_SET1
0000229E  E291                    5974      ROXR.l  #1,d1               * shift extend result >>
000022A0  5240                    5975      ADDQ.w  #1,d0               * adjust exponent
000022A2                          5976  
000022A2                          5977                              * test for over/under flow
000022A2                          5978  L_DIVRND
000022A2  3600                    5979      MOVE.w  d0,d3               * copy exponent
000022A4  6B1A                    5980      BMI.s       LAB_DIV0            * if -ve return zero
000022A6                          5981  
000022A6  0243 FF00               5982      ANDI.w  #$FF00,d3           * mask word high byte
000022AA  6600 E3FE               5983      BNE     LAB_OFER            * branch if overflow
000022AE                          5984  
000022AE                          5985                              * move result into FAC1
000022AE                          5986  LAB_XDIV
000022AE  2E1F                    5987      MOVE.l  (sp)+,d7            * restore d7
000022B0  1740 0594               5988      MOVE.b  d0,FAC1_e(a3)       * save result exponent
000022B4  2741 0590               5989      MOVE.l  d1,FAC1_m(a3)       * save result mantissa
000022B8  4E75                    5990      RTS
000022BA                          5991  
000022BA                          5992  * FAC1 mantissa = FAC2 mantissa so set result mantissa
000022BA                          5993  
000022BA                          5994  LAB_MAN1
000022BA  7201                    5995      MOVEQ       #1,d1               * set bit
000022BC  E2A9                    5996      LSR.l       d1,d1               * bit into eXtend
000022BE  60DE                    5997      BRA.s       LAB_SET1            * set mantissa, adjust exponent and exit
000022C0                          5998  
000022C0                          5999  * result is zero
000022C0                          6000  
000022C0                          6001  LAB_DIV0
000022C0  7000                    6002      MOVEQ       #0,d0               * zero exponent & sign
000022C2  2200                    6003      MOVE.l  d0,d1               * zero mantissa
000022C4  60E8                    6004      BRA     LAB_XDIV            * exit divide
000022C6                          6005  
000022C6                          6006  * divide 16 bits into 32, AB/Ex
000022C6                          6007  *
000022C6                          6008  * d4            AAAA    BBBB            * 32 bit numerator
000022C6                          6009  * d3            EEEE    xxxx            * 16 bit denominator
000022C6                          6010  *
000022C6                          6011  * returns -
000022C6                          6012  *
000022C6                          6013  * d1            xxxx    DDDD            * 16 bit result
000022C6                          6014  * d2                HHHH    IIII        * 32 bit remainder
000022C6                          6015  
000022C6                          6016  LAB_32_16
000022C6  2404                    6017      MOVE.l  d4,d2               * copy FAC2 mantissa        (AB)
000022C8                          6018  LAB_3216
000022C8  2A03                    6019      MOVE.l  d3,d5               * copy FAC1 mantissa        (EF)
000022CA  4245                    6020      CLR.w       d5              * clear low word d1     (Ex)
000022CC  4845                    6021      SWAP        d5              * swap high word to low word    (xE)
000022CE                          6022  
000022CE                          6023  * d3            EEEE    FFFF            * denominator copy
000022CE                          6024  * d5        0000    EEEE                * denominator high word
000022CE                          6025  * d2            AAAA    BBBB            * numerator copy
000022CE                          6026  * d4            AAAA    BBBB            * numerator
000022CE                          6027  
000022CE  88C5                    6028      DIVU.w  d5,d4               * do FAC2/FAC1 high word    (AB/E)
000022D0  6802                    6029      BVC.s       LAB_LT_1            * if no overflow DIV was ok
000022D2                          6030  
000022D2  78FF                    6031      MOVEQ       #-1,d4          * else set default value
000022D4                          6032  
000022D4                          6033  ; done the divide, now check the result, we have ...
000022D4                          6034  
000022D4                          6035  * d3            EEEE    FFFF            * denominator copy
000022D4                          6036  * d5        0000    EEEE                * denominator high word
000022D4                          6037  * d2            AAAA    BBBB            * numerator copy
000022D4                          6038  * d4            MMMM    DDDD            * result MOD and DIV
000022D4                          6039  
000022D4                          6040  LAB_LT_1
000022D4  3C04                    6041      MOVE.w  d4,d6               * copy 16 bit result
000022D6  3204                    6042      MOVE.w  d4,d1               * copy 16 bit result again
000022D8                          6043  
000022D8                          6044  * we now have ..
000022D8                          6045  * d3            EEEE    FFFF            * denominator copy
000022D8                          6046  * d5        0000    EEEE                * denominator high word
000022D8                          6047  * d6            xxxx  DDDD          * result DIV copy
000022D8                          6048  * d1            xxxx  DDDD          * result DIV copy
000022D8                          6049  * d2            AAAA    BBBB            * numerator copy
000022D8                          6050  * d4            MMMM    DDDD            * result MOD and DIV
000022D8                          6051  
000022D8                          6052  * now multiply out 32 bit denominator by 16 bit result
000022D8                          6053  * QRS = AB*D
000022D8                          6054  
000022D8  CCC3                    6055      MULU.w  d3,d6               * FFFF * DDDD =       rrrr  SSSS
000022DA  C8C5                    6056      MULU.w  d5,d4               * EEEE * DDDD = QQQQ  rrrr
000022DC                          6057  
000022DC                          6058  * we now have ..
000022DC                          6059  * d3            EEEE    FFFF            * denominator copy
000022DC                          6060  * d5        0000    EEEE                * denominator high word
000022DC                          6061  * d6                rrrr  SSSS      * 48 bit result partial low
000022DC                          6062  * d1            xxxx  DDDD          * result DIV copy
000022DC                          6063  * d2            AAAA    BBBB            * numerator copy
000022DC                          6064  * d4            QQQQ    rrrr            * 48 bit result partial
000022DC                          6065  
000022DC  3E06                    6066      MOVE.w  d6,d7               * copy low word of low multiply
000022DE                          6067  
000022DE                          6068  * d7                xxxx    SSSS        * 48 bit result partial low
000022DE                          6069  
000022DE  4246                    6070      CLR.w       d6              * clear low word of low multiply
000022E0  4846                    6071      SWAP        d6              * high word of low multiply to low word
000022E2                          6072  
000022E2                          6073  * d6            0000    rrrr            * high word of 48 bit result partial low
000022E2                          6074  
000022E2  D886                    6075      ADD.l       d6,d4
000022E4                          6076  
000022E4                          6077  * d4            QQQQ    RRRR            * 48 bit result partial high longword
000022E4                          6078  
000022E4  7C00                    6079      MOVEQ       #0,d6               * clear to extend numerator to 48 bits
000022E6                          6080  
000022E6                          6081  * now do GHI = AB0 - QRS (which is the remainder)
000022E6                          6082  
000022E6  9C47                    6083      SUB.w       d7,d6               * low word subtract
000022E8                          6084  
000022E8                          6085  * d6                xxxx    IIII        * remainder low word
000022E8                          6086  
000022E8  9584                    6087      SUBX.l  d4,d2               * high longword subtract
000022EA                          6088  
000022EA                          6089  * d2            GGGG    HHHH            * remainder high longword
000022EA                          6090  
000022EA                          6091  * now if we got the divide correct then the remainder high longword will be +ve
000022EA                          6092  
000022EA  6A08                    6093      BPL.s       L_DDIV          * branch if result is ok (<needed)
000022EC                          6094  
000022EC                          6095  * remainder was -ve so DDDD is too big
000022EC                          6096  
000022EC                          6097  LAB_REMM
000022EC  5341                    6098      SUBQ.w  #1,d1               * adjust DDDD
000022EE                          6099  
000022EE                          6100  * d3                xxxx    FFFF        * denominator copy
000022EE                          6101  * d6                xxxx    IIII        * remainder low word
000022EE                          6102  
000022EE  DC43                    6103      ADD.w       d3,d6               * add EF*1 low remainder low word
000022F0                          6104  
000022F0                          6105  * d5            0000    EEEE            * denominator high word
000022F0                          6106  * d2            GGGG    HHHH            * remainder high longword
000022F0                          6107  
000022F0  D585                    6108      ADDX.l  d5,d2               * add extend EF*1 to remainder high longword
000022F2  6BF8                    6109      BMI.s       LAB_REMM            * loop if result still too big
000022F4                          6110  
000022F4                          6111  * all done and result correct or <
000022F4                          6112  
000022F4                          6113  L_DDIV
000022F4  4842                    6114      SWAP        d2              * remainder mid word to high word
000022F6                          6115  
000022F6                          6116  * d2            HHHH    GGGG            * (high word /should/ be $0000)
000022F6                          6117  
000022F6  3406                    6118      MOVE.w  d6,d2               * remainder in high word
000022F8                          6119  
000022F8                          6120  * d2                HHHH    IIII        * now is 32 bit remainder
000022F8                          6121  * d1            xxxx    DDDD            * 16 bit result
000022F8                          6122  
000022F8  4E75                    6123      RTS
000022FA                          6124  
000022FA                          6125  
000022FA                          6126  *************************************************************************************
000022FA                          6127  *
000022FA                          6128  * unpack memory (a0) into FAC1
000022FA                          6129  
000022FA                          6130  LAB_UFAC
000022FA  2010                    6131      MOVE.l  (a0),d0         * get packed value
000022FC  4840                    6132      SWAP        d0              * exponent and sign into least significant word
000022FE  3740 0594               6133      MOVE.w  d0,FAC1_e(a3)       * save exponent and sign
00002302  6708                    6134      BEQ.s       LAB_NB1T            * branch if exponent (and the rest) zero
00002304                          6135  
00002304  807C 0080               6136      OR.w        #$80,d0         * set MSb
00002308  4840                    6137      SWAP        d0              * word order back to normal
0000230A  E180                    6138      ASL.l       #8,d0               * shift exponent & clear guard byte
0000230C                          6139  LAB_NB1T
0000230C  2740 0590               6140      MOVE.l  d0,FAC1_m(a3)       * move into FAC1
00002310                          6141  
00002310  102B 0594               6142      MOVE.b  FAC1_e(a3),d0       * get FAC1 exponent
00002314  4E75                    6143      RTS
00002316                          6144  
00002316                          6145  
00002316                          6146  *************************************************************************************
00002316                          6147  *
00002316                          6148  * set numeric variable, pack FAC1 into Lvarpl
00002316                          6149  
00002316                          6150  LAB_PFAC
00002316  2F08                    6151      MOVE.l  a0,-(sp)            * save pointer
00002318  206B 0472               6152      MOVEA.l Lvarpl(a3),a0       * get destination pointer
0000231C  082B 0006 05B5          6153      BTST        #6,Dtypef(a3)       * test data type
00002322  670C                    6154      BEQ.s       LAB_277C            * branch if floating
00002324                          6155  
00002324  6100 00C6               6156      BSR     LAB_2831            * convert FAC1 floating to fixed
00002328                          6157                              * result in d0 and Itemp
00002328  2080                    6158      MOVE.l  d0,(a0)         * save in var
0000232A  205F                    6159      MOVE.l  (sp)+,a0            * restore pointer
0000232C  4E75                    6160      RTS
0000232E                          6161  
0000232E                          6162  
0000232E                          6163  *************************************************************************************
0000232E                          6164  *
0000232E                          6165  * normalise round and pack FAC1 into (a0)
0000232E                          6166  
0000232E                          6167  LAB_2778
0000232E  2F08                    6168      MOVE.l  a0,-(sp)            * save pointer
00002330                          6169  LAB_277C
00002330  6100 FD60               6170      BSR     LAB_24D5            * normalise FAC1
00002334  612C                    6171      BSR.s       LAB_27BA            * round FAC1
00002336  202B 0590               6172      MOVE.l  FAC1_m(a3),d0       * get FAC1 mantissa
0000233A  E098                    6173      ROR.l       #8,d0               * align 24/32 bit mantissa
0000233C  4840                    6174      SWAP        d0              * exponent/sign into 0-15
0000233E  C07C 007F               6175      AND.w       #$7F,d0         * clear exponent and sign bit
00002342  022B 0080 0595          6176      ANDI.b  #$80,FAC1_s(a3)     * clear non sign bits in sign
00002348  806B 0594               6177      OR.w        FAC1_e(a3),d0       * OR in exponent and sign
0000234C  4840                    6178      SWAP        d0              * move exponent and sign back to 16-31
0000234E  2080                    6179      MOVE.l  d0,(a0)         * store in destination
00002350  205F                    6180      MOVE.l  (sp)+,a0            * restore pointer
00002352  4E75                    6181      RTS
00002354                          6182  
00002354                          6183  
00002354                          6184  *************************************************************************************
00002354                          6185  *
00002354                          6186  * copy FAC2 to FAC1
00002354                          6187  
00002354                          6188  LAB_279B
00002354  376B 059C 0594          6189      MOVE.w  FAC2_e(a3),FAC1_e(a3)   * copy exponent & sign
0000235A  276B 0598 0590          6190      MOVE.l  FAC2_m(a3),FAC1_m(a3)   * copy mantissa
00002360  4E75                    6191      RTS
00002362                          6192  
00002362                          6193  
00002362                          6194  *************************************************************************************
00002362                          6195  *
00002362                          6196  * round FAC1
00002362                          6197  
00002362                          6198  LAB_27BA
00002362  102B 0594               6199      MOVE.b  FAC1_e(a3),d0       * get FAC1 exponent
00002366  6720                    6200      BEQ.s       LAB_27C4            * branch if zero
00002368                          6201  
00002368  202B 0590               6202      MOVE.l  FAC1_m(a3),d0       * get FAC1
0000236C  0680 00000080           6203      ADD.l       #$80,d0         * round to 24 bit
00002372  640A                    6204      BCC.s       LAB_27C3            * branch if no overflow
00002374                          6205  
00002374  E290                    6206      ROXR.l  #1,d0               * shift FAC1 mantissa
00002376  522B 0594               6207      ADDQ.b  #1,FAC1_e(a3)       * correct exponent
0000237A  6500 E32E               6208      BCS     LAB_OFER            * if carry do overflow error & warm start
0000237E                          6209  
0000237E                          6210  LAB_27C3
0000237E  C03C 0000               6211      AND.b       #$00,d0         * clear guard byte
00002382  2740 0590               6212      MOVE.l  d0,FAC1_m(a3)       * save back to FAC1
00002386  4E75                    6213      RTS
00002388                          6214  
00002388                          6215  LAB_27C4
00002388  1740 0595               6216      MOVE.b  d0,FAC1_s(a3)       * make zero always +ve
0000238C                          6217  RTS_017
0000238C  4E75                    6218      RTS
0000238E                          6219  
0000238E                          6220  
0000238E                          6221  *************************************************************************************
0000238E                          6222  *
0000238E                          6223  * get FAC1 sign
0000238E                          6224  * return d0=-1,C=1/-ve d0=+1,C=0/+ve
0000238E                          6225  
0000238E                          6226  LAB_27CA
0000238E  7000                    6227      MOVEQ       #0,d0               * clear d0
00002390  102B 0594               6228      MOVE.b  FAC1_e(a3),d0       * get FAC1 exponent
00002394  67F6                    6229      BEQ.s       RTS_017         * exit if zero (already correct SGN(0)=0)
00002396                          6230  
00002396                          6231  
00002396                          6232  *************************************************************************************
00002396                          6233  *
00002396                          6234  * return d0=-1,C=1/-ve d0=+1,C=0/+ve
00002396                          6235  * no = 0 check
00002396                          6236  
00002396                          6237  LAB_27CE
00002396  102B 0595               6238      MOVE.b  FAC1_s(a3),d0       * else get FAC1 sign (b7)
0000239A                          6239  
0000239A                          6240  
0000239A                          6241  *************************************************************************************
0000239A                          6242  *
0000239A                          6243  * return d0=-1,C=1/-ve d0=+1,C=0/+ve
0000239A                          6244  * no = 0 check, sign in d0
0000239A                          6245  
0000239A                          6246  LAB_27D0
0000239A  4880                    6247      EXT.w       d0              * make word
0000239C  48C0                    6248      EXT.l       d0              * make longword
0000239E  E080                    6249      ASR.l       #8,d0               * move sign bit through byte to carry
000023A0  65EA                    6250      BCS.s       RTS_017         * exit if carry set
000023A2                          6251  
000023A2  7001                    6252      MOVEQ       #1,d0               * set result for +ve sign
000023A4  4E75                    6253      RTS
000023A6                          6254  
000023A6                          6255  
000023A6                          6256  *************************************************************************************
000023A6                          6257  *
000023A6                          6258  * perform SGN()
000023A6                          6259  
000023A6                          6260  LAB_SGN
000023A6  61E6                    6261      BSR.s       LAB_27CA            * get FAC1 sign
000023A8                          6262                              * return d0=-1/-ve d0=+1/+ve
000023A8                          6263  
000023A8                          6264  
000023A8                          6265  *************************************************************************************
000023A8                          6266  *
000023A8                          6267  * save d0 as integer longword
000023A8                          6268  
000023A8                          6269  LAB_27DB
000023A8  2740 0590               6270      MOVE.l  d0,FAC1_m(a3)       * save FAC1 mantissa
000023AC  377C A000 0594          6271      MOVE.w  #$A000,FAC1_e(a3)       * set FAC1 exponent & sign
000023B2  D080                    6272      ADD.l       d0,d0               * top bit into carry
000023B4  6000 FCD0               6273      BRA     LAB_24D0            * do +/- (carry is sign) & normalise FAC1
000023B8                          6274  
000023B8                          6275  
000023B8                          6276  *************************************************************************************
000023B8                          6277  *
000023B8                          6278  * perform ABS()
000023B8                          6279  
000023B8                          6280  LAB_ABS
000023B8  177C 0000 0595          6281      MOVE.b  #0,FAC1_s(a3)       * clear FAC1 sign
000023BE  4E75                    6282      RTS
000023C0                          6283  
000023C0                          6284  
000023C0                          6285  *************************************************************************************
000023C0                          6286  *
000023C0                          6287  * compare FAC1 with FAC2
000023C0                          6288  * returns d0=+1 Cb=0 if FAC1 > FAC2
000023C0                          6289  * returns d0= 0 Cb=0 if FAC1 = FAC2
000023C0                          6290  * returns d0=-1 Cb=1 if FAC1 < FAC2
000023C0                          6291  
000023C0                          6292  LAB_27FA
000023C0  122B 059C               6293      MOVE.b  FAC2_e(a3),d1       * get FAC2 exponent
000023C4  67C8                    6294      BEQ.s       LAB_27CA            * branch if FAC2 exponent=0 & get FAC1 sign
000023C6                          6295                              * d0=-1,C=1/-ve d0=+1,C=0/+ve
000023C6                          6296  
000023C6  102B 059E               6297      MOVE.b  FAC_sc(a3),d0       * get FAC sign compare
000023CA  6BCA                    6298      BMI.s       LAB_27CE            * if signs <> do return d0=-1,C=1/-ve
000023CC                          6299                              * d0=+1,C=0/+ve & return
000023CC                          6300  
000023CC  102B 0595               6301      MOVE.b  FAC1_s(a3),d0       * get FAC1 sign
000023D0  B22B 0594               6302      CMP.b       FAC1_e(a3),d1       * compare FAC1 exponent with FAC2 exponent
000023D4  660A                    6303      BNE.s       LAB_2828            * branch if different
000023D6                          6304  
000023D6  222B 0598               6305      MOVE.l  FAC2_m(a3),d1       * get FAC2 mantissa
000023DA  B2AB 0590               6306      CMP.l       FAC1_m(a3),d1       * compare mantissas
000023DE  6708                    6307      BEQ.s       LAB_282F            * exit if mantissas equal
000023E0                          6308  
000023E0                          6309  * gets here if number <> FAC1
000023E0                          6310  
000023E0                          6311  LAB_2828
000023E0  65B8                    6312      BCS.s       LAB_27D0            * if FAC1 > FAC2 return d0=-1,C=1/-ve d0=+1,
000023E2                          6313                              * C=0/+ve
000023E2                          6314  
000023E2  0A00 0080               6315      EORI.b  #$80,d0         * else toggle FAC1 sign
000023E6                          6316  LAB_282E
000023E6  60B2                    6317      BRA.s       LAB_27D0            * return d0=-1,C=1/-ve d0=+1,C=0/+ve
000023E8                          6318  
000023E8                          6319  LAB_282F
000023E8  7000                    6320      MOVEQ       #0,d0               * clear result
000023EA  4E75                    6321      RTS
000023EC                          6322  
000023EC                          6323  
000023EC                          6324  *************************************************************************************
000023EC                          6325  *
000023EC                          6326  * convert FAC1 floating to fixed
000023EC                          6327  * result in d0 and Itemp, sets flags correctly
000023EC                          6328  
000023EC                          6329  LAB_2831
000023EC  202B 0590               6330      MOVE.l  FAC1_m(a3),d0       * copy mantissa
000023F0  6732                    6331      BEQ.s       LAB_284J            * branch if mantissa = 0
000023F2                          6332  
000023F2  2F01                    6333      MOVE.l  d1,-(sp)            * save d1
000023F4  72A0                    6334      MOVEQ       #$A0,d1         * set for no floating bits
000023F6  922B 0594               6335      SUB.b       FAC1_e(a3),d1       * subtract FAC1 exponent
000023FA  6500 E2AE               6336      BCS     LAB_OFER            * do overflow if too big
000023FE                          6337  
000023FE  660E                    6338      BNE.s       LAB_284G            * branch if exponent was not $A0
00002400                          6339  
00002400  4A2B 0595               6340      TST.b       FAC1_s(a3)          * test FAC1 sign
00002404  6A1C                    6341      BPL.s       LAB_284H            * branch if FAC1 +ve
00002406                          6342  
00002406  4480                    6343      NEG.l       d0
00002408  6918                    6344      BVS.s       LAB_284H            * branch if was $80000000
0000240A                          6345  
0000240A  6000 E29E               6346      BRA     LAB_OFER            * do overflow if too big
0000240E                          6347  
0000240E                          6348  LAB_284G
0000240E  B23C 0020               6349      CMP.b       #$20,d1         * compare with minimum result for integer
00002412  6500 0004               6350      BCS     LAB_284L            * if < minimum just do shift
00002416                          6351  
00002416  7000                    6352      MOVEQ       #0,d0               * else return zero
00002418                          6353  LAB_284L
00002418  E2A8                    6354      LSR.l       d1,d0               * shift integer
0000241A                          6355  
0000241A  4A2B 0595               6356      TST.b       FAC1_s(a3)          * test FAC1 sign (b7)
0000241E  6A02                    6357      BPL.s       LAB_284H            * branch if FAC1 +ve
00002420                          6358  
00002420  4480                    6359      NEG.l       d0              * negate integer value
00002422                          6360  LAB_284H
00002422  221F                    6361      MOVE.l  (sp)+,d1            * restore d1
00002424                          6362  LAB_284J
00002424  2740 042A               6363      MOVE.l  d0,Itemp(a3)        * save the result
00002428  4E75                    6364      RTS
0000242A                          6365  
0000242A                          6366  
0000242A                          6367  *************************************************************************************
0000242A                          6368  *
0000242A                          6369  * perform INT()
0000242A                          6370  
0000242A                          6371  LAB_INT
0000242A  70A0                    6372      MOVEQ       #$A0,d0         * set for no floating bits
0000242C  902B 0594               6373      SUB.b       FAC1_e(a3),d0       * subtract FAC1 exponent
00002430  6310                    6374      BLS.s       LAB_IRTS            * exit if exponent >= $A0
00002432                          6375                              * (too big for fraction part!)
00002432                          6376  
00002432  B03C 0020               6377      CMP.b       #$20,d0         * compare with minimum result for integer
00002436  6400 025E               6378      BCC     LAB_POZE            * if >= minimum go return 0
0000243A                          6379                              * (too small for integer part!)
0000243A                          6380  
0000243A  72FF                    6381      MOVEQ       #-1,d1          * set integer mask
0000243C  E1A1                    6382      ASL.l       d0,d1               * shift mask [8+2*d0]
0000243E  C3AB 0590               6383      AND.l       d1,FAC1_m(a3)       * mask mantissa
00002442                          6384  LAB_IRTS
00002442  4E75                    6385      RTS
00002444                          6386  
00002444                          6387  
00002444                          6388  *************************************************************************************
00002444                          6389  *
00002444                          6390  * print " in line [LINE #]"
00002444                          6391  
00002444                          6392  LAB_2953
00002444  41FA 188E               6393      LEA     LAB_LMSG(pc),a0     * point to " in line " message
00002448  6100 EAEA               6394      BSR     LAB_18C3            * print null terminated string
0000244C                          6395  
0000244C                          6396                              * Print Basic line #
0000244C  202B 0452               6397      MOVE.l  Clinel(a3),d0       * get current line
00002450                          6398  
00002450                          6399  
00002450                          6400  *************************************************************************************
00002450                          6401  *
00002450                          6402  * print d0 as unsigned integer
00002450                          6403  
00002450                          6404  LAB_295E
00002450  43FA 0DE8               6405      LEA     Bin2dec(pc),a1      * get table address
00002454  7200                    6406      MOVEQ       #0,d1               * table index
00002456  41EB 05CC               6407      LEA     Usdss(a3),a0        * output string start
0000245A  2401                    6408      MOVE.l  d1,d2               * output string index
0000245C                          6409  LAB_2967
0000245C  2631 1000               6410      MOVE.l  (a1,d1.w),d3        * get table value
00002460  6714                    6411      BEQ.s       LAB_2969            * exit if end marker
00002462                          6412  
00002462  782F                    6413      MOVEQ       #'0'-1,d4           * set character to "0"-1
00002464                          6414  LAB_2968
00002464  5244                    6415      ADDQ.w  #1,d4               * next numeric character
00002466  9083                    6416      SUB.l       d3,d0               * subtract table value
00002468  6AFA                    6417      BPL.s       LAB_2968            * not overdone so loop
0000246A                          6418  
0000246A  D083                    6419      ADD.l       d3,d0               * correct value
0000246C  1184 2000               6420      MOVE.b  d4,(a0,d2.w)        * character out to string
00002470  5841                    6421      ADDQ.w  #4,d1               * increment table pointer
00002472  5242                    6422      ADDQ.w  #1,d2               * increment output string pointer
00002474  60E6                    6423      BRA.s       LAB_2967            * loop
00002476                          6424  
00002476                          6425  LAB_2969
00002476  0600 0030               6426      ADD.b       #'0',d0         * make last character
0000247A  1180 2000               6427      MOVE.b  d0,(a0,d2.w)        * character out to string
0000247E  5348                    6428      SUBQ.w  #1,a0               * decrement a0 (allow simple loop)
00002480                          6429  
00002480                          6430                              * now find non zero start of string
00002480                          6431  LAB_296A
00002480  5248                    6432      ADDQ.w  #1,a0               * increment a0 (this will never carry to b16)
00002482  43EB 05D5               6433      LEA     BHsend-1(a3),a1     * get string end
00002486  B1C9                    6434      CMPA.l  a1,a0               * are we at end
00002488  6700 EAAA               6435      BEQ     LAB_18C3            * if so print null terminated string and RETURN
0000248C                          6436  
0000248C  0C10 0030               6437      CMPI.b  #'0',(a0)           * is character "0" ?
00002490  67EE                    6438      BEQ.s       LAB_296A            * loop if so
00002492                          6439  
00002492  6000 EAA0               6440      BRA     LAB_18C3            * print null terminated string from memory & RET
00002496                          6441  
00002496                          6442  
00002496                          6443  *************************************************************************************
00002496                          6444  *
00002496                          6445  * convert FAC1 to ASCII string result in (a0)
00002496                          6446  * STR$() function enters here
00002496                          6447  
00002496                          6448  * now outputs 7 significant digits
00002496                          6449  
00002496                          6450  * d0 is character out
00002496                          6451  * d1 is save index
00002496                          6452  * d2 is gash
00002496                          6453  
00002496                          6454  * a0 is output string pointer
00002496                          6455  
00002496                          6456  LAB_2970
00002496  43EB 05C6               6457      LEA     Decss(a3),a1        * set output string start
0000249A                          6458  
0000249A  7420                    6459      MOVEQ       #' ',d2         * character = " ", assume +ve
0000249C  08AB 0007 0595          6460      BCLR.b  #7,FAC1_s(a3)       * test and clear FAC1 sign (b7)
000024A2  6702                    6461      BEQ.s       LAB_2978            * branch if +ve
000024A4                          6462  
000024A4  742D                    6463      MOVEQ       #'-',d2         * else character = "-"
000024A6                          6464  LAB_2978
000024A6  1282                    6465      MOVE.b  d2,(a1)         * save the sign character
000024A8  142B 0594               6466      MOVE.b  FAC1_e(a3),d2       * get FAC1 exponent
000024AC  6608                    6467      BNE.s       LAB_2989            * branch if FAC1<>0
000024AE                          6468  
000024AE                          6469                              * exponent was $00 so FAC1 is 0
000024AE  7030                    6470      MOVEQ       #'0',d0         * set character = "0"
000024B0  7201                    6471      MOVEQ       #1,d1               * set output string index
000024B2  6000 01A4               6472      BRA     LAB_2A89            * save last character, [EOT] & exit
000024B6                          6473  
000024B6                          6474                              * FAC1 is some non zero value
000024B6                          6475  LAB_2989
000024B6  177C 0000 05AC          6476      MOVE.b  #0,numexp(a3)       * clear number exponent count
000024BC  B43C 0081               6477      CMP.b       #$81,d2         * compare FAC1 exponent with $81 (>1.00000)
000024C0                          6478  
000024C0  6448                    6479      BCC.s       LAB_299C            * branch if FAC1=>1
000024C2                          6480  
000024C2                          6481                              * else FAC1 < 1
000024C2  277C 98968000 0598      6482      MOVE.l  #$98968000,FAC2_m(a3)   * 10000000 mantissa
000024CA  377C 9800 059C          6483      MOVE.w  #$9800,FAC2_e(a3)       * 10000000 exponent & sign
000024D0  176B 0595 059E          6484      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * make FAC1 sign sign compare
000024D6  6100 FCE2               6485      BSR     LAB_MULTIPLY        * do FAC2*FAC1
000024DA                          6486  
000024DA  177C 00F9 05AC          6487      MOVE.b  #$F9,numexp(a3)     * set number exponent count (-7)
000024E0  6028                    6488      BRA.s       LAB_299C            * go test for fit
000024E2                          6489  
000024E2                          6490  LAB_29B9
000024E2  376B 0594 059C          6491      MOVE.w  FAC1_e(a3),FAC2_e(a3)   * copy exponent & sign from FAC1 to FAC2
000024E8  276B 0590 0598          6492      MOVE.l  FAC1_m(a3),FAC2_m(a3)   * copy FAC1 mantissa to FAC2 mantissa
000024EE  176B 0595 059E          6493      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * save FAC1_s as sign compare
000024F4                          6494  
000024F4  277C CCCCCCCD 0590      6495      MOVE.l  #$CCCCCCCD,FAC1_m(a3)   * 1/10 mantissa
000024FC  377C 7D00 0594          6496      MOVE.w  #$7D00,FAC1_e(a3)       * 1/10 exponent & sign
00002502  6100 FCB6               6497      BSR     LAB_MULTIPLY        * do FAC2*FAC1, effectively divide by 10 but
00002506                          6498                              * faster
00002506                          6499  
00002506  522B 05AC               6500      ADDQ.b  #1,numexp(a3)       * increment number exponent count
0000250A                          6501  LAB_299C
0000250A  277C 98967F70 0598      6502      MOVE.l  #$98967F70,FAC2_m(a3)   * 9999999.4375 mantissa
00002512  377C 9800 059C          6503      MOVE.w  #$9800,FAC2_e(a3)       * 9999999.4375 exponent & sign
00002518                          6504                              * (max before scientific notation)
00002518  6100 014C               6505      BSR     LAB_27F0            * fast compare FAC1 with FAC2
0000251C                          6506                              * returns d0=+1 C=0 if FAC1 > FAC2
0000251C                          6507                              * returns d0= 0 C=0 if FAC1 = FAC2
0000251C                          6508                              * returns d0=-1 C=1 if FAC1 < FAC2
0000251C  62C4                    6509      BHI.s       LAB_29B9            * go do /10 if FAC1 > 9999999.4375
0000251E                          6510  
0000251E  6750                    6511      BEQ.s       LAB_29C3            * branch if FAC1 = 9999999.4375
00002520                          6512  
00002520                          6513                              * FAC1 < 9999999.4375
00002520  277C F423F800 0598      6514      MOVE.l  #$F423F800,FAC2_m(a3)   * set mantissa for 999999.5
00002528  377C 9400 059C          6515      MOVE.w  #$9400,FAC2_e(a3)       * set exponent for 999999.5
0000252E  41EB 0590               6516      LEA     FAC1_m(a3),a0       * set pointer for x10
00002532                          6517  LAB_29A7
00002532  6100 0132               6518      BSR     LAB_27F0            * fast compare FAC1 with FAC2
00002536                          6519                              * returns d0=+1 C=0 if FAC1 > FAC2
00002536                          6520                              * returns d0= 0 C=0 if FAC1 = FAC2
00002536                          6521                              * returns d0=-1 C=1 if FAC1 < FAC2
00002536  6220                    6522      BHI.s       LAB_29C0            * branch if FAC1 > 99999.9375,no decimal places
00002538                          6523  
00002538                          6524                              * FAC1 <= 999999.5 so do x 10
00002538  2010                    6525      MOVE.l  (a0),d0         * get FAC1 mantissa
0000253A  1228 0004               6526      MOVE.b  4(a0),d1            * get FAC1 exponent
0000253E  2400                    6527      MOVE.l  d0,d2               * copy it
00002540  E488                    6528      LSR.l       #2,d0               * /4
00002542  D082                    6529      ADD.l       d2,d0               * add FAC1 (x1.125)
00002544  6404                    6530      BCC.s       LAB_29B7            * branch if no carry
00002546                          6531  
00002546  E290                    6532      ROXR.l  #1,d0               * shift carry back in
00002548  5201                    6533      ADDQ.b  #1,d1               * increment exponent (never overflows)
0000254A                          6534  LAB_29B7
0000254A  5601                    6535      ADDQ.b  #3,d1               * correct exponent ( 8 x 1.125 = 10 )
0000254C                          6536                              * (never overflows)
0000254C  2080                    6537      MOVE.l  d0,(a0)         * save new mantissa
0000254E  1141 0004               6538      MOVE.b  d1,4(a0)            * save new exponent
00002552  532B 05AC               6539      SUBQ.b  #1,numexp(a3)       * decrement number exponent count
00002556  60DA                    6540      BRA.s       LAB_29A7            * go test again
00002558                          6541  
00002558                          6542                              * now we have just the digits to do
00002558                          6543  LAB_29C0
00002558  277C 80000000 0598      6544      MOVE.l  #$80000000,FAC2_m(a3)   * set mantissa for 0.5
00002560  377C 8000 059C          6545      MOVE.w  #$8000,FAC2_e(a3)       * set exponent for 0.5
00002566  176B 0595 059E          6546      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * sign compare = sign
0000256C  6100 FAA8               6547      BSR     LAB_ADD         * add the 0.5 to FAC1 (round FAC1)
00002570                          6548  
00002570                          6549  LAB_29C3
00002570  6100 FE7A               6550      BSR     LAB_2831            * convert FAC1 floating to fixed
00002574                          6551                              * result in d0 and Itemp
00002574  7401                    6552      MOVEQ       #$01,d2         * set default digits before dp = 1
00002576  102B 05AC               6553      MOVE.b  numexp(a3),d0       * get number exponent count
0000257A  5000                    6554      ADD.b       #8,d0               * allow 7 digits before point
0000257C  6B0C                    6555      BMI.s       LAB_29D9            * if -ve then 1 digit before dp
0000257E                          6556  
0000257E  B03C 0009               6557      CMP.b       #$09,d0         * d0>=9 if n>=1E7
00002582  6406                    6558      BCC.s       LAB_29D9            * branch if >= $09
00002584                          6559  
00002584                          6560                              * < $08
00002584  5300                    6561      SUBQ.b  #1,d0               * take 1 from digit count
00002586  1400                    6562      MOVE.b  d0,d2               * copy byte
00002588  7002                    6563      MOVEQ       #$02,d0         * set exponent adjust
0000258A                          6564  LAB_29D9
0000258A  7200                    6565      MOVEQ       #0,d1               * set output string index
0000258C  5500                    6566      SUBQ.b  #2,d0               * -2
0000258E  1740 05AD               6567      MOVE.b  d0,expcnt(a3)       * save exponent adjust
00002592  1742 05AC               6568      MOVE.b  d2,numexp(a3)       * save digits before dp count
00002596  1002                    6569      MOVE.b  d2,d0               * copy digits before dp count
00002598  6702                    6570      BEQ.s       LAB_29E4            * branch if no digits before dp
0000259A                          6571  
0000259A  6A14                    6572      BPL.s       LAB_29F7            * branch if digits before dp
0000259C                          6573  
0000259C                          6574  LAB_29E4
0000259C  5281                    6575      ADDQ.l  #1,d1               * increment index
0000259E  13BC 002E 1000          6576      MOVE.b  #'.',(a1,d1.w)      * save to output string
000025A4                          6577  
000025A4  4A02                    6578      TST.b       d2              * test digits before dp count
000025A6  6708                    6579      BEQ.s       LAB_29F7            * branch if no digits before dp
000025A8                          6580  
000025A8  5281                    6581      ADDQ.l  #1,d1               * increment index
000025AA  13BC 0030 1000          6582      MOVE.b  #'0',(a1,d1.w)      * save to output string
000025B0                          6583  LAB_29F7
000025B0  7400                    6584      MOVEQ       #0,d2               * clear index (point to 1,000,000)
000025B2  7080                    6585      MOVEQ       #$80-$100,d0        * set output character
000025B4                          6586  LAB_29FB
000025B4  41FA 1140               6587      LEA     LAB_2A9A(pc),a0     * get base of table
000025B8  2630 2000               6588      MOVE.l  (a0,d2.w),d3        * get table value
000025BC                          6589  LAB_29FD
000025BC  5200                    6590      ADDQ.b  #1,d0               * increment output character
000025BE  D7AB 042A               6591      ADD.l       d3,Itemp(a3)        * add to (now fixed) mantissa
000025C2  0800 0007               6592      BTST        #7,d0               * set test sense (z flag only)
000025C6  6504                    6593      BCS.s       LAB_2A18            * did carry so has wrapped past zero
000025C8                          6594  
000025C8  67F2                    6595      BEQ.s       LAB_29FD            * no wrap and +ve test so try again
000025CA                          6596  
000025CA  6002                    6597      BRA.s       LAB_2A1A            * found this digit
000025CC                          6598  
000025CC                          6599  LAB_2A18
000025CC  66EE                    6600      BNE.s       LAB_29FD            * wrap and -ve test so try again
000025CE                          6601  
000025CE                          6602  LAB_2A1A
000025CE  6406                    6603      BCC.s       LAB_2A21            * branch if +ve test result
000025D0                          6604  
000025D0  4400                    6605      NEG.b       d0              * negate the digit number
000025D2  0600 000B               6606      ADD.b       #$0B,d0         * and subtract from 11 decimal
000025D6                          6607  LAB_2A21
000025D6  0600 002F               6608      ADD.b       #$2F,d0         * add "0"-1 to result
000025DA  5842                    6609      ADDQ.w  #4,d2               * increment index to next less power of ten
000025DC  5241                    6610      ADDQ.w  #1,d1               * increment output string index
000025DE  1600                    6611      MOVE.b  d0,d3               * copy character to d3
000025E0  C63C 007F               6612      AND.b       #$7F,d3         * mask out top bit
000025E4  1383 1000               6613      MOVE.b  d3,(a1,d1.w)        * save to output string
000025E8  532B 05AC               6614      SUB.b       #1,numexp(a3)       * decrement # of characters before the dp
000025EC  6608                    6615      BNE.s       LAB_2A3B            * branch if still characters to do
000025EE                          6616  
000025EE                          6617                              * else output the point
000025EE  5281                    6618      ADDQ.l  #1,d1               * increment index
000025F0  13BC 002E 1000          6619      MOVE.b  #'.',(a1,d1.w)      * save to output string
000025F6                          6620  LAB_2A3B
000025F6  C03C 0080               6621      AND.b       #$80,d0         * mask test sense bit
000025FA  0A00 0080               6622      EORI.b  #$80,d0         * invert it
000025FE  B43C 001C               6623      CMP.b       #LAB_2A9B-LAB_2A9A,d2   * compare table index with max+4
00002602  66B0                    6624      BNE.s       LAB_29FB            * loop if not max
00002604                          6625  
00002604                          6626                              * now remove trailing zeroes
00002604                          6627  LAB_2A4B
00002604  1031 1000               6628      MOVE.b  (a1,d1.w),d0        * get character from output string
00002608  5381                    6629      SUBQ.l  #1,d1               * decrement output string index
0000260A  B03C 0030               6630      CMP.b       #'0',d0         * compare with "0"
0000260E  67F4                    6631      BEQ.s       LAB_2A4B            * loop until non "0" character found
00002610                          6632  
00002610  B03C 002E               6633      CMP.b       #'.',d0         * compare with "."
00002614  6702                    6634      BEQ.s       LAB_2A58            * branch if was dp
00002616                          6635  
00002616                          6636                              * else restore last character
00002616  5281                    6637      ADDQ.l  #1,d1               * increment output string index
00002618                          6638  LAB_2A58
00002618  13BC 002B 1002          6639      MOVE.b  #'+',2(a1,d1.w)     * save character "+" to output string
0000261E  4A2B 05AD               6640      TST.b       expcnt(a3)          * test exponent count
00002622  6738                    6641      BEQ.s       LAB_2A8C            * if zero go set null terminator & exit
00002624                          6642  
00002624                          6643                              * exponent isn't zero so write exponent
00002624  6A0A                    6644      BPL.s       LAB_2A68            * branch if exponent count +ve
00002626                          6645  
00002626  13BC 002D 1002          6646      MOVE.b  #'-',2(a1,d1.w)     * save character "-" to output string
0000262C  442B 05AD               6647      NEG.b       expcnt(a3)          * convert -ve to +ve
00002630                          6648  LAB_2A68
00002630  13BC 0045 1001          6649      MOVE.b  #'E',1(a1,d1.w)     * save character "E" to output string
00002636  142B 05AD               6650      MOVE.b  expcnt(a3),d2       * get exponent count
0000263A  702F                    6651      MOVEQ       #$2F,d0         * one less than "0" character
0000263C                          6652  LAB_2A74
0000263C  5200                    6653      ADDQ.b  #1,d0               * increment 10's character
0000263E  0402 000A               6654      SUB.b       #$0A,d2         * subtract 10 from exponent count
00002642  64F8                    6655      BCC.s       LAB_2A74            * loop while still >= 0
00002644                          6656  
00002644  0602 003A               6657      ADD.b       #$3A,d2         * add character ":", $30+$0A, result is 10-value
00002648  1380 1003               6658      MOVE.b  d0,3(a1,d1.w)       * save 10's character to output string
0000264C  1382 1004               6659      MOVE.b  d2,4(a1,d1.w)       * save 1's character to output string
00002650  13BC 0000 1005          6660      MOVE.b  #0,5(a1,d1.w)       * save null terminator after last character
00002656  600A                    6661      BRA.s       LAB_2A91            * go set string pointer (a0) and exit
00002658                          6662  
00002658                          6663  LAB_2A89
00002658  1380 1000               6664      MOVE.b  d0,(a1,d1.w)        * save last character to output string
0000265C                          6665  LAB_2A8C
0000265C  13BC 0000 1001          6666      MOVE.b  #0,1(a1,d1.w)       * save null terminator after last character
00002662                          6667  LAB_2A91
00002662  2049                    6668      MOVEA.l a1,a0               * set result string pointer (a0)
00002664  4E75                    6669      RTS
00002666                          6670  
00002666                          6671  
00002666                          6672  *************************************************************************************
00002666                          6673  *
00002666                          6674  * fast compare FAC1 with FAC2
00002666                          6675  * assumes both are +ve and FAC2>0
00002666                          6676  * returns d0=+1 C=0 if FAC1 > FAC2
00002666                          6677  * returns d0= 0 C=0 if FAC1 = FAC2
00002666                          6678  * returns d0=-1 C=1 if FAC1 < FAC2
00002666                          6679  
00002666                          6680  LAB_27F0
00002666  7000                    6681      MOVEQ       #0,d0               * set for FAC1 = FAC2
00002668  122B 059C               6682      MOVE.b  FAC2_e(a3),d1       * get FAC2 exponent
0000266C  B22B 0594               6683      CMP.b       FAC1_e(a3),d1       * compare FAC1 exponent with FAC2 exponent
00002670  660A                    6684      BNE.s       LAB_27F1            * branch if different
00002672                          6685  
00002672  222B 0598               6686      MOVE.l  FAC2_m(a3),d1       * get FAC2 mantissa
00002676  B2AB 0590               6687      CMP.l       FAC1_m(a3),d1       * compare mantissas
0000267A  6708                    6688      BEQ.s       LAB_27F3            * exit if mantissas equal
0000267C                          6689  
0000267C                          6690  LAB_27F1
0000267C  6504                    6691      BCS.s       LAB_27F2            * if FAC1 > FAC2 return d0=+1,C=0
0000267E                          6692  
0000267E  5380                    6693      SUBQ.l  #1,d0               * else FAC1 < FAC2 return d0=-1,C=1
00002680  4E75                    6694      RTS
00002682                          6695  
00002682                          6696  LAB_27F2
00002682  5280                    6697      ADDQ.l  #1,d0
00002684                          6698  LAB_27F3
00002684  4E75                    6699      RTS
00002686                          6700  
00002686                          6701  
00002686                          6702  *************************************************************************************
00002686                          6703  *
00002686                          6704  * make FAC1 = 1
00002686                          6705  
00002686                          6706  LAB_POON
00002686  277C 80000000 0590      6707      MOVE.l  #$80000000,FAC1_m(a3)   * 1 mantissa
0000268E  377C 8100 0594          6708      MOVE.w  #$8100,FAC1_e(a3)       * 1 exonent & sign
00002694  4E75                    6709      RTS
00002696                          6710  
00002696                          6711  
00002696                          6712  *************************************************************************************
00002696                          6713  *
00002696                          6714  * make FAC1 = 0
00002696                          6715  
00002696                          6716  LAB_POZE
00002696  7000                    6717      MOVEQ       #0,d0               * clear longword
00002698  2740 0590               6718      MOVE.l  d0,FAC1_m(a3)       * 0 mantissa
0000269C  3740 0594               6719      MOVE.w  d0,FAC1_e(a3)       * 0 exonent & sign
000026A0  4E75                    6720      RTS
000026A2                          6721  
000026A2                          6722  
000026A2                          6723  *************************************************************************************
000026A2                          6724  *
000026A2                          6725  * Perform power function
000026A2                          6726  * The number is in FAC2, the power is in FAC1
000026A2                          6727  * no longer trashes Itemp
000026A2                          6728  
000026A2                          6729  LAB_POWER
000026A2  4A2B 0594               6730      TST.b       FAC1_e(a3)          * test power
000026A6  67DE                    6731      BEQ.s       LAB_POON            * if zero go return 1
000026A8                          6732  
000026A8  4A2B 059C               6733      TST.b       FAC2_e(a3)          * test number
000026AC  67E8                    6734      BEQ.s       LAB_POZE            * if zero go return 0
000026AE                          6735  
000026AE  1F2B 059D               6736      MOVE.b  FAC2_s(a3),-(sp)        * save number sign
000026B2  6A20                    6737      BPL.s       LAB_POWP            * power of positive number
000026B4                          6738  
000026B4  7200                    6739      MOVEQ       #0,d1               * clear d1
000026B6  1741 059D               6740      MOVE.b  d1,FAC2_s(a3)       * make sign +ve
000026BA                          6741  
000026BA                          6742                              * number sign was -ve and can only be raised to
000026BA                          6743                              * an integer power which gives an x +j0 result,
000026BA                          6744                              * else do 'function call' error
000026BA  122B 0594               6745      MOVE.b  FAC1_e(a3),d1       * get power exponent
000026BE  0441 0080               6746      SUB.w       #$80,d1         * normalise to .5
000026C2  6300 DFEA               6747      BLS     LAB_FCER            * if 0<power<1 then do 'function call' error
000026C6                          6748  
000026C6                          6749                              * now shift all the integer bits out
000026C6  202B 0590               6750      MOVE.l  FAC1_m(a3),d0       * get power mantissa
000026CA  E3A0                    6751      ASL.l       d1,d0               * shift mantissa
000026CC  6600 DFE0               6752      BNE     LAB_FCER            * if power<>INT(power) then do 'function call'
000026D0                          6753                              * error
000026D0                          6754  
000026D0  6502                    6755      BCS.s       LAB_POWP            * if integer value odd then leave result -ve
000026D2                          6756  
000026D2  1E80                    6757      MOVE.b  d0,(sp)         * save result sign +ve
000026D4                          6758  LAB_POWP
000026D4  2F2B 0590               6759      MOVE.l  FAC1_m(a3),-(sp)        * save power mantissa
000026D8  3F2B 0594               6760      MOVE.w  FAC1_e(a3),-(sp)        * save power sign & exponent
000026DC                          6761  
000026DC  6100 FC76               6762      BSR     LAB_279B            * copy number to FAC1
000026E0  6100 F9E6               6763      BSR     LAB_LOG         * find log of number
000026E4                          6764  
000026E4  301F                    6765      MOVE.w  (sp)+,d0            * get power sign & exponent
000026E6  275F 0598               6766      MOVE.l  (sp)+,FAC2_m(a3)        * get power mantissa
000026EA  3740 059C               6767      MOVE.w  d0,FAC2_e(a3)       * save sign & exponent to FAC2
000026EE  1740 059E               6768      MOVE.b  d0,FAC_sc(a3)       * save sign as sign compare
000026F2  102B 0595               6769      MOVE.b  FAC1_s(a3),d0       * get FAC1 sign
000026F6  B12B 059E               6770      EOR.b       d0,FAC_sc(a3)       * make sign compare (FAC1_s EOR FAC2_s)
000026FA                          6771  
000026FA  6100 FABE               6772      BSR     LAB_MULTIPLY        * multiply by power
000026FE  6158                    6773      BSR.s       LAB_EXP         * find exponential
00002700  175F 0595               6774      MOVE.b  (sp)+,FAC1_s(a3)        * restore number sign
00002704  4E75                    6775      RTS
00002706                          6776  
00002706                          6777  
00002706                          6778  *************************************************************************************
00002706                          6779  *
00002706                          6780  * do - FAC1
00002706                          6781  
00002706                          6782  LAB_GTHAN
00002706  4A2B 0594               6783      TST.b       FAC1_e(a3)          * test for non zero FAC1
0000270A  6706                    6784      BEQ.s       RTS_020         * branch if null
0000270C                          6785  
0000270C  0A2B 0080 0595          6786      EORI.b  #$80,FAC1_s(a3)     * (else) toggle FAC1 sign bit
00002712                          6787  RTS_020
00002712  4E75                    6788      RTS
00002714                          6789  
00002714                          6790  
00002714                          6791  *************************************************************************************
00002714                          6792  *
00002714                          6793                              * return +1
00002714                          6794  LAB_EX1
00002714  277C 80000000 0590      6795      MOVE.l  #$80000000,FAC1_m(a3)   * +1 mantissa
0000271C  377C 8100 0594          6796      MOVE.w  #$8100,FAC1_e(a3)       * +1 sign & exponent
00002722  4E75                    6797      RTS
00002724                          6798                              * do over/under flow
00002724                          6799  LAB_EXOU
00002724  4A2B 0595               6800      TST.b       FAC1_s(a3)          * test sign
00002728  6A00 DF80               6801      BPL     LAB_OFER            * was +ve so do overflow error
0000272C                          6802  
0000272C                          6803                              * else underflow so return zero
0000272C  7000                    6804      MOVEQ       #0,d0               * clear longword
0000272E  2740 0590               6805      MOVE.l  d0,FAC1_m(a3)       * 0 mantissa
00002732  3740 0594               6806      MOVE.w  d0,FAC1_e(a3)       * 0 sign & exponent
00002736  4E75                    6807      RTS
00002738                          6808                              * fraction was zero so do 2^n
00002738                          6809  LAB_EXOF
00002738  277C 80000000 0590      6810      MOVE.l  #$80000000,FAC1_m(a3)   * +n mantissa
00002740  177C 0000 0595          6811      MOVE.b  #0,FAC1_s(a3)       * clear sign
00002746  4A2B 05B4               6812      TST.b       cosout(a3)          * test sign flag
0000274A  6A02                    6813      BPL.s       LAB_EXOL            * branch if +ve
0000274C                          6814  
0000274C  4481                    6815      NEG.l       d1              * else do 1/2^n
0000274E                          6816  LAB_EXOL
0000274E  0601 0081               6817      ADD.b       #$81,d1         * adjust exponent
00002752  1741 0594               6818      MOVE.b  d1,FAC1_e(a3)       * save exponent
00002756  4E75                    6819      RTS
00002758                          6820  
00002758                          6821  * perform EXP() (x^e)
00002758                          6822  * valid input range is -88 to +88
00002758                          6823  
00002758                          6824  LAB_EXP
00002758  102B 0594               6825      MOVE.b  FAC1_e(a3),d0       * get exponent
0000275C  67B6                    6826      BEQ.s       LAB_EX1         * return 1 for zero in
0000275E                          6827  
0000275E  B03C 0064               6828      CMP.b       #$64,d0         * compare exponent with min
00002762  65B0                    6829      BCS.s       LAB_EX1         * if smaller just return 1
00002764                          6830  
00002764                          6831  **  MOVEM.l d1-d6/a0,-(sp)      * save the registers
00002764  177C 0000 05B4          6832      MOVE.b  #0,cosout(a3)       * flag +ve number
0000276A  222B 0590               6833      MOVE.l  FAC1_m(a3),d1       * get mantissa
0000276E  B03C 0087               6834      CMP.b       #$87,d0         * compare exponent with max
00002772  62B0                    6835      BHI.s       LAB_EXOU            * go do over/under flow if greater
00002774                          6836  
00002774  6608                    6837      BNE.s       LAB_EXCM            * branch if less
00002776                          6838  
00002776                          6839                              * else is 2^7
00002776  B2BC B00F33C7           6840      CMP.l       #$B00F33C7,d1       * compare mantissa with n*2^7 max
0000277C  64A6                    6841      BCC.s       LAB_EXOU            * if => go over/underflow
0000277E                          6842  
0000277E                          6843  LAB_EXCM
0000277E  4A2B 0595               6844      TST.b       FAC1_s(a3)          * test sign
00002782  6A0C                    6845      BPL.s       LAB_EXPS            * branch if arg +ve
00002784                          6846  
00002784  177C 00FF 05B4          6847      MOVE.b  #$FF,cosout(a3)     * flag -ve number
0000278A  177C 0000 0595          6848      MOVE.b  #0,FAC1_s(a3)       * take absolute value
00002790                          6849  LAB_EXPS
00002790                          6850                              * now do n/LOG(2)
00002790  277C B8AA3B29 0598      6851      MOVE.l  #$B8AA3B29,FAC2_m(a3)   * 1/LOG(2) mantissa
00002798  377C 8100 059C          6852      MOVE.w  #$8100,FAC2_e(a3)       * 1/LOG(2) exponent & sign
0000279E  177C 0000 059E          6853      MOVE.b  #0,FAC_sc(a3)       * we know they're both +ve
000027A4  6100 FA14               6854      BSR     LAB_MULTIPLY        * effectively divide by log(2)
000027A8                          6855  
000027A8                          6856                              * max here is +/- 127
000027A8                          6857                              * now separate integer and fraction
000027A8  177C 0000 05D9          6858      MOVE.b  #0,tpower(a3)       * clear exponent add byte
000027AE  1A2B 0594               6859      MOVE.b  FAC1_e(a3),d5       * get exponent
000027B2  0405 0080               6860      SUB.b       #$80,d5         * normalise
000027B6  6324                    6861      BLS.s       LAB_ESML            * branch if < 1 (d5 is 0 or -ve)
000027B8                          6862  
000027B8                          6863                              * result is > 1
000027B8  202B 0590               6864      MOVE.l  FAC1_m(a3),d0       * get mantissa
000027BC  2200                    6865      MOVE.l  d0,d1               * copy it
000027BE  2C05                    6866      MOVE.l  d5,d6               * copy normalised exponent
000027C0                          6867  
000027C0  4446                    6868      NEG.w       d6              * make -ve
000027C2  0646 0020               6869      ADD.w       #32,d6          * is now 32-d6
000027C6  ECA9                    6870      LSR.l       d6,d1               * just integer bits
000027C8  1741 05D9               6871      MOVE.b  d1,tpower(a3)       * set exponent add byte
000027CC                          6872  
000027CC  EBA8                    6873      LSL.l       d5,d0               * shift out integer bits
000027CE  6700 FF68               6874      BEQ     LAB_EXOF            * fraction is zero so do 2^n
000027D2                          6875  
000027D2  2740 0590               6876      MOVE.l  d0,FAC1_m(a3)       * fraction to FAC1
000027D6  377C 8000 0594          6877      MOVE.w  #$8000,FAC1_e(a3)       * set exponent & sign
000027DC                          6878  
000027DC                          6879                              * multiple was < 1
000027DC                          6880  LAB_ESML
000027DC  277C B17217F8 0598      6881      MOVE.l  #$B17217F8,FAC2_m(a3)   * LOG(2) mantissa
000027E4  377C 8000 059C          6882      MOVE.w  #$8000,FAC2_e(a3)       * LOG(2) exponent & sign
000027EA  177C 0000 059E          6883      MOVE.b  #0,FAC_sc(a3)       * clear sign compare
000027F0  6100 F9C8               6884      BSR     LAB_MULTIPLY        * multiply by log(2)
000027F4                          6885  
000027F4  202B 0590               6886      MOVE.l  FAC1_m(a3),d0       * get mantissa
000027F8  1A2B 0594               6887      MOVE.b  FAC1_e(a3),d5       * get exponent
000027FC  0445 0082               6888      SUB.w       #$82,d5         * normalise and -2 (result is -1 to -30)
00002800  4445                    6889      NEG.w       d5              * make +ve
00002802  EAA8                    6890      LSR.l       d5,d0               * shift for 2 integer bits
00002804                          6891  
00002804                          6892  * d0 = arg
00002804                          6893  * d6 = x, d1 = y
00002804                          6894  * d2 = x1, d3 = y1
00002804                          6895  * d4 = shift count
00002804                          6896  * d5 = loop count
00002804                          6897                              * now do cordic set-up
00002804  7200                    6898      MOVEQ       #0,d1               * y = 0
00002806  2C3C 26A3D110           6899      MOVE.l  #KFCTSEED,d6        * x = 1 with jkh inverse factored out
0000280C  41FA 0D2A               6900      LEA     TAB_HTHET(pc),a0        * get pointer to hyperbolic arctan table
00002810  7800                    6901      MOVEQ       #0,d4               * clear shift count
00002812                          6902   
00002812                          6903                              * cordic loop, shifts 4 and 13 (and 39
00002812                          6904                              * if it went that far) need to be repeated
00002812  7A03                    6905      MOVEQ       #3,d5               * 4 loops
00002814  6136                    6906      BSR.s       LAB_EXCC            * do loops 1 through 4
00002816  5948                    6907      SUBQ.w  #4,a0               * do table entry again
00002818  5384                    6908      SUBQ.l  #1,d4               * do shift count again
0000281A  7A09                    6909      MOVEQ       #9,d5               * 10 loops
0000281C  612E                    6910      BSR.s       LAB_EXCC            * do loops 4 (again) through 13
0000281E  5948                    6911      SUBQ.w  #4,a0               * do table entry again
00002820  5384                    6912      SUBQ.l  #1,d4               * do shift count again
00002822  7A12                    6913      MOVEQ       #18,d5          * 19 loops
00002824  6126                    6914      BSR.s       LAB_EXCC            * do loops 13 (again) through 31
00002826                          6915   
00002826                          6916                              * now get the result
00002826  4A2B 05B4               6917      TST.b       cosout(a3)          * test sign flag
0000282A  6A06                    6918      BPL.s       LAB_EXPL            * branch if +ve
0000282C                          6919  
0000282C  4481                    6920      NEG.l       d1              * do -y
0000282E  442B 05D9               6921      NEG.b       tpower(a3)          * do -exp
00002832                          6922  LAB_EXPL
00002832  7083                    6923      MOVEQ       #$83-$100,d0        * set exponent
00002834  DC81                    6924      ADD.l       d1,d6               * y = y +/- x
00002836  6B06                    6925      BMI.s       LAB_EXRN            * branch if result normal
00002838                          6926  
00002838                          6927  LAB_EXNN
00002838  5380                    6928      SUBQ.l  #1,d0               * decrement exponent
0000283A  DC86                    6929      ADD.l       d6,d6               * shift mantissa
0000283C  6AFA                    6930      BPL.s       LAB_EXNN            * loop if not normal
0000283E                          6931  
0000283E                          6932  LAB_EXRN
0000283E  2746 0590               6933      MOVE.l  d6,FAC1_m(a3)       * save exponent result
00002842  D02B 05D9               6934      ADD.b       tpower(a3),d0       * add integer part
00002846  1740 0594               6935      MOVE.b  d0,FAC1_e(a3)       * save exponent
0000284A                          6936  **  MOVEM.l (sp)+,d1-d6/a0      * restore registers
0000284A  4E75                    6937      RTS
0000284C                          6938   
0000284C                          6939                              * cordic loop
0000284C                          6940  LAB_EXCC
0000284C  5284                    6941      ADDQ.l  #1,d4               * increment shift count
0000284E  2406                    6942      MOVE.l  d6,d2               * x1 = x
00002850  E8A2                    6943      ASR.l       d4,d2               * x1 >> n
00002852  2601                    6944      MOVE.l  d1,d3               * y1 = y
00002854  E8A3                    6945      ASR.l       d4,d3               * y1 >> n
00002856  4A80                    6946      TST.l       d0              * test arg
00002858  6B0C                    6947      BMI.s       LAB_EXAD            * branch if -ve
0000285A                          6948  
0000285A  D282                    6949      ADD.l       d2,d1               * y = y + x1
0000285C  DC83                    6950      ADD.l       d3,d6               * x = x + y1
0000285E  9098                    6951      SUB.l       (a0)+,d0            * arg = arg - atnh(a0)
00002860  51CD FFEA               6952      DBF     d5,LAB_EXCC         * decrement and loop if not done
00002864                          6953  
00002864  4E75                    6954      RTS
00002866                          6955  
00002866                          6956  LAB_EXAD
00002866  9282                    6957      SUB.l       d2,d1               * y = y - x1
00002868  9C83                    6958      SUB.l       d3,d6               * x = x + y1
0000286A  D098                    6959      ADD.l       (a0)+,d0            * arg = arg + atnh(a0)
0000286C  51CD FFDE               6960      DBF     d5,LAB_EXCC         * decrement and loop if not done
00002870                          6961  
00002870  4E75                    6962      RTS
00002872                          6963  
00002872                          6964  
00002872                          6965  *************************************************************************************
00002872                          6966  *
00002872                          6967  * RND(n), 32 bit Galois version. make n=0 for 19th next number in sequence or n<>0
00002872                          6968  * to get 19th next number in sequence after seed n. This version of the PRNG uses
00002872                          6969  * the Galois method and a sample of 65536 bytes produced gives the following values.
00002872                          6970  
00002872                          6971  * Entropy = 7.997442 bits per byte
00002872                          6972  * Optimum compression would reduce these 65536 bytes by 0 percent
00002872                          6973  
00002872                          6974  * Chi square distribution for 65536 samples is 232.01, and
00002872                          6975  * randomly would exceed this value 75.00 percent of the time
00002872                          6976  
00002872                          6977  * Arithmetic mean value of data bytes is 127.6724, 127.5 would be random
00002872                          6978  * Monte Carlo value for Pi is 3.122871269, error 0.60 percent
00002872                          6979  * Serial correlation coefficient is -0.000370, totally uncorrelated would be 0.0
00002872                          6980  
00002872                          6981  LAB_RND
00002872  4A2B 0594               6982      TST.b       FAC1_e(a3)          * get FAC1 exponent
00002876  6708                    6983      BEQ.s       NextPRN         * do next random number if zero
00002878                          6984  
00002878                          6985                              * else get seed into random number store
00002878  41EB 05A0               6986      LEA     PRNlword(a3),a0     * set PRNG pointer
0000287C  6100 FAB0               6987      BSR     LAB_2778            * pack FAC1 into (a0)
00002880                          6988  NextPRN
00002880  72AF                    6989      MOVEQ       #$AF-$100,d1        * set EOR value
00002882  7412                    6990      MOVEQ       #18,d2          * do this 19 times
00002884  202B 05A0               6991      MOVE.l  PRNlword(a3),d0     * get current
00002888                          6992  Ninc0
00002888  D080                    6993      ADD.l       d0,d0               * shift left 1 bit
0000288A  6402                    6994      BCC.s       Ninc1               * branch if bit 32 not set
0000288C                          6995  
0000288C  B300                    6996      EOR.b       d1,d0               * do Galois LFSR feedback
0000288E                          6997  Ninc1
0000288E  51CA FFF8               6998      DBF     d2,Ninc0            * loop
00002892                          6999  
00002892  2740 05A0               7000      MOVE.l  d0,PRNlword(a3)     * save back to seed word
00002896  2740 0590               7001      MOVE.l  d0,FAC1_m(a3)       * copy to FAC1 mantissa
0000289A  377C 8000 0594          7002      MOVE.w  #$8000,FAC1_e(a3)       * set the exponent and clear the sign
000028A0  6000 F7F0               7003      BRA     LAB_24D5            * normalise FAC1 & return
000028A4                          7004  
000028A4                          7005  
000028A4                          7006  *************************************************************************************
000028A4                          7007  *
000028A4                          7008  * cordic TAN(x) routine, TAN(x) = SIN(x)/COS(x)
000028A4                          7009  * x = angle in radians
000028A4                          7010  
000028A4                          7011  LAB_TAN
000028A4  6138                    7012      BSR.s       LAB_SIN         * go do SIN/COS cordic compute
000028A6  376B 0594 059C          7013      MOVE.w  FAC1_e(a3),FAC2_e(a3)   * copy exponent & sign from FAC1 to FAC2
000028AC  276B 0590 0598          7014      MOVE.l  FAC1_m(a3),FAC2_m(a3)   * copy FAC1 mantissa to FAC2 mantissa
000028B2  2741 0590               7015      MOVE.l  d1,FAC1_m(a3)       * get COS(x) mantissa
000028B6  1743 0594               7016      MOVE.b  d3,FAC1_e(a3)       * get COS(x) exponent
000028BA  6700 DDEE               7017      BEQ     LAB_OFER            * do overflow if COS = 0
000028BE                          7018  
000028BE  6100 F7D2               7019      BSR     LAB_24D5            * normalise FAC1
000028C2  6000 F982               7020      BRA     LAB_DIVIDE          * do FAC2/FAC1 and return, FAC_sc set by SIN
000028C6                          7021                              * COS calculation
000028C6                          7022  
000028C6                          7023  
000028C6                          7024  *************************************************************************************
000028C6                          7025  *
000028C6                          7026  * cordic SIN(x), COS(x) routine
000028C6                          7027  * x = angle in radians
000028C6                          7028  
000028C6                          7029  LAB_COS
000028C6  277C C90FDAA3 0598      7030      MOVE.l  #$C90FDAA3,FAC2_m(a3)   * pi/2 mantissa (LSB is rounded up so
000028CE                          7031                              * COS(PI/2)=0)
000028CE  377C 8100 059C          7032      MOVE.w  #$8100,FAC2_e(a3)       * pi/2 exponent and sign
000028D4  176B 0595 059E          7033      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * sign = FAC1 sign (b7)
000028DA  6100 F73A               7034      BSR     LAB_ADD         * add FAC2 to FAC1, adjust for COS(x)
000028DE                          7035  
000028DE                          7036  
000028DE                          7037  *************************************************************************************
000028DE                          7038  *
000028DE                          7039  * SIN/COS cordic calculator
000028DE                          7040  
000028DE                          7041  LAB_SIN
000028DE  177C 0000 05B4          7042      MOVE.b  #0,cosout(a3)       * set needed result
000028E4                          7043  
000028E4  277C A2F9836F 0598      7044      MOVE.l  #$A2F9836F,FAC2_m(a3)   * 1/pi mantissa (LSB is rounded up so SIN(PI)=0)
000028EC  377C 7F00 059C          7045      MOVE.w  #$7F00,FAC2_e(a3)       * 1/pi exponent & sign
000028F2  176B 0595 059E          7046      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * sign = FAC1 sign (b7)
000028F8  6100 F8C0               7047      BSR     LAB_MULTIPLY        * multiply by 1/pi
000028FC                          7048  
000028FC  102B 0594               7049      MOVE.b  FAC1_e(a3),d0       * get FAC1 exponent
00002900  671C                    7050      BEQ.s       LAB_SCZE            * branch if zero
00002902                          7051  
00002902  41FA 0B34               7052      LEA     TAB_SNCO(pc),a0     * get pointer to constants table
00002906  2C2B 0590               7053      MOVE.l  FAC1_m(a3),d6       * get FAC1 mantissa
0000290A  5300                    7054      SUBQ.b  #1,d0               * 2 radians in 360 degrees so /2
0000290C  6710                    7055      BEQ.s       LAB_SCZE            * branch if zero
0000290E                          7056  
0000290E  0400 0080               7057      SUB.b       #$80,d0         * normalise exponent
00002912  6B18                    7058      BMI.s       LAB_SCL0            * branch if < 1
00002914                          7059  
00002914                          7060                              * X is > 1
00002914  B03C 0020               7061      CMP.b       #$20,d0         * is it >= 2^32
00002918  6404                    7062      BCC.s       LAB_SCZE            * may as well do zero
0000291A                          7063  
0000291A  E1AE                    7064      LSL.l       d0,d6               * shift out integer part bits
0000291C  6618                    7065      BNE.s       LAB_CORD            * if fraction go test quadrant and adjust
0000291E                          7066  
0000291E                          7067                              * else no fraction so do zero
0000291E                          7068  LAB_SCZE
0000291E  7481                    7069      MOVEQ       #$81-$100,d2        * set exponent for 1.0
00002920  7600                    7070      MOVEQ       #0,d3               * set exponent for 0.0
00002922  203C 80000000           7071      MOVE.l  #$80000000,d0       * mantissa for 1.0
00002928  2203                    7072      MOVE.l  d3,d1               * mantissa for 0.0
0000292A  6062                    7073      BRA.s       outloop         * go output it
0000292C                          7074  
0000292C                          7075                              * x is < 1
0000292C                          7076  LAB_SCL0
0000292C  4400                    7077      NEG.b       d0              * make +ve
0000292E  B03C 001E               7078      CMP.b       #$1E,d0         * is it <= 2^-30
00002932  64EA                    7079      BCC.s       LAB_SCZE            * may as well do zero
00002934                          7080  
00002934  E0AE                    7081      LSR.l       d0,d6               * shift out <= 2^-32 bits
00002936                          7082  
00002936                          7083  * cordic calculator, argument in d6
00002936                          7084  * table pointer in a0, returns in d0-d3
00002936                          7085  
00002936                          7086  LAB_CORD
00002936  176B 0595 059E          7087      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * copy as sign compare for TAN
0000293C  DC86                    7088      ADD.l       d6,d6               * shift 0.5 bit into carry
0000293E  6406                    7089      BCC.s       LAB_LTPF            * branch if less than 0.5
00002940                          7090  
00002940  0A2B 00FF 0595          7091      EORI.b  #$FF,FAC1_s(a3)     * toggle result sign
00002946                          7092  LAB_LTPF
00002946  DC86                    7093      ADD.l       d6,d6               * shift 0.25 bit into carry
00002948  640C                    7094      BCC.s       LAB_LTPT            * branch if less than 0.25
0000294A                          7095  
0000294A  0A2B 00FF 05B4          7096      EORI.b  #$FF,cosout(a3)     * toggle needed result
00002950  0A2B 00FF 059E          7097      EORI.b  #$FF,FAC_sc(a3)     * toggle sign compare for TAN
00002956                          7098  
00002956                          7099  LAB_LTPT
00002956  E48E                    7100      LSR.l       #2,d6               * shift the bits back (clear integer bits)
00002958  67C4                    7101      BEQ.s       LAB_SCZE            * no fraction so go do zero
0000295A                          7102  
0000295A                          7103                              * set start values
0000295A  7A01                    7104      MOVEQ       #1,d5               * set bit count
0000295C  2028 FFFC               7105      MOVE.l  -4(a0),d0           * get multiply constant (1st itteration d0)
00002960  2200                    7106      MOVE.l  d0,d1               * 1st itteration d1
00002962  9C98                    7107      SUB.l       (a0)+,d6            * 1st always +ve so do 1st step
00002964  6008                    7108      BRA.s       mainloop            * jump into routine
00002966                          7109  
00002966                          7110  subloop
00002966  9C98                    7111      SUB.l       (a0)+,d6            * z = z - arctan(i)/2pi
00002968  9083                    7112      SUB.l       d3,d0               * x = x - y1
0000296A  D282                    7113      ADD.l       d2,d1               * y = y + x1
0000296C  6012                    7114      BRA.s       nexta               * back to main loop
0000296E                          7115  
0000296E                          7116  mainloop
0000296E  2400                    7117      MOVE.l  d0,d2               * x1 = x
00002970  EAA2                    7118      ASR.l       d5,d2               * / (2 ^ i)
00002972  2601                    7119      MOVE.l  d1,d3               * y1 = y
00002974  EAA3                    7120      ASR.l       d5,d3               * / (2 ^ i)
00002976  4A86                    7121      TST.l       d6              * test sign (is 2^0 bit)
00002978  6AEC                    7122      BPL.s       subloop         * go do subtract if > 1
0000297A                          7123  
0000297A  DC98                    7124      ADD.l       (a0)+,d6            * z = z + arctan(i)/2pi
0000297C  D083                    7125      ADD.l       d3,d0               * x = x + y1
0000297E  9282                    7126      SUB.l       d2,d1               * y = y + x1
00002980                          7127  nexta
00002980  5285                    7128      ADDQ.l  #1,d5               * i = i + 1
00002982  BABC 0000001E           7129      CMP.l       #$1E,d5         * check end condition
00002988  66E4                    7130      BNE.s       mainloop            * loop if not all done
0000298A                          7131  
0000298A                          7132                              * now untangle output value
0000298A  7481                    7133      MOVEQ       #$81-$100,d2        * set exponent for 0 to .99 rec.
0000298C  2602                    7134      MOVE.l  d2,d3               * copy it for cos output
0000298E                          7135  outloop
0000298E  4A2B 05B4               7136      TST.b       cosout(a3)          * did we want cos output?
00002992  6B04                    7137      BMI.s       subexit         * if so skip
00002994                          7138  
00002994  C141                    7139      EXG     d0,d1               * swap SIN and COS mantissas
00002996  C543                    7140      EXG     d2,d3               * swap SIN and COS exponents
00002998                          7141  subexit
00002998  2740 0590               7142      MOVE.l  d0,FAC1_m(a3)       * set result mantissa
0000299C  1742 0594               7143      MOVE.b  d2,FAC1_e(a3)       * set result exponent
000029A0  6000 F6F0               7144      BRA     LAB_24D5            * normalise FAC1 & return
000029A4                          7145  
000029A4                          7146  
000029A4                          7147  
000029A4                          7148  *************************************************************************************
000029A4                          7149  *
000029A4                          7150  * perform ATN()
000029A4                          7151  
000029A4                          7152  LAB_ATN
000029A4  102B 0594               7153      MOVE.b  FAC1_e(a3),d0       * get FAC1 exponent
000029A8  6700 00AA               7154      BEQ     RTS_021         * ATN(0) = 0 so skip calculation
000029AC                          7155  
000029AC  177C 0000 05B4          7156      MOVE.b  #0,cosout(a3)       * set result needed
000029B2  B03C 0081               7157      CMP.b       #$81,d0         * compare exponent with 1
000029B6  6528                    7158      BCS.s       LAB_ATLE            * branch if n<1
000029B8                          7159  
000029B8  6608                    7160      BNE.s       LAB_ATGO            * branch if n>1
000029BA                          7161  
000029BA  202B 0590               7162      MOVE.l  FAC1_m(a3),d0       * get mantissa
000029BE  D080                    7163      ADD.l       d0,d0               * shift left
000029C0  671E                    7164      BEQ.s       LAB_ATLE            * branch if n=1
000029C2                          7165  
000029C2                          7166  LAB_ATGO
000029C2  277C 80000000 0598      7167      MOVE.l  #$80000000,FAC2_m(a3)   * set mantissa for 1
000029CA  377C 8100 059C          7168      MOVE.w  #$8100,FAC2_e(a3)       * set exponent for 1
000029D0  176B 0595 059E          7169      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * sign compare = sign
000029D6  6100 F86E               7170      BSR     LAB_DIVIDE          * do 1/n
000029DA  177C 00FF 05B4          7171      MOVE.b  #$FF,cosout(a3)     * set inverse result needed
000029E0                          7172  LAB_ATLE
000029E0  202B 0590               7173      MOVE.l  FAC1_m(a3),d0       * get FAC1 mantissa
000029E4  7282                    7174      MOVEQ       #$82,d1         * set to correct exponent
000029E6  922B 0594               7175      SUB.b       FAC1_e(a3),d1       * subtract FAC1 exponent (always <= 1)
000029EA  E2A8                    7176      LSR.l       d1,d0               * shift in two integer part bits
000029EC  41FA 0ACA               7177      LEA     TAB_ATNC(pc),a0     * get pointer to arctan table
000029F0  7C00                    7178      MOVEQ       #0,d6               * Z = 0
000029F2  223C 40000000           7179      MOVE.l  #1<<30,d1           * y = 1
000029F8  7A1D                    7180      MOVEQ       #29,d5          * loop 30 times
000029FA  7801                    7181      MOVEQ       #1,d4               * shift counter
000029FC  6006                    7182      BRA.s       LAB_ATCD            * enter loop
000029FE                          7183  
000029FE                          7184  LAB_ATNP
000029FE  E8A2                    7185      ASR.l       d4,d2               * x1 / 2^i
00002A00  D282                    7186      ADD.l       d2,d1               * y = y + x1
00002A02  DC90                    7187      ADD.l       (a0),d6         * z = z + atn(i)
00002A04                          7188  LAB_ATCD
00002A04  2400                    7189      MOVE.l  d0,d2               * x1 = x
00002A06  2601                    7190      MOVE.l  d1,d3               * y1 = y
00002A08  E8A3                    7191      ASR.l       d4,d3               * y1 / 2^i
00002A0A                          7192  LAB_CATN
00002A0A  9083                    7193      SUB.l       d3,d0               * x = x - y1
00002A0C  6AF0                    7194      BPL.s       LAB_ATNP            * branch if x >= 0
00002A0E                          7195  
00002A0E  2002                    7196      MOVE.l  d2,d0               * else get x back
00002A10  5848                    7197      ADDQ.w  #4,a0               * increment pointer
00002A12  5284                    7198      ADDQ.l  #1,d4               * increment i
00002A14  E283                    7199      ASR.l       #1,d3               * y1 / 2^i
00002A16  51CD FFF2               7200      DBF     d5,LAB_CATN         * decrement and loop if not done
00002A1A                          7201  
00002A1A  177C 0082 0594          7202      MOVE.b  #$82,FAC1_e(a3)     * set new exponent
00002A20  2746 0590               7203      MOVE.l  d6,FAC1_m(a3)       * save mantissa
00002A24  6100 F66C               7204      BSR     LAB_24D5            * normalise FAC1
00002A28                          7205  
00002A28  4A2B 05B4               7206      TST.b       cosout(a3)          * was it > 1 ?
00002A2C  6A26                    7207      BPL.s       RTS_021         * branch if not
00002A2E                          7208  
00002A2E  1E2B 0595               7209      MOVE.b  FAC1_s(a3),d7       * get sign
00002A32  177C 0000 0595          7210      MOVE.b  #0,FAC1_s(a3)       * clear sign
00002A38  277C C90FDAA2 0598      7211      MOVE.l  #$C90FDAA2,FAC2_m(a3)   * set -(pi/2)
00002A40  377C 8180 059C          7212      MOVE.w  #$8180,FAC2_e(a3)       * set exponent and sign
00002A46  177C 00FF 059E          7213      MOVE.b  #$FF,FAC_sc(a3)     * set sign compare
00002A4C  6100 F5C8               7214      BSR     LAB_ADD         * perform addition, FAC2 to FAC1
00002A50  1747 0595               7215      MOVE.b  d7,FAC1_s(a3)       * restore sign
00002A54                          7216  RTS_021
00002A54  4E75                    7217      RTS
00002A56                          7218  
00002A56                          7219  
00002A56                          7220  *************************************************************************************
00002A56                          7221  *
00002A56                          7222  * perform BITSET
00002A56                          7223  
00002A56                          7224  LAB_BITSET
00002A56  6100 F26E               7225      BSR     LAB_GADB            * get two parameters for POKE or WAIT
00002A5A                          7226                              * first parameter in a0, second in d0
00002A5A  B03C 0008               7227      CMP.b       #$08,d0         * only 0 to 7 are allowed
00002A5E  6400 DC4E               7228      BCC     LAB_FCER            * branch if > 7
00002A62                          7229  
00002A62  01D0                    7230      BSET        d0,(a0)         * set bit
00002A64  4E75                    7231      RTS
00002A66                          7232  
00002A66                          7233  
00002A66                          7234  *************************************************************************************
00002A66                          7235  *
00002A66                          7236  * perform BITCLR
00002A66                          7237  
00002A66                          7238  LAB_BITCLR
00002A66  6100 F25E               7239      BSR     LAB_GADB            * get two parameters for POKE or WAIT
00002A6A                          7240                              * first parameter in a0, second in d0
00002A6A  B03C 0008               7241      CMP.b       #$08,d0         * only 0 to 7 are allowed
00002A6E  6400 DC3E               7242      BCC     LAB_FCER            * branch if > 7
00002A72                          7243  
00002A72  0190                    7244      BCLR        d0,(a0)         * clear bit
00002A74  4E75                    7245      RTS
00002A76                          7246  
00002A76                          7247  
00002A76                          7248  *************************************************************************************
00002A76                          7249  *
00002A76                          7250  * perform BITTST()
00002A76                          7251  
00002A76                          7252  LAB_BTST
00002A76  101D                    7253      MOVE.b  (a5)+,d0            * increment BASIC pointer
00002A78  6100 F24C               7254      BSR     LAB_GADB            * get two parameters for POKE or WAIT
00002A7C                          7255                              * first parameter in a0, second in d0
00002A7C  B03C 0008               7256      CMP.b       #$08,d0         * only 0 to 7 are allowed
00002A80  6400 DC2C               7257      BCC     LAB_FCER            * branch if > 7
00002A84                          7258  
00002A84  2200                    7259      MOVE.l  d0,d1               * copy bit # to test
00002A86  6100 E878               7260      BSR     LAB_GBYT            * get next BASIC byte
00002A8A  B03C 0029               7261      CMP.b       #')',d0         * is next character ")"
00002A8E  6600 DC2A               7262      BNE     LAB_SNER            * if not ")" go do syntax error, then warm start
00002A92                          7263  
00002A92  6100 E86A               7264      BSR     LAB_IGBY            * update execute pointer (to character past ")")
00002A96  7000                    7265      MOVEQ       #0,d0               * set the result as zero
00002A98  0310                    7266      BTST        d1,(a0)         * test bit
00002A9A  6700 F90C               7267      BEQ     LAB_27DB            * branch if zero (already correct)
00002A9E                          7268  
00002A9E  70FF                    7269      MOVEQ       #-1,d0          * set for -1 result
00002AA0  6000 F906               7270      BRA     LAB_27DB            * go do SGN tail
00002AA4                          7271  
00002AA4                          7272  
00002AA4                          7273  *************************************************************************************
00002AA4                          7274  *
00002AA4                          7275  * perform USING$()
00002AA4                          7276  
00002AA4  =00000000               7277  fsd EQU  0                  *   (sp) format string descriptor pointer
00002AA4  =00000004               7278  fsti    EQU  4                  *  4(sp) format string this index
00002AA4  =00000006               7279  fsli    EQU  6                  *  6(sp) format string last index
00002AA4  =00000008               7280  fsdpi   EQU  8                  *  8(sp) format string decimal point index
00002AA4  =0000000A               7281  fsdc    EQU 10                  * 10(sp) format string decimal characters
00002AA4  =00000008               7282  fend    EQU 12-4                    *  x(sp) end-4, fsd is popped by itself
00002AA4                          7283  
00002AA4  =00000023               7284  ofchr   EQU '#'                 * the overflow character
00002AA4                          7285  
00002AA4                          7286  LAB_USINGS
00002AA4  4A2B 05B5               7287      TST.b       Dtypef(a3)          * test data type, $80=string
00002AA8  6A00 DBBC               7288      BPL     LAB_FOER            * if not string type go do format error
00002AAC                          7289  
00002AAC  246B 0590               7290      MOVEA.l FAC1_m(a3),a2       * get the format string descriptor pointer
00002AB0  3E2A 0004               7291      MOVE.w  4(a2),d7            * get the format string length
00002AB4  6700 DBB0               7292      BEQ     LAB_FOER            * if null string go do format error
00002AB8                          7293  
00002AB8                          7294  * clear the format string values
00002AB8                          7295  
00002AB8  7000                    7296      MOVEQ       #0,d0               * clear d0
00002ABA  3F00                    7297      MOVE.w  d0,-(sp)            * clear the format string decimal characters
00002ABC  3F00                    7298      MOVE.w  d0,-(sp)            * clear the format string decimal point index
00002ABE  3F00                    7299      MOVE.w  d0,-(sp)            * clear the format string last index
00002AC0  3F00                    7300      MOVE.w  d0,-(sp)            * clear the format string this index
00002AC2  2F0A                    7301      MOVE.l  a2,-(sp)            * save the format string descriptor pointer
00002AC4                          7302  
00002AC4                          7303  * make a null return string for the first string add
00002AC4                          7304  
00002AC4  7200                    7305      MOVEQ       #0,d1               * make a null string
00002AC6  2041                    7306      MOVEA.l d1,a0               * with a null pointer
00002AC8  6100 EE98               7307      BSR     LAB_RTST            * push a string on the descriptor stack
00002ACC                          7308                              * a0 = pointer, d1 = length
00002ACC                          7309  
00002ACC                          7310  * do the USING$() function next value
00002ACC                          7311  
00002ACC  101D                    7312      MOVE.b  (a5)+,d0            * get the next BASIC byte
00002ACE                          7313  LAB_U002
00002ACE  B03C 002C               7314      CMP.b       #',',d0         * compare with comma
00002AD2  6600 DBE6               7315      BNE     LAB_SNER            * if not "," go do syntax error
00002AD6                          7316  
00002AD6  6100 028E               7317      BSR     LAB_ProcFo          * process the format string
00002ADA  4A02                    7318      TST.b       d2              * test the special characters flag
00002ADC  6700 DB88               7319      BEQ     LAB_FOER            * if no special characters go do format error
00002AE0                          7320  
00002AE0  6100 E6BC               7321      BSR     LAB_EVEX            * evaluate the expression
00002AE4  4A2B 05B5               7322      TST.b       Dtypef(a3)          * test the data type
00002AE8  6B00 DBA4               7323      BMI     LAB_TMER            * if string type go do type missmatch error
00002AEC                          7324  
00002AEC  4A2B 0594               7325      TST.b       FAC1_e(a3)          * test FAC1 exponent
00002AF0  6732                    7326      BEQ.s       LAB_U004            * if FAC1 = 0 skip the rounding
00002AF2                          7327  
00002AF2  322F 000A               7328      MOVE.w  fsdc(sp),d1         * get the format string decimal character count
00002AF6  B27C 0008               7329      CMP.w       #8,d1               * compare the fraction digit count with 8
00002AFA  6428                    7330      BCC.s       LAB_U004            * if >= 8 skip the rounding
00002AFC                          7331  
00002AFC  3001                    7332      MOVE.w  d1,d0               * else copy the fraction digit count
00002AFE  D241                    7333      ADD.w       d1,d1               * * 2
00002B00  D240                    7334      ADD.w       d0,d1               * * 3
00002B02  D241                    7335      ADD.w       d1,d1               * * 6
00002B04  41FA 0844               7336      LEA     LAB_P_10(pc),a0     * get the rounding table base
00002B08  2770 1002 0598          7337      MOVE.l  2(a0,d1.w),FAC2_m(a3)   * get the rounding mantissa
00002B0E  3030 1000               7338      MOVE.w  (a0,d1.w),d0        * get the rounding exponent
00002B12  0440 0100               7339      SUB.w       #$100,d0            * effectively divide the mantissa by 2
00002B16  3740 059C               7340      MOVE.w  d0,FAC2_e(a3)       * save the rounding exponent
00002B1A  177C 0000 059E          7341      MOVE.b  #$00,FAC_sc(a3)     * clear the sign compare
00002B20  6100 F4F4               7342      BSR     LAB_ADD         * round the value to n places
00002B24                          7343  LAB_U004
00002B24  6100 F970               7344      BSR     LAB_2970            * convert FAC1 to string - not on stack
00002B28                          7345  
00002B28  6100 01FE               7346      BSR     LAB_DupFmt          * duplicate the processed format string section
00002B2C                          7347                              * returns length in d1, pointer in a0
00002B2C                          7348  
00002B2C                          7349  * process the number string, length in d6, decimal point index in d2
00002B2C                          7350  
00002B2C  45EB 05C6               7351      LEA     Decss(a3),a2        * set the number string start
00002B30  7C00                    7352      MOVEQ       #0,d6               * clear the number string index
00002B32  782E                    7353      MOVEQ       #'.',d4         * set the decimal point character
00002B34                          7354  LAB_U005
00002B34  3406                    7355      MOVE.w  d6,d2               * save the index to flag the decimal point
00002B36                          7356  LAB_U006
00002B36  5246                    7357      ADDQ.w  #1,d6               * increment the number string index
00002B38  1032 6000               7358      MOVE.b  (a2,d6.w),d0        * get a number string character
00002B3C  677A                    7359      BEQ.s       LAB_U010            * if null then number complete
00002B3E                          7360  
00002B3E  B03C 0045               7361      CMP.b       #'E',d0         * compare the character with an "E"
00002B42  6706                    7362      BEQ.s       LAB_U008            * was sx[.x]Esxx so go handle sci notation
00002B44                          7363  
00002B44  B004                    7364      CMP.b       d4,d0               * compare the character with "."
00002B46  66EE                    7365      BNE.s       LAB_U006            * if not decimal point go get the next digit
00002B48                          7366  
00002B48  60EA                    7367      BRA.s       LAB_U005            * go save the index and get the next digit
00002B4A                          7368  
00002B4A                          7369  * have found an sx[.x]Esxx number, the [.x] will not be present for a single digit
00002B4A                          7370  
00002B4A                          7371  LAB_U008
00002B4A  3606                    7372      MOVE.w  d6,d3               * copy the index to the "E"
00002B4C  5343                    7373      SUBQ.w  #1,d3               * -1 gives the last digit index
00002B4E                          7374  
00002B4E  5246                    7375      ADDQ.w  #1,d6               * increment the index to the exponent sign
00002B50  1032 6000               7376      MOVE.b  (a2,d6.w),d0        * get the exponent sign character
00002B54  B03C 002D               7377      CMP.b       #'-',d0         * compare the exponent sign with "-"
00002B58  6600 DB54               7378      BNE     LAB_FCER            * if it wasn't sx[.x]E-xx go do function
00002B5C                          7379                              * call error
00002B5C                          7380  
00002B5C                          7381  * found an sx[.x]E-xx number so check the exponent magnitude
00002B5C                          7382  
00002B5C  5246                    7383      ADDQ.w  #1,d6               * increment the index to the exponent 10s
00002B5E  1032 6000               7384      MOVE.b  (a2,d6.w),d0        * get the exponent 10s character
00002B62  B03C 0030               7385      CMP.b       #'0',d0         * compare the exponent 10s with "0"
00002B66  6704                    7386      BEQ.s       LAB_U009            * if it was sx[.x]E-0x go get the exponent
00002B68                          7387                              * 1s character
00002B68                          7388  
00002B68  700A                    7389      MOVEQ       #10,d0          * else start writing at index 10
00002B6A  6008                    7390      BRA.s       LAB_U00A            * go copy the digits
00002B6C                          7391  
00002B6C                          7392  * found an sx[.x]E-0x number so get the exponent magnitude
00002B6C                          7393  
00002B6C                          7394  LAB_U009
00002B6C  5246                    7395      ADDQ.w  #1,d6               * increment the index to the exponent 1s
00002B6E  700F                    7396      MOVEQ       #$0F,d0         * set the mask for the exponent 1s digit
00002B70  C032 6000               7397      AND.b       (a2,d6.w),d0        * get and convert the exponent 1s digit
00002B74                          7398  LAB_U00A
00002B74  3403                    7399      MOVE.w  d3,d2               * copy the number last digit index
00002B76  0C42 0001               7400      CMPI.w  #1,d2               * is the number of the form sxE-0x
00002B7A  6602                    7401      BNE.s       LAB_U00B            * if it is sx.xE-0x skip the increment
00002B7C                          7402  
00002B7C                          7403                              * else make room for the decimal point
00002B7C  5242                    7404      ADDQ.w  #1,d2               * add 1 to the write index
00002B7E                          7405  LAB_U00B
00002B7E  D440                    7406      ADD.w       d0,d2               * add the exponent 1s to the write index
00002B80  700A                    7407      MOVEQ       #10,d0          * set the maximum write index
00002B82  9042                    7408      SUB.w       d2,d0               * compare the index with the maximum
00002B84  6E0C                    7409      BGT.s       LAB_U00C            * if the index < the maximum continue
00002B86                          7410  
00002B86  D440                    7411      ADD.w       d0,d2               * else set the index to the maximum
00002B88  D640                    7412      ADD.w       d0,d3               * adjust the read index
00002B8A  0C43 0001               7413      CMPI.w  #1,d3               * compare the adjusted index with 1
00002B8E  6E02                    7414      BGT.s       LAB_U00C            * if > 1 continue
00002B90                          7415  
00002B90  7600                    7416      MOVEQ       #0,d3               * else allow for the decimal point
00002B92                          7417  LAB_U00C
00002B92  3C02                    7418      MOVE.       d2,d6               * copy the write index as the number
00002B94                          7419                              * string length
00002B94  7000                    7420      MOVEQ       #0,d0               * clear d0 to null terminate the number
00002B96                          7421                              * string
00002B96                          7422  LAB_U00D
00002B96  1580 2000               7423      MOVE.b  d0,(a2,d2.w)        * save the character to the number string
00002B9A  5342                    7424      SUBQ.w  #1,d2               * decrement the number write index
00002B9C  0C42 0001               7425      CMPI.w  #1,d2               * compare the number write index with 1
00002BA0  6712                    7426      BEQ.s       LAB_U00F            * if at the decimal point go save it
00002BA2                          7427  
00002BA2                          7428                              * else write a digit to the number string
00002BA2  7030                    7429      MOVEQ       #'0',d0         * default to "0"
00002BA4  4A43                    7430      TST.w       d3              * test the number read index
00002BA6  67EE                    7431      BEQ.s       LAB_U00D            * if zero just go save the "0"
00002BA8                          7432  
00002BA8                          7433  LAB_U00E
00002BA8  1032 3000               7434      MOVE.b  (a2,d3.w),d0        * read the next number digit
00002BAC  5343                    7435      SUBQ.w  #1,d3               * decrement the read index
00002BAE  B004                    7436      CMP.b       d4,d0               * compare the digit with "."
00002BB0  66E4                    7437      BNE.s       LAB_U00D            * if not "." go save the digit
00002BB2                          7438  
00002BB2  60F4                    7439      BRA.s       LAB_U00E            * else go get the next digit
00002BB4                          7440  
00002BB4                          7441  LAB_U00F
00002BB4  1584 2000               7442      MOVE.b  d4,(a2,d2.w)        * save the decimal point
00002BB8                          7443  LAB_U010
00002BB8  4A42                    7444      TST.w       d2              * test the number string decimal point index
00002BBA  6602                    7445      BNE.s       LAB_U014            * if dp present skip the reset
00002BBC                          7446  
00002BBC  3406                    7447      MOVE.w  d6,d2               * make the decimal point index = the length
00002BBE                          7448  
00002BBE                          7449  * copy the fractional digit characters from the number string
00002BBE                          7450  
00002BBE                          7451  LAB_U014
00002BBE  3602                    7452      MOVE.w  d2,d3               * copy the number string decimal point index
00002BC0  5243                    7453      ADDQ.w  #1,d3               * increment the number string index
00002BC2  382F 0008               7454      MOVE.w  fsdpi(sp),d4        * get the new format string decimal point index
00002BC6                          7455  LAB_U018
00002BC6  5244                    7456      ADDQ.w  #1,d4               * increment the new format string index
00002BC8  B244                    7457      CMP.w       d4,d1               * compare it with the new format string length
00002BCA  6322                    7458      BLS.s       LAB_U022            * if done the fraction digits go do integer
00002BCC                          7459  
00002BCC  1030 4000               7460      MOVE.b  (a0,d4.w),d0        * get a new format string character
00002BD0  B03C 0025               7461      CMP.b       #'%',d0         * compare it with "%"
00002BD4  6706                    7462      BEQ.s       LAB_U01C            * if "%" go copy a number character
00002BD6                          7463  
00002BD6  B03C 0023               7464      CMP.b       #'#',d0         * compare it with "#"
00002BDA  66EA                    7465      BNE.s       LAB_U018            * if not "#" go do the next new format character
00002BDC                          7466  
00002BDC                          7467  LAB_U01C
00002BDC  7030                    7468      MOVEQ       #'0',d0         * default to "0" character
00002BDE  BC43                    7469      CMP.w       d3,d6               * compare the number string index with length
00002BE0  6306                    7470      BLS.s       LAB_U020            * if there skip the character get
00002BE2                          7471  
00002BE2  1032 3000               7472      MOVE.b  (a2,d3.w),d0        * get a character from the number string
00002BE6  5243                    7473      ADDQ.w  #1,d3               * increment the number string index
00002BE8                          7474  LAB_U020
00002BE8  1180 4000               7475      MOVE.b  d0,(a0,d4.w)        * save the number character to the new format
00002BEC                          7476                              * string
00002BEC  60D8                    7477      BRA.s       LAB_U018            * go do the next new format character
00002BEE                          7478  
00002BEE                          7479  * now copy the integer digit characters from the number string
00002BEE                          7480  
00002BEE                          7481  LAB_U022
00002BEE  7C00                    7482      MOVEQ       #0,d6               * clear the sign done flag
00002BF0  7A00                    7483      MOVEQ       #0,d5               * clear the sign present flag
00002BF2  5342                    7484      SUBQ.w  #1,d2               * decrement the number string index
00002BF4  6608                    7485      BNE.s       LAB_U026            * if not now at sign continue
00002BF6                          7486  
00002BF6  7401                    7487      MOVEQ       #1,d2               * increment the number string index
00002BF8  15BC 0030 2000          7488      MOVE.b  #'0',(a2,d2.w)      * replace the point with a zero
00002BFE                          7489  LAB_U026
00002BFE  382F 0008               7490      MOVE.w  fsdpi(sp),d4        * get the new format string decimal point index
00002C02  B244                    7491      CMP.w       d4,d1               * compare it with the new format string length
00002C04  6402                    7492      BCC.s       LAB_U02A            * if within the string go use the index
00002C06                          7493  
00002C06  3801                    7494      MOVE.w  d1,d4               * else set the index to the end of the string
00002C08                          7495  LAB_U02A
00002C08  5344                    7496      SUBQ.w  #1,d4               * decrement the new format string index
00002C0A  6B62                    7497      BMI.s       LAB_U03E            * if all done go test for any overflow
00002C0C                          7498  
00002C0C  1030 4000               7499      MOVE.b  (a0,d4.w),d0        * else get a new format string character
00002C10                          7500  
00002C10  7E30                    7501      MOVEQ       #'0',d7         * default to "0" character
00002C12  B03C 0025               7502      CMP.b       #'%',d0         * compare it with "%"
00002C16  6708                    7503      BEQ.s       LAB_U02B            * if "%" go copy a number character
00002C18                          7504  
00002C18  7E20                    7505      MOVEQ       #' ',d7         * default to " " character
00002C1A  B03C 0023               7506      CMP.b       #'#',d0         * compare it with "#"
00002C1E  6606                    7507      BNE.s       LAB_U02C            * if not "#" go try ","
00002C20                          7508  
00002C20                          7509  LAB_U02B
00002C20  4A42                    7510      TST.w       d2              * test the number string index
00002C22  6634                    7511      BNE.s       LAB_U036            * if not at the sign go get a number character
00002C24                          7512  
00002C24  6042                    7513      BRA.s       LAB_U03C            * else go save the default character
00002C26                          7514  
00002C26                          7515  LAB_U02C
00002C26  B03C 002C               7516      CMP.b       #',',d0         * compare it with ","
00002C2A  6610                    7517      BNE.s       LAB_U030            * if not "," go try the sign characters
00002C2C                          7518  
00002C2C  4A42                    7519      TST.w       d2              * test the number string index
00002C2E  6608                    7520      BNE.s       LAB_U02E            * if not at the sign keep the ","
00002C30                          7521  
00002C30  0C30 0025 40FF          7522      CMP.b       #'%',-1(a0,d4.w)        * else compare the next format string character
00002C36                          7523                              * with "%"
00002C36  6630                    7524      BNE.s       LAB_U03C            * if not "%" keep the default character
00002C38                          7525  
00002C38                          7526  LAB_U02E
00002C38  1E00                    7527      MOVE.b  d0,d7               * else use the "," character
00002C3A  602C                    7528      BRA.s       LAB_U03C            * go save the character to the string
00002C3C                          7529  
00002C3C                          7530  LAB_U030
00002C3C  B03C 002D               7531      CMP.b       #'-',d0         * compare it with "-"
00002C40  6710                    7532      BEQ.s       LAB_U034            * if "-" go do the sign character
00002C42                          7533  
00002C42  B03C 002B               7534      CMP.b       #'+',d0         * compare it with "+"
00002C46  66C0                    7535      BNE.s       LAB_U02A            * if not "+" go do the next new format character
00002C48                          7536  
00002C48  0C12 002D               7537      CMP.b       #'-',(a2)           * compare the sign character with "-"
00002C4C  6704                    7538      BEQ.s       LAB_U034            * if "-" don't change the sign character
00002C4E                          7539  
00002C4E  14BC 002B               7540      MOVE.b  #'+',(a2)           * else make the sign character "+"
00002C52                          7541  LAB_U034
00002C52  1A00                    7542      MOVE.b  d0,d5               * set the sign present flag
00002C54  4A42                    7543      TST.w       d2              * test the number string index
00002C56  6708                    7544      BEQ.s       LAB_U038            * if at the sign keep the default character
00002C58                          7545  
00002C58                          7546  LAB_U036
00002C58  1E32 2000               7547      MOVE.b  (a2,d2.w),d7        * else get a character from the number string
00002C5C  5342                    7548      SUBQ.w  #1,d2               * decrement the number string index
00002C5E  6008                    7549      BRA.s       LAB_U03C            * go save the character
00002C60                          7550  
00002C60                          7551  LAB_U038
00002C60  4A06                    7552      TST.b       d6              * test the sign done flag
00002C62  6604                    7553      BNE.s       LAB_U03C            * if the sign has been done go use the space
00002C64                          7554                              * character
00002C64                          7555  
00002C64  1E12                    7556      MOVE.b  (a2),d7         * else get the sign character
00002C66  1C07                    7557      MOVE.b  d7,d6               * flag that the sign has been done
00002C68                          7558  LAB_U03C
00002C68  1187 4000               7559      MOVE.b  d7,(a0,d4.w)        * save the number character to the new format
00002C6C                          7560                              * string
00002C6C  609A                    7561      BRA.s       LAB_U02A            * go do the next new format character
00002C6E                          7562  
00002C6E                          7563  * test for overflow conditions
00002C6E                          7564  
00002C6E                          7565  LAB_U03E
00002C6E  4A42                    7566      TST.w       d2              * test the number string index
00002C70  6614                    7567      BNE.s       LAB_U040            * if all the digits aren't done go output
00002C72                          7568                              * an overflow indication
00002C72                          7569  
00002C72                          7570  * test for sign overflows
00002C72                          7571  
00002C72  4A05                    7572      TST.b       d5              * test the sign present flag
00002C74  6754                    7573      BEQ.s       LAB_U04A            * if no sign present go add the string
00002C76                          7574  
00002C76                          7575  * there was a sign in the format string
00002C76                          7576  
00002C76  4A06                    7577      TST.b       d6              * test the sign done flag
00002C78  6650                    7578      BNE.s       LAB_U04A            * if the sign is done go add the string
00002C7A                          7579  
00002C7A                          7580  * the sign isn't done so see if it was mandatory
00002C7A                          7581  
00002C7A  0C05 002B               7582      CMPI.b  #'+',d5         * compare the sign with "+"
00002C7E  6706                    7583      BEQ.s       LAB_U040            * if it was "+" go output an overflow
00002C80                          7584                              * indication
00002C80                          7585  
00002C80                          7586  * the sign wasn't mandatory but the number may have been negative
00002C80                          7587  
00002C80  0C12 002D               7588      CMP.b       #'-',(a2)           * compare the sign character with "-"
00002C84  6644                    7589      BNE.s       LAB_U04A            * if it wasn't "-" go add the string
00002C86                          7590  
00002C86                          7591  * else the sign was "-" and a sign hasn't been output so ..
00002C86                          7592  
00002C86                          7593  * the number overflowed the format string so replace all the special format characters
00002C86                          7594  * with the overflow character
00002C86                          7595  
00002C86                          7596  LAB_U040
00002C86  7A23                    7597      MOVEQ       #ofchr,d5           * set the overflow character
00002C88  3E01                    7598      MOVE.w  d1,d7               * copy the new format string length
00002C8A  5347                    7599      SUBQ.w  #1,d7               * adjust for the loop type
00002C8C  3C2F 0004               7600      MOVE.w  fsti(sp),d6         * copy the new format string last index
00002C90  5346                    7601      SUBQ.w  #1,d6               * -1 gives the last character of this string
00002C92  6E02                    7602      BGT.s       LAB_U044            * if not zero continue
00002C94                          7603  
00002C94  3C07                    7604      MOVE.w  d7,d6               * else set the format string index to the end
00002C96                          7605  LAB_U044
00002C96  1031 6000               7606      MOVE.b  (a1,d6.w),d0        * get a character from the format string
00002C9A  0C00 0023               7607      CMPI.b  #'#',d0         * compare it with "#" special format character
00002C9E  671E                    7608      BEQ.s       LAB_U046            * if "#" go use the overflow character
00002CA0                          7609  
00002CA0  0C00 0025               7610      CMPI.b  #'%',d0         * compare it with "%" special format character
00002CA4  6718                    7611      BEQ.s       LAB_U046            * if "%" go use the overflow character
00002CA6                          7612  
00002CA6  0C00 002C               7613      CMPI.b  #',',d0         * compare it with "," special format character
00002CAA  6712                    7614      BEQ.s       LAB_U046            * if "," go use the overflow character
00002CAC                          7615  
00002CAC  0C00 002B               7616      CMPI.b  #'+',d0         * compare it with "+" special format character
00002CB0  670C                    7617      BEQ.s       LAB_U046            * if "+" go use the overflow character
00002CB2                          7618  
00002CB2  0C00 002D               7619      CMPI.b  #'-',d0         * compare it with "-" special format character
00002CB6  6706                    7620      BEQ.s       LAB_U046            * if "-" go use the overflow character
00002CB8                          7621  
00002CB8  0C00 002E               7622      CMPI.b  #'.',d0         * compare it with "." special format character
00002CBC  6602                    7623      BNE.s       LAB_U048            * if not "." skip the using overflow character
00002CBE                          7624  
00002CBE                          7625  LAB_U046
00002CBE  1005                    7626      MOVE.b  d5,d0               * use the overflow character
00002CC0                          7627  LAB_U048
00002CC0  1180 7000               7628      MOVE.b  d0,(a0,d7.w)        * save the character to the new format string
00002CC4  5346                    7629      SUBQ.w  #1,d6               * decrement the format string index
00002CC6  51CF FFCE               7630      DBF     d7,LAB_U044         * decrement the count and loop if not all done
00002CCA                          7631  
00002CCA                          7632  * add the new string to the previous string
00002CCA                          7633  
00002CCA                          7634  LAB_U04A
00002CCA  41EC 0006               7635      LEA     6(a4),a0            * get the descriptor pointer for string 1
00002CCE  274C 0590               7636      MOVE.l  a4,FAC1_m(a3)       * save the descriptor pointer for string 2
00002CD2  6100 EDDE               7637      BSR     LAB_224E            * concatenate the strings
00002CD6                          7638  
00002CD6                          7639  * now check for any tail on the format string
00002CD6                          7640  
00002CD6  302F 0004               7641      MOVE.w  fsti(sp),d0         * get this index
00002CDA  6720                    7642      BEQ.s       LAB_U04C            * if at start of string skip the output
00002CDC                          7643  
00002CDC  3F40 0006               7644      MOVE.w  d0,fsli(sp)         * save this index to the last index
00002CE0  6100 0084               7645      BSR     LAB_ProcFo          * now process the format string
00002CE4  4A02                    7646      TST.b       d2              * test the special characters flag
00002CE6  6614                    7647      BNE.s       LAB_U04C            * if special characters present skip the output
00002CE8                          7648  
00002CE8                          7649  * else output the new string part
00002CE8                          7650  
00002CE8  613E                    7651      BSR.s       LAB_DupFmt          * duplicate the processed format string section
00002CEA  3F6F 0004 0006          7652      MOVE.w  fsti(sp),fsli(sp)       * copy this index to the last index
00002CF0                          7653  
00002CF0                          7654  * add the new string to the previous string
00002CF0                          7655  
00002CF0  41EC 0006               7656      LEA     6(a4),a0            * get the descriptor pointer for string 1
00002CF4  274C 0590               7657      MOVE.l  a4,FAC1_m(a3)       * save the descriptor pointer for string 2
00002CF8  6100 EDB8               7658      BSR     LAB_224E            * concatenate the strings
00002CFC                          7659  
00002CFC                          7660  * check for another value or end of function
00002CFC                          7661  
00002CFC                          7662  LAB_U04C
00002CFC  101D                    7663      MOVE.b  (a5)+,d0            * get the next BASIC byte
00002CFE  B03C 0029               7664      CMP.b       #')',d0         * compare with close bracket
00002D02  6600 FDCA               7665      BNE     LAB_U002            * if not ")" go do next value
00002D06                          7666  
00002D06                          7667  * pop the result string off the descriptor stack
00002D06                          7668  
00002D06  204C                    7669      MOVEA.l a4,a0               * copy the result string descriptor pointer
00002D08  222B 0446               7670      MOVE.l  Sstorl(a3),d1       * save the bottom of string space
00002D0C  6100 EE06               7671      BSR     LAB_22BA            * pop (a0) descriptor, returns with ..
00002D10                          7672                              * d0 = length, a0 = pointer
00002D10  2741 0446               7673      MOVE.l  d1,Sstorl(a3)       * restore the bottom of string space
00002D14  2248                    7674      MOVEA.l a0,a1               * copy the string result pointer
00002D16  3200                    7675      MOVE.w  d0,d1               * copy the string result length
00002D18                          7676  
00002D18                          7677  * pop the format string off the descriptor stack
00002D18                          7678  
00002D18  205F                    7679      MOVEA.l (sp)+,a0            * pull the format string descriptor pointer
00002D1A  6100 EDF8               7680      BSR     LAB_22BA            * pop (a0) descriptor, returns with ..
00002D1E                          7681                              * d0 = length, a0 = pointer
00002D1E                          7682  
00002D1E  4FEF 0008               7683      LEA     fend(sp),sp         * dump the saved values
00002D22                          7684  
00002D22                          7685  * push the result string back on the descriptor stack and return
00002D22                          7686  
00002D22  2049                    7687      MOVEA.l a1,a0               * copy the result string pointer back
00002D24  6000 EC3C               7688      BRA     LAB_RTST            * push a string on the descriptor stack and
00002D28                          7689                              * return. a0 = pointer, d1 = length
00002D28                          7690  
00002D28                          7691  
00002D28                          7692  *************************************************************************************
00002D28                          7693  *
00002D28                          7694  * duplicate the processed format string section
00002D28                          7695  
00002D28                          7696                              * make a string as long as the format string
00002D28                          7697  LAB_DupFmt
00002D28  226F 0004               7698      MOVEA.l 4+fsd(sp),a1        * get the format string descriptor pointer
00002D2C  3E29 0004               7699      MOVE.w  4(a1),d7            * get the format string length
00002D30  342F 000A               7700      MOVE.w  4+fsli(sp),d2       * get the format string last index
00002D34  3C2F 0008               7701      MOVE.w  4+fsti(sp),d6       * get the format string this index
00002D38  3206                    7702      MOVE.w  d6,d1               * copy the format string this index
00002D3A  9242                    7703      SUB.w       d2,d1               * subtract the format string last index
00002D3C  6202                    7704      BHI.s       LAB_D002            * if > 0 skip the correction
00002D3E                          7705  
00002D3E  D247                    7706      ADD.w       d7,d1               * else add the format string length as the
00002D40                          7707                              * correction
00002D40                          7708  LAB_D002
00002D40  6100 EC3A               7709      BSR     LAB_2115            * make string space d1 bytes long
00002D44                          7710                              * return a0/Sutill = pointer, others unchanged
00002D44                          7711  
00002D44                          7712  * push the new string on the descriptor stack
00002D44                          7713  
00002D44  6100 EC1C               7714      BSR     LAB_RTST            * push a string on the descriptor stack and
00002D48                          7715                              * return. a0 = pointer, d1 = length
00002D48                          7716  
00002D48                          7717  * copy the characters from the format string
00002D48                          7718  
00002D48  226F 0004               7719      MOVEA.l 4+fsd(sp),a1        * get the format string descriptor pointer
00002D4C  2251                    7720      MOVEA.l (a1),a1         * get the format string pointer
00002D4E  7800                    7721      MOVEQ       #0,d4               * clear the new string index
00002D50                          7722  LAB_D00A
00002D50  11B1 2000 4000          7723      MOVE.b  (a1,d2.w),(a0,d4.w) * get a character from the format string and
00002D56                          7724                              * save it to the new string
00002D56  5244                    7725      ADDQ.w  #1,d4               * increment the new string index
00002D58  5242                    7726      ADDQ.w  #1,d2               * increment the format string index
00002D5A  BE42                    7727      CMP.w       d2,d7               * compare the format index with the length
00002D5C  6602                    7728      BNE.s       LAB_D00E            * if not there skip the reset
00002D5E                          7729  
00002D5E  7400                    7730      MOVEQ       #0,d2               * else reset the format string index
00002D60                          7731  LAB_D00E
00002D60  BC42                    7732      CMP.w       d2,d6               * compare the index with this index
00002D62  66EC                    7733      BNE.s       LAB_D00A            * if not equal go do the next character
00002D64                          7734  
00002D64  4E75                    7735      RTS
00002D66                          7736  
00002D66                          7737  
00002D66                          7738  **************************************************************************************
00002D66                          7739  *
00002D66                          7740  * process the format string
00002D66                          7741  
00002D66                          7742  LAB_ProcFo
00002D66  226F 0004               7743      MOVEA.l 4+fsd(sp),a1        * get the format string descriptor pointer
00002D6A  3E29 0004               7744      MOVE.w  4(a1),d7            * get the format string length
00002D6E  2251                    7745      MOVEA.l (a1),a1         * get the format string pointer
00002D70  3C2F 000A               7746      MOVE.w  4+fsli(sp),d6       * get the format string last index
00002D74                          7747  
00002D74  3F47 000C               7748      MOVE.w  d7,4+fsdpi(sp)      * set the format string decimal point index
00002D78  7A00                    7749      MOVEQ       #0,d5               * no decimal point
00002D7A  7600                    7750      MOVEQ       #0,d3               * no decimal characters
00002D7C  7400                    7751      MOVEQ       #0,d2               * no special characters
00002D7E                          7752  LAB_P004
00002D7E  1031 6000               7753      MOVE.b  (a1,d6.w),d0        * get a format string byte
00002D82                          7754  
00002D82  B03C 002C               7755      CMP.b       #',',d0         * compare it with ","
00002D86  6742                    7756      BEQ.s       LAB_P01A            * if "," go do the next format string byte
00002D88                          7757  
00002D88  B03C 0023               7758      CMP.b       #'#',d0         * compare it with "#"
00002D8C  6706                    7759      BEQ.s       LAB_P008            * if "#" go flag special characters
00002D8E                          7760  
00002D8E  B03C 0025               7761      CMP.b       #'%',d0         * compare it with "%"
00002D92  6608                    7762      BNE.s       LAB_P00C            * if not "%" go try "+"
00002D94                          7763  
00002D94                          7764  LAB_P008
00002D94  4A85                    7765      TST.l       d5              * test the decimal point flag
00002D96  6A10                    7766      BPL.s       LAB_P00E            * if no point skip counting decimal characters
00002D98                          7767  
00002D98  5243                    7768      ADDQ.w  #1,d3               * else increment the decimal character count
00002D9A  602E                    7769      BRA.s       LAB_P01A            * go do the next character
00002D9C                          7770  
00002D9C                          7771  LAB_P00C
00002D9C  B03C 002B               7772      CMP.b       #'+',d0         * compare it with "+"
00002DA0  6706                    7773      BEQ.s       LAB_P00E            * if "+" go flag special characters
00002DA2                          7774  
00002DA2  B03C 002D               7775      CMP.b       #'-',d0         * compare it with "-"
00002DA6  6604                    7776      BNE.s       LAB_P010            * if not "-" go check decimal point
00002DA8                          7777  
00002DA8                          7778  LAB_P00E
00002DA8  8400                    7779      OR.b        d0,d2               * flag special characters
00002DAA  601E                    7780      BRA.s       LAB_P01A            * go do the next character
00002DAC                          7781  
00002DAC                          7782  LAB_P010
00002DAC  B03C 002E               7783      CMP.b       #'.',d0         * compare it with "."
00002DB0  6614                    7784      BNE.s       LAB_P018            * if not "." go check next
00002DB2                          7785  
00002DB2                          7786  * "." a decimal point
00002DB2                          7787  
00002DB2  4A85                    7788      TST.l       d5              * if there is already a decimal point
00002DB4  6B14                    7789      BMI.s       LAB_P01A            * go do the next character
00002DB6                          7790  
00002DB6  3006                    7791      MOVE.w  d6,d0               * copy the decimal point index
00002DB8  906F 000A               7792      SUB.w       4+fsli(sp),d0       * calculate it from the scan start
00002DBC  3F40 000C               7793      MOVE.w  d0,4+fsdpi(sp)      * save the decimal point index
00002DC0  7AFF                    7794      MOVEQ       #-1,d5          * flag decimal point
00002DC2  8400                    7795      OR.b        d0,d2               * flag special characters
00002DC4  6004                    7796      BRA.s       LAB_P01A            * go do the next character
00002DC6                          7797  
00002DC6                          7798  * was not a special character
00002DC6                          7799  
00002DC6                          7800  LAB_P018
00002DC6  4A02                    7801      TST.b       d2              * test if there have been special characters
00002DC8  6608                    7802      BNE.s       LAB_P01E            * if so exit the format string process
00002DCA                          7803  
00002DCA                          7804  LAB_P01A
00002DCA  5246                    7805      ADDQ.w  #1,d6               * increment the format string index
00002DCC  BE46                    7806      CMP.w       d6,d7               * compare it with the format string length
00002DCE  62AE                    7807      BHI.s       LAB_P004            * if length > index go get the next character
00002DD0                          7808  
00002DD0  7C00                    7809      MOVEQ       #0,d6               * length = index so reset the format string
00002DD2                          7810                              * index
00002DD2                          7811  LAB_P01E
00002DD2  3F46 0008               7812      MOVE.w  d6,4+fsti(sp)       * save the format string this index
00002DD6  3F43 000E               7813      MOVE.w  d3,4+fsdc(sp)       * save the format string decimal characters
00002DDA                          7814  
00002DDA  4E75                    7815      RTS
00002DDC                          7816  
00002DDC                          7817  
00002DDC                          7818  *************************************************************************************
00002DDC                          7819  *
00002DDC                          7820  * perform BIN$()
00002DDC                          7821  * # of leading 0s is in d1, the number is in d0
00002DDC                          7822  
00002DDC                          7823  LAB_BINS
00002DDC  B23C 0021               7824      CMP.b       #$21,d1         * max + 1
00002DE0  6400 D8CC               7825      BCC     LAB_FCER            * exit if too big ( > or = )
00002DE4                          7826  
00002DE4  741F                    7827      MOVEQ       #$1F,d2         * bit count-1
00002DE6  41EB 05B6               7828      LEA     Binss(a3),a0        * point to string
00002DEA  7830                    7829      MOVEQ       #$30,d4         * "0" character for ADDX
00002DEC                          7830  NextB1
00002DEC  7600                    7831      MOVEQ       #0,d3               * clear byte
00002DEE  E288                    7832      LSR.l       #1,d0               * shift bit into Xb
00002DF0  D704                    7833      ADDX.b  d4,d3               * add carry and character to zero
00002DF2  1183 2000               7834      MOVE.b  d3,(a0,d2.w)        * save character to string
00002DF6  51CA FFF4               7835      DBF     d2,NextB1           * decrement and loop if not done
00002DFA                          7836  
00002DFA                          7837  * this is the exit code and is also used by HEX$()
00002DFA                          7838  
00002DFA                          7839  EndBHS
00002DFA  177C 0000 05D6          7840      MOVE.b  #0,BHsend(a3)       * null terminate the string
00002E00  4A01                    7841      TST.b       d1              * test # of characters
00002E02  670E                    7842      BEQ.s       NextB2          * go truncate string
00002E04                          7843  
00002E04  4481                    7844      NEG.l       d1              * make -ve
00002E06  0681 000005D6           7845      ADD.l       #BHsend,d1          * effectively (end-length)
00002E0C  41F3 1000               7846      LEA     0(a3,d1.w),a0       * effectively add (end-length) to pointer
00002E10  600E                    7847      BRA.s       BinPr               * go print string
00002E12                          7848  
00002E12                          7849  * truncate string to remove leading "0"s
00002E12                          7850  
00002E12                          7851  NextB2
00002E12  1010                    7852      MOVE.b  (a0),d0         * get byte
00002E14  670A                    7853      BEQ.s       BinPr               * if null then end of string so add 1 and go
00002E16                          7854                              * print it
00002E16                          7855  
00002E16  B03C 0030               7856      CMP.b       #'0',d0         * compare with "0"
00002E1A  660E                    7857      BNE.s       GoPr                * if not "0" then go print string from here
00002E1C                          7858  
00002E1C  5248                    7859      ADDQ.w  #1,a0               * else increment pointer
00002E1E  60F2                    7860      BRA.s       NextB2          * loop always
00002E20                          7861  
00002E20                          7862  * make fixed length output string - ignore overflows!
00002E20                          7863  
00002E20                          7864  BinPr
00002E20  43EB 05D6               7865      LEA     BHsend(a3),a1       * get string end
00002E24  B1C9                    7866      CMPA.l  a1,a0               * are we at the string end
00002E26  6602                    7867      BNE.s       GoPr                * branch if not
00002E28                          7868  
00002E28  5348                    7869      SUBQ.w  #1,a0               * else need at least one zero
00002E2A                          7870  GoPr
00002E2A  6000 EAF0               7871      BRA     LAB_20AE            * print " terminated string to FAC1, stack & RET
00002E2E                          7872  
00002E2E                          7873  
00002E2E                          7874  *************************************************************************************
00002E2E                          7875  *
00002E2E                          7876  * perform HEX$()
00002E2E                          7877  * # of leading 0s is in d1, the number is in d0
00002E2E                          7878  
00002E2E                          7879  LAB_HEXS
00002E2E  B23C 0009               7880      CMP.b       #$09,d1         * max + 1
00002E32  6400 D87A               7881      BCC     LAB_FCER            * exit if too big ( > or = )
00002E36                          7882  
00002E36  7407                    7883      MOVEQ       #$07,d2         * nibble count-1
00002E38  41EB 05CE               7884      LEA     Hexss(a3),a0        * point to string
00002E3C  7830                    7885      MOVEQ       #$30,d4         * "0" character for ABCD
00002E3E                          7886  NextH1
00002E3E  1600                    7887      MOVE.b  d0,d3               * copy lowest byte
00002E40  E898                    7888      ROR.l       #4,d0               * shift nibble into 0-3
00002E42  C63C 000F               7889      AND.b       #$0F,d3         * just this nibble
00002E46  1A03                    7890      MOVE.b  d3,d5               * copy it
00002E48  0605 00F6               7891      ADD.b       #$F6,d5         * set extend bit
00002E4C  C704                    7892      ABCD        d4,d3               * decimal add extend and character to zero
00002E4E  1183 2000               7893      MOVE.b  d3,(a0,d2.w)        * save character to string
00002E52  51CA FFEA               7894      DBF     d2,NextH1           * decrement and loop if not done
00002E56                          7895  
00002E56  60A2                    7896      BRA.s       EndBHS          * go process string
00002E58                          7897  
00002E58                          7898  
00002E58                          7899  *************************************************************************************
00002E58                          7900  *
00002E58                          7901  * ctrl-c check routine. includes limited "life" byte save for INGET routine
00002E58                          7902  
00002E58                          7903  VEC_CC
00002E58  4A2B 05E8               7904      TST.b       ccflag(a3)          * check [CTRL-C] check flag
00002E5C  661E                    7905      BNE.s       RTS_022         * exit if [CTRL-C] check inhibited
00002E5E                          7906  
00002E5E  4EAB 040C               7907      JSR     V_INPT(a3)          * scan input device
00002E62  640E                    7908      BCC.s       LAB_FBA0            * exit if buffer empty
00002E64                          7909  
00002E64  1740 05E9               7910      MOVE.b  d0,ccbyte(a3)       * save received byte
00002E68  177C 0020 05EA          7911      MOVE.b  #$20,ccnull(a3)     * set "life" timer for bytes countdown
00002E6E  6000 DCB8               7912      BRA     LAB_1636            * return to BASIC
00002E72                          7913  
00002E72                          7914  LAB_FBA0
00002E72  4A2B 05EA               7915      TST.b       ccnull(a3)          * get countdown byte
00002E76  6704                    7916      BEQ.s       RTS_022         * exit if finished
00002E78                          7917  
00002E78  532B 05EA               7918      SUBQ.b  #1,ccnull(a3)       * else decrement countdown
00002E7C                          7919  RTS_022
00002E7C  4E75                    7920      RTS
00002E7E                          7921  
00002E7E                          7922  
00002E7E                          7923  *************************************************************************************
00002E7E                          7924  *
00002E7E                          7925  * get byte from input device, no waiting
00002E7E                          7926  * returns with carry set if byte in A
00002E7E                          7927  
00002E7E                          7928  INGET
00002E7E  4EAB 040C               7929      JSR     V_INPT(a3)          * call scan input device
00002E82  650A                    7930      BCS.s       LAB_FB95            * if byte go reset timer
00002E84                          7931  
00002E84  102B 05EA               7932      MOVE.b  ccnull(a3),d0       * get countdown
00002E88  67F2                    7933      BEQ.s       RTS_022         * exit if empty
00002E8A                          7934  
00002E8A  102B 05E9               7935      MOVE.b  ccbyte(a3),d0       * get last received byte
00002E8E                          7936  LAB_FB95
00002E8E  177C 0000 05EA          7937      MOVE.b  #$00,ccnull(a3)     * clear timer because we got a byte
00002E94  003C 0001               7938      ORI.b       #1,CCR          * set carry, flag we got a byte
00002E98  4E75                    7939      RTS
00002E9A                          7940  
00002E9A                          7941  
00002E9A                          7942  *************************************************************************************
00002E9A                          7943  *
00002E9A                          7944  * perform MAX()
00002E9A                          7945  
00002E9A                          7946  LAB_MAX
00002E9A  6100 E304               7947      BSR     LAB_EVEZ            * evaluate expression (no decrement)
00002E9E  4A2B 05B5               7948      TST.b       Dtypef(a3)          * test data type
00002EA2  6B00 D7EA               7949      BMI     LAB_TMER            * if string do Type missmatch Error/warm start
00002EA6                          7950  
00002EA6                          7951  LAB_MAXN
00002EA6  612E                    7952      BSR.s       LAB_PHFA            * push FAC1, evaluate expression,
00002EA8                          7953                              * pull FAC2 & compare with FAC1
00002EA8  64FC                    7954      BCC.s       LAB_MAXN            * branch if no swap to do
00002EAA                          7955  
00002EAA  6100 F4A8               7956      BSR     LAB_279B            * copy FAC2 to FAC1
00002EAE  60F6                    7957      BRA.s       LAB_MAXN            * go do next
00002EB0                          7958  
00002EB0                          7959  
00002EB0                          7960  *************************************************************************************
00002EB0                          7961  *
00002EB0                          7962  * perform MIN()
00002EB0                          7963  
00002EB0                          7964  LAB_MIN
00002EB0  6100 E2EE               7965      BSR     LAB_EVEZ            * evaluate expression (no decrement)
00002EB4  4A2B 05B5               7966      TST.b       Dtypef(a3)          * test data type
00002EB8  6B00 D7D4               7967      BMI     LAB_TMER            * if string do Type missmatch Error/warm start
00002EBC                          7968  
00002EBC                          7969  LAB_MINN
00002EBC  6118                    7970      BSR.s       LAB_PHFA            * push FAC1, evaluate expression,
00002EBE                          7971                              * pull FAC2 & compare with FAC1
00002EBE  63FC                    7972      BLS.s       LAB_MINN            * branch if no swap to do
00002EC0                          7973  
00002EC0  6100 F492               7974      BSR     LAB_279B            * copy FAC2 to FAC1
00002EC4  60F6                    7975      BRA.s       LAB_MINN            * go do next (branch always)
00002EC6                          7976  
00002EC6                          7977  * exit routine. don't bother returning to the loop code
00002EC6                          7978  * check for correct exit, else so syntax error
00002EC6                          7979  
00002EC6                          7980  LAB_MMEC
00002EC6  B03C 0029               7981      CMP.b       #')',d0         * is it end of function?
00002ECA  6600 D7EE               7982      BNE     LAB_SNER            * if not do MAX MIN syntax error
00002ECE                          7983  
00002ECE  4FEF 0004               7984      LEA     4(sp),sp            * dump return address (faster)
00002ED2  6000 E42A               7985      BRA     LAB_IGBY            * update BASIC execute pointer (to chr past ")")
00002ED6                          7986                              * and return
00002ED6                          7987  
00002ED6                          7988  * check for next, evaluate & return or exit
00002ED6                          7989  * this is the routine that does most of the work
00002ED6                          7990  
00002ED6                          7991  LAB_PHFA
00002ED6  6100 E428               7992      BSR     LAB_GBYT            * get next BASIC byte
00002EDA  B03C 002C               7993      CMP.b       #',',d0         * is there more ?
00002EDE  66E6                    7994      BNE.s       LAB_MMEC            * if not go do end check
00002EE0                          7995  
00002EE0  3F2B 0594               7996      MOVE.w  FAC1_e(a3),-(sp)        * push exponent and sign
00002EE4  2F2B 0590               7997      MOVE.l  FAC1_m(a3),-(sp)        * push mantissa
00002EE8                          7998  
00002EE8  6100 E2B6               7999      BSR     LAB_EVEZ            * evaluate expression (no decrement)
00002EEC  4A2B 05B5               8000      TST.b       Dtypef(a3)          * test data type
00002EF0  6B00 D79C               8001      BMI     LAB_TMER            * if string do Type missmatch Error/warm start
00002EF4                          8002  
00002EF4                          8003  
00002EF4                          8004                              * pop FAC2 (MAX/MIN expression so far)
00002EF4  275F 0598               8005      MOVE.l  (sp)+,FAC2_m(a3)        * pop mantissa
00002EF8                          8006  
00002EF8  301F                    8007      MOVE.w  (sp)+,d0            * pop exponent and sign
00002EFA  3740 059C               8008      MOVE.w  d0,FAC2_e(a3)       * save exponent and sign
00002EFE  176B 0595 059E          8009      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * get FAC1 sign
00002F04  B12B 059E               8010      EOR.b       d0,FAC_sc(a3)       * EOR to create sign compare
00002F08  6000 F4B6               8011      BRA     LAB_27FA            * compare FAC1 with FAC2 & return
00002F0C                          8012                              * returns d0=+1 Cb=0 if FAC1 > FAC2
00002F0C                          8013                              * returns d0= 0 Cb=0 if FAC1 = FAC2
00002F0C                          8014                              * returns d0=-1 Cb=1 if FAC1 < FAC2
00002F0C                          8015  
00002F0C                          8016  
00002F0C                          8017  *************************************************************************************
00002F0C                          8018  *
00002F0C                          8019  * perform WIDTH
00002F0C                          8020  
00002F0C                          8021  LAB_WDTH
00002F0C  B03C 002C               8022      CMP.b       #',',d0         * is next byte ","
00002F10  672C                    8023      BEQ.s       LAB_TBSZ            * if so do tab size
00002F12                          8024  
00002F12  6100 ED5C               8025      BSR     LAB_GTBY            * get byte parameter, result in d0 and Itemp
00002F16  4A00                    8026      TST.b       d0              * test result
00002F18  6712                    8027      BEQ.s       LAB_NSTT            * branch if set for infinite line
00002F1A                          8028  
00002F1A  B03C 0010               8029      CMP.b       #$10,d0         * else make min width = 16d
00002F1E  6500 D78E               8030      BCS     LAB_FCER            * if less do function call error & exit
00002F22                          8031  
00002F22                          8032  * this next compare ensures that we can't exit WIDTH via an error leaving the
00002F22                          8033  * tab size greater than the line length.
00002F22                          8034  
00002F22  B02B 05E2               8035      CMP.b       TabSiz(a3),d0       * compare with tab size
00002F26  6404                    8036      BCC.s       LAB_NSTT            * branch if >= tab size
00002F28                          8037  
00002F28  1740 05E2               8038      MOVE.b  d0,TabSiz(a3)       * else make tab size = terminal width
00002F2C                          8039  LAB_NSTT
00002F2C  1740 05E6               8040      MOVE.b  d0,TWidth(a3)       * set the terminal width
00002F30  6100 E3CE               8041      BSR     LAB_GBYT            * get BASIC byte back
00002F34  672C                    8042      BEQ.s       WExit               * exit if no following
00002F36                          8043  
00002F36  B03C 002C               8044      CMP.b       #',',d0         * else is it ","
00002F3A  6600 D77E               8045      BNE     LAB_SNER            * if not do syntax error
00002F3E                          8046  
00002F3E                          8047  LAB_TBSZ
00002F3E  6100 ED2C               8048      BSR     LAB_SGBY            * increment and get byte, result in d0 and Itemp
00002F42  4A00                    8049      TST.b       d0              * test TAB size
00002F44  6B00 D768               8050      BMI     LAB_FCER            * if >127 do function call error & exit
00002F48                          8051  
00002F48  B03C 0001               8052      CMP.b       #1,d0               * compare with min-1
00002F4C  6500 D760               8053      BCS     LAB_FCER            * if <=1 do function call error & exit
00002F50                          8054  
00002F50  122B 05E6               8055      MOVE.b  TWidth(a3),d1       * set flags for width
00002F54  6708                    8056      BEQ.s       LAB_SVTB            * skip check if infinite line
00002F56                          8057  
00002F56  B02B 05E6               8058      CMP.b       TWidth(a3),d0       * compare TAB with width
00002F5A  6E00 D752               8059      BGT     LAB_FCER            * branch if too big
00002F5E                          8060  
00002F5E                          8061  LAB_SVTB
00002F5E  1740 05E2               8062      MOVE.b  d0,TabSiz(a3)       * save TAB size
00002F62                          8063  
00002F62                          8064  * calculate tab column limit from TAB size. The Iclim is set to the last tab
00002F62                          8065  * position on a line that still has at least one whole tab width between it
00002F62                          8066  * and the end of the line.
00002F62                          8067  
00002F62                          8068  WExit
00002F62  102B 05E6               8069      MOVE.b  TWidth(a3),d0       * get width
00002F66  670A                    8070      BEQ.s       LAB_WDLP            * branch if infinite line
00002F68                          8071  
00002F68  B02B 05E2               8072      CMP.b       TabSiz(a3),d0       * compare with tab size
00002F6C  6404                    8073      BCC.s       LAB_WDLP            * branch if >= tab size
00002F6E                          8074  
00002F6E  1740 05E2               8075      MOVE.b  d0,TabSiz(a3)       * else make tab size = terminal width
00002F72                          8076  LAB_WDLP
00002F72  902B 05E2               8077      SUB.b       TabSiz(a3),d0       * subtract tab size
00002F76  64FA                    8078      BCC.s       LAB_WDLP            * loop while no borrow
00002F78                          8079  
00002F78  D02B 05E2               8080      ADD.b       TabSiz(a3),d0       * add tab size back
00002F7C  D02B 05E2               8081      ADD.b       TabSiz(a3),d0       * add tab size back again
00002F80                          8082  
00002F80  4400                    8083      NEG.b       d0              * make -ve
00002F82  D02B 05E6               8084      ADD.b       TWidth(a3),d0       * subtract remainder from width
00002F86  1740 05E7               8085      MOVE.b  d0,Iclim(a3)        * save tab column limit
00002F8A                          8086  RTS_023
00002F8A  4E75                    8087      RTS
00002F8C                          8088  
00002F8C                          8089  
00002F8C                          8090  *************************************************************************************
00002F8C                          8091  *
00002F8C                          8092  * perform SQR()
00002F8C                          8093  
00002F8C                          8094  * d0 is number to find the root of
00002F8C                          8095  * d1 is the root result
00002F8C                          8096  * d2 is the remainder
00002F8C                          8097  * d3 is a counter
00002F8C                          8098  * d4 is temp
00002F8C                          8099  
00002F8C                          8100  LAB_SQR
00002F8C  4A2B 0595               8101      TST.b       FAC1_s(a3)          * test FAC1 sign
00002F90  6B00 D71C               8102      BMI     LAB_FCER            * if -ve do function call error
00002F94                          8103  
00002F94  4A2B 0594               8104      TST.b       FAC1_e(a3)          * test exponent
00002F98  67F0                    8105      BEQ.s       RTS_023         * exit if zero
00002F9A                          8106  
00002F9A  48E7 7800               8107      MOVEM.l d1-d4,-(sp)         * save registers
00002F9E  202B 0590               8108      MOVE.l  FAC1_m(a3),d0       * copy FAC1
00002FA2  7400                    8109      MOVEQ       #0,d2               * clear remainder
00002FA4  2202                    8110      MOVE.l  d2,d1               * clear root
00002FA6                          8111  
00002FA6  761F                    8112      MOVEQ       #$1F,d3         * $1F for DBF, 64 pairs of bits to
00002FA8                          8113                              * do for a 32 bit result
00002FA8  082B 0000 0594          8114      BTST        #0,FAC1_e(a3)       * test exponent odd/even
00002FAE  6606                    8115      BNE.s       LAB_SQE2            * if odd only 1 shift first time
00002FB0                          8116  
00002FB0                          8117  LAB_SQE1
00002FB0  D080                    8118      ADD.l       d0,d0               * shift highest bit of number ..
00002FB2  D582                    8119      ADDX.l  d2,d2               * .. into remainder .. never overflows
00002FB4  D281                    8120      ADD.l       d1,d1               * root = root * 2 .. never overflows
00002FB6                          8121  LAB_SQE2
00002FB6  D080                    8122      ADD.l       d0,d0               * shift highest bit of number ..
00002FB8  D582                    8123      ADDX.l  d2,d2               * .. into remainder .. never overflows
00002FBA                          8124  
00002FBA  2801                    8125      MOVE.l  d1,d4               * copy root
00002FBC  D884                    8126      ADD.l       d4,d4               * 2n
00002FBE  5284                    8127      ADDQ.l  #1,d4               * 2n+1
00002FC0                          8128  
00002FC0  B484                    8129      CMP.l       d4,d2               * compare 2n+1 to remainder
00002FC2  6504                    8130      BCS.s       LAB_SQNS            * skip sub if remainder smaller
00002FC4                          8131  
00002FC4  9484                    8132      SUB.l       d4,d2               * subtract temp from remainder
00002FC6  5281                    8133      ADDQ.l  #1,d1               * increment root
00002FC8                          8134  LAB_SQNS
00002FC8  51CB FFE6               8135      DBF     d3,LAB_SQE1         * loop if not all done
00002FCC                          8136  
00002FCC  2741 0590               8137      MOVE.l  d1,FAC1_m(a3)       * save result mantissa
00002FD0  102B 0594               8138      MOVE.b  FAC1_e(a3),d0       * get exponent (d0 is clear here)
00002FD4  0440 0080               8139      SUB.w       #$80,d0         * normalise
00002FD8  E248                    8140      LSR.w       #1,d0               * /2
00002FDA  6402                    8141      BCC.s       LAB_SQNA            * skip increment if carry clear
00002FDC                          8142  
00002FDC  5240                    8143      ADDQ.w  #1,d0               * add bit zero back in (allow for half shift)
00002FDE                          8144  LAB_SQNA
00002FDE  0640 0080               8145      ADD.w       #$80,d0         * re-bias to $80
00002FE2  1740 0594               8146      MOVE.b  d0,FAC1_e(a3)       * save it
00002FE6  4CDF 001E               8147      MOVEM.l (sp)+,d1-d4         * restore registers
00002FEA  6000 F0A6               8148      BRA     LAB_24D5            * normalise FAC1 & return
00002FEE                          8149  
00002FEE                          8150  
00002FEE                          8151  *************************************************************************************
00002FEE                          8152  *
00002FEE                          8153  * perform VARPTR()
00002FEE                          8154  
00002FEE                          8155  LAB_VARPTR
00002FEE  101D                    8156      MOVE.b  (a5)+,d0            * increment pointer
00002FF0  6100 E524               8157      BSR     LAB_GVAR            * get variable address in a0
00002FF4  6100 E2F6               8158      BSR     LAB_1BFB            * scan for ")", else do syntax error/warm start
00002FF8  2008                    8159      MOVE.l  a0,d0               * get var address
00002FFA  6000 E80A               8160      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & return
00002FFE                          8161  
00002FFE                          8162  
00002FFE                          8163  *************************************************************************************
00002FFE                          8164  *
00002FFE                          8165  * perform RAMBASE
00002FFE                          8166  
00002FFE                          8167  LAB_RAM
00002FFE  41EB 0400               8168      LEA     ram_base(a3),a0     * get start of EhBASIC RAM
00003002  2008                    8169      MOVE.l  a0,d0               * copy it
00003004  6000 E800               8170      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & return
00003008                          8171  
00003008                          8172  
00003008                          8173  *************************************************************************************
00003008                          8174  *
00003008                          8175  * perform PI
00003008                          8176  
00003008                          8177  LAB_PI
00003008  277C C90FDAA2 0590      8178      MOVE.l  #$C90FDAA2,FAC1_m(a3)   * pi mantissa (32 bit)
00003010  377C 8200 0594          8179      MOVE.w  #$8200,FAC1_e(a3)       * pi exponent and sign
00003016  4E75                    8180      RTS
00003018                          8181  
00003018                          8182  
00003018                          8183  *************************************************************************************
00003018                          8184  *
00003018                          8185  * perform TWOPI
00003018                          8186  
00003018                          8187  LAB_TWOPI
00003018  277C C90FDAA2 0590      8188      MOVE.l  #$C90FDAA2,FAC1_m(a3)   * 2pi mantissa (32 bit)
00003020  377C 8300 0594          8189      MOVE.w  #$8300,FAC1_e(a3)       * 2pi exponent and sign
00003026  4E75                    8190      RTS
00003028                          8191  
00003028                          8192  
00003028                          8193  *************************************************************************************
00003028                          8194  *
00003028                          8195  * get ASCII string equivalent into FAC1 as integer32 or float
00003028                          8196  
00003028                          8197  * entry is with a5 pointing to the first character of the string
00003028                          8198  * exit with a5 pointing to the first character after the string
00003028                          8199  
00003028                          8200  * d0 is character
00003028                          8201  * d1 is mantissa
00003028                          8202  * d2 is partial and table mantissa
00003028                          8203  * d3 is mantissa exponent (decimal & binary)
00003028                          8204  * d4 is decimal exponent
00003028                          8205  
00003028                          8206  * get FAC1 from string
00003028                          8207  * this routine now handles hex and binary values from strings
00003028                          8208  * starting with "$" and "%" respectively
00003028                          8209  
00003028                          8210  LAB_2887
00003028  48E7 7C00               8211      MOVEM.l d1-d5,-(sp)         * save registers
0000302C  7200                    8212      MOVEQ       #$00,d1         * clear temp accumulator
0000302E  2601                    8213      MOVE.l  d1,d3               * set mantissa decimal exponent count
00003030  2801                    8214      MOVE.l  d1,d4               * clear decimal exponent
00003032  1741 0595               8215      MOVE.b  d1,FAC1_s(a3)       * clear sign byte
00003036  1741 05B5               8216      MOVE.b  d1,Dtypef(a3)       * set float data type
0000303A  1741 05AF               8217      MOVE.b  d1,expneg(a3)       * clear exponent sign
0000303E  6100 E2C0               8218      BSR     LAB_GBYT            * get first byte back
00003042  653C                    8219      BCS.s       LAB_28FE            * go get floating if 1st character numeric
00003044                          8220  
00003044  B03C 002D               8221      CMP.b       #'-',d0         * or is it -ve number
00003048  6608                    8222      BNE.s       LAB_289A            * branch if not
0000304A                          8223  
0000304A  177C 00FF 0595          8224      MOVE.b  #$FF,FAC1_s(a3)     * set sign byte
00003050  6006                    8225      BRA.s       LAB_289C            * now go scan & check for hex/bin/int
00003052                          8226  
00003052                          8227  LAB_289A
00003052                          8228                              * first character wasn't numeric or -
00003052  B03C 002B               8229      CMP.b       #'+',d0         * compare with '+'
00003056  6606                    8230      BNE.s       LAB_289D            * branch if not '+', go check for '.'/hex/binary
00003058                          8231                              * /integer
00003058                          8232      
00003058                          8233  LAB_289C
00003058                          8234                              * was "+" or "-" to start, so get next character
00003058  6100 E2A4               8235      BSR     LAB_IGBY            * increment & scan memory
0000305C  6522                    8236      BCS.s       LAB_28FE            * branch if numeric character
0000305E                          8237  
0000305E                          8238  LAB_289D
0000305E  B03C 002E               8239      CMP.b       #'.',d0         * else compare with '.'
00003062  6700 0092               8240      BEQ     LAB_2904            * branch if '.'
00003066                          8241  
00003066                          8242                              * code here for hex/binary/integer numbers
00003066  B03C 0024               8243      CMP.b       #'$',d0         * compare with '$'
0000306A  6700 010A               8244      BEQ     LAB_CHEX            * branch if '$'
0000306E                          8245  
0000306E  B03C 0025               8246      CMP.b       #'%',d0         * else compare with '%'
00003072  6700 0164               8247      BEQ     LAB_CBIN            * branch if '%'
00003076                          8248  
00003076  6000 008C               8249      BRA     LAB_2Y01            * not #.$%& so return 0
0000307A                          8250  
0000307A                          8251  LAB_28FD
0000307A  6100 E282               8252      BSR     LAB_IGBY            * get next character
0000307E  646C                    8253      BCC.s       LAB_2902            * exit loop if not a digit
00003080                          8254  
00003080                          8255  LAB_28FE
00003080  6100 01A8               8256      BSR     d1x10               * multiply d1 by 10 and add character
00003084  64F4                    8257      BCC.s       LAB_28FD            * loop for more if no overflow
00003086                          8258  
00003086                          8259  LAB_28FF
00003086                          8260                              * overflowed mantissa, count 10s exponent
00003086  5283                    8261      ADDQ.l  #1,d3               * increment mantissa decimal exponent count
00003088  6100 E274               8262      BSR     LAB_IGBY            * get next character
0000308C  65F8                    8263      BCS.s       LAB_28FF            * loop while numeric character
0000308E                          8264  
0000308E                          8265                              * done overflow, now flush fraction or do E
0000308E  B03C 002E               8266      CMP.b       #'.',d0         * else compare with '.'
00003092  6606                    8267      BNE.s       LAB_2901            * branch if not '.'
00003094                          8268  
00003094                          8269  LAB_2900
00003094                          8270                              * flush remaining fraction digits
00003094  6100 E268               8271      BSR     LAB_IGBY            * get next character
00003098  65FA                    8272      BCS     LAB_2900            * loop while numeric character
0000309A                          8273  
0000309A                          8274  LAB_2901
0000309A                          8275                              * done number, only (possible) exponent remains
0000309A  B03C 0045               8276      CMP.b       #'E',d0         * else compare with 'E'
0000309E  6664                    8277      BNE.s       LAB_2Y01            * if not 'E' all done, go evaluate
000030A0                          8278  
000030A0                          8279                              * process exponent
000030A0  6100 E25C               8280      BSR     LAB_IGBY            * get next character
000030A4  6528                    8281      BCS.s       LAB_2X04            * branch if digit
000030A6                          8282  
000030A6  B03C 002D               8283      CMP.b       #'-',d0         * or is it -ve number
000030AA  6706                    8284      BEQ.s       LAB_2X01            * branch if so
000030AC                          8285  
000030AC  B03C 00C0               8286      CMP.b       #TK_MINUS,d0        * or is it -ve number
000030B0  6608                    8287      BNE.s       LAB_2X02            * branch if not
000030B2                          8288  
000030B2                          8289  LAB_2X01
000030B2  177C 00FF 05AF          8290      MOVE.b  #$FF,expneg(a3)     * set exponent sign
000030B8  600E                    8291      BRA.s       LAB_2X03            * now go scan & check exponent
000030BA                          8292  
000030BA                          8293  LAB_2X02
000030BA  B03C 002B               8294      CMP.b       #'+',d0         * or is it +ve number
000030BE  6708                    8295      BEQ.s       LAB_2X03            * branch if so
000030C0                          8296  
000030C0  B03C 00BF               8297      CMP.b       #TK_PLUS,d0         * or is it +ve number
000030C4  6600 D5F4               8298      BNE     LAB_SNER            * wasn't - + TK_MINUS TK_PLUS or # so do error
000030C8                          8299  
000030C8                          8300  LAB_2X03
000030C8  6100 E234               8301      BSR     LAB_IGBY            * get next character
000030CC  6436                    8302      BCC.s       LAB_2Y01            * if not digit all done, go evaluate
000030CE                          8303  LAB_2X04
000030CE  C8FC 000A               8304      MULU        #10,d4          * multiply decimal exponent by 10
000030D2  C0BC 000000FF           8305      AND.l       #$FF,d0         * mask character
000030D8  0400 0030               8306      SUB.b       #'0',d0         * convert to value
000030DC  D880                    8307      ADD.l       d0,d4               * add to decimal exponent
000030DE  B83C 0030               8308      CMP.b       #48,d4          * compare with decimal exponent limit+10
000030E2  6FE4                    8309      BLE.s       LAB_2X03            * loop if no overflow/underflow
000030E4                          8310  
000030E4                          8311  LAB_2X05
000030E4                          8312                              * exponent value has overflowed
000030E4  6100 E218               8313      BSR     LAB_IGBY            * get next character
000030E8  65FA                    8314      BCS.s       LAB_2X05            * loop while numeric digit
000030EA                          8315  
000030EA  6018                    8316      BRA.s       LAB_2Y01            * all done, go evaluate
000030EC                          8317  
000030EC                          8318  LAB_2902
000030EC  B03C 002E               8319      CMP.b       #'.',d0         * else compare with '.'
000030F0  6704                    8320      BEQ.s       LAB_2904            * branch if was '.'
000030F2                          8321  
000030F2  60A6                    8322      BRA.s       LAB_2901            * branch if not '.' (go check/do 'E')
000030F4                          8323  
000030F4                          8324  LAB_2903
000030F4  5383                    8325      SUBQ.l  #1,d3               * decrement mantissa decimal exponent
000030F6                          8326  LAB_2904
000030F6                          8327                              * was dp so get fraction part
000030F6  6100 E206               8328      BSR     LAB_IGBY            * get next character
000030FA  649E                    8329      BCC.s       LAB_2901            * exit loop if not a digit (go check/do 'E')
000030FC                          8330  
000030FC  6100 012C               8331      BSR     d1x10               * multiply d1 by 10 and add character
00003100  64F2                    8332      BCC.s       LAB_2903            * loop for more if no overflow
00003102                          8333  
00003102  6090                    8334      BRA.s       LAB_2900            * else go flush remaining fraction part
00003104                          8335  
00003104                          8336  LAB_2Y01
00003104                          8337                              * now evaluate result
00003104  4A2B 05AF               8338      TST.b       expneg(a3)          * test exponent sign
00003108  6A02                    8339      BPL.s       LAB_2Y02            * branch if sign positive
0000310A                          8340  
0000310A  4484                    8341      NEG.l       d4              * negate decimal exponent
0000310C                          8342  LAB_2Y02
0000310C  D883                    8343      ADD.l       d3,d4               * add mantissa decimal exponent
0000310E  7620                    8344      MOVEQ       #32,d3          * set up max binary exponent
00003110  4A81                    8345      TST.l       d1              * test mantissa
00003112  6752                    8346      BEQ.s       LAB_rtn0            * if mantissa=0 return 0
00003114                          8347  
00003114  6B08                    8348      BMI.s       LAB_2Y04            * branch if already mormalised
00003116                          8349  
00003116  5383                    8350      SUBQ.l  #1,d3               * decrement bianry exponent for DBMI loop
00003118                          8351  LAB_2Y03
00003118  D281                    8352      ADD.l       d1,d1               * shift mantissa
0000311A  5BCB FFFC               8353      DBMI        d3,LAB_2Y03         * decrement & loop if not normalised
0000311E                          8354  
0000311E                          8355                              * ensure not too big or small
0000311E                          8356  LAB_2Y04
0000311E  B8BC 00000026           8357      CMP.l       #38,d4          * compare decimal exponent with max exponent
00003124  6E00 D584               8358      BGT     LAB_OFER            * if greater do overflow error and warm start
00003128                          8359  
00003128  B8BC FFFFFFDA           8360      CMP.l       #-38,d4         * compare decimal exponent with min exponent
0000312E  6D34                    8361      BLT.s       LAB_ret0            * if less just return zero
00003130                          8362  
00003130  4484                    8363      NEG.l       d4              * negate decimal exponent to go right way
00003132  C9FC 0006               8364      MULS        #6,d4               * 6 bytes per entry
00003136  2F08                    8365      MOVE.l  a0,-(sp)            * save register
00003138  41FA 0210               8366      LEA     LAB_P_10(pc),a0     * point to table
0000313C  1770 4000 059C          8367      MOVE.b  (a0,d4.w),FAC2_e(a3)    * copy exponent for multiply
00003142  2770 4002 0598          8368      MOVE.l  2(a0,d4.w),FAC2_m(a3)   * copy table mantissa
00003148  205F                    8369      MOVE.l  (sp)+,a0            * restore register
0000314A                          8370  
0000314A  0A03 0080               8371      EORI.b  #$80,d3         * normalise input exponent
0000314E  2741 0590               8372      MOVE.l  d1,FAC1_m(a3)       * save input mantissa
00003152  1743 0594               8373      MOVE.b  d3,FAC1_e(a3)       * save input exponent
00003156  176B 0595 059E          8374      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * set sign as sign compare
0000315C                          8375  
0000315C  4CDF 003E               8376      MOVEM.l (sp)+,d1-d5         * restore registers
00003160  6000 F058               8377      BRA     LAB_MULTIPLY        * go multiply input by table
00003164                          8378  
00003164                          8379  LAB_ret0
00003164  7200                    8380      MOVEQ       #0,d1               * clear mantissa
00003166                          8381  LAB_rtn0
00003166  2601                    8382      MOVE.l  d1,d3               * clear exponent
00003168  1743 0594               8383      MOVE.b  d3,FAC1_e(a3)       * save exponent
0000316C  2741 0590               8384      MOVE.l  d1,FAC1_m(a3)       * save mantissa
00003170  4CDF 003E               8385      MOVEM.l (sp)+,d1-d5         * restore registers
00003174  4E75                    8386      RTS
00003176                          8387  
00003176                          8388  
00003176                          8389  *************************************************************************************
00003176                          8390  *
00003176                          8391  * $ for hex add-on
00003176                          8392  
00003176                          8393  * gets here if the first character was "$" for hex
00003176                          8394  * get hex number
00003176                          8395  
00003176                          8396  LAB_CHEX
00003176  177C 0040 05B5          8397      MOVE.b  #$40,Dtypef(a3)     * set integer numeric data type
0000317C  7620                    8398      MOVEQ       #32,d3          * set up max binary exponent
0000317E                          8399  LAB_CHXX
0000317E  6100 E17E               8400      BSR     LAB_IGBY            * increment & scan memory
00003182  6514                    8401      BCS.s       LAB_ISHN            * branch if numeric character
00003184                          8402  
00003184  803C 0020               8403      OR.b        #$20,d0         * case convert, allow "A" to "F" and "a" to "f"
00003188  0400 0061               8404      SUB.b       #'a',d0         * subtract "a"
0000318C  652A                    8405      BCS.s       LAB_CHX3            * exit if <"a"
0000318E                          8406  
0000318E  B03C 0006               8407      CMP.b       #$06,d0         * compare normalised with $06 (max+1)
00003192  6424                    8408      BCC.s       LAB_CHX3            * exit if >"f"
00003194                          8409  
00003194  0600 003A               8410      ADD.b       #$3A,d0         * convert to nibble+"0"
00003198                          8411  LAB_ISHN
00003198  616C                    8412      BSR.s       d1x16               * multiply d1 by 16 and add character
0000319A  64E2                    8413      BCC.s       LAB_CHXX            * loop for more if no overflow
0000319C                          8414  
0000319C                          8415                              * overflowed mantissa, count 16s exponent
0000319C                          8416  LAB_CHX1
0000319C  5883                    8417      ADDQ.l  #4,d3               * increment mantissa exponent count
0000319E  6900 D50A               8418      BVS     LAB_OFER            * do overflow error if overflowed
000031A2                          8419  
000031A2  6100 E15A               8420      BSR     LAB_IGBY            * get next character
000031A6  65F4                    8421      BCS.s       LAB_CHX1            * loop while numeric character
000031A8                          8422  
000031A8  803C 0020               8423      OR.b        #$20,d0         * case convert, allow "A" to "F" and "a" to "f"
000031AC  0400 0061               8424      SUB.b       #'a',d0         * subtract "a"
000031B0  6506                    8425      BCS.s       LAB_CHX3            * exit if <"a"
000031B2                          8426  
000031B2  B03C 0006               8427      CMP.b       #$06,d0         * compare normalised with $06 (max+1)
000031B6  65E4                    8428      BCS.s       LAB_CHX1            * loop if <="f"
000031B8                          8429  
000031B8                          8430                              * now return value
000031B8                          8431  LAB_CHX3
000031B8  4A81                    8432      TST.l       d1              * test mantissa
000031BA  67AA                    8433      BEQ.s       LAB_rtn0            * if mantissa=0 return 0
000031BC                          8434  
000031BC  6B08                    8435      BMI.s       LAB_exxf            * branch if already mormalised
000031BE                          8436  
000031BE  5383                    8437      SUBQ.l  #1,d3               * decrement bianry exponent for DBMI loop
000031C0                          8438  LAB_CHX2
000031C0  D281                    8439      ADD.l       d1,d1               * shift mantissa
000031C2  5BCB FFFC               8440      DBMI        d3,LAB_CHX2         * decrement & loop if not normalised
000031C6                          8441  
000031C6                          8442  LAB_exxf
000031C6  0A03 0080               8443      EORI.b  #$80,d3         * normalise exponent
000031CA  1743 0594               8444      MOVE.b  d3,FAC1_e(a3)       * save exponent
000031CE  2741 0590               8445      MOVE.l  d1,FAC1_m(a3)       * save mantissa
000031D2  4CDF 003E               8446      MOVEM.l (sp)+,d1-d5         * restore registers
000031D6                          8447  RTS_024
000031D6  4E75                    8448      RTS
000031D8                          8449  
000031D8                          8450  
000031D8                          8451  *************************************************************************************
000031D8                          8452  *
000031D8                          8453  * % for binary add-on
000031D8                          8454  
000031D8                          8455  * gets here if the first character was "%" for binary
000031D8                          8456  * get binary number
000031D8                          8457  
000031D8                          8458  LAB_CBIN
000031D8  177C 0040 05B5          8459      MOVE.b  #$40,Dtypef(a3)     * set integer numeric data type
000031DE  7620                    8460      MOVEQ       #32,d3          * set up max binary exponent
000031E0                          8461  LAB_CBXN
000031E0  6100 E11C               8462      BSR     LAB_IGBY            * increment & scan memory
000031E4  64D2                    8463      BCC.s       LAB_CHX3            * if not numeric character go return value
000031E6                          8464  
000031E6  B03C 0032               8465      CMP.b       #'2',d0         * compare with "2" (max+1)
000031EA  64CC                    8466      BCC.s       LAB_CHX3            * if >="2" go return value
000031EC                          8467  
000031EC  2401                    8468      MOVE.l  d1,d2               * copy value
000031EE  6124                    8469      BSR.s       d1x02               * multiply d1 by 2 and add character
000031F0  64EE                    8470      BCC.s       LAB_CBXN            * loop for more if no overflow
000031F2                          8471  
000031F2                          8472                              * overflowed mantissa, count 2s exponent
000031F2                          8473  LAB_CBX1
000031F2  5283                    8474      ADDQ.l  #1,d3               * increment mantissa exponent count
000031F4  6900 D4B4               8475      BVS     LAB_OFER            * do overflow error if overflowed
000031F8                          8476  
000031F8  6100 E104               8477      BSR     LAB_IGBY            * get next character
000031FC  64BA                    8478      BCC.s       LAB_CHX3            * if not numeric character go return value
000031FE                          8479  
000031FE  B03C 0032               8480      CMP.b       #'2',d0         * compare with "2" (max+1)
00003202  65EE                    8481      BCS.s       LAB_CBX1            * loop if <"2"
00003204                          8482  
00003204  60B2                    8483      BRA.s       LAB_CHX3            * if not numeric character go return value
00003206                          8484  
00003206                          8485  * half way decent times 16 and times 2 with overflow checks
00003206                          8486  
00003206                          8487  d1x16
00003206  2401                    8488      MOVE.l  d1,d2               * copy value
00003208  D482                    8489      ADD.l       d2,d2               * times two
0000320A  65CA                    8490      BCS.s       RTS_024         * return if overflow
0000320C                          8491  
0000320C  D482                    8492      ADD.l       d2,d2               * times four
0000320E  65C6                    8493      BCS.s       RTS_024         * return if overflow
00003210                          8494  
00003210  D482                    8495      ADD.l       d2,d2               * times eight
00003212  65C2                    8496      BCS.s       RTS_024         * return if overflow
00003214                          8497  
00003214                          8498  d1x02
00003214  D482                    8499      ADD.l       d2,d2               * times sixteen (ten/two)
00003216  65BE                    8500      BCS.s       RTS_024         * return if overflow
00003218                          8501  
00003218                          8502  * now add in new digit
00003218                          8503  
00003218  C0BC 000000FF           8504      AND.l       #$FF,d0         * mask character
0000321E  0400 0030               8505      SUB.b       #'0',d0         * convert to value
00003222  D480                    8506      ADD.l       d0,d2               * add to result
00003224  65B0                    8507      BCS.s       RTS_024         * return if overflow, it should never ever do
00003226                          8508                              * this
00003226                          8509  
00003226  2202                    8510      MOVE.l  d2,d1               * copy result
00003228  4E75                    8511      RTS
0000322A                          8512  
0000322A                          8513  * half way decent times 10 with overflow checks
0000322A                          8514  
0000322A                          8515  d1x10
0000322A  2401                    8516      MOVE.l  d1,d2               * copy value
0000322C  D482                    8517      ADD.l       d2,d2               * times two
0000322E  6508                    8518      BCS.s       RTS_025         * return if overflow
00003230                          8519  
00003230  D482                    8520      ADD.l       d2,d2               * times four
00003232  6504                    8521      BCS.s       RTS_025         * return if overflow
00003234                          8522  
00003234  D481                    8523      ADD.l       d1,d2               * times five
00003236  64DC                    8524      BCC.s       d1x02               * do times two and add in new digit if ok
00003238                          8525  
00003238                          8526  RTS_025
00003238  4E75                    8527      RTS
0000323A                          8528  
0000323A                          8529  
0000323A                          8530  *************************************************************************************
0000323A                          8531  
0000323A                          8532  * token values needed for BASIC
0000323A                          8533  
0000323A  =00000080               8534  TK_END      EQU $80         * $80
0000323A  =00000081               8535  TK_FOR      EQU TK_END+1        * $81
0000323A  =00000082               8536  TK_NEXT     EQU TK_FOR+1        * $82
0000323A  =00000083               8537  TK_DATA     EQU TK_NEXT+1       * $83
0000323A  =00000084               8538  TK_INPUT        EQU TK_DATA+1       * $84
0000323A  =00000085               8539  TK_DIM      EQU TK_INPUT+1      * $85
0000323A  =00000086               8540  TK_READ     EQU TK_DIM+1        * $86
0000323A  =00000087               8541  TK_LET      EQU TK_READ+1       * $87
0000323A  =00000088               8542  TK_DEC      EQU TK_LET+1        * $88
0000323A  =00000089               8543  TK_GOTO     EQU TK_DEC+1        * $89
0000323A  =0000008A               8544  TK_RUN      EQU TK_GOTO+1       * $8A
0000323A  =0000008B               8545  TK_IF           EQU TK_RUN+1        * $8B
0000323A  =0000008C               8546  TK_RESTORE      EQU TK_IF+1         * $8C
0000323A  =0000008D               8547  TK_GOSUB        EQU TK_RESTORE+1        * $8D
0000323A  =0000008E               8548  TK_RETURN       EQU TK_GOSUB+1      * $8E
0000323A  =0000008F               8549  TK_REM      EQU TK_RETURN+1     * $8F
0000323A  =00000090               8550  TK_STOP     EQU TK_REM+1        * $90
0000323A  =00000091               8551  TK_ON           EQU TK_STOP+1       * $91
0000323A  =00000092               8552  TK_NULL     EQU TK_ON+1         * $92
0000323A  =00000093               8553  TK_INC      EQU TK_NULL+1       * $93
0000323A  =00000094               8554  TK_WAIT     EQU TK_INC+1        * $94
0000323A  =00000095               8555  TK_LOAD     EQU TK_WAIT+1       * $95
0000323A  =00000096               8556  TK_SAVE     EQU TK_LOAD+1       * $96
0000323A  =00000097               8557  TK_DEF      EQU TK_SAVE+1       * $97
0000323A  =00000098               8558  TK_POKE     EQU TK_DEF+1        * $98
0000323A  =00000099               8559  TK_DOKE     EQU TK_POKE+1       * $99
0000323A  =0000009A               8560  TK_LOKE     EQU TK_DOKE+1       * $9A
0000323A  =0000009B               8561  TK_CALL     EQU TK_LOKE+1       * $9B
0000323A  =0000009C               8562  TK_DO           EQU TK_CALL+1       * $9C
0000323A  =0000009D               8563  TK_LOOP     EQU TK_DO+1         * $9D
0000323A  =0000009E               8564  TK_PRINT        EQU TK_LOOP+1       * $9E
0000323A  =0000009F               8565  TK_CONT     EQU TK_PRINT+1      * $9F
0000323A                          8566  
0000323A  =000000A0               8567  TK_BUFFER       EQU TK_CONT+1       * $A0 EASy68k graphics extension
0000323A  =000000A1               8568  TK_CLS      EQU TK_BUFFER+1     * $A1 EASy68k graphics extension
0000323A  =000000A2               8569  TK_CURSOR       EQU TK_CLS+1        * $A2 EASy68k graphics extension
0000323A  =000000A3               8570  TK_LINE     EQU TK_CURSOR+1     * $A3 EASy68k graphics extension
0000323A  =000000A4               8571  TK_FILL     EQU TK_LINE+1       * $A4 EASy68k graphics extension
0000323A  =000000A5               8572  TK_MOVE     EQU TK_FILL+1       * $A5 EASy68k graphics extension
0000323A  =000000A6               8573  TK_POINT        EQU TK_MOVE+1       * $A6 EASy68k graphics extension
0000323A  =000000A7               8574  TK_RECT     EQU TK_POINT+1      * $A7 EASy68k graphics extension
0000323A  =000000A8               8575  TK_FRECT        EQU TK_RECT+1       * $A8 EASy68k graphics extension
0000323A  =000000A9               8576  TK_ELLIPSE      EQU TK_FRECT+1      * $A9 EASy68k graphics extension
0000323A  =000000AA               8577  TK_FELLIPSE     EQU TK_ELLIPSE+1        * $AA EASy68k graphics extension
0000323A  =000000AB               8578  TK_MODE     EQU TK_FELLIPSE+1       * $AB EASy68k graphics extension
0000323A  =000000AC               8579  TK_SIZE     EQU TK_MODE+1       * $AC EASy68k graphics extension
0000323A                          8580  
0000323A  =000000AD               8581  TK_LIST     EQU TK_SIZE+1       * $AD
0000323A  =000000AE               8582  TK_CLEAR        EQU TK_LIST+1       * $AE
0000323A  =000000AF               8583  TK_NEW      EQU TK_CLEAR+1      * $AF
0000323A  =000000B0               8584  TK_WIDTH        EQU TK_NEW+1        * $B0
0000323A  =000000B1               8585  TK_GET      EQU TK_WIDTH+1      * $B1
0000323A  =000000B2               8586  TK_SWAP     EQU TK_GET+1        * $B2
0000323A  =000000B3               8587  TK_BITSET       EQU TK_SWAP+1       * $B3
0000323A  =000000B4               8588  TK_BITCLR       EQU TK_BITSET+1     * $B4
0000323A  =000000B5               8589  TK_TAB      EQU TK_BITCLR+1     * $B5
0000323A  =000000B6               8590  TK_ELSE     EQU TK_TAB+1        * $B6
0000323A  =000000B7               8591  TK_TO           EQU TK_ELSE+1       * $B7
0000323A  =000000B8               8592  TK_FN           EQU TK_TO+1         * $B8
0000323A  =000000B9               8593  TK_SPC      EQU TK_FN+1         * $B9
0000323A  =000000BA               8594  TK_THEN     EQU TK_SPC+1        * $BA
0000323A  =000000BB               8595  TK_NOT      EQU TK_THEN+1       * $BB
0000323A  =000000BC               8596  TK_STEP     EQU TK_NOT+1        * $BC
0000323A  =000000BD               8597  TK_UNTIL        EQU TK_STEP+1       * $BD
0000323A  =000000BE               8598  TK_WHILE        EQU TK_UNTIL+1      * $BE
0000323A  =000000BF               8599  TK_PLUS     EQU TK_WHILE+1      * $BF
0000323A  =000000C0               8600  TK_MINUS        EQU TK_PLUS+1       * $C0
0000323A  =000000C1               8601  TK_MULT     EQU TK_MINUS+1      * $C1
0000323A  =000000C2               8602  TK_DIV      EQU TK_MULT+1       * $C2
0000323A  =000000C3               8603  TK_POWER        EQU TK_DIV+1        * $C3
0000323A  =000000C4               8604  TK_AND      EQU TK_POWER+1      * $C4
0000323A  =000000C5               8605  TK_EOR      EQU TK_AND+1        * $C5
0000323A  =000000C6               8606  TK_OR           EQU TK_EOR+1        * $C6
0000323A  =000000C7               8607  TK_RSHIFT       EQU TK_OR+1         * $C7
0000323A  =000000C8               8608  TK_LSHIFT       EQU TK_RSHIFT+1     * $C8
0000323A  =000000C9               8609  TK_GT           EQU TK_LSHIFT+1     * $C9
0000323A  =000000CA               8610  TK_EQUAL        EQU TK_GT+1         * $CA
0000323A  =000000CB               8611  TK_LT           EQU TK_EQUAL+1      * $CB
0000323A  =000000CC               8612  TK_SGN      EQU TK_LT+1         * $CC
0000323A  =000000CD               8613  TK_INT      EQU TK_SGN+1        * $CD
0000323A  =000000CE               8614  TK_ABS      EQU TK_INT+1        * $CE
0000323A  =000000CF               8615  TK_USR      EQU TK_ABS+1        * $CF
0000323A  =000000D0               8616  TK_FRE      EQU TK_USR+1        * $D0
0000323A  =000000D1               8617  TK_POS      EQU TK_FRE+1        * $D1
0000323A  =000000D2               8618  TK_SQR      EQU TK_POS+1        * $D2
0000323A  =000000D3               8619  TK_RND      EQU TK_SQR+1        * $D3
0000323A  =000000D4               8620  TK_LOG      EQU TK_RND+1        * $D4
0000323A  =000000D5               8621  TK_EXP      EQU TK_LOG+1        * $D5
0000323A  =000000D6               8622  TK_COS      EQU TK_EXP+1        * $D6
0000323A  =000000D7               8623  TK_SIN      EQU TK_COS+1        * $D7
0000323A  =000000D8               8624  TK_TAN      EQU TK_SIN+1        * $D8
0000323A  =000000D9               8625  TK_ATN      EQU TK_TAN+1        * $D9
0000323A  =000000DA               8626  TK_PEEK     EQU TK_ATN+1        * $DA
0000323A  =000000DB               8627  TK_DEEK     EQU TK_PEEK+1       * $DB
0000323A  =000000DC               8628  TK_LEEK     EQU TK_DEEK+1       * $DC
0000323A  =000000DD               8629  TK_LEN      EQU TK_LEEK+1       * $DD
0000323A  =000000DE               8630  TK_STRS     EQU TK_LEN+1        * $DE
0000323A  =000000DF               8631  TK_VAL      EQU TK_STRS+1       * $DF
0000323A  =000000E0               8632  TK_ASC      EQU TK_VAL+1        * $E0
0000323A  =000000E1               8633  TK_UCASES       EQU TK_ASC+1        * $E1
0000323A  =000000E2               8634  TK_LCASES       EQU TK_UCASES+1     * $E2
0000323A  =000000E3               8635  TK_CHRS     EQU TK_LCASES+1     * $E3
0000323A  =000000E4               8636  TK_HEXS     EQU TK_CHRS+1       * $E4
0000323A  =000000E5               8637  TK_BINS     EQU TK_HEXS+1       * $E5
0000323A  =000000E6               8638  TK_BITTST       EQU TK_BINS+1       * $E6
0000323A  =000000E7               8639  TK_MAX      EQU TK_BITTST+1     * $E7
0000323A  =000000E8               8640  TK_MIN      EQU TK_MAX+1        * $E8
0000323A  =000000E9               8641  TK_RAM      EQU TK_MIN+1        * $E9
0000323A  =000000EA               8642  TK_KEYS     EQU TK_RAM+1        * $EA EASy68k simulator extension
0000323A  =000000EB               8643  TK_TI           EQU TK_KEYS+1       * $EB EASy68k simulator extension
0000323A  =000000EC               8644  TK_PI           EQU TK_TI+1         * $EC
0000323A  =000000ED               8645  TK_TWOPI        EQU TK_PI+1         * $ED
0000323A  =000000EE               8646  TK_VPTR     EQU TK_TWOPI+1      * $EE
0000323A  =000000EF               8647  TK_SADD     EQU TK_VPTR+1       * $EF
0000323A  =000000F0               8648  TK_LEFTS        EQU TK_SADD+1       * $F0
0000323A  =000000F1               8649  TK_RIGHTS       EQU TK_LEFTS+1      * $F1
0000323A  =000000F2               8650  TK_MIDS     EQU TK_RIGHTS+1     * $F2
0000323A  =000000F3               8651  TK_USINGS       EQU TK_MIDS+1       * $F3
0000323A                          8652  
0000323A                          8653  
0000323A                          8654  ************************************************************************************
0000323A                          8655  *
0000323A                          8656  * binary to unsigned decimal table
0000323A                          8657  
0000323A                          8658  Bin2dec
0000323A= 3B9ACA00                8659      dc.l    $3B9ACA00               * 1000000000
0000323E= 05F5E100                8660      dc.l    $05F5E100               * 100000000
00003242= 00989680                8661      dc.l    $00989680               * 10000000
00003246= 000F4240                8662      dc.l    $000F4240               * 1000000
0000324A= 000186A0                8663      dc.l    $000186A0               * 100000
0000324E= 00002710                8664      dc.l    $00002710               * 10000
00003252= 000003E8                8665      dc.l    $000003E8               * 1000
00003256= 00000064                8666      dc.l    $00000064               * 100
0000325A= 0000000A                8667      dc.l    $0000000A               * 10
0000325E= 00000000                8668      dc.l    $00000000               * 0 end marker
00003262                          8669  
00003262                          8670  LAB_RSED
00003262= 332E3232                8671      dc.l    $332E3232               * 858665522
00003266                          8672  
00003266                          8673  * string to value exponent table
00003266                          8674  
00003266= FF00                    8675      dc.w    255<<8              * 10**38
00003268= 96769951                8676      dc.l    $96769951
0000326C= FB00                    8677      dc.w    251<<8              * 10**37
0000326E= F0BDC21B                8678      dc.l    $F0BDC21B
00003272= F800                    8679      dc.w    248<<8              * 10**36
00003274= C097CE7C                8680      dc.l    $C097CE7C
00003278= F500                    8681      dc.w    245<<8              * 10**35
0000327A= 9A130B96                8682      dc.l    $9A130B96
0000327E= F100                    8683      dc.w    241<<8              * 10**34
00003280= F684DF57                8684      dc.l    $F684DF57
00003284= EE00                    8685      dc.w    238<<8              * 10**33
00003286= C5371912                8686      dc.l    $C5371912
0000328A= EB00                    8687      dc.w    235<<8              * 10**32
0000328C= 9DC5ADA8                8688      dc.l    $9DC5ADA8
00003290= E700                    8689      dc.w    231<<8              * 10**31
00003292= FC6F7C40                8690      dc.l    $FC6F7C40
00003296= E400                    8691      dc.w    228<<8              * 10**30
00003298= C9F2C9CD                8692      dc.l    $C9F2C9CD
0000329C= E100                    8693      dc.w    225<<8              * 10**29
0000329E= A18F07D7                8694      dc.l    $A18F07D7
000032A2= DE00                    8695      dc.w    222<<8              * 10**28
000032A4= 813F3979                8696      dc.l    $813F3979
000032A8= DA00                    8697      dc.w    218<<8              * 10**27
000032AA= CECB8F28                8698      dc.l    $CECB8F28
000032AE= D700                    8699      dc.w    215<<8              * 10**26
000032B0= A56FA5BA                8700      dc.l    $A56FA5BA
000032B4= D400                    8701      dc.w    212<<8              * 10**25
000032B6= 84595161                8702      dc.l    $84595161
000032BA= D000                    8703      dc.w    208<<8              * 10**24
000032BC= D3C21BCF                8704      dc.l    $D3C21BCF
000032C0= CD00                    8705      dc.w    205<<8              * 10**23
000032C2= A968163F                8706      dc.l    $A968163F
000032C6= CA00                    8707      dc.w    202<<8              * 10**22
000032C8= 87867832                8708      dc.l    $87867832
000032CC= C600                    8709      dc.w    198<<8              * 10**21
000032CE= D8D726B7                8710      dc.l    $D8D726B7
000032D2= C300                    8711      dc.w    195<<8              * 10**20
000032D4= AD78EBC6                8712      dc.l    $AD78EBC6
000032D8= C000                    8713      dc.w    192<<8              * 10**19
000032DA= 8AC72305                8714      dc.l    $8AC72305
000032DE= BC00                    8715      dc.w    188<<8              * 10**18
000032E0= DE0B6B3A                8716      dc.l    $DE0B6B3A
000032E4= B900                    8717      dc.w    185<<8              * 10**17
000032E6= B1A2BC2F                8718      dc.l    $B1A2BC2F
000032EA= B600                    8719      dc.w    182<<8              * 10**16
000032EC= 8E1BC9BF                8720      dc.l    $8E1BC9BF
000032F0= B200                    8721      dc.w    178<<8              * 10**15
000032F2= E35FA932                8722      dc.l    $E35FA932
000032F6= AF00                    8723      dc.w    175<<8              * 10**14
000032F8= B5E620F5                8724      dc.l    $B5E620F5
000032FC= AC00                    8725      dc.w    172<<8              * 10**13
000032FE= 9184E72A                8726      dc.l    $9184E72A
00003302= A800                    8727      dc.w    168<<8              * 10**12
00003304= E8D4A510                8728      dc.l    $E8D4A510
00003308= A500                    8729      dc.w    165<<8              * 10**11
0000330A= BA43B740                8730      dc.l    $BA43B740
0000330E= A200                    8731      dc.w    162<<8              * 10**10
00003310= 9502F900                8732      dc.l    $9502F900
00003314= 9E00                    8733      dc.w    158<<8              * 10**9
00003316= EE6B2800                8734      dc.l    $EE6B2800
0000331A= 9B00                    8735      dc.w    155<<8              * 10**8
0000331C= BEBC2000                8736      dc.l    $BEBC2000
00003320= 9800                    8737      dc.w    152<<8              * 10**7
00003322= 98968000                8738      dc.l    $98968000
00003326= 9400                    8739      dc.w    148<<8              * 10**6
00003328= F4240000                8740      dc.l    $F4240000
0000332C= 9100                    8741      dc.w    145<<8              * 10**5
0000332E= C3500000                8742      dc.l    $C3500000
00003332= 8E00                    8743      dc.w    142<<8              * 10**4
00003334= 9C400000                8744      dc.l    $9C400000
00003338= 8A00                    8745      dc.w    138<<8              * 10**3
0000333A= FA000000                8746      dc.l    $FA000000
0000333E= 8700                    8747      dc.w    135<<8              * 10**2
00003340= C8000000                8748      dc.l    $C8000000
00003344= 8400                    8749      dc.w    132<<8              * 10**1
00003346= A0000000                8750      dc.l    $A0000000
0000334A                          8751  LAB_P_10
0000334A= 8100                    8752      dc.w    129<<8              * 10**0
0000334C= 80000000                8753      dc.l    $80000000
00003350= 7D00                    8754      dc.w    125<<8              * 10**-1
00003352= CCCCCCCD                8755      dc.l    $CCCCCCCD
00003356= 7A00                    8756      dc.w    122<<8              * 10**-2
00003358= A3D70A3D                8757      dc.l    $A3D70A3D
0000335C= 7700                    8758      dc.w    119<<8              * 10**-3
0000335E= 83126E98                8759      dc.l    $83126E98
00003362= 7300                    8760      dc.w    115<<8              * 10**-4
00003364= D1B71759                8761      dc.l    $D1B71759
00003368= 7000                    8762      dc.w    112<<8              * 10**-5
0000336A= A7C5AC47                8763      dc.l    $A7C5AC47
0000336E= 6D00                    8764      dc.w    109<<8              * 10**-6
00003370= 8637BD06                8765      dc.l    $8637BD06
00003374= 6900                    8766      dc.w    105<<8              * 10**-7
00003376= D6BF94D6                8767      dc.l    $D6BF94D6
0000337A= 6600                    8768      dc.w    102<<8              * 10**-8
0000337C= ABCC7712                8769      dc.l    $ABCC7712
00003380= 6300                    8770      dc.w    99<<8                   * 10**-9
00003382= 89705F41                8771      dc.l    $89705F41
00003386= 5F00                    8772      dc.w    95<<8                   * 10**-10
00003388= DBE6FECF                8773      dc.l    $DBE6FECF
0000338C= 5C00                    8774      dc.w    92<<8                   * 10**-11
0000338E= AFEBFF0C                8775      dc.l    $AFEBFF0C
00003392= 5900                    8776      dc.w    89<<8                   * 10**-12
00003394= 8CBCCC09                8777      dc.l    $8CBCCC09
00003398= 5500                    8778      dc.w    85<<8                   * 10**-13
0000339A= E12E1342                8779      dc.l    $E12E1342
0000339E= 5200                    8780      dc.w    82<<8                   * 10**-14
000033A0= B424DC35                8781      dc.l    $B424DC35
000033A4= 4F00                    8782      dc.w    79<<8                   * 10**-15
000033A6= 901D7CF7                8783      dc.l    $901D7CF7
000033AA= 4B00                    8784      dc.w    75<<8                   * 10**-16
000033AC= E69594BF                8785      dc.l    $E69594BF
000033B0= 4800                    8786      dc.w    72<<8                   * 10**-17
000033B2= B877AA32                8787      dc.l    $B877AA32
000033B6= 4500                    8788      dc.w    69<<8                   * 10**-18
000033B8= 9392EE8F                8789      dc.l    $9392EE8F
000033BC= 4100                    8790      dc.w    65<<8                   * 10**-19
000033BE= EC1E4A7E                8791      dc.l    $EC1E4A7E
000033C2= 3E00                    8792      dc.w    62<<8                   * 10**-20
000033C4= BCE50865                8793      dc.l    $BCE50865
000033C8= 3B00                    8794      dc.w    59<<8                   * 10**-21
000033CA= 971DA050                8795      dc.l    $971DA050
000033CE= 3700                    8796      dc.w    55<<8                   * 10**-22
000033D0= F1C90081                8797      dc.l    $F1C90081
000033D4= 3400                    8798      dc.w    52<<8                   * 10**-23
000033D6= C16D9A01                8799      dc.l    $C16D9A01
000033DA= 3100                    8800      dc.w    49<<8                   * 10**-24
000033DC= 9ABE14CD                8801      dc.l    $9ABE14CD
000033E0= 2D00                    8802      dc.w    45<<8                   * 10**-25
000033E2= F79687AE                8803      dc.l    $F79687AE
000033E6= 2A00                    8804      dc.w    42<<8                   * 10**-26
000033E8= C6120625                8805      dc.l    $C6120625
000033EC= 2700                    8806      dc.w    39<<8                   * 10**-27
000033EE= 9E74D1B8                8807      dc.l    $9E74D1B8
000033F2= 2300                    8808      dc.w    35<<8                   * 10**-28
000033F4= FD87B5F3                8809      dc.l    $FD87B5F3
000033F8= 2000                    8810      dc.w    32<<8                   * 10**-29
000033FA= CAD2F7F5                8811      dc.l    $CAD2F7F5
000033FE= 1D00                    8812      dc.w    29<<8                   * 10**-30
00003400= A2425FF7                8813      dc.l    $A2425FF7
00003404= 1A00                    8814      dc.w    26<<8                   * 10**-31
00003406= 81CEB32C                8815      dc.l    $81CEB32C
0000340A= 1600                    8816      dc.w    22<<8                   * 10**-32
0000340C= CFB11EAD                8817      dc.l    $CFB11EAD
00003410= 1300                    8818      dc.w    19<<8                   * 10**-33
00003412= A6274BBE                8819      dc.l    $A6274BBE
00003416= 1000                    8820      dc.w    16<<8                   * 10**-34
00003418= 84EC3C98                8821      dc.l    $84EC3C98
0000341C= 0C00                    8822      dc.w    12<<8                   * 10**-35
0000341E= D4AD2DC0                8823      dc.l    $D4AD2DC0
00003422= 0900                    8824      dc.w    9<<8                    * 10**-36
00003424= AA242499                8825      dc.l    $AA242499
00003428= 0600                    8826      dc.w    6<<8                    * 10**-37
0000342A= 881CEA14                8827      dc.l    $881CEA14
0000342E= 0200                    8828      dc.w    2<<8                    * 10**-38
00003430= D9C7DCED                8829      dc.l    $D9C7DCED
00003434                          8830  
00003434                          8831  
00003434                          8832  *************************************************************************************
00003434                          8833  *
00003434                          8834  * table of constants for cordic SIN/COS/TAN calculations
00003434                          8835  * constants are un normalised fractions and are atn(2^-i)/2pi
00003434                          8836  
00003434= 4DBA76D4                8837      dc.l    $4DBA76D4               * SIN/COS multiply constant
00003438                          8838  TAB_SNCO
00003438= 20000000                8839      dc.l    $20000000               * atn(2^0)/2pi
0000343C= 12E4051E                8840      dc.l    $12E4051E               * atn(2^1)/2pi
00003440= 09FB385C                8841      dc.l    $09FB385C               * atn(2^2)/2pi
00003444= 051111D5                8842      dc.l    $051111D5               * atn(2^3)/2pi
00003448= 028B0D44                8843      dc.l    $028B0D44               * atn(2^4)/2pi
0000344C= 0145D7E2                8844      dc.l    $0145D7E2               * atn(2^5)/2pi
00003450= 00A2F61F                8845      dc.l    $00A2F61F               * atn(2^6)/2pi
00003454= 00517C56                8846      dc.l    $00517C56               * atn(2^7)/2pi
00003458= 0028BE54                8847      dc.l    $0028BE54               * atn(2^8)/2pi
0000345C= 00145F2F                8848      dc.l    $00145F2F               * atn(2^9)/2pi
00003460= 000A2F99                8849      dc.l    $000A2F99               * atn(2^10)/2pi
00003464= 000517CD                8850      dc.l    $000517CD               * atn(2^11)/2pi
00003468= 00028BE7                8851      dc.l    $00028BE7               * atn(2^12)/2pi
0000346C= 000145F4                8852      dc.l    $000145F4               * atn(2^13)/2pi
00003470= 0000A2FA                8853      dc.l    $0000A2FA               * atn(2^14)/2pi
00003474= 0000517D                8854      dc.l    $0000517D               * atn(2^15)/2pi
00003478= 000028BF                8855      dc.l    $000028BF               * atn(2^16)/2pi
0000347C= 00001460                8856      dc.l    $00001460               * atn(2^17)/2pi
00003480= 00000A30                8857      dc.l    $00000A30               * atn(2^18)/2pi
00003484= 00000518                8858      dc.l    $00000518               * atn(2^19)/2pi
00003488= 0000028C                8859      dc.l    $0000028C               * atn(2^20)/2pi
0000348C= 00000146                8860      dc.l    $00000146               * atn(2^21)/2pi
00003490= 000000A3                8861      dc.l    $000000A3               * atn(2^22)/2pi
00003494= 00000052                8862      dc.l    $00000052               * atn(2^23)/2pi
00003498= 00000029                8863      dc.l    $00000029               * atn(2^24)/2pi
0000349C= 00000015                8864      dc.l    $00000015               * atn(2^25)/2pi
000034A0= 0000000B                8865      dc.l    $0000000B               * atn(2^26)/2pi
000034A4= 00000006                8866      dc.l    $00000006               * atn(2^27)/2pi
000034A8= 00000003                8867      dc.l    $00000003               * atn(2^28)/2pi
000034AC= 00000002                8868      dc.l    $00000002               * atn(2^29)/2pi
000034B0= 00000001                8869      dc.l    $00000001               * atn(2^30)/2pi
000034B4= 00000001                8870      dc.l    $00000001               * atn(2^31)/2pi
000034B8                          8871  
000034B8                          8872  
000034B8                          8873  *************************************************************************************
000034B8                          8874  *
000034B8                          8875  * table of constants for cordic ATN calculation
000034B8                          8876  * constants are normalised to two integer bits and are atn(2^-i)
000034B8                          8877  
000034B8                          8878  TAB_ATNC
000034B8= 1DAC6705                8879      dc.l    $1DAC6705               * atn(2^-1)
000034BC= 0FADBAFD                8880      dc.l    $0FADBAFD               * atn(2^-2)
000034C0= 07F56EA7                8881      dc.l    $07F56EA7               * atn(2^-3)
000034C4= 03FEAB77                8882      dc.l    $03FEAB77               * atn(2^-4)
000034C8= 01FFD55C                8883      dc.l    $01FFD55C               * atn(2^-5)
000034CC= 00FFFAAB                8884      dc.l    $00FFFAAB               * atn(2^-6)
000034D0= 007FFF55                8885      dc.l    $007FFF55               * atn(2^-7)
000034D4= 003FFFEB                8886      dc.l    $003FFFEB               * atn(2^-8)
000034D8= 001FFFFD                8887      dc.l    $001FFFFD               * atn(2^-9)
000034DC= 00100000                8888      dc.l    $00100000               * atn(2^-10)
000034E0= 00080000                8889      dc.l    $00080000               * atn(2^-11)
000034E4= 00040000                8890      dc.l    $00040000               * atn(2^-12)
000034E8= 00020000                8891      dc.l    $00020000               * atn(2^-13)
000034EC= 00010000                8892      dc.l    $00010000               * atn(2^-14)
000034F0= 00008000                8893      dc.l    $00008000               * atn(2^-15)
000034F4= 00004000                8894      dc.l    $00004000               * atn(2^-16)
000034F8= 00002000                8895      dc.l    $00002000               * atn(2^-17)
000034FC= 00001000                8896      dc.l    $00001000               * atn(2^-18)
00003500= 00000800                8897      dc.l    $00000800               * atn(2^-19)
00003504= 00000400                8898      dc.l    $00000400               * atn(2^-20)
00003508= 00000200                8899      dc.l    $00000200               * atn(2^-21)
0000350C= 00000100                8900      dc.l    $00000100               * atn(2^-22)
00003510= 00000080                8901      dc.l    $00000080               * atn(2^-23)
00003514= 00000040                8902      dc.l    $00000040               * atn(2^-24)
00003518= 00000020                8903      dc.l    $00000020               * atn(2^-25)
0000351C= 00000010                8904      dc.l    $00000010               * atn(2^-26)
00003520= 00000008                8905      dc.l    $00000008               * atn(2^-27)
00003524= 00000004                8906      dc.l    $00000004               * atn(2^-28)
00003528= 00000002                8907      dc.l    $00000002               * atn(2^-29)
0000352C= 00000001                8908      dc.l    $00000001               * atn(2^-30)
00003530                          8909  LAB_1D96
00003530= 00000000                8910      dc.l    $00000000               * atn(2^-31)
00003534= 00000000                8911      dc.l    $00000000               * atn(2^-32)
00003538                          8912  
00003538                          8913  * constants are normalised to n integer bits and are tanh(2^-i)
00003538  =00000002               8914  n   equ 2
00003538                          8915  TAB_HTHET
00003538= 2327D4F4                8916      dc.l    $8C9F53D0>>n            * atnh(2^-1)    .549306144
0000353C= 1058AEFA                8917      dc.l    $4162BBE8>>n            * atnh(2^-2)    .255412812
00003540= 080AC48E                8918      dc.l    $202B1238>>n            * atnh(2^-3)
00003544= 04015622                8919      dc.l    $10055888>>n            * atnh(2^-4)
00003548= 02002AB0                8920      dc.l    $0800AAC0>>n            * atnh(2^-5)
0000354C= 01000554                8921      dc.l    $04001550>>n            * atnh(2^-6)
00003550= 008000AA                8922      dc.l    $020002A8>>n            * atnh(2^-7)
00003554= 00400014                8923      dc.l    $01000050>>n            * atnh(2^-8)
00003558= 00200002                8924      dc.l    $00800008>>n            * atnh(2^-9)
0000355C= 00100000                8925      dc.l    $00400000>>n            * atnh(2^-10)
00003560= 00080000                8926      dc.l    $00200000>>n            * atnh(2^-11)
00003564= 00040000                8927      dc.l    $00100000>>n            * atnh(2^-12)
00003568= 00020000                8928      dc.l    $00080000>>n            * atnh(2^-13)
0000356C= 00010000                8929      dc.l    $00040000>>n            * atnh(2^-14)
00003570= 00008000                8930      dc.l    $00020000>>n            * atnh(2^-15)
00003574= 00004000                8931      dc.l    $00010000>>n            * atnh(2^-16)
00003578= 00002000                8932      dc.l    $00008000>>n            * atnh(2^-17)
0000357C= 00001000                8933      dc.l    $00004000>>n            * atnh(2^-18)
00003580= 00000800                8934      dc.l    $00002000>>n            * atnh(2^-19)
00003584= 00000400                8935      dc.l    $00001000>>n            * atnh(2^-20)
00003588= 00000200                8936      dc.l    $00000800>>n            * atnh(2^-21)
0000358C= 00000100                8937      dc.l    $00000400>>n            * atnh(2^-22)
00003590= 00000080                8938      dc.l    $00000200>>n            * atnh(2^-23)
00003594= 00000040                8939      dc.l    $00000100>>n            * atnh(2^-24)
00003598= 00000020                8940      dc.l    $00000080>>n            * atnh(2^-25)
0000359C= 00000010                8941      dc.l    $00000040>>n            * atnh(2^-26)
000035A0= 00000008                8942      dc.l    $00000020>>n            * atnh(2^-27)
000035A4= 00000004                8943      dc.l    $00000010>>n            * atnh(2^-28)
000035A8= 00000002                8944      dc.l    $00000008>>n            * atnh(2^-29)
000035AC= 00000001                8945      dc.l    $00000004>>n            * atnh(2^-30)
000035B0= 00000000                8946      dc.l    $00000002>>n            * atnh(2^-31)
000035B4= 00000000                8947      dc.l    $00000001>>n            * atnh(2^-32)
000035B8                          8948  
000035B8  =26A3D110               8949  KFCTSEED    equ $9A8F4441>>n        * $26A3D110
000035B8                          8950  
000035B8                          8951  
000035B8                          8952  *************************************************************************************
000035B8                          8953  *
000035B8                          8954  * command vector table
000035B8                          8955  
000035B8                          8956  LAB_CTBL
000035B8= D578                    8957      dc.w    LAB_END-LAB_CTBL            * END
000035BA= D4AC                    8958      dc.w    LAB_FOR-LAB_CTBL            * FOR
000035BC= DB18                    8959      dc.w    LAB_NEXT-LAB_CTBL           * NEXT
000035BE= D6CC                    8960      dc.w    LAB_DATA-LAB_CTBL           * DATA
000035C0= DA0C                    8961      dc.w    LAB_INPUT-LAB_CTBL      * INPUT
000035C2= DEF0                    8962      dc.w    LAB_DIM-LAB_CTBL            * DIM
000035C4= DA32                    8963      dc.w    LAB_READ-LAB_CTBL           * READ
000035C6= D83E                    8964      dc.w    LAB_LET-LAB_CTBL            * LET
000035C8= D7DC                    8965      dc.w    LAB_DEC-LAB_CTBL            * DEC   
000035CA= D634                    8966      dc.w    LAB_GOTO-LAB_CTBL           * GOTO
000035CC= D5FC                    8967      dc.w    LAB_RUN-LAB_CTBL            * RUN
000035CE= D6F4                    8968      dc.w    LAB_IF-LAB_CTBL         * IF
000035D0= D5A6                    8969      dc.w    LAB_RESTORE-LAB_CTBL        * RESTORE
000035D2= D622                    8970      dc.w    LAB_GOSUB-LAB_CTBL      * GOSUB
000035D4= D6B8                    8971      dc.w    LAB_RETURN-LAB_CTBL     * RETURN
000035D6= D762                    8972      dc.w    LAB_REM-LAB_CTBL            * REM
000035D8= D580                    8973      dc.w    LAB_STOP-LAB_CTBL           * STOP
000035DA= D76A                    8974      dc.w    LAB_ON-LAB_CTBL         * ON
000035DC= D5D4                    8975      dc.w    LAB_NULL-LAB_CTBL           * NULL
000035DE= D7E2                    8976      dc.w    LAB_INC-LAB_CTBL            * INC   
000035E0= E7F6                    8977      dc.w    LAB_WAIT-LAB_CTBL           * WAIT
000035E2= E7E4                    8978      dc.w    LAB_LOAD-LAB_CTBL           * LOAD
000035E4= E7E8                    8979      dc.w    LAB_SAVE-LAB_CTBL           * SAVE
000035E6= E280                    8980      dc.w    LAB_DEF-LAB_CTBL            * DEF
000035E8= E764                    8981      dc.w    LAB_POKE-LAB_CTBL           * POKE
000035EA= E794                    8982      dc.w    LAB_DOKE-LAB_CTBL           * DOKE
000035EC= E79A                    8983      dc.w    LAB_LOKE-LAB_CTBL           * LOKE
000035EE= E7EC                    8984      dc.w    LAB_CALL-LAB_CTBL           * CALL
000035F0= D610                    8985      dc.w    LAB_DO-LAB_CTBL         * DO    
000035F2= D662                    8986      dc.w    LAB_LOOP-LAB_CTBL           * LOOP
000035F4= D8D2                    8987      dc.w    LAB_PRINT-LAB_CTBL      * PRINT
000035F6= D5DE                    8988      dc.w    LAB_CONT-LAB_CTBL           * CONT
000035F8                          8989  
000035F8= EA2E                    8990      dc.w    LAB_BUFFER-LAB_CTBL     * BUFFER
000035FA= EA38                    8991      dc.w    LAB_CLS-LAB_CTBL            * CLS
000035FC= E9EA                    8992      dc.w    LAB_CURSOR-LAB_CTBL     * CURSOR
000035FE= E8F0                    8993      dc.w    LAB_LINE-LAB_CTBL           * LINE
00003600= E92C                    8994      dc.w    LAB_FILL-LAB_CTBL           * FILL
00003602= E91E                    8995      dc.w    LAB_MOVE-LAB_CTBL           * MOVE
00003604= E928                    8996      dc.w    LAB_POINT-LAB_CTBL      * POINT
00003606= E964                    8997      dc.w    LAB_RECT-LAB_CTBL           * RECT
00003608= E968                    8998      dc.w    LAB_FRECT-LAB_CTBL      * FRECT
0000360A= E96C                    8999      dc.w    LAB_ELLIPSE-LAB_CTBL        * ELLIPSE
0000360C= E970                    9000      dc.w    LAB_FELLIPSE-LAB_CTBL       * FELLIPSE
0000360E= E9CA                    9001      dc.w    LAB_MODE-LAB_CTBL           * MODE
00003610= E9DE                    9002      dc.w    LAB_SIZE-LAB_CTBL           * SIZE
00003612                          9003  
00003612= D3F6                    9004      dc.w    LAB_LIST-LAB_CTBL           * LIST
00003614= D3F2                    9005      dc.w    LAB_CLEAR-LAB_CTBL      * CLEAR
00003616= D3A2                    9006      dc.w    LAB_NEW-LAB_CTBL            * NEW
00003618= F954                    9007      dc.w    LAB_WDTH-LAB_CTBL           * WIDTH
0000361A= D898                    9008      dc.w    LAB_GET-LAB_CTBL            * GET
0000361C= E7AE                    9009      dc.w    LAB_SWAP-LAB_CTBL           * SWAP
0000361E= F49E                    9010      dc.w    LAB_BITSET-LAB_CTBL     * BITSET
00003620= F4AE                    9011      dc.w    LAB_BITCLR-LAB_CTBL     * BITCLR
00003622                          9012  
00003622                          9013  
00003622                          9014  *************************************************************************************
00003622                          9015  *
00003622                          9016  * function pre process routine table
00003622                          9017  
00003622                          9018  LAB_FTPP
00003622= DD84                    9019      dc.w    LAB_PPFN-LAB_FTPP           * SGN(n)    process numeric expression in ()
00003624= DD84                    9020      dc.w    LAB_PPFN-LAB_FTPP           * INT(n)        "
00003626= DD84                    9021      dc.w    LAB_PPFN-LAB_FTPP           * ABS(n)        "
00003628= DB7E                    9022      dc.w    LAB_EVEZ-LAB_FTPP           * USR(x)    process any expression
0000362A= DCC6                    9023      dc.w    LAB_1BF7-LAB_FTPP           * FRE(x)    process any expression in ()
0000362C= DCC6                    9024      dc.w    LAB_1BF7-LAB_FTPP           * POS(x)        "
0000362E= DD84                    9025      dc.w    LAB_PPFN-LAB_FTPP           * SQR(n)    process numeric expression in ()
00003630= DD84                    9026      dc.w    LAB_PPFN-LAB_FTPP           * RND(n)        "
00003632= DD84                    9027      dc.w    LAB_PPFN-LAB_FTPP           * LOG(n)        "
00003634= DD84                    9028      dc.w    LAB_PPFN-LAB_FTPP           * EXP(n)        "
00003636= DD84                    9029      dc.w    LAB_PPFN-LAB_FTPP           * COS(n)        "
00003638= DD84                    9030      dc.w    LAB_PPFN-LAB_FTPP           * SIN(n)        "
0000363A= DD84                    9031      dc.w    LAB_PPFN-LAB_FTPP           * TAN(n)        "
0000363C= DD84                    9032      dc.w    LAB_PPFN-LAB_FTPP           * ATN(n)        "
0000363E= DD84                    9033      dc.w    LAB_PPFN-LAB_FTPP           * PEEK(n)       "
00003640= DD84                    9034      dc.w    LAB_PPFN-LAB_FTPP           * DEEK(n)       "
00003642= DD84                    9035      dc.w    LAB_PPFN-LAB_FTPP           * LEEK(n)       "
00003644= DD76                    9036      dc.w    LAB_PPFS-LAB_FTPP           * LEN($)    process string expression in ()
00003646= DD84                    9037      dc.w    LAB_PPFN-LAB_FTPP           * STR$(n)   process numeric expression in ()
00003648= DD76                    9038      dc.w    LAB_PPFS-LAB_FTPP           * VAL($)    process string expression in ()
0000364A= DD76                    9039      dc.w    LAB_PPFS-LAB_FTPP           * ASC($)        "
0000364C= DD76                    9040      dc.w    LAB_PPFS-LAB_FTPP           * UCASE$($)     "
0000364E= DD76                    9041      dc.w    LAB_PPFS-LAB_FTPP           * LCASE$($)     "
00003650= DD84                    9042      dc.w    LAB_PPFN-LAB_FTPP           * CHR$(n)   process numeric expression in ()
00003652= DDBE                    9043      dc.w    LAB_BHSS-LAB_FTPP           * HEX$()    bin/hex pre process
00003654= DDBE                    9044      dc.w    LAB_BHSS-LAB_FTPP           * BIN$()        "
00003656= 0000                    9045      dc.w    $0000                   * BITTST()  none
00003658= 0000                    9046      dc.w    $0000                   * MAX()     "
0000365A= 0000                    9047      dc.w    $0000                   * MIN()     "
0000365C= DD92                    9048      dc.w    LAB_PPBI-LAB_FTPP           * RAMBASE   advance pointer
0000365E= DCC6                    9049      dc.w    LAB_1BF7-LAB_FTPP           * KEYS(x)   process any expression in ()
00003660= DD92                    9050      dc.w    LAB_PPBI-LAB_FTPP           * TI        advance pointer
00003662= DD92                    9051      dc.w    LAB_PPBI-LAB_FTPP           * PI            "
00003664= DD92                    9052      dc.w    LAB_PPBI-LAB_FTPP           * TWOPI     "
00003666= 0000                    9053      dc.w    $0000                   * VARPTR()  none
00003668= 0000                    9054      dc.w    $0000                   * SADD()        "
0000366A= DD9C                    9055      dc.w    LAB_LRMS-LAB_FTPP           * LEFT$()   process string expression
0000366C= DD9C                    9056      dc.w    LAB_LRMS-LAB_FTPP           * RIGHT$()      "
0000366E= DD9C                    9057      dc.w    LAB_LRMS-LAB_FTPP           * MID$()        "
00003670= DB7E                    9058      dc.w    LAB_EVEZ-LAB_FTPP           * USING$(x) process any expression
00003672                          9059  
00003672                          9060  
00003672                          9061  *************************************************************************************
00003672                          9062  *
00003672                          9063  * action addresses for functions
00003672                          9064  
00003672                          9065  LAB_FTBL
00003672= ED34                    9066      dc.w    LAB_SGN-LAB_FTBL            * SGN()
00003674= EDB8                    9067      dc.w    LAB_INT-LAB_FTBL            * INT()
00003676= ED46                    9068      dc.w    LAB_ABS-LAB_FTBL            * ABS()
00003678= E722                    9069      dc.w    LAB_USR-LAB_FTBL            * USR()
0000367A= E17E                    9070      dc.w    LAB_FRE-LAB_FTBL            * FRE()
0000367C= E1B0                    9071      dc.w    LAB_POS-LAB_FTBL            * POS()
0000367E= F91A                    9072      dc.w    LAB_SQR-LAB_FTBL            * SQR()
00003680= F200                    9073      dc.w    LAB_RND-LAB_FTBL            * RND()
00003682= EA56                    9074      dc.w    LAB_LOG-LAB_FTBL            * LOG()
00003684= F0E6                    9075      dc.w    LAB_EXP-LAB_FTBL            * EXP()
00003686= F254                    9076      dc.w    LAB_COS-LAB_FTBL            * COS()
00003688= F26C                    9077      dc.w    LAB_SIN-LAB_FTBL            * SIN()
0000368A= F232                    9078      dc.w    LAB_TAN-LAB_FTBL            * TAN()
0000368C= F332                    9079      dc.w    LAB_ATN-LAB_FTBL            * ATN()
0000368E= E69E                    9080      dc.w    LAB_PEEK-LAB_FTBL           * PEEK()
00003690= E6B0                    9081      dc.w    LAB_DEEK-LAB_FTBL           * DEEK()
00003692= E6C6                    9082      dc.w    LAB_LEEK-LAB_FTBL           * LEEK()
00003694= E5E2                    9083      dc.w    LAB_LENS-LAB_FTBL           * LEN()
00003696= E2A6                    9084      dc.w    LAB_STRS-LAB_FTBL           * STR$()
00003698= E626                    9085      dc.w    LAB_VAL-LAB_FTBL            * VAL()
0000369A= E5EA                    9086      dc.w    LAB_ASC-LAB_FTBL            * ASC()
0000369C= E598                    9087      dc.w    LAB_UCASE-LAB_FTBL      * UCASE$()
0000369E= E568                    9088      dc.w    LAB_LCASE-LAB_FTBL      * LCASE$()
000036A0= E4D0                    9089      dc.w    LAB_CHRS-LAB_FTBL           * CHR$()
000036A2= F7BC                    9090      dc.w    LAB_HEXS-LAB_FTBL           * HEX$()
000036A4= F76A                    9091      dc.w    LAB_BINS-LAB_FTBL           * BIN$()
000036A6= F404                    9092      dc.w    LAB_BTST-LAB_FTBL           * BITTST()
000036A8= F828                    9093      dc.w    LAB_MAX-LAB_FTBL            * MAX()
000036AA= F83E                    9094      dc.w    LAB_MIN-LAB_FTBL            * MIN()
000036AC= F98C                    9095      dc.w    LAB_RAM-LAB_FTBL            * RAMBASE
000036AE= E772                    9096      dc.w    LAB_KEYS-LAB_FTBL           * KEYS()
000036B0= E760                    9097      dc.w    LAB_TI-LAB_FTBL         * TI
000036B2= F996                    9098      dc.w    LAB_PI-LAB_FTBL         * PI
000036B4= F9A6                    9099      dc.w    LAB_TWOPI-LAB_FTBL      * TWOPI
000036B6= F97C                    9100      dc.w    LAB_VARPTR-LAB_FTBL     * VARPTR()
000036B8= E5CA                    9101      dc.w    LAB_SADD-LAB_FTBL           * SADD()
000036BA= E4E0                    9102      dc.w    LAB_LEFT-LAB_FTBL           * LEFT$()
000036BC= E4F4                    9103      dc.w    LAB_RIGHT-LAB_FTBL      * RIGHT$()
000036BE= E524                    9104      dc.w    LAB_MIDS-LAB_FTBL           * MID$()
000036C0= F432                    9105      dc.w    LAB_USINGS-LAB_FTBL     * USING$()
000036C2                          9106  
000036C2                          9107  
000036C2                          9108  *************************************************************************************
000036C2                          9109  *
000036C2                          9110  * hierarchy and action addresses for operator
000036C2                          9111  
000036C2                          9112  LAB_OPPT
000036C2= 0079                    9113      dc.w    $0079                   * +
000036C4= E954                    9114      dc.w    LAB_ADD-LAB_OPPT
000036C6= 0079                    9115      dc.w    $0079                   * -
000036C8= E940                    9116      dc.w    LAB_SUBTRACT-LAB_OPPT
000036CA= 007B                    9117      dc.w    $007B                   * *
000036CC= EAF8                    9118      dc.w    LAB_MULTIPLY-LAB_OPPT
000036CE= 007B                    9119      dc.w    $007B                   * /
000036D0= EB84                    9120      dc.w    LAB_DIVIDE-LAB_OPPT
000036D2= 007F                    9121      dc.w    $007F                   * ^
000036D4= EFE0                    9122      dc.w    LAB_POWER-LAB_OPPT
000036D6= 0050                    9123      dc.w    $0050                   * AND
000036D8= DD5E                    9124      dc.w    LAB_AND-LAB_OPPT
000036DA= 0046                    9125      dc.w    $0046                   * EOR
000036DC= DD4E                    9126      dc.w    LAB_EOR-LAB_OPPT
000036DE= 0046                    9127      dc.w    $0046                   * OR
000036E0= DD56                    9128      dc.w    LAB_OR-LAB_OPPT
000036E2= 0056                    9129      dc.w    $0056                   * >>
000036E4= DE02                    9130      dc.w    LAB_RSHIFT-LAB_OPPT
000036E6= 0056                    9131      dc.w    $0056                   * <<
000036E8= DDF2                    9132      dc.w    LAB_LSHIFT-LAB_OPPT
000036EA= 007D                    9133      dc.w    $007D                   * >
000036EC= F044                    9134      dc.w    LAB_GTHAN-LAB_OPPT      * used to evaluate -n
000036EE= 005A                    9135      dc.w    $005A                   * =
000036F0= DD74                    9136      dc.w    LAB_EQUAL-LAB_OPPT      * used to evaluate NOT
000036F2= 0064                    9137      dc.w    $0064                   * <
000036F4= DD7E                    9138      dc.w    LAB_LTHAN-LAB_OPPT
000036F6                          9139  
000036F6                          9140  
000036F6                          9141  *************************************************************************************
000036F6                          9142  *
000036F6                          9143  * misc constants
000036F6                          9144  
000036F6                          9145  * This table is used in converting numbers to ASCII.
000036F6                          9146  
000036F6                          9147  LAB_2A9A
000036F6= FFF0BDC0                9148      dc.l    $FFF0BDC0               * -1000000
000036FA= 000186A0                9149      dc.l    $000186A0               * 100000
000036FE= FFFFD8F0                9150      dc.l    $FFFFD8F0               * -10000
00003702= 000003E8                9151      dc.l    $000003E8               * 1000
00003706= FFFFFF9C                9152      dc.l    $FFFFFF9C               * -100
0000370A= 0000000A                9153      dc.l    $0000000A               * 10
0000370E= FFFFFFFF                9154      dc.l    $FFFFFFFF               * -1
00003712                          9155  LAB_2A9B
00003712                          9156  
00003712                          9157  
00003712                          9158  *************************************************************************************
00003712                          9159  *
00003712                          9160  * new keyword tables
00003712                          9161  
00003712                          9162  * offsets to keyword tables
00003712                          9163  
00003712                          9164  TAB_CHRT
00003712= 0000                    9165      dc.w    TAB_STAR-TAB_STAR           * "*"   $2A
00003714= 0002                    9166      dc.w    TAB_PLUS-TAB_STAR           * "+"   $2B
00003716= FFFF                    9167      dc.w    -1                  * "," $2C no keywords
00003718= 0004                    9168      dc.w    TAB_MNUS-TAB_STAR           * "-"   $2D
0000371A= FFFF                    9169      dc.w    -1                  * "." $2E no keywords
0000371C= 0006                    9170      dc.w    TAB_SLAS-TAB_STAR           * "/"   $2F
0000371E= FFFF                    9171      dc.w    -1                  * "0" $30 no keywords
00003720= FFFF                    9172      dc.w    -1                  * "1" $31 no keywords
00003722= FFFF                    9173      dc.w    -1                  * "2" $32 no keywords
00003724= FFFF                    9174      dc.w    -1                  * "3" $33 no keywords
00003726= FFFF                    9175      dc.w    -1                  * "4" $34 no keywords
00003728= FFFF                    9176      dc.w    -1                  * "5" $35 no keywords
0000372A= FFFF                    9177      dc.w    -1                  * "6" $36 no keywords
0000372C= FFFF                    9178      dc.w    -1                  * "7" $37 no keywords
0000372E= FFFF                    9179      dc.w    -1                  * "8" $38 no keywords
00003730= FFFF                    9180      dc.w    -1                  * "9" $39 no keywords
00003732= FFFF                    9181      dc.w    -1                  * ";" $3A no keywords
00003734= FFFF                    9182      dc.w    -1                  * ":" $3B no keywords
00003736= 0008                    9183      dc.w    TAB_LESS-TAB_STAR           * "<"   $3C
00003738= 000C                    9184      dc.w    TAB_EQUL-TAB_STAR           * "="   $3D
0000373A= 000E                    9185      dc.w    TAB_MORE-TAB_STAR           * ">"   $3E
0000373C= 0012                    9186      dc.w    TAB_QEST-TAB_STAR           * "?"   $3F
0000373E= FFFF                    9187      dc.w    -1                  * "@" $40 no keywords
00003740= 0014                    9188      dc.w    TAB_ASCA-TAB_STAR           * "A"   $41
00003742= 0024                    9189      dc.w    TAB_ASCB-TAB_STAR           * "B"   $42
00003744= 0043                    9190      dc.w    TAB_ASCC-TAB_STAR           * "C"   $43
00003746= 0063                    9191      dc.w    TAB_ASCD-TAB_STAR           * "D"   $44
00003748= 007C                    9192      dc.w    TAB_ASCE-TAB_STAR           * "E"   $45
0000374A= 009A                    9193      dc.w    TAB_ASCF-TAB_STAR           * "F"   $46
0000374C= 00A8                    9194      dc.w    TAB_ASCG-TAB_STAR           * "G"   $47
0000374E= 00B5                    9195      dc.w    TAB_ASCH-TAB_STAR           * "H"   $48
00003750= 00BB                    9196      dc.w    TAB_ASCI-TAB_STAR           * "I"   $49
00003752= FFFF                    9197      dc.w    -1                  * "J" $4A no keywords
00003754= 00CA                    9198      dc.w    TAB_ASCK-TAB_STAR           * "K" $4B
00003756= 00D0                    9199      dc.w    TAB_ASCL-TAB_STAR           * "L"   $4C
00003758= 0102                    9200      dc.w    TAB_ASCM-TAB_STAR           * "M"   $4D
0000375A= 0118                    9201      dc.w    TAB_ASCN-TAB_STAR           * "N"   $4E
0000375C= 0127                    9202      dc.w    TAB_ASCO-TAB_STAR           * "O"   $4F
0000375E= 012C                    9203      dc.w    TAB_ASCP-TAB_STAR           * "P"   $50
00003760= FFFF                    9204      dc.w    -1                  * "Q" $51 no keywords
00003762= 0146                    9205      dc.w    TAB_ASCR-TAB_STAR           * "R"   $52
00003764= 0179                    9206      dc.w    TAB_ASCS-TAB_STAR           * "S"   $53
00003766= 01A8                    9207      dc.w    TAB_ASCT-TAB_STAR           * "T"   $54
00003768= 01BE                    9208      dc.w    TAB_ASCU-TAB_STAR           * "U"   $55
0000376A= 01D6                    9209      dc.w    TAB_ASCV-TAB_STAR           * "V"   $56
0000376C= 01E2                    9210      dc.w    TAB_ASCW-TAB_STAR           * "W"   $57
0000376E= FFFF                    9211      dc.w    -1                  * "X" $58 no keywords
00003770= FFFF                    9212      dc.w    -1                  * "Y" $59 no keywords
00003772= FFFF                    9213      dc.w    -1                  * "Z" $5A no keywords
00003774= FFFF                    9214      dc.w    -1                  * "[" $5B no keywords
00003776= FFFF                    9215      dc.w    -1                  * "\" $5C no keywords
00003778= FFFF                    9216      dc.w    -1                  * "]" $5D no keywords
0000377A= 01F1                    9217      dc.w    TAB_POWR-TAB_STAR           * "^"   $5E
0000377C                          9218  
0000377C                          9219  
0000377C                          9220  *************************************************************************************
0000377C                          9221  *
0000377C                          9222  * Table of Basic keywords for LIST command
0000377C                          9223  * [byte]first character,[byte]remaining length -1
0000377C                          9224  * [word]offset from table start
0000377C                          9225  
0000377C                          9226  LAB_KEYT
0000377C= 45 01                   9227      dc.b    'E',1
0000377E= 0080                    9228      dc.w    KEY_END-TAB_STAR            * END
00003780= 46 01                   9229      dc.b    'F',1
00003782= 009E                    9230      dc.w    KEY_FOR-TAB_STAR            * FOR
00003784= 4E 02                   9231      dc.b    'N',2
00003786= 011B                    9232      dc.w    KEY_NEXT-TAB_STAR           * NEXT
00003788= 44 02                   9233      dc.b    'D',2
0000378A= 0063                    9234      dc.w    KEY_DATA-TAB_STAR           * DATA
0000378C= 49 03                   9235      dc.b    'I',3
0000378E= 00C0                    9236      dc.w    KEY_INPUT-TAB_STAR      * INPUT
00003790= 44 01                   9237      dc.b    'D',1
00003792= 0072                    9238      dc.w    KEY_DIM-TAB_STAR            * DIM
00003794= 52 02                   9239      dc.b    'R',2
00003796= 014D                    9240      dc.w    KEY_READ-TAB_STAR           * READ
00003798= 4C 01                   9241      dc.b    'L',1
0000379A= 00E6                    9242      dc.w    KEY_LET-TAB_STAR            * LET
0000379C= 44 01                   9243      dc.b    'D',1
0000379E= 0067                    9244      dc.w    KEY_DEC-TAB_STAR            * DEC
000037A0= 47 02                   9245      dc.b    'G',2
000037A2= 00AB                    9246      dc.w    KEY_GOTO-TAB_STAR           * GOTO
000037A4= 52 01                   9247      dc.b    'R',1
000037A6= 0175                    9248      dc.w    KEY_RUN-TAB_STAR            * RUN
000037A8= 49 00                   9249      dc.b    'I',0
000037AA= 00BB                    9250      dc.w    KEY_IF-TAB_STAR         * IF
000037AC= 52 05                   9251      dc.b    'R',5
000037AE= 015D                    9252      dc.w    KEY_RESTORE-TAB_STAR        * RESTORE
000037B0= 47 03                   9253      dc.b    'G',3
000037B2= 00AF                    9254      dc.w    KEY_GOSUB-TAB_STAR      * GOSUB
000037B4= 52 04                   9255      dc.b    'R',4
000037B6= 0164                    9256      dc.w    KEY_RETURN-TAB_STAR     * RETURN
000037B8= 52 01                   9257      dc.b    'R',1
000037BA= 015A                    9258      dc.w    KEY_REM-TAB_STAR            * REM
000037BC= 53 02                   9259      dc.b    'S',2
000037BE= 019A                    9260      dc.w    KEY_STOP-TAB_STAR           * STOP
000037C0= 4F 00                   9261      dc.b    'O',0
000037C2= 0127                    9262      dc.w    KEY_ON-TAB_STAR         * ON
000037C4= 4E 02                   9263      dc.b    'N',2
000037C6= 0122                    9264      dc.w    KEY_NULL-TAB_STAR           * NULL
000037C8= 49 01                   9265      dc.b    'I',1
000037CA= 00BD                    9266      dc.w    KEY_INC-TAB_STAR            * INC
000037CC= 57 02                   9267      dc.b    'W',2
000037CE= 01E2                    9268      dc.w    KEY_WAIT-TAB_STAR           * WAIT
000037D0= 4C 02                   9269      dc.b    'L',2
000037D2= 00F1                    9270      dc.w    KEY_LOAD-TAB_STAR           * LOAD
000037D4= 53 02                   9271      dc.b    'S',2
000037D6= 017E                    9272      dc.w    KEY_SAVE-TAB_STAR           * SAVE
000037D8= 44 01                   9273      dc.b    'D',1
000037DA= 006F                    9274      dc.w    KEY_DEF-TAB_STAR            * DEF
000037DC= 50 02                   9275      dc.b    'P',2
000037DE= 0138                    9276      dc.w    KEY_POKE-TAB_STAR           * POKE
000037E0= 44 02                   9277      dc.b    'D',2
000037E2= 0075                    9278      dc.w    KEY_DOKE-TAB_STAR           * DOKE
000037E4= 4C 02                   9279      dc.b    'L',2
000037E6= 00F9                    9280      dc.w    KEY_LOKE-TAB_STAR           * LOKE
000037E8= 43 02                   9281      dc.b    'C',2
000037EA= 0043                    9282      dc.w    KEY_CALL-TAB_STAR           * CALL
000037EC= 44 00                   9283      dc.b    'D',0
000037EE= 0079                    9284      dc.w    KEY_DO-TAB_STAR         * DO
000037F0= 4C 02                   9285      dc.b    'L',2
000037F2= 00FD                    9286      dc.w    KEY_LOOP-TAB_STAR           * LOOP
000037F4= 50 03                   9287      dc.b    'P',3
000037F6= 0140                    9288      dc.w    KEY_PRINT-TAB_STAR      * PRINT
000037F8= 43 02                   9289      dc.b    'C',2
000037FA= 0054                    9290      dc.w    KEY_CONT-TAB_STAR           * CONT
000037FC                          9291  
000037FC= 42 04                   9292      dc.b    'B',4
000037FE= 003C                    9293      dc.w    KEY_BUFFER-TAB_STAR     * BUFFER
00003800= 43 01                   9294      dc.b    'C',1
00003802= 0051                    9295      dc.w    KEY_CLS-TAB_STAR            * CLS
00003804= 43 04                   9296      dc.b    'C',4
00003806= 005C                    9297      dc.w    KEY_CURSOR-TAB_STAR     * CURSOR
00003808= 4C 02                   9298      dc.b    'L',2
0000380A= 00E9                    9299      dc.w    KEY_LINE-TAB_STAR           * LINE
0000380C= 46 02                   9300      dc.b    'F',2
0000380E= 009A                    9301      dc.w    KEY_FILL-TAB_STAR           * FILL
00003810= 4D 02                   9302      dc.b    'M',2
00003812= 0113                    9303      dc.w    KEY_MOVE-TAB_STAR           * MOVE
00003814= 50 03                   9304      dc.b    'P',3
00003816= 0133                    9305      dc.w    KEY_POINT-TAB_STAR      * POINT
00003818= 52 02                   9306      dc.b    'R',2
0000381A= 0156                    9307      dc.w    KEY_RECT-TAB_STAR           * RECT
0000381C= 52 03                   9308      dc.b    'R',3
0000381E= 0151                    9309      dc.w    KEY_FRECT-TAB_STAR      * RECTF
00003820= 45 05                   9310      dc.b    'E',5
00003822= 008B                    9311      dc.w    KEY_ELLIPSE-TAB_STAR        * ELLIPSE
00003824= 45 06                   9312      dc.b    'E',6
00003826= 0083                    9313      dc.w    KEY_FELLIPSE-TAB_STAR       * ELLIPSEF
00003828= 4D 02                   9314      dc.b    'M',2
0000382A= 010F                    9315      dc.w    KEY_MODE-TAB_STAR           * MODE
0000382C= 53 02                   9316      dc.b    'S',2
0000382E= 018A                    9317      dc.w    KEY_SIZE-TAB_STAR           * SIZE
00003830                          9318  
00003830= 4C 02                   9319      dc.b    'L',2
00003832= 00ED                    9320      dc.w    KEY_LIST-TAB_STAR           * LIST
00003834= 43 03                   9321      dc.b    'C',3
00003836= 004C                    9322      dc.w    KEY_CLEAR-TAB_STAR      * CLEAR
00003838= 4E 01                   9323      dc.b    'N',1
0000383A= 0118                    9324      dc.w    KEY_NEW-TAB_STAR            * NEW
0000383C= 57 03                   9325      dc.b    'W',3
0000383E= 01EB                    9326      dc.w    KEY_WIDTH-TAB_STAR      * WIDTH
00003840= 47 01                   9327      dc.b    'G',1
00003842= 00A8                    9328      dc.w    KEY_GET-TAB_STAR            * GET
00003844= 53 02                   9329      dc.b    'S',2
00003846= 01A3                    9330      dc.w    KEY_SWAP-TAB_STAR           * SWAP
00003848= 42 04                   9331      dc.b    'B',4
0000384A= 002F                    9332      dc.w    KEY_BITSET-TAB_STAR     * BITSET
0000384C= 42 04                   9333      dc.b    'B',4
0000384E= 0029                    9334      dc.w    KEY_BITCLR-TAB_STAR     * BITCLR
00003850= 54 02                   9335      dc.b    'T',2
00003852= 01A8                    9336      dc.w    KEY_TAB-TAB_STAR            * TAB(
00003854= 45 02                   9337      dc.b    'E',2
00003856= 007C                    9338      dc.w    KEY_ELSE-TAB_STAR           * ELSE
00003858= 54 00                   9339      dc.b    'T',0
0000385A= 01B6                    9340      dc.w    KEY_TO-TAB_STAR         * TO
0000385C= 46 00                   9341      dc.b    'F',0
0000385E= 00A1                    9342      dc.w    KEY_FN-TAB_STAR         * FN
00003860= 53 02                   9343      dc.b    'S',2
00003862= 018E                    9344      dc.w    KEY_SPC-TAB_STAR            * SPC(
00003864= 54 02                   9345      dc.b    'T',2
00003866= 01B0                    9346      dc.w    KEY_THEN-TAB_STAR           * THEN
00003868= 4E 01                   9347      dc.b    'N',1
0000386A= 011F                    9348      dc.w    KEY_NOT-TAB_STAR            * NOT
0000386C= 53 02                   9349      dc.b    'S',2
0000386E= 0196                    9350      dc.w    KEY_STEP-TAB_STAR           * STEP
00003870= 55 03                   9351      dc.b    'U',3
00003872= 01C5                    9352      dc.w    KEY_UNTIL-TAB_STAR      * UNTIL
00003874= 57 03                   9353      dc.b    'W',3
00003876= 01E6                    9354      dc.w    KEY_WHILE-TAB_STAR      * WHILE
00003878                          9355  
00003878= 2B FF                   9356      dc.b    '+',-1
0000387A= 0002                    9357      dc.w    KEY_PLUS-TAB_STAR           * +
0000387C= 2D FF                   9358      dc.b    '-',-1
0000387E= 0004                    9359      dc.w    KEY_MINUS-TAB_STAR      * -
00003880= 2A FF                   9360      dc.b    '*',-1
00003882= 0000                    9361      dc.w    KEY_MULT-TAB_STAR           * *
00003884= 2F FF                   9362      dc.b    '/',-1
00003886= 0006                    9363      dc.w    KEY_DIV-TAB_STAR            * /
00003888= 5E FF                   9364      dc.b    '^',-1
0000388A= 01F1                    9365      dc.w    KEY_POWER-TAB_STAR      * ^
0000388C= 41 01                   9366      dc.b    'A',1
0000388E= 0018                    9367      dc.w    KEY_AND-TAB_STAR            * AND
00003890= 45 01                   9368      dc.b    'E',1
00003892= 0092                    9369      dc.w    KEY_EOR-TAB_STAR            * EOR
00003894= 4F 00                   9370      dc.b    'O',0
00003896= 0129                    9371      dc.w    KEY_OR-TAB_STAR         * OR
00003898= 3E 00                   9372      dc.b    '>',0
0000389A= 000E                    9373      dc.w    KEY_RSHIFT-TAB_STAR     * >>
0000389C= 3C 00                   9374      dc.b    '<',0
0000389E= 0008                    9375      dc.w    KEY_LSHIFT-TAB_STAR     * <<
000038A0= 3E FF                   9376      dc.b    '>',-1
000038A2= 0010                    9377      dc.w    KEY_GT-TAB_STAR         * >
000038A4= 3D FF                   9378      dc.b    '=',-1
000038A6= 000C                    9379      dc.w    KEY_EQUAL-TAB_STAR      * =
000038A8= 3C FF                   9380      dc.b    '<',-1
000038AA= 000A                    9381      dc.w    KEY_LT-TAB_STAR         * <
000038AC                          9382  
000038AC= 53 02                   9383      dc.b    'S',2
000038AE= 0182                    9384      dc.w    KEY_SGN-TAB_STAR            * SGN(
000038B0= 49 02                   9385      dc.b    'I',2
000038B2= 00C5                    9386      dc.w    KEY_INT-TAB_STAR            * INT(
000038B4= 41 02                   9387      dc.b    'A',2
000038B6= 0014                    9388      dc.w    KEY_ABS-TAB_STAR            * ABS(
000038B8= 55 02                   9389      dc.b    'U',2
000038BA= 01D1                    9390      dc.w    KEY_USR-TAB_STAR            * USR(
000038BC= 46 02                   9391      dc.b    'F',2
000038BE= 00A3                    9392      dc.w    KEY_FRE-TAB_STAR            * FRE(
000038C0= 50 02                   9393      dc.b    'P',2
000038C2= 013C                    9394      dc.w    KEY_POS-TAB_STAR            * POS(
000038C4= 53 02                   9395      dc.b    'S',2
000038C6= 0192                    9396      dc.w    KEY_SQR-TAB_STAR            * SQR(
000038C8= 52 02                   9397      dc.b    'R',2
000038CA= 0171                    9398      dc.w    KEY_RND-TAB_STAR            * RND(
000038CC= 4C 02                   9399      dc.b    'L',2
000038CE= 00F5                    9400      dc.w    KEY_LOG-TAB_STAR            * LOG(
000038D0= 45 02                   9401      dc.b    'E',2
000038D2= 0095                    9402      dc.w    KEY_EXP-TAB_STAR            * EXP(
000038D4= 43 02                   9403      dc.b    'C',2
000038D6= 0058                    9404      dc.w    KEY_COS-TAB_STAR            * COS(
000038D8= 53 02                   9405      dc.b    'S',2
000038DA= 0186                    9406      dc.w    KEY_SIN-TAB_STAR            * SIN(
000038DC= 54 02                   9407      dc.b    'T',2
000038DE= 01AC                    9408      dc.w    KEY_TAN-TAB_STAR            * TAN(
000038E0= 41 02                   9409      dc.b    'A',2
000038E2= 001F                    9410      dc.w    KEY_ATN-TAB_STAR            * ATN(
000038E4= 50 03                   9411      dc.b    'P',3
000038E6= 012C                    9412      dc.w    KEY_PEEK-TAB_STAR           * PEEK(
000038E8= 44 03                   9413      dc.b    'D',3
000038EA= 006A                    9414      dc.w    KEY_DEEK-TAB_STAR           * DEEK(
000038EC= 4C 03                   9415      dc.b    'L',3
000038EE= 00D7                    9416      dc.w    KEY_LEEK-TAB_STAR           * LEEK(
000038F0= 4C 02                   9417      dc.b    'L',2
000038F2= 00E2                    9418      dc.w    KEY_LEN-TAB_STAR            * LEN(
000038F4= 53 03                   9419      dc.b    'S',3
000038F6= 019E                    9420      dc.w    KEY_STRS-TAB_STAR           * STR$(
000038F8= 56 02                   9421      dc.b    'V',2
000038FA= 01D6                    9422      dc.w    KEY_VAL-TAB_STAR            * VAL(
000038FC= 41 02                   9423      dc.b    'A',2
000038FE= 001B                    9424      dc.w    KEY_ASC-TAB_STAR            * ASC(
00003900= 55 05                   9425      dc.b    'U',5
00003902= 01BE                    9426      dc.w    KEY_UCASES-TAB_STAR     * UCASE$(
00003904= 4C 05                   9427      dc.b    'L',5
00003906= 00D0                    9428      dc.w    KEY_LCASES-TAB_STAR     * LCASE$(
00003908= 43 03                   9429      dc.b    'C',3
0000390A= 0047                    9430      dc.w    KEY_CHRS-TAB_STAR           * CHR$(
0000390C= 48 03                   9431      dc.b    'H',3
0000390E= 00B5                    9432      dc.w    KEY_HEXS-TAB_STAR           * HEX$(
00003910= 42 03                   9433      dc.b    'B',3
00003912= 0024                    9434      dc.w    KEY_BINS-TAB_STAR           * BIN$(
00003914= 42 05                   9435      dc.b    'B',5
00003916= 0035                    9436      dc.w    KEY_BITTST-TAB_STAR     * BITTST(
00003918= 4D 02                   9437      dc.b    'M',2
0000391A= 0102                    9438      dc.w    KEY_MAX-TAB_STAR            * MAX(
0000391C= 4D 02                   9439      dc.b    'M',2
0000391E= 010B                    9440      dc.w    KEY_MIN-TAB_STAR            * MIN(
00003920= 52 05                   9441      dc.b    'R',5
00003922= 0146                    9442      dc.w    KEY_RAM-TAB_STAR            * RAMBASE
00003924= 4B 03                   9443      dc.b    'K',3
00003926= 00CA                    9444      dc.w    KEY_KEYS-TAB_STAR           * KEYS(
00003928= 54 00                   9445      dc.b    'T',0
0000392A= 01B4                    9446      dc.w    KEY_TI-TAB_STAR         * TI
0000392C= 50 00                   9447      dc.b    'P',0
0000392E= 0131                    9448      dc.w    KEY_PI-TAB_STAR         * PI
00003930= 54 03                   9449      dc.b    'T',3
00003932= 01B8                    9450      dc.w    KEY_TWOPI-TAB_STAR      * TWOPI
00003934= 56 05                   9451      dc.b    'V',5
00003936= 01DA                    9452      dc.w    KEY_VPTR-TAB_STAR           * VARPTR(
00003938= 53 03                   9453      dc.b    'S',3
0000393A= 0179                    9454      dc.w    KEY_SADD-TAB_STAR           * SADD(
0000393C= 4C 04                   9455      dc.b    'L',4
0000393E= 00DC                    9456      dc.w    KEY_LEFTS-TAB_STAR      * LEFT$(
00003940= 52 05                   9457      dc.b    'R',5
00003942= 016A                    9458      dc.w    KEY_RIGHTS-TAB_STAR     * RIGHT$(
00003944= 4D 03                   9459      dc.b    'M',3
00003946= 0106                    9460      dc.w    KEY_MIDS-TAB_STAR           * MID$(
00003948= 55 05                   9461      dc.b    'U',5
0000394A= 01CA                    9462      dc.w    KEY_USINGS-TAB_STAR     * USING$(
0000394C                          9463  
0000394C                          9464  
0000394C                          9465  *************************************************************************************
0000394C                          9466  *
0000394C                          9467  * BASIC error messages
0000394C                          9468  
0000394C                          9469  LAB_BAER
0000394C= 002E                    9470      dc.w    LAB_NF-LAB_BAER         * $00 NEXT without FOR
0000394E= 003F                    9471      dc.w    LAB_SN-LAB_BAER         * $02 syntax
00003950= 0046                    9472      dc.w    LAB_RG-LAB_BAER         * $04 RETURN without GOSUB
00003952= 005B                    9473      dc.w    LAB_OD-LAB_BAER         * $06 out of data
00003954= 0067                    9474      dc.w    LAB_FC-LAB_BAER         * $08 function call
00003956= 0075                    9475      dc.w    LAB_OV-LAB_BAER         * $0A overflow
00003958= 007E                    9476      dc.w    LAB_OM-LAB_BAER         * $0C out of memory
0000395A= 008C                    9477      dc.w    LAB_US-LAB_BAER         * $0E undefined statement
0000395C= 00A0                    9478      dc.w    LAB_BS-LAB_BAER         * $10 array bounds
0000395E= 00AD                    9479      dc.w    LAB_DD-LAB_BAER         * $12 double dimension array
00003960= 00BE                    9480      dc.w    LAB_D0-LAB_BAER         * $14 divide by 0
00003962= 00CD                    9481      dc.w    LAB_ID-LAB_BAER         * $16 illegal direct
00003964= 00DC                    9482      dc.w    LAB_TM-LAB_BAER         * $18 type mismatch
00003966= 00EA                    9483      dc.w    LAB_LS-LAB_BAER         * $1A long string
00003968= 00FA                    9484      dc.w    LAB_ST-LAB_BAER         * $1C string too complex
0000396A= 010D                    9485      dc.w    LAB_CN-LAB_BAER         * $1E continue error
0000396C= 011C                    9486      dc.w    LAB_UF-LAB_BAER         * $20 undefined function
0000396E= 012F                    9487      dc.w    LAB_LD-LAB_BAER         * $22 LOOP without DO
00003970= 013F                    9488      dc.w    LAB_UV-LAB_BAER         * $24 undefined variable
00003972= 0152                    9489      dc.w    LAB_UA-LAB_BAER         * $26 undimensioned array
00003974= 0166                    9490      dc.w    LAB_WD-LAB_BAER         * $28 wrong dimensions
00003976= 0177                    9491      dc.w    LAB_AD-LAB_BAER         * $2A address
00003978= 017F                    9492      dc.w    LAB_FO-LAB_BAER         * $2C format
0000397A                          9493  
0000397A= 4E 45 58 54 20 77 ...   9494  LAB_NF  dc.b    'NEXT without FOR',$00
0000398B= 53 79 6E 74 61 78 00    9495  LAB_SN  dc.b    'Syntax',$00
00003992= 52 45 54 55 52 4E ...   9496  LAB_RG  dc.b    'RETURN without GOSUB',$00
000039A7= 4F 75 74 20 6F 66 ...   9497  LAB_OD  dc.b    'Out of DATA',$00
000039B3= 46 75 6E 63 74 69 ...   9498  LAB_FC  dc.b    'Function call',$00
000039C1= 4F 76 65 72 66 6C ...   9499  LAB_OV  dc.b    'Overflow',$00
000039CA= 4F 75 74 20 6F 66 ...   9500  LAB_OM  dc.b    'Out of memory',$00
000039D8= 55 6E 64 65 66 69 ...   9501  LAB_US  dc.b    'Undefined statement',$00
000039EC= 41 72 72 61 79 20 ...   9502  LAB_BS  dc.b    'Array bounds',$00
000039F9= 44 6F 75 62 6C 65 ...   9503  LAB_DD  dc.b    'Double dimension',$00
00003A0A= 44 69 76 69 64 65 ...   9504  LAB_D0  dc.b    'Divide by zero',$00
00003A19= 49 6C 6C 65 67 61 ...   9505  LAB_ID  dc.b    'Illegal direct',$00
00003A28= 54 79 70 65 20 6D ...   9506  LAB_TM  dc.b    'Type mismatch',$00
00003A36= 53 74 72 69 6E 67 ...   9507  LAB_LS  dc.b    'String too long',$00
00003A46= 53 74 72 69 6E 67 ...   9508  LAB_ST  dc.b    'String too complex',$00
00003A59= 43 61 6E 27 74 20 ...   9509  LAB_CN  dc.b    'Can''t continue',$00
00003A68= 55 6E 64 65 66 69 ...   9510  LAB_UF  dc.b    'Undefined function',$00
00003A7B= 4C 4F 4F 50 20 77 ...   9511  LAB_LD  dc.b    'LOOP without DO',$00
00003A8B= 55 6E 64 65 66 69 ...   9512  LAB_UV  dc.b    'Undefined variable',$00
00003A9E= 55 6E 64 69 6D 65 ...   9513  LAB_UA  dc.b    'Undimensioned array',$00
00003AB2= 57 72 6F 6E 67 20 ...   9514  LAB_WD  dc.b    'Wrong dimensions',$00
00003AC3= 41 64 64 72 65 73 ...   9515  LAB_AD  dc.b    'Address',$00
00003ACB= 46 6F 72 6D 61 74 00    9516  LAB_FO  dc.b    'Format',$00
00003AD2                          9517  
00003AD2                          9518  
00003AD2                          9519  *************************************************************************************
00003AD2                          9520  *
00003AD2                          9521  * keyword table for line (un)crunching
00003AD2                          9522  
00003AD2                          9523  * [keyword,token
00003AD2                          9524  * [keyword,token]]
00003AD2                          9525  * end marker (#$00)
00003AD2                          9526  
00003AD2                          9527  TAB_STAR
00003AD2                          9528  KEY_MULT
00003AD2= C1 00                   9529      dc.b TK_MULT,$00                * *
00003AD4                          9530  TAB_PLUS
00003AD4                          9531  KEY_PLUS
00003AD4= BF 00                   9532      dc.b TK_PLUS,$00                * +
00003AD6                          9533  TAB_MNUS
00003AD6                          9534  KEY_MINUS
00003AD6= C0 00                   9535      dc.b TK_MINUS,$00               * -
00003AD8                          9536  TAB_SLAS
00003AD8                          9537  KEY_DIV
00003AD8= C2 00                   9538      dc.b TK_DIV,$00             * /
00003ADA                          9539  TAB_LESS
00003ADA                          9540  KEY_LSHIFT
00003ADA= 3C C8                   9541      dc.b    '<',TK_LSHIFT           * <<
00003ADC                          9542  KEY_LT
00003ADC= CB                      9543      dc.b TK_LT                  * <
00003ADD= 00                      9544      dc.b    $00
00003ADE                          9545  TAB_EQUL
00003ADE                          9546  KEY_EQUAL
00003ADE= CA 00                   9547      dc.b TK_EQUAL,$00               * =
00003AE0                          9548  TAB_MORE
00003AE0                          9549  KEY_RSHIFT
00003AE0= 3E C7                   9550      dc.b    '>',TK_RSHIFT           * >>
00003AE2                          9551  KEY_GT
00003AE2= C9                      9552      dc.b TK_GT                  * >
00003AE3= 00                      9553      dc.b    $00
00003AE4                          9554  TAB_QEST
00003AE4= 9E 00                   9555      dc.b TK_PRINT,$00               * ?
00003AE6                          9556  TAB_ASCA
00003AE6                          9557  KEY_ABS
00003AE6= 42 53 28 CE             9558      dc.b    'BS(',TK_ABS            * ABS(
00003AEA                          9559  KEY_AND
00003AEA= 4E 44 C4                9560      dc.b    'ND',TK_AND             * AND
00003AED                          9561  KEY_ASC
00003AED= 53 43 28 E0             9562      dc.b    'SC(',TK_ASC            * ASC(
00003AF1                          9563  KEY_ATN
00003AF1= 54 4E 28 D9             9564      dc.b    'TN(',TK_ATN            * ATN(
00003AF5= 00                      9565      dc.b    $00
00003AF6                          9566  TAB_ASCB
00003AF6                          9567  KEY_BINS
00003AF6= 49 4E 24 28 E5          9568      dc.b    'IN$(',TK_BINS          * BIN$(
00003AFB                          9569  KEY_BITCLR
00003AFB= 49 54 43 4C 52 B4       9570      dc.b    'ITCLR',TK_BITCLR           * BITCLR
00003B01                          9571  KEY_BITSET
00003B01= 49 54 53 45 54 B3       9572      dc.b    'ITSET',TK_BITSET           * BITSET
00003B07                          9573  KEY_BITTST
00003B07= 49 54 54 53 54 28 E6    9574      dc.b    'ITTST(',TK_BITTST      * BITTST(
00003B0E                          9575  KEY_BUFFER
00003B0E= 55 46 46 45 52 A0       9576      dc.b    'UFFER',TK_BUFFER           * BUFFER
00003B14= 00                      9577      dc.b    $00
00003B15                          9578  TAB_ASCC
00003B15                          9579  KEY_CALL
00003B15= 41 4C 4C 9B             9580      dc.b    'ALL',TK_CALL           * CALL
00003B19                          9581  KEY_CHRS
00003B19= 48 52 24 28 E3          9582      dc.b    'HR$(',TK_CHRS          * CHR$(
00003B1E                          9583  KEY_CLEAR
00003B1E= 4C 45 41 52 AE          9584      dc.b    'LEAR',TK_CLEAR         * CLEAR
00003B23                          9585  KEY_CLS
00003B23= 4C 53 A1                9586      dc.b    'LS',TK_CLS             * CLS
00003B26                          9587  KEY_CONT
00003B26= 4F 4E 54 9F             9588      dc.b    'ONT',TK_CONT           * CONT
00003B2A                          9589  KEY_COS
00003B2A= 4F 53 28 D6             9590      dc.b    'OS(',TK_COS            * COS(
00003B2E                          9591  KEY_CURSOR
00003B2E= 55 52 53 4F 52 A2       9592      dc.b    'URSOR',TK_CURSOR           * CURSOR
00003B34= 00                      9593      dc.b    $00
00003B35                          9594  TAB_ASCD
00003B35                          9595  KEY_DATA
00003B35= 41 54 41 83             9596      dc.b    'ATA',TK_DATA           * DATA
00003B39                          9597  KEY_DEC
00003B39= 45 43 88                9598      dc.b    'EC',TK_DEC             * DEC
00003B3C                          9599  KEY_DEEK
00003B3C= 45 45 4B 28 DB          9600      dc.b    'EEK(',TK_DEEK          * DEEK(
00003B41                          9601  KEY_DEF
00003B41= 45 46 97                9602      dc.b    'EF',TK_DEF             * DEF
00003B44                          9603  KEY_DIM
00003B44= 49 4D 85                9604      dc.b    'IM',TK_DIM             * DIM
00003B47                          9605  KEY_DOKE
00003B47= 4F 4B 45 99             9606      dc.b    'OKE',TK_DOKE           * DOKE
00003B4B                          9607  KEY_DO
00003B4B= 4F 9C                   9608      dc.b    'O',TK_DO               * DO
00003B4D= 00                      9609      dc.b    $00
00003B4E                          9610  TAB_ASCE
00003B4E                          9611  KEY_ELSE
00003B4E= 4C 53 45 B6             9612      dc.b    'LSE',TK_ELSE           * ELSE
00003B52                          9613  KEY_END
00003B52= 4E 44 80                9614      dc.b    'ND',TK_END             * END
00003B55                          9615  KEY_FELLIPSE
00003B55= 4C 4C 49 50 53 45 ...   9616      dc.b    'LLIPSEF',TK_FELLIPSE       * ELLIPSEF
00003B5D                          9617  KEY_ELLIPSE
00003B5D= 4C 4C 49 50 53 45 A9    9618      dc.b    'LLIPSE',TK_ELLIPSE     * ELLIPSE
00003B64                          9619  KEY_EOR
00003B64= 4F 52 C5                9620      dc.b    'OR',TK_EOR             * EOR
00003B67                          9621  KEY_EXP
00003B67= 58 50 28 D5             9622      dc.b    'XP(',TK_EXP            * EXP(
00003B6B= 00                      9623      dc.b    $00
00003B6C                          9624  TAB_ASCF
00003B6C                          9625  KEY_FILL
00003B6C= 49 4C 4C A4             9626      dc.b    'ILL',TK_FILL           * FILL
00003B70                          9627  KEY_FOR
00003B70= 4F 52 81                9628      dc.b    'OR',TK_FOR             * FOR
00003B73                          9629  KEY_FN
00003B73= 4E B8                   9630      dc.b    'N',TK_FN               * FN
00003B75                          9631  KEY_FRE
00003B75= 52 45 28 D0             9632      dc.b    'RE(',TK_FRE            * FRE(
00003B79= 00                      9633      dc.b    $00
00003B7A                          9634  TAB_ASCG
00003B7A                          9635  KEY_GET
00003B7A= 45 54 B1                9636      dc.b    'ET',TK_GET             * GET
00003B7D                          9637  KEY_GOTO
00003B7D= 4F 54 4F 89             9638      dc.b    'OTO',TK_GOTO           * GOTO
00003B81                          9639  KEY_GOSUB
00003B81= 4F 53 55 42 8D          9640      dc.b    'OSUB',TK_GOSUB         * GOSUB
00003B86= 00                      9641      dc.b    $00
00003B87                          9642  TAB_ASCH
00003B87                          9643  KEY_HEXS
00003B87= 45 58 24 28 E4 00       9644      dc.b    'EX$(',TK_HEXS,$00      * HEX$(
00003B8D                          9645  TAB_ASCI
00003B8D                          9646  KEY_IF
00003B8D= 46 8B                   9647      dc.b    'F',TK_IF               * IF
00003B8F                          9648  KEY_INC
00003B8F= 4E 43 93                9649      dc.b    'NC',TK_INC             * INC
00003B92                          9650  KEY_INPUT
00003B92= 4E 50 55 54 84          9651      dc.b    'NPUT',TK_INPUT         * INPUT
00003B97                          9652  KEY_INT
00003B97= 4E 54 28 CD             9653      dc.b    'NT(',TK_INT            * INT(
00003B9B= 00                      9654      dc.b    $00
00003B9C                          9655  TAB_ASCK
00003B9C                          9656  KEY_KEYS
00003B9C= 45 59 53 28 EA          9657      dc.b    'EYS(',TK_KEYS          * KEYS(
00003BA1= 00                      9658      dc.b    $00
00003BA2                          9659  TAB_ASCL
00003BA2                          9660  KEY_LCASES
00003BA2= 43 41 53 45 24 28 E2    9661      dc.b    'CASE$(',TK_LCASES      * LCASE$(
00003BA9                          9662  KEY_LEEK
00003BA9= 45 45 4B 28 DC          9663      dc.b    'EEK(',TK_LEEK          * LEEK(
00003BAE                          9664  KEY_LEFTS
00003BAE= 45 46 54 24 28 F0       9665      dc.b    'EFT$(',TK_LEFTS            * LEFT$(
00003BB4                          9666  KEY_LEN
00003BB4= 45 4E 28 DD             9667      dc.b    'EN(',TK_LEN            * LEN(
00003BB8                          9668  KEY_LET
00003BB8= 45 54 87                9669      dc.b    'ET',TK_LET             * LET
00003BBB                          9670  KEY_LINE
00003BBB= 49 4E 45 A3             9671      dc.b    'INE',TK_LINE           * LINE
00003BBF                          9672  KEY_LIST
00003BBF= 49 53 54 AD             9673      dc.b    'IST',TK_LIST           * LIST
00003BC3                          9674  KEY_LOAD
00003BC3= 4F 41 44 95             9675      dc.b    'OAD',TK_LOAD           * LOAD
00003BC7                          9676  KEY_LOG
00003BC7= 4F 47 28 D4             9677      dc.b    'OG(',TK_LOG            * LOG(
00003BCB                          9678  KEY_LOKE
00003BCB= 4F 4B 45 9A             9679      dc.b    'OKE',TK_LOKE           * LOKE
00003BCF                          9680  KEY_LOOP
00003BCF= 4F 4F 50 9D             9681      dc.b    'OOP',TK_LOOP           * LOOP
00003BD3= 00                      9682      dc.b    $00
00003BD4                          9683  TAB_ASCM
00003BD4                          9684  KEY_MAX
00003BD4= 41 58 28 E7             9685      dc.b    'AX(',TK_MAX            * MAX(
00003BD8                          9686  KEY_MIDS
00003BD8= 49 44 24 28 F2          9687      dc.b    'ID$(',TK_MIDS          * MID$(
00003BDD                          9688  KEY_MIN
00003BDD= 49 4E 28 E8             9689      dc.b    'IN(',TK_MIN            * MIN(
00003BE1                          9690  KEY_MODE
00003BE1= 4F 44 45 AB             9691      dc.b    'ODE',TK_MODE           * MODE
00003BE5                          9692  KEY_MOVE
00003BE5= 4F 56 45 A5             9693      dc.b    'OVE',TK_MOVE           * MOVE
00003BE9= 00                      9694      dc.b    $00
00003BEA                          9695  TAB_ASCN
00003BEA                          9696  KEY_NEW
00003BEA= 45 57 AF                9697      dc.b    'EW',TK_NEW             * NEW
00003BED                          9698  KEY_NEXT
00003BED= 45 58 54 82             9699      dc.b    'EXT',TK_NEXT           * NEXT
00003BF1                          9700  KEY_NOT
00003BF1= 4F 54 BB                9701      dc.b    'OT',TK_NOT             * NOT
00003BF4                          9702  KEY_NULL
00003BF4= 55 4C 4C 92             9703      dc.b    'ULL',TK_NULL           * NULL
00003BF8= 00                      9704      dc.b    $00
00003BF9                          9705  TAB_ASCO
00003BF9                          9706  KEY_ON
00003BF9= 4E 91                   9707      dc.b    'N',TK_ON               * ON
00003BFB                          9708  KEY_OR
00003BFB= 52 C6                   9709      dc.b    'R',TK_OR               * OR
00003BFD= 00                      9710      dc.b    $00
00003BFE                          9711  TAB_ASCP
00003BFE                          9712  KEY_PEEK
00003BFE= 45 45 4B 28 DA          9713      dc.b    'EEK(',TK_PEEK          * PEEK(
00003C03                          9714  KEY_PI
00003C03= 49 EC                   9715      dc.b    'I',TK_PI               * PI
00003C05                          9716  KEY_POINT
00003C05= 4F 49 4E 54 A6          9717      dc.b    'OINT',TK_POINT         * POINT
00003C0A                          9718  KEY_POKE
00003C0A= 4F 4B 45 98             9719      dc.b    'OKE',TK_POKE           * POKE
00003C0E                          9720  KEY_POS
00003C0E= 4F 53 28 D1             9721      dc.b    'OS(',TK_POS            * POS(
00003C12                          9722  KEY_PRINT
00003C12= 52 49 4E 54 9E          9723      dc.b    'RINT',TK_PRINT         * PRINT
00003C17= 00                      9724      dc.b    $00
00003C18                          9725  TAB_ASCR
00003C18                          9726  KEY_RAM
00003C18= 41 4D 42 41 53 45 E9    9727      dc.b    'AMBASE',TK_RAM         * RAMBASE
00003C1F                          9728  KEY_READ
00003C1F= 45 41 44 86             9729      dc.b    'EAD',TK_READ           * READ
00003C23                          9730  KEY_FRECT
00003C23= 45 43 54 46 A8          9731      dc.b    'ECTF',TK_FRECT         * RECTF
00003C28                          9732  KEY_RECT
00003C28= 45 43 54 A7             9733      dc.b    'ECT',TK_RECT           * RECT
00003C2C                          9734  KEY_REM
00003C2C= 45 4D 8F                9735      dc.b    'EM',TK_REM             * REM
00003C2F                          9736  KEY_RESTORE
00003C2F= 45 53 54 4F 52 45 8C    9737      dc.b    'ESTORE',TK_RESTORE     * RESTORE
00003C36                          9738  KEY_RETURN
00003C36= 45 54 55 52 4E 8E       9739      dc.b    'ETURN',TK_RETURN           * RETURN
00003C3C                          9740  KEY_RIGHTS
00003C3C= 49 47 48 54 24 28 F1    9741      dc.b    'IGHT$(',TK_RIGHTS      * RIGHT$(
00003C43                          9742  KEY_RND
00003C43= 4E 44 28 D3             9743      dc.b    'ND(',TK_RND            * RND(
00003C47                          9744  KEY_RUN
00003C47= 55 4E 8A                9745      dc.b    'UN',TK_RUN             * RUN
00003C4A= 00                      9746      dc.b    $00
00003C4B                          9747  TAB_ASCS
00003C4B                          9748  KEY_SADD
00003C4B= 41 44 44 28 EF          9749      dc.b    'ADD(',TK_SADD          * SADD(
00003C50                          9750  KEY_SAVE
00003C50= 41 56 45 96             9751      dc.b    'AVE',TK_SAVE           * SAVE
00003C54                          9752  KEY_SGN
00003C54= 47 4E 28 CC             9753      dc.b    'GN(',TK_SGN            * SGN(
00003C58                          9754  KEY_SIN
00003C58= 49 4E 28 D7             9755      dc.b    'IN(',TK_SIN            * SIN(
00003C5C                          9756  KEY_SIZE
00003C5C= 49 5A 45 AC             9757      dc.b    'IZE',TK_SIZE           * SIZE
00003C60                          9758  KEY_SPC
00003C60= 50 43 28 B9             9759      dc.b    'PC(',TK_SPC            * SPC(
00003C64                          9760  KEY_SQR
00003C64= 51 52 28 D2             9761      dc.b    'QR(',TK_SQR            * SQR(
00003C68                          9762  KEY_STEP
00003C68= 54 45 50 BC             9763      dc.b    'TEP',TK_STEP           * STEP
00003C6C                          9764  KEY_STOP
00003C6C= 54 4F 50 90             9765      dc.b    'TOP',TK_STOP           * STOP
00003C70                          9766  KEY_STRS
00003C70= 54 52 24 28 DE          9767      dc.b    'TR$(',TK_STRS          * STR$(
00003C75                          9768  KEY_SWAP
00003C75= 57 41 50 B2             9769      dc.b    'WAP',TK_SWAP           * SWAP
00003C79= 00                      9770      dc.b    $00
00003C7A                          9771  TAB_ASCT
00003C7A                          9772  KEY_TAB
00003C7A= 41 42 28 B5             9773      dc.b    'AB(',TK_TAB            * TAB(
00003C7E                          9774  KEY_TAN
00003C7E= 41 4E 28 D8             9775      dc.b    'AN(',TK_TAN            * TAN
00003C82                          9776  KEY_THEN
00003C82= 48 45 4E BA             9777      dc.b    'HEN',TK_THEN           * THEN
00003C86                          9778  KEY_TI
00003C86= 49 EB                   9779      dc.b    'I',TK_TI               * TI
00003C88                          9780  KEY_TO
00003C88= 4F B7                   9781      dc.b    'O',TK_TO               * TO
00003C8A                          9782  KEY_TWOPI
00003C8A= 57 4F 50 49 ED          9783      dc.b    'WOPI',TK_TWOPI         * TWOPI
00003C8F= 00                      9784      dc.b    $00
00003C90                          9785  TAB_ASCU
00003C90                          9786  KEY_UCASES
00003C90= 43 41 53 45 24 28 E1    9787      dc.b    'CASE$(',TK_UCASES      * UCASE$(
00003C97                          9788  KEY_UNTIL
00003C97= 4E 54 49 4C BD          9789      dc.b    'NTIL',TK_UNTIL         * UNTIL
00003C9C                          9790  KEY_USINGS
00003C9C= 53 49 4E 47 24 28 F3    9791      dc.b    'SING$(',TK_USINGS      * USING$(
00003CA3                          9792  KEY_USR
00003CA3= 53 52 28 CF             9793      dc.b    'SR(',TK_USR            * USR(
00003CA7= 00                      9794      dc.b    $00
00003CA8                          9795  TAB_ASCV
00003CA8                          9796  KEY_VAL
00003CA8= 41 4C 28 DF             9797      dc.b    'AL(',TK_VAL            * VAL(
00003CAC                          9798  KEY_VPTR
00003CAC= 41 52 50 54 52 28 EE    9799      dc.b    'ARPTR(',TK_VPTR            * VARPTR(
00003CB3= 00                      9800      dc.b    $00
00003CB4                          9801  TAB_ASCW
00003CB4                          9802  KEY_WAIT
00003CB4= 41 49 54 94             9803      dc.b    'AIT',TK_WAIT           * WAIT
00003CB8                          9804  KEY_WHILE
00003CB8= 48 49 4C 45 BE          9805      dc.b    'HILE',TK_WHILE         * WHILE
00003CBD                          9806  KEY_WIDTH
00003CBD= 49 44 54 48 B0          9807      dc.b    'IDTH',TK_WIDTH         * WIDTH
00003CC2= 00                      9808      dc.b    $00
00003CC3                          9809  TAB_POWR
00003CC3                          9810  KEY_POWER
00003CC3= C3 00                   9811      dc.b    TK_POWER,$00            * ^
00003CC5                          9812  
00003CC5                          9813  
00003CC5                          9814  *************************************************************************************
00003CC5                          9815  *
00003CC5                          9816  * just messages
00003CC5                          9817  
00003CC5                          9818  LAB_BMSG
00003CC5= 0D 0A 42 72 65 61 ...   9819      dc.b    $0D,$0A,'Break',$00
00003CCD                          9820  LAB_EMSG
00003CCD= 20 45 72 72 6F 72 00    9821      dc.b    ' Error',$00
00003CD4                          9822  LAB_LMSG
00003CD4= 20 69 6E 20 6C 69 ...   9823      dc.b    ' in line ',$00
00003CDE                          9824  LAB_IMSG
00003CDE= 45 78 74 72 61 20 ...   9825      dc.b    'Extra ignored',$0D,$0A,$00
00003CEE                          9826  LAB_REDO
00003CEE= 52 65 64 6F 20 66 ...   9827      dc.b    'Redo from start',$0D,$0A,$00
00003D00                          9828  LAB_RMSG
00003D00= 0D 0A 52 65 61 64 ...   9829      dc.b    $0D,$0A,'Ready',$0D,$0A,$00
00003D0A                          9830  LAB_SMSG
00003D0A= 20 42 79 74 65 73 ...   9831      dc.b    ' Bytes free',$0D,$0A,$0A
00003D18= 45 6E 68 61 6E 63 ...   9832      dc.b    'Enhanced 68k BASIC Version 3.52',$0D,$0A
00003D39= 66 6F 72 20 74 68 ...   9833      dc.b    'for the Sim68k 68000 simulator',$0D,$0A
00003D59= 45 78 74 65 6E 73 ...   9834      dc.b    'Extension commands Version 2.33',$0D,$0A,$00
00003D7B                          9835  
00003D7B                          9836  *************************************************************************************
00003D7B                          9837  * EhBASIC keywords quick reference list                             *
00003D7B                          9838  *************************************************************************************
00003D7B                          9839  
00003D7B                          9840  * glossary
00003D7B                          9841  
00003D7B                          9842  *       <.>       required
00003D7B                          9843  *       {.|.}         one of required
00003D7B                          9844  *       [.]       optional
00003D7B                          9845  *       ...       may repeat as last
00003D7B                          9846  
00003D7B                          9847  *       any     = anything
00003D7B                          9848  *       num     = number
00003D7B                          9849  *       state       = statement
00003D7B                          9850  *       pint        = positive integer
00003D7B                          9851  *       str     = string
00003D7B                          9852  *       var     = variable
00003D7B                          9853  *       nvar        = numeric variable
00003D7B                          9854  *       svar        = string variable
00003D7B                          9855  *       expr        = expression
00003D7B                          9856  *       nexpr       = numeric expression
00003D7B                          9857  *       sexpr       = string expression
00003D7B                          9858  
00003D7B                          9859  * statement separator
00003D7B                          9860  
00003D7B                          9861  * :     . [<state>] : [<state>]                     * done
00003D7B                          9862  
00003D7B                          9863  * number bases
00003D7B                          9864  
00003D7B                          9865  * %     . %<binary num>                         * done
00003D7B                          9866  * $     . $<hex num>                            * done
00003D7B                          9867  
00003D7B                          9868  * commands
00003D7B                          9869  
00003D7B                          9870  * END       . END                                   * done
00003D7B                          9871  * FOR       . FOR <nvar>=<nexpr> TO <nexpr> [STEP <nexpr>]      * done
00003D7B                          9872  * NEXT  . NEXT [<nvar>[,<nvar>]...]                 * done
00003D7B                          9873  * DATA  . DATA [{num|["]str["]}[,{num|["]str["]}]...]       * done
00003D7B                          9874  * INPUT . INPUT [<">str<">;] <var>[,<var>[,<var>]...]       * done
00003D7B                          9875  * DIM       . DIM <var>(<nexpr>[,<nexpr>[,<nexpr>]])            * done
00003D7B                          9876  * READ  . READ <var>[,<var>[,<var>]...]             * done
00003D7B                          9877  * LET       . [LET] <var>=<expr>                        * done
00003D7B                          9878  * DEC       . DEC <nvar>[,<nvar>[,<nvar>]...]               * done
00003D7B                          9879  * GOTO  . GOTO <pint>                           * done
00003D7B                          9880  * RUN       . RUN [pint]                            * done
00003D7B                          9881  * IF        . IF <expr>{GOTO<n>|THEN<{n|comm}>}[ELSE <{n|comm}>]    * done
00003D7B                          9882  * RESTORE   . RESTORE [pint]                            * done
00003D7B                          9883  * GOSUB . GOSUB <pint>                          * done
00003D7B                          9884  * RETURN    . RETURN                                * done
00003D7B                          9885  * REM       . REM [any]                             * done
00003D7B                          9886  * STOP  . STOP                              * done
00003D7B                          9887  * ON        . ON <nexpr> {GOTO|GOSUB} <pint>[,<pint>[,<pint>]...]   * done
00003D7B                          9888  * NULL  . NULL <nexpr>                          * done
00003D7B                          9889  * INC       . INC <nvar>[,<nvar>[,<nvar>]...]               * done
00003D7B                          9890  * WAIT  . WAIT <nexpr>,<nexpr>[,<nexpr>]                * done
00003D7B                          9891  * LOAD  . LOAD [<sexpr>]                            * done for simulator
00003D7B                          9892  * SAVE  . SAVE [<sexpr>][,[<n>][-<n>]]              * done for simulator
00003D7B                          9893  * DEF       . DEF FN<var>(<var>)=<expr>                 * done
00003D7B                          9894  * POKE  . POKE <nexpr>,<nexpr>                      * done
00003D7B                          9895  * DOKE  . DOKE <nexpr>,<nexpr>                      * done
00003D7B                          9896  * LOKE  . LOKE <nexpr>,<nexpr>                      * done
00003D7B                          9897  * CALL  . CALL <nexpr>                          * done
00003D7B                          9898  * DO        . DO                                    * done
00003D7B                          9899  * LOOP  . LOOP [{WHILE|UNTIL}<nexpr>]                   * done
00003D7B                          9900  * PRINT . PRINT [{;|,}][expr][{;|,}[expr][{;|,}[expr]]...]  * done
00003D7B                          9901  * CONT  . CONT                              * done
00003D7B                          9902  * LIST  . LIST [pint][-pint]                        * done
00003D7B                          9903  * CLEAR . CLEAR                             * done
00003D7B                          9904  * NEW       . NEW                                   * done
00003D7B                          9905  * WIDTH . WIDTH [<pint>][,<pint>]                   * done
00003D7B                          9906  * GET       . GET <var>                             * done
00003D7B                          9907  * SWAP  . SWAP <var>,<var>                      * done
00003D7B                          9908  * BITSET    . BITSET <nexpr>,<nexpr>                    * done
00003D7B                          9909  * BITCLR    . BITCLR <nexpr>,<nexpr>                    * done
00003D7B                          9910  
00003D7B                          9911  * new graphics commands for EASy68k
00003D7B                          9912  
00003D7B                          9913  * BUFFER    . BUFFER                                * done
00003D7B                          9914  * CLS       . CLS                                   * done
00003D7B                          9915  * CURSOR    . CURSOR <nexpr>,<nexpr>                    * done
00003D7B                          9916  * LINE  . LINE <nexpr>,<nexpr>[,<nexpr>,<nexpr>][,][<nexpr>]    * done
00003D7B                          9917  * FILL  . FILL <nexpr>,<nexpr>[,][<nexpr>]              * done
00003D7B                          9918  * MOVE  . MOVE <nexpr>,<nexpr>                      * done
00003D7B                          9919  * POINT . POINT <nexpr>,<nexpr>[,][<nexpr>]             * done
00003D7B                          9920  * RECT  . RECT <nexpr>,<nexpr>[,<nexpr>,<nexpr>][,<nexpr>[,<nexpr>]]    * done
00003D7B                          9921  * RECTF . RECTF <nexpr>,<nexpr>[,<nexpr>,<nexpr>][,<nexpr>[,<nexpr>]]   * done
00003D7B                          9922  * ELLIPSE   . ELLIPSE <nexpr>,<nexpr>[,<nexpr>,<nexpr>][,<nexpr>[,<nexpr>]] * done
00003D7B                          9923  * ELLIPSEF  . ELLIPSEF <nexpr>,<nexpr>[,<nexpr>,<nexpr>][,<nexpr>[,<nexpr>]]    * done
00003D7B                          9924  * MODE  . MODE <pint>                           * done
00003D7B                          9925  * SIZE  . SIZE <pint>                           * done
00003D7B                          9926  
00003D7B                          9927  * sub commands (may not start a statement)
00003D7B                          9928  
00003D7B                          9929  * TAB       . TAB(<nexpr>)                          * done
00003D7B                          9930  * ELSE  . IF <expr>{GOTO<n>|THEN<{n|comm}>}[ELSE <{n|comm}>]    * done
00003D7B                          9931  * TO        . FOR <nvar>=<nexpr> TO <nexpr> [STEP <nexpr>]      * done
00003D7B                          9932  * FN        . FN<var>(<expr>)                           * done
00003D7B                          9933  * SPC       . SPC(<nexpr>)                          * done
00003D7B                          9934  * THEN  . IF <nexpr> {THEN {pint|comm}|GOTO <pint>}     * done
00003D7B                          9935  * NOT       . NOT <nexpr>                           * done
00003D7B                          9936  * STEP  . FOR <nvar>=<nexpr> TO <nexpr> [STEP <nexpr>]      * done
00003D7B                          9937  * UNTIL . LOOP [{WHILE|UNTIL}<nexpr>]                   * done
00003D7B                          9938  * WHILE . LOOP [{WHILE|UNTIL}<nexpr>]                   * done
00003D7B                          9939  
00003D7B                          9940  * operators
00003D7B                          9941  
00003D7B                          9942  * +     . [expr] + <expr>                           * done
00003D7B                          9943  * -     . [nexpr] - <nexpr>                     * done
00003D7B                          9944  * *     . <nexpr> * <nexpr>                     * done fast hardware
00003D7B                          9945  * /     . <nexpr> / <nexpr>                     * done fast hardware
00003D7B                          9946  * ^     . <nexpr> ^ <nexpr>                     * done
00003D7B                          9947  * AND       . <nexpr> AND <nexpr>                       * done
00003D7B                          9948  * EOR       . <nexpr> EOR <nexpr>                       * done
00003D7B                          9949  * OR        . <nexpr> OR <nexpr>                        * done
00003D7B                          9950  * >>        . <nexpr> >> <nexpr>                        * done
00003D7B                          9951  * <<        . <nexpr> << <nexpr>                        * done
00003D7B                          9952  
00003D7B                          9953  * compare functions
00003D7B                          9954  
00003D7B                          9955  * <     . <expr> < <expr>                           * done
00003D7B                          9956  * =     . <expr> = <expr>                           * done
00003D7B                          9957  * >     . <expr> > <expr>                           * done
00003D7B                          9958  
00003D7B                          9959  * functions
00003D7B                          9960  
00003D7B                          9961  * SGN       . SGN(<nexpr>)                          * done
00003D7B                          9962  * INT       . INT(<nexpr>)                          * done
00003D7B                          9963  * ABS       . ABS(<nexpr>)                          * done
00003D7B                          9964  * USR       . USR(<expr>)                           * done
00003D7B                          9965  * FRE       . FRE(<expr>)                           * done
00003D7B                          9966  * POS       . POS(<expr>)                           * done
00003D7B                          9967  * SQR       . SQR(<nexpr>)                          * done fast shift/sub
00003D7B                          9968  * RND       . RND(<nexpr>)                          * done 32 bit PRNG
00003D7B                          9969  * LOG       . LOG(<nexpr>)                          * done fast cordic
00003D7B                          9970  * EXP       . EXP(<nexpr>)                          * done fast cordic
00003D7B                          9971  * COS       . COS(<nexpr>)                          * done fast cordic
00003D7B                          9972  * SIN       . SIN(<nexpr>)                          * done fast cordic
00003D7B                          9973  * TAN       . TAN(<nexpr>)                          * done fast cordic
00003D7B                          9974  * ATN       . ATN(<nexpr>)                          * done fast cordic
00003D7B                          9975  * PEEK  . PEEK(<nexpr>)                         * done
00003D7B                          9976  * DEEK  . DEEK(<nexpr>)                         * done
00003D7B                          9977  * LEEK  . LEEK(<nexpr>)                         * done
00003D7B                          9978  * LEN       . LEN(<sexpr>)                          * done
00003D7B                          9979  * STR$  . STR$(<nexpr>)                         * done
00003D7B                          9980  * VAL       . VAL(<sexpr>)                          * done
00003D7B                          9981  * ASC       . ASC(<sexpr>)                          * done
00003D7B                          9982  * UCASE$    . UCASE$(<sexpr>)                           * done
00003D7B                          9983  * LCASE$    . LCASE$(<sexpr>)                           * done
00003D7B                          9984  * CHR$  . CHR$(<nexpr>)                         * done
00003D7B                          9985  * HEX$  . HEX$(<nexpr>)                         * done
00003D7B                          9986  * BIN$  . BIN$(<nexpr>)                         * done
00003D7B                          9987  * BTST  . BTST(<nexpr>,<nexpr>)                     * done
00003D7B                          9988  * MAX       . MAX(<nexpr>[,<nexpr>[,<nexpr>]...])           * done
00003D7B                          9989  * MIN       . MIN(<nexpr>[,<nexpr>[,<nexpr>]...])           * done
00003D7B                          9990  * KEYS  . KEYS(<expr>)                          * done for simulator
00003D7B                          9991  * TI        . TI                                    * done for simulator
00003D7B                          9992  * PI        . PI                                    * done
00003D7B                          9993  * TWOPI . TWOPI                             * done
00003D7B                          9994  * VARPTR    . VARPTR(<var>)                         * done
00003D7B                          9995  * SADD  . SADD(<svar>)                          * done
00003D7B                          9996  * LEFT$ . LEFT$(<sexpr>,<nexpr>)                    * done
00003D7B                          9997  * RIGHT$    . RIGHT$(<sexpr>,<nexpr>)                   * done
00003D7B                          9998  * MID$  . MID$(<sexpr>,<nexpr>[,<nexpr>])               * done
00003D7B                          9999  * USING$    . USING$(<sexpr>,<nexpr>[,<nexpr>]...])         * done
00003D7B                         10000  
00003D7B                         10001  * New functions for EASy68k
00003D7B                         10002  
00003D7B                         10003  * POINT . POINT(<nexpr>,<nexpr>)                    * done
00003D7B                         10004  
00003D7B                         10005  
00003D7B                         10006  *************************************************************************************
00003D7B                         10007  
00003D7B                         10008      END code_start

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
AC1GTAC2            227E
ASPTL               5A8
ASRCH               5DA
ASTRTL              5AC
BHSEND              5D6
BIN2DEC             323A
BINPR               2E20
BINSS               5B6
BLINEL              456
BREAKF              5DC
CCBYTE              5E9
CCFLAG              5E8
CCNULL              5EA
CFLAG               5E1
CLINEL              452
CODE_START          596
COMP_F              5E3
COSOUT              5B4
CPNTRL              45A
CVARAL              46E
D1X02               3214
D1X10               322A
D1X16               3206
DECSS               5C6
DEFDIM              5B4
DES_SK              48E
DES_SK_E            476
DIMCNT              5DB
DLINEL              45E
DOCMP               C50
DOREST              C3C
DPTRL               462
DTYPEF              5B5
EARRYL              442
EMEML               44A
ENDBHS              2DFA
EXPCNT              5AD
EXPNEG              5AF
FAC1_E              594
FAC1_M              590
FAC1_S              595
FAC2_E              59C
FAC2_M              598
FAC2_S              59D
FAC_SC              59E
FEND                8
FILE_BYTE           5EB
FILE_ID             5EC
FILE_LIST           510
FLAG                59F
FSD                 0
FSDC                A
FSDPI               8
FSLI                6
FSTI                4
FUNC_L              5B0
GCLCTD              5DE
GETFIRST            1428
GETPAIR             14E4
GET_FILE            49C
GET_FILENAME        49A
GET_NAME            4DC
GOPR                2E2A
HEXSS               5CE
IBUFFE              590
IBUFFS              490
ICLIM               5E7
IMODE               5E0
INGET               2E7E
ITEMP               42A
KEY_ABS             3AE6
KEY_AND             3AEA
KEY_ASC             3AED
KEY_ATN             3AF1
KEY_BINS            3AF6
KEY_BITCLR          3AFB
KEY_BITSET          3B01
KEY_BITTST          3B07
KEY_BUFFER          3B0E
KEY_CALL            3B15
KEY_CHRS            3B19
KEY_CLEAR           3B1E
KEY_CLS             3B23
KEY_CONT            3B26
KEY_COS             3B2A
KEY_CURSOR          3B2E
KEY_DATA            3B35
KEY_DEC             3B39
KEY_DEEK            3B3C
KEY_DEF             3B41
KEY_DIM             3B44
KEY_DIV             3AD8
KEY_DO              3B4B
KEY_DOKE            3B47
KEY_ELLIPSE         3B5D
KEY_ELSE            3B4E
KEY_END             3B52
KEY_EOR             3B64
KEY_EQUAL           3ADE
KEY_EXP             3B67
KEY_FELLIPSE        3B55
KEY_FILL            3B6C
KEY_FN              3B73
KEY_FOR             3B70
KEY_FRE             3B75
KEY_FRECT           3C23
KEY_GET             3B7A
KEY_GOSUB           3B81
KEY_GOTO            3B7D
KEY_GT              3AE2
KEY_HEXS            3B87
KEY_IF              3B8D
KEY_INC             3B8F
KEY_INPUT           3B92
KEY_INT             3B97
KEY_KEYS            3B9C
KEY_LCASES          3BA2
KEY_LEEK            3BA9
KEY_LEFTS           3BAE
KEY_LEN             3BB4
KEY_LET             3BB8
KEY_LINE            3BBB
KEY_LIST            3BBF
KEY_LOAD            3BC3
KEY_LOG             3BC7
KEY_LOKE            3BCB
KEY_LOOP            3BCF
KEY_LSHIFT          3ADA
KEY_LT              3ADC
KEY_MAX             3BD4
KEY_MIDS            3BD8
KEY_MIN             3BDD
KEY_MINUS           3AD6
KEY_MODE            3BE1
KEY_MOVE            3BE5
KEY_MULT            3AD2
KEY_NEW             3BEA
KEY_NEXT            3BED
KEY_NOT             3BF1
KEY_NULL            3BF4
KEY_ON              3BF9
KEY_OR              3BFB
KEY_PEEK            3BFE
KEY_PI              3C03
KEY_PLUS            3AD4
KEY_POINT           3C05
KEY_POKE            3C0A
KEY_POS             3C0E
KEY_POWER           3CC3
KEY_PRINT           3C12
KEY_RAM             3C18
KEY_READ            3C1F
KEY_RECT            3C28
KEY_REM             3C2C
KEY_RESTORE         3C2F
KEY_RETURN          3C36
KEY_RIGHTS          3C3C
KEY_RND             3C43
KEY_RSHIFT          3AE0
KEY_RUN             3C47
KEY_SADD            3C4B
KEY_SAVE            3C50
KEY_SGN             3C54
KEY_SIN             3C58
KEY_SIZE            3C5C
KEY_SPC             3C60
KEY_SQR             3C64
KEY_STEP            3C68
KEY_STOP            3C6C
KEY_STRS            3C70
KEY_SWAP            3C75
KEY_TAB             3C7A
KEY_TAN             3C7E
KEY_THEN            3C82
KEY_TI              3C86
KEY_TO              3C88
KEY_TWOPI           3C8A
KEY_UCASES          3C90
KEY_UNTIL           3C97
KEY_USINGS          3C9C
KEY_USR             3CA3
KEY_VAL             3CA8
KEY_VPTR            3CAC
KEY_WAIT            3CB4
KEY_WHILE           3CB8
KEY_WIDTH           3CBD
KFCTSEED            26A3D110
LAB_11A5            10F0
LAB_11A6            10F2
LAB_11BD            10FE
LAB_1269            6DC
LAB_1274            6EA
LAB_127D            6F8
LAB_127E            706
LAB_1295            71A
LAB_12AE            73C
LAB_12B0            73E
LAB_12E6            75E
LAB_12FF            790
LAB_1301            792
LAB_1303            7B0
LAB_1325            7C8
LAB_132E            7B8
LAB_1330            7BA
LAB_134B            7D6
LAB_1357            7F4
LAB_1359            7FA
LAB_1374            81A
LAB_1378            820
LAB_137F            82C
LAB_138E            832
LAB_1392            836
LAB_13A6            86A
LAB_13AC            872
LAB_13C6            89C
LAB_13CC            8A2
LAB_13D6            8C4
LAB_13D8            8CA
LAB_13EA            8D6
LAB_13EC            8D8
LAB_13FF            8F0
LAB_1401            8F4
LAB_1408            900
LAB_1410            90C
LAB_1417            916
LAB_141B            918
LAB_141F            928
LAB_142A            92E
LAB_142C            93A
LAB_145E            954
LAB_145F            946
LAB_1463            95C
LAB_1477            968
LAB_147A            96E
LAB_1491            992
LAB_14BD            9C2
LAB_14C0            9C6
LAB_14D4            9E6
LAB_14E2            A02
LAB_150C            A10
LAB_1519            A20
LAB_152E            A2C
LAB_1540            A58
LAB_15B3            AB8
LAB_15C2            AE2
LAB_15D1            AEE
LAB_15DC            ACA
LAB_15F6            ADC
LAB_15FF            AFC
LAB_1602            B00
LAB_1624            B84
LAB_1629            B24
LAB_1636            B28
LAB_1639            B2E
LAB_163B            B3A
LAB_1647            B46
LAB_164F            B4C
LAB_16B0            BE4
LAB_16D0            C08
LAB_1723            CA2
LAB_1725            CA6
LAB_172C            C92
LAB_172D            C9A
LAB_174B            CCE
LAB_174E            CF2
LAB_1750            CFA
LAB_1752            D06
LAB_1754            D1E
LAB_1756            D0A
LAB_176C            D3C
LAB_1773            D46
LAB_1785            D62
LAB_1786            D8E
LAB_17B7            DA4
LAB_17B8            DA0
LAB_17D5            E1E
LAB_17D6            E22
LAB_1810            E34
LAB_1811            E44
LAB_1813            E4A
LAB_1829            E82
LAB_182C            E86
LAB_1831            E8C
LAB_185E            ECC
LAB_1866            ED0
LAB_1880            F92
LAB_1886            F9C
LAB_188A            FA0
LAB_188B            EDE
LAB_1898            EEC
LAB_18A2            EF6
LAB_18B7            F18
LAB_18B8            F24
LAB_18BD            F2A
LAB_18C3            F34
LAB_18C6            F38
LAB_18CD            F42
LAB_18E3            F4C
LAB_18F0            F6C
LAB_18F7            F7A
LAB_18F9            F7E
LAB_1904            FA4
LAB_1913            FB6
LAB_1934            FDC
LAB_1953            FF0
LAB_195B            FF8
LAB_1961            1002
LAB_1984            1022
LAB_1985            1026
LAB_1986            102A
LAB_1999            103E
LAB_19B0            1050
LAB_19B6            1060
LAB_19C2            1070
LAB_19DD            1084
LAB_19F6            10A4
LAB_1A03            10B2
LAB_1A0E            10C2
LAB_1A1B            10C8
LAB_1A46            10E2
LAB_1A90            1160
LAB_1A9B            116E
LAB_1ABA            1198
LAB_1ACD            11C4
LAB_1ADB            11D0
LAB_1ADE            11D4
LAB_1AE0            11EA
LAB_1AFA            1204
LAB_1B0B            121A
LAB_1B13            1222
LAB_1B1C            1232
LAB_1B1D            1234
LAB_1B2A            1246
LAB_1B3C            1262
LAB_1B43            11A8
LAB_1B78            126E
LAB_1B7B            1272
LAB_1B7D            1274
LAB_1B84            127E
LAB_1B86            1282
LAB_1B9D            12A6
LAB_1BC1            12D6
LAB_1BD0            1344
LAB_1BE7            135E
LAB_1BF3            12E2
LAB_1BF7            12E8
LAB_1BFB            12EC
LAB_1C01            12F4
LAB_1C11            131C
LAB_1C13            1322
LAB_1C18            132A
LAB_1C19            132E
LAB_1C1A            133E
LAB_1C2A            13A4
LAB_1CAE            144C
LAB_1CB5            146A
LAB_1CD4            1474
LAB_1CD5            147A
LAB_1CD6            147C
LAB_1CDB            148C
LAB_1CE6            147E
LAB_1CF2            148E
LAB_1CFE            14A4
LAB_1D10            151C
LAB_1D12            1520
LAB_1D2D            1532
LAB_1D2E            153E
LAB_1D44            155A
LAB_1D45            156A
LAB_1D48            157E
LAB_1D49            1586
LAB_1D4A            158A
LAB_1D4B            159A
LAB_1D5D            15A2
LAB_1D5E            15A8
LAB_1D83            150C
LAB_1D8A            1506
LAB_1D94            15BC
LAB_1D96            3530
LAB_1D98            15C6
LAB_1DAC            15E0
LAB_1DAE            15E2
LAB_1DAF            15EE
LAB_1DB0            15FC
LAB_1DB1            1600
LAB_1DB2            1604
LAB_1DD7            161C
LAB_1DE6            1636
LAB_1E17            1678
LAB_1E1F            167E
LAB_1E5C            16B8
LAB_1E8D            16D4
LAB_1EA1            16F0
LAB_1EC0            1718
LAB_1ED6            1744
LAB_1ED8            1752
LAB_1EDF            170C
LAB_1F07            1764
LAB_1F28            177E
LAB_1F2C            1784
LAB_1F5A            1792
LAB_1F6A            17BA
LAB_1F6B            17C6
LAB_1F7C            17CC
LAB_1FB4            17FA
LAB_1FD0            1826
LAB_201E            1880
LAB_2043            18CE
LAB_2044            1900
LAB_2045            190A
LAB_204S            18D0
LAB_204T            18FE
LAB_20AE            191C
LAB_20B4            1920
LAB_20BE            1926
LAB_20C9            194A
LAB_20CB            1936
LAB_20D0            193E
LAB_20D8            1954
LAB_20E0            195C
LAB_2115            197C
LAB_2117            1994
LAB_2128            19AE
LAB_2137            19B2
LAB_214B            19D2
LAB_2161            19E8
LAB_2176            19F0
LAB_217E            19FE
LAB_2183            1A18
LAB_218B            1A20
LAB_218F            1A22
LAB_21C2            1A2E
LAB_21C4            1A34
LAB_21D1            1A68
LAB_2206            1A6E
LAB_2212            1A96
LAB_2216            1A58
LAB_2240            1A60
LAB_224D            1A9C
LAB_224E            1AB2
LAB_229E            1AF6
LAB_22A0            1B02
LAB_22B6            1B10
LAB_22BA            1B14
LAB_22BD            1B1E
LAB_22E6            1B38
LAB_2316            1B78
LAB_2317            1B7A
LAB_231C            1B7E
LAB_2358            1BB2
LAB_2368            1BD2
LAB_2441            1DC4
LAB_2445            1DC8
LAB_2467            2048
LAB_2468            204C
LAB_249C            203A
LAB_24A8            2050
LAB_24B4            207A
LAB_24D0            2086
LAB_24D5            2092
LAB_24D6            20AC
LAB_24D7            20BA
LAB_24D8            20C0
LAB_24D9            20A0
LAB_24DA            20C6
LAB_24F7            206A
LAB_24F8            2070
LAB_2778            232E
LAB_277C            2330
LAB_279B            2354
LAB_27BA            2362
LAB_27C3            237E
LAB_27C4            2388
LAB_27CA            238E
LAB_27CE            2396
LAB_27D0            239A
LAB_27DB            23A8
LAB_27F0            2666
LAB_27F1            267C
LAB_27F2            2682
LAB_27F3            2684
LAB_27FA            23C0
LAB_2828            23E0
LAB_282E            23E6
LAB_282F            23E8
LAB_2831            23EC
LAB_284G            240E
LAB_284H            2422
LAB_284J            2424
LAB_284L            2418
LAB_2887            3028
LAB_289A            3052
LAB_289C            3058
LAB_289D            305E
LAB_28FD            307A
LAB_28FE            3080
LAB_28FF            3086
LAB_2900            3094
LAB_2901            309A
LAB_2902            30EC
LAB_2903            30F4
LAB_2904            30F6
LAB_2953            2444
LAB_295E            2450
LAB_2967            245C
LAB_2968            2464
LAB_2969            2476
LAB_296A            2480
LAB_2970            2496
LAB_2978            24A6
LAB_2989            24B6
LAB_299C            250A
LAB_29A7            2532
LAB_29B7            254A
LAB_29B9            24E2
LAB_29C0            2558
LAB_29C3            2570
LAB_29D9            258A
LAB_29E4            259C
LAB_29F7            25B0
LAB_29FB            25B4
LAB_29FD            25BC
LAB_2A18            25CC
LAB_2A1A            25CE
LAB_2A21            25D6
LAB_2A3B            25F6
LAB_2A4B            2604
LAB_2A58            2618
LAB_2A68            2630
LAB_2A74            263C
LAB_2A89            2658
LAB_2A8C            265C
LAB_2A91            2662
LAB_2A9A            36F6
LAB_2A9B            3712
LAB_2X01            30B2
LAB_2X02            30BA
LAB_2X03            30C8
LAB_2X04            30CE
LAB_2X05            30E4
LAB_2Y01            3104
LAB_2Y02            310C
LAB_2Y03            3118
LAB_2Y04            311E
LAB_3216            22C8
LAB_32_16           22C6
LAB_ABER            69E
LAB_ABS             23B8
LAB_AD              3AC3
LAB_ADD             2016
LAB_ADER            66A
LAB_AND             1420
LAB_ASC             1C5C
LAB_ATCD            2A04
LAB_ATGO            29C2
LAB_ATLE            29E0
LAB_ATN             29A4
LAB_ATNP            29FE
LAB_AYFC            1806
LAB_BAER            394C
LAB_BHCB            1406
LAB_BHSS            13E0
LAB_BINS            2DDC
LAB_BITCLR          2A66
LAB_BITSET          2A56
LAB_BMSG            3CC5
LAB_BS              39EC
LAB_BTST            2A76
LAB_BUFFER          1FE6
LAB_CALL            1DA4
LAB_CASC            14F6
LAB_CATN            2A0A
LAB_CAUC            14FC
LAB_CBIN            31D8
LAB_CBX1            31F2
LAB_CBXN            31E0
LAB_CCER            682
LAB_CDLP            1FD6
LAB_CHEX            3176
LAB_CHRS            1B42
LAB_CHX1            319C
LAB_CHX2            31C0
LAB_CHX3            31B8
LAB_CHXX            317E
LAB_CKRN            182E
LAB_CKTM            118A
LAB_CLEAR           9AA
LAB_CLS             1FF0
LAB_CN              3A59
LAB_COLD            5A8
LAB_CONT            B96
LAB_CORD            2936
LAB_COS             28C6
LAB_CRLF            ED6
LAB_CRTS            1FE0
LAB_CTBL            35B8
LAB_CTNM            1188
LAB_CURSOR          1FA2
LAB_D0              3A0A
LAB_D002            2D40
LAB_D00A            2D50
LAB_D00E            2D60
LAB_DATA            C84
LAB_DD              39F9
LAB_DDER            69A
LAB_DEC             D94
LAB_DECI            DF2
LAB_DEEK            1D22
LAB_DEF             1838
LAB_DIM             14A8
LAB_DIV0            22C0
LAB_DIVIDE          2246
LAB_DIVX            2296
LAB_DO              BC8
LAB_DOKE            1D4C
LAB_DUPFMT          2D28
LAB_DZER            696
LAB_ELLIPSE         1F24
LAB_EMSG            3CCD
LAB_END             B30
LAB_EOR             1410
LAB_EQUAL           1436
LAB_ESML            27DC
LAB_EVBY            1C74
LAB_EVEX            119E
LAB_EVEZ            11A0
LAB_EVIN            1642
LAB_EVIR            1652
LAB_EVNM            1186
LAB_EVPI            164A
LAB_EVSW            1E44
LAB_EX1             2714
LAB_EXAD            2866
LAB_EXCC            284C
LAB_EXCM            277E
LAB_EXNN            2838
LAB_EXOF            2738
LAB_EXOL            274E
LAB_EXOU            2724
LAB_EXP             2758
LAB_EXPL            2832
LAB_EXPS            2790
LAB_EXRN            283E
LAB_EXXF            31C6
LAB_FB95            2E8E
LAB_FBA0            2E72
LAB_FC              39B3
LAB_FCER            6AE
LAB_FELLIPSE        1F28
LAB_FILL            1EE4
LAB_FO              3ACB
LAB_FOER            666
LAB_FOR             A64
LAB_FPOINT          1E18
LAB_FRE             17F0
LAB_FRECT           1F20
LAB_FTBL            3672
LAB_FTPP            3622
LAB_FVAR            1514
LAB_GADB            1CC6
LAB_GADW            1CDA
LAB_GARB            19C8
LAB_GBYT            1300
LAB_GEAD            1CFA
LAB_GET             E50
LAB_GETS            E6A
LAB_GFPN            D56
LAB_GGEX            1E82
LAB_GGLP            1E58
LAB_GGPR            1E56
LAB_GMEM            5FE
LAB_GOSUB           BDA
LAB_GOTO            BEC
LAB_GOTS            BFC
LAB_GSCH            B7C
LAB_GTBY            1C70
LAB_GTHAN           2706
LAB_GTSW            1E3C
LAB_GTWO            1C84
LAB_GVAL            12AC
LAB_GVAR            1516
LAB_HEXS            2E2E
LAB_ID              3A19
LAB_IDER            692
LAB_IF              CAC
LAB_IGBY            12FE
LAB_IMSG            3CDE
LAB_INC             D9A
LAB_INCI            DE8
LAB_INCT            DDA
LAB_INLN            7EA
LAB_INPUT           FC4
LAB_INT             242A
LAB_IRTS            2442
LAB_ISHN            3198
LAB_ISWD            1E52
LAB_KESS            1DFC
LAB_KETT            1DF0
LAB_KEYS            1DE4
LAB_KEYT            377C
LAB_KEZZ            1DEE
LAB_KKSS            1E0A
LAB_KSSS            1E0E
LAB_LAAD            2140
LAB_LCASE           1BDA
LAB_LD              3A7B
LAB_LDER            67A
LAB_LEEK            1D38
LAB_LEFT            1B52
LAB_LENS            1C54
LAB_LET             DF6
LAB_LINE            1EA8
LAB_LIST            9AE
LAB_LMSG            3CD4
LAB_LNCO            1EC0
LAB_LOAD            1D9C
LAB_LOCC            2146
LAB_LOCX            2162
LAB_LOG             20C8
LAB_LOKE            1D52
LAB_LOLP            2150
LAB_LONE            217E
LAB_LONN            2166
LAB_LOOP            C1A
LAB_LOWZ            21B8
LAB_LOXO            2184
LAB_LOXP            2174
LAB_LRMS            13BE
LAB_LS              3A36
LAB_LSHIFT          14B4
LAB_LTHAN           1440
LAB_LTPF            2946
LAB_LTPT            2956
LAB_LT_1            22D4
LAB_MADD            21E6
LAB_MAN1            22BA
LAB_MAX             2E9A
LAB_MAXN            2EA6
LAB_MIDS            1B96
LAB_MIN             2EB0
LAB_MINN            2EBC
LAB_MMEC            2EC6
LAB_MNOC            21E0
LAB_MODE            1F82
LAB_MOVE            1ED6
LAB_MUEX            2234
LAB_MUF1            2210
LAB_MUF2            221A
LAB_MUF3            2230
LAB_MULTIPLY        21BA
LAB_MUUF            223A
LAB_NB1T            230C
LAB_NEW             95A
LAB_NEXT            10D0
LAB_NF              397A
LAB_NFER            6BE
LAB_NOST            E7C
LAB_NSTT            2F2C
LAB_NULL            B8C
LAB_OD              39A7
LAB_ODER            6B2
LAB_OFER            6AA
LAB_OM              39CA
LAB_OMER            6A6
LAB_ON              D22
LAB_OPPT            36C2
LAB_OR              1418
LAB_OV              39C1
LAB_P004            2D7E
LAB_P008            2D94
LAB_P00C            2D9C
LAB_P00E            2DA8
LAB_P010            2DAC
LAB_P018            2DC6
LAB_P01A            2DCA
LAB_P01E            2DD2
LAB_PEEK            1D10
LAB_PFAC            2316
LAB_PHFA            2ED6
LAB_PI              3008
LAB_PIXEL           1EE6
LAB_PNCE            1F12
LAB_PNCO            1F0C
LAB_POINT           1EE0
LAB_POKE            1D1C
LAB_POON            2686
LAB_POS             1822
LAB_POWER           26A2
LAB_POWP            26D4
LAB_POZE            2696
LAB_PPBI            13B4
LAB_PPFN            13A6
LAB_PPFS            1398
LAB_PRINT           E8A
LAB_PRNA            F4E
LAB_PROCFO          2D66
LAB_P_10            334A
LAB_RAM             2FFE
LAB_READ            FEA
LAB_RECT            1F1C
LAB_REDO            3CEE
LAB_REM             D1A
LAB_REMM            22EC
LAB_RESS            B70
LAB_RESTORE         B5E
LAB_RET0            3164
LAB_RETURN          C70
LAB_RG              3992
LAB_RGER            6B6
LAB_RIGHT           1B66
LAB_RMSG            3D00
LAB_RND             2872
LAB_RSED            3262
LAB_RSHIFT          14C4
LAB_RTN0            3166
LAB_RTST            1962
LAB_RUN             BB4
LAB_RUNN            BC2
LAB_S1XY            1F68
LAB_S2XY            1F58
LAB_SADD            1C3C
LAB_SAVE            1DA0
LAB_SCCA            12F6
LAB_SCER            686
LAB_SCGB            12F0
LAB_SCL0            292C
LAB_SCLN            948
LAB_SCZE            291E
LAB_SELC            1F08
LAB_SET1            229E
LAB_SFCO            1E96
LAB_SGBY            1C6C
LAB_SGN             23A6
LAB_SHAPE           1F2A
LAB_SIN             28DE
LAB_SIZE            1F96
LAB_SIZOK           5B4
LAB_SLCO            1E84
LAB_SLER            68A
LAB_SMSG            3D0A
LAB_SN              398B
LAB_SNBS            C8A
LAB_SNER            6BA
LAB_SNFC            1F46
LAB_SQE1            2FB0
LAB_SQE2            2FB6
LAB_SQNA            2FDE
LAB_SQNS            2FC8
LAB_SQR             2F8C
LAB_SRTS            1F7E
LAB_SSLN            940
LAB_ST              3A46
LAB_STOP            B38
LAB_STRS            1918
LAB_SUBTRACT        2002
LAB_SVAR            1512
LAB_SVTB            2F5E
LAB_SWAP            1D66
LAB_TAN             28A4
LAB_TBSZ            2F3E
LAB_TI              1DD2
LAB_TM              3A28
LAB_TMER            68E
LAB_TWOPI           3018
LAB_U002            2ACE
LAB_U004            2B24
LAB_U005            2B34
LAB_U006            2B36
LAB_U008            2B4A
LAB_U009            2B6C
LAB_U00A            2B74
LAB_U00B            2B7E
LAB_U00C            2B92
LAB_U00D            2B96
LAB_U00E            2BA8
LAB_U00F            2BB4
LAB_U010            2BB8
LAB_U014            2BBE
LAB_U018            2BC6
LAB_U01C            2BDC
LAB_U020            2BE8
LAB_U022            2BEE
LAB_U026            2BFE
LAB_U02A            2C08
LAB_U02B            2C20
LAB_U02C            2C26
LAB_U02E            2C38
LAB_U030            2C3C
LAB_U034            2C52
LAB_U036            2C58
LAB_U038            2C60
LAB_U03C            2C68
LAB_U03E            2C6E
LAB_U040            2C86
LAB_U044            2C96
LAB_U046            2CBE
LAB_U048            2CC0
LAB_U04A            2CCA
LAB_U04C            2CFC
LAB_UA              3A9E
LAB_UCASE           1C0A
LAB_UDER            672
LAB_UF              3A68
LAB_UFAC            22FA
LAB_UFER            67E
LAB_US              39D8
LAB_USER            6A2
LAB_USINGS          2AA4
LAB_USR             1D94
LAB_UV              3A8B
LAB_UVER            676
LAB_VAL             1C98
LAB_VALZ            1CC0
LAB_VARPTR          2FEE
LAB_WAIT            1DAE
LAB_WARM            400
LAB_WD              3AB2
LAB_WDER            66E
LAB_WDLP            2F72
LAB_WDTH            2F0C
LAB_XDIV            22AE
LAB_XERR            6C0
LAB_XGADW           1CF4
LC_LOOP             1BF0
LOAD_EOF            480
LOAD_EXIT           456
LOAD_IN             45E
LOAD_TITLE          4FC
LOOPALWAYS          C56
LOOPDONE            C6A
LVARPL              472
L_DDIV              22F4
L_DIVRND            22A2
MAINLOOP            296E
N                   2
NAME_COPY           4CA
NEXTA               2980
NEXTB1              2DEC
NEXTB2              2E12
NEXTH1              2E3E
NEXTPRN             2880
NINC0               2888
NINC1               288E
NOBRK               0
NOLCASE             1C32
NOSHIFT             14C0
NOSTRING            1C38
NOT2BIG             14D8
NOUCASE             1C02
NOVAR               0
NULLCT              5E4
NUMEXP              5AC
OFCHR               23
OQUOTE              5DD
OUTLOOP             298E
PRG_STRT            5F2
PRNLWORD            5A0
PRSTK               5D8
RAM_ADDR            80000
RAM_BASE            400
RAM_SIZE            80000
RAM_STRT            0
RDPTRL              466
RETCHR              420
RTS_001             131A
RTS_005             9A8
RTS_006             B8A
RTS_007             C88
RTS_007A            C9E
RTS_008             E4E
RTS_009             F4A
RTS_011             17CA
RTS_012             1A9A
RTS_013             1B0E
RTS_015             1D64
RTS_016             206E
RTS_017             238C
RTS_020             2712
RTS_021             2A54
RTS_022             2E7C
RTS_023             2F8A
RTS_024             31D6
RTS_025             3238
SARRYL              43E
SAVE_BAS            56A
SAVE_OUT            57C
SAVE_RTN            52A
SAVE_TITLE          506
SFNCL               432
SMEML               42E
SSTORL              446
SSTRL               43A
SUBEXIT             2998
SUBLOOP             2966
SUFNXF              5DF
SUTILL              44E
SVARL               436
TABSIZ              5E2
TAB_ASCA            3AE6
TAB_ASCB            3AF6
TAB_ASCC            3B15
TAB_ASCD            3B35
TAB_ASCE            3B4E
TAB_ASCF            3B6C
TAB_ASCG            3B7A
TAB_ASCH            3B87
TAB_ASCI            3B8D
TAB_ASCK            3B9C
TAB_ASCL            3BA2
TAB_ASCM            3BD4
TAB_ASCN            3BEA
TAB_ASCO            3BF9
TAB_ASCP            3BFE
TAB_ASCR            3C18
TAB_ASCS            3C4B
TAB_ASCT            3C7A
TAB_ASCU            3C90
TAB_ASCV            3CA8
TAB_ASCW            3CB4
TAB_ATNC            34B8
TAB_CHRT            3712
TAB_EQUL            3ADE
TAB_HTHET           3538
TAB_LESS            3ADA
TAB_MNUS            3AD6
TAB_MORE            3AE0
TAB_PLUS            3AD4
TAB_POWR            3CC3
TAB_QEST            3AE4
TAB_SLAS            3AD8
TAB_SNCO            3438
TAB_STAR            3AD2
TK_ABS              CE
TK_AND              C4
TK_ASC              E0
TK_ATN              D9
TK_BINS             E5
TK_BITCLR           B4
TK_BITSET           B3
TK_BITTST           E6
TK_BUFFER           A0
TK_CALL             9B
TK_CHRS             E3
TK_CLEAR            AE
TK_CLS              A1
TK_CONT             9F
TK_COS              D6
TK_CURSOR           A2
TK_DATA             83
TK_DEC              88
TK_DEEK             DB
TK_DEF              97
TK_DIM              85
TK_DIV              C2
TK_DO               9C
TK_DOKE             99
TK_ELLIPSE          A9
TK_ELSE             B6
TK_END              80
TK_EOR              C5
TK_EQUAL            CA
TK_EXP              D5
TK_FELLIPSE         AA
TK_FILL             A4
TK_FN               B8
TK_FOR              81
TK_FRE              D0
TK_FRECT            A8
TK_GET              B1
TK_GOSUB            8D
TK_GOTO             89
TK_GT               C9
TK_HEXS             E4
TK_IF               8B
TK_INC              93
TK_INPUT            84
TK_INT              CD
TK_KEYS             EA
TK_LCASES           E2
TK_LEEK             DC
TK_LEFTS            F0
TK_LEN              DD
TK_LET              87
TK_LINE             A3
TK_LIST             AD
TK_LOAD             95
TK_LOG              D4
TK_LOKE             9A
TK_LOOP             9D
TK_LSHIFT           C8
TK_LT               CB
TK_MAX              E7
TK_MIDS             F2
TK_MIN              E8
TK_MINUS            C0
TK_MODE             AB
TK_MOVE             A5
TK_MULT             C1
TK_NEW              AF
TK_NEXT             82
TK_NOT              BB
TK_NULL             92
TK_ON               91
TK_OR               C6
TK_PEEK             DA
TK_PI               EC
TK_PLUS             BF
TK_POINT            A6
TK_POKE             98
TK_POS              D1
TK_POWER            C3
TK_PRINT            9E
TK_RAM              E9
TK_READ             86
TK_RECT             A7
TK_REM              8F
TK_RESTORE          8C
TK_RETURN           8E
TK_RIGHTS           F1
TK_RND              D3
TK_RSHIFT           C7
TK_RUN              8A
TK_SADD             EF
TK_SAVE             96
TK_SGN              CC
TK_SIN              D7
TK_SIZE             AC
TK_SPC              B9
TK_SQR              D2
TK_STEP             BC
TK_STOP             90
TK_STRS             DE
TK_SWAP             B2
TK_TAB              B5
TK_TAN              D8
TK_THEN             BA
TK_TI               EB
TK_TO               B7
TK_TWOPI            ED
TK_UCASES           E1
TK_UNTIL            BD
TK_USINGS           F3
TK_USR              CF
TK_VAL              DF
TK_VPTR             EE
TK_WAIT             94
TK_WHILE            BE
TK_WIDTH            B0
TOOBIG              14DE
TPOS                5E5
TPOWER              5D9
TWIDTH              5E6
UC_LOOP             1C20
USDSS               5CC
USRJMP              406
USRJPV              408
UT1_PL              5A4
VARNAME             46A
VEC_CC              2E58
VEC_IN              410
VEC_LD              430
VEC_OUT             400
VEC_SV              516
V_CTLC              424
V_CTLCV             426
V_INPT              40C
V_INPTV             40E
V_LOAD              418
V_LOADV             41A
V_OUTP              412
V_OUTPV             414
V_SAVE              41E
V_SAVEV             420
WEXIT               2F62
WRMJPV              402
